MEAP Edition   Manning Early Access Program   React Hooks in Action   With Suspense and Concurrent Mode  Version 3   Copyright 2020 Manning Publications  For more information on this and other Manning titles go to   manning.com    Manning Publications Co.  To comment go to  liveBook    welcome   Thank you for purchasing the MEAP for React Hooks in Action with Suspense and Concurrent  Mode.  The  book  covers  some  of  the  latest  additions  to  React  including  some  experimental  features and I hope you find it interesting, easy to follow and of immediate use. It does assume  that readers have some experience with React as it focusses on the new features of the library.  The React team are working hard to improve the developer experience to help developers  create great products. These efforts have led to a number of changes to the underlying workings  of React and to some additions to the ways it can be used. This book explores React Hooks and  their use with stateful functional components and introduces Suspense and Concurrent Mode  and the thinking behind them.   Compared to classes, stateful functional components with Hooks encourage cleaner, leaner  code which can be easily tested, maintained and reused. Features can even be extracted into  their own functions, or custom hooks, outside of the component, ready for reuse or sharing.   A  large  part  of  the  motivation  for  the  rewrite  of  React  for  version  16  was  to  build  the  architecture  to  cope  with  the  multiple  demands  put  upon  a  user  interface  as  it  loads  and  manipulates data while users continue interacting with the application. Concurrent Mode is a  core  piece  of  that  new  architecture  and  Suspense  components  fit  the  new  mode  naturally.  Together, they enable greater control over the scheduling of UI updates, data fetching patterns,  and fallback states.   This  book  includes  a  number  of  short  code  examples  as  well  as  an  ongoing  project  that  exemplifies  the  ways  in  which  state  and  functionality  can  be  distributed  throughout  an  application  and  internet.  The  code  has  a  home  on  GitHub  at  https:  github.com jrlarsen ReactHooks.   loaded  over  the   I hope you enjoy the book and can incorporate the ideas and methods it contains into your  work as appropriate. Please do leave feedback in the liveBook discussion forum - it really will  help me to make the most useful book possible.   -- John Larsen    Manning Publications Co.  To comment go to  liveBook     brief contents   Part 1 The React Roadmap    1 React is evolving   2 Making Your Code Shorter and Simpler   Part 2 React Hooks    3 Managing component state with the useState hook   4 Managing component state with the useReducer hook   5 Working with side effects   6 Managing component state with the useRef hook   7 Managing application state   8 Managing performance with useMemo   9 Managing state with the Context API  10 Encapsulating code with custom hooks  11 Third-party hooks   Part 3 Suspense and Concurrent Mode   12 Managing the user experience with Suspense  13 Managing the user experience with Concurrent Mode    Manning Publications Co.  To comment go to  liveBook        1    React is evolving   React is a JavaScript library for building beautiful user interfaces. The React team want the  developer experience to be as great as possible so that developers are inspired and enabled  to create delightful, productive user experiences. React Hooks in Action with Suspense and  Concurrent  Mode  is  your  guide  to  the  latest  additions  to  the  library,  additions  that  can  simplify  your  code,  improve  code  reuse  and  help  make  your  applications  slicker  and  more  responsive, leading to happier developers and happier users.   This  chapter  will  give  a  brief  overview  of  React  and  its  new  features,  to  whet  your   appetite for the details that follow later in the book.   1.1  What is React?  Say you are creating a user interface for the web, the desktop, for a smartphone, or even for  a VR experience. You want your page or app to display a variety of data that changes over  time,  like  authenticated  user  info,  filterable  product  lists,  data  visualization  or  customer  details.  You  expect  the  user  to  interact  with  the  app,  choosing  filters  and  data  sets  and  customers to view, filling in form fields, or even exploring a VR space! Or maybe your app  will  consume  data  from  a  network  or  from  the  Internet,  like  social  media  updates,  stock  tickers, or product availability. React is here to help.   React makes it easy to build user interface components that are composable and reusable  and  that  react  to  changes  in  data  and  to  user  interactions.  Figure  1.1  shows  a  page  from  Facebook  that  includes  buttons,  posts,  comments,  images  and  video,  among  many  other  interface components.    Manning Publications Co.  To comment go to  liveBook   1      Figure 1.1. The Star Wars UK Facebook page. It shows a lot of data and has many interactive components.   React  helps  update  the  interface  as  the  user  scrolls  down  the  page,  opens  up  posts,  adds  comments or transitions to other views. Notice that a number of the components on the page  have  repeated  sub-components   as  shown  in  figure  1.2 ,  page  elements  with  the  same  structure but different content. And those sub-components are made up of components too!  There are image thumbnails, repeated buttons, clickable text and icons aplenty. Taken as a  whole,  the  Facebook  page  has  hundreds  of  such  elements.  But,  by  breaking  such  rich  interfaces  into reusable  components,  development  teams can  more easily focus on  specific  areas of functionality and put the components to use on multiple pages.    Manning Publications Co.  To comment go to  liveBook   2      Figure 1.2. Components from a Facebook page that include repeated sub-components.   Making  it  easy  to  define  and  reuse  components  and  compose  them  into  complex  but  understandable and usable interfaces is one of React’s core purposes. There are other front- end  libraries  out  there,  like  Angular,  Vue  and  Ember,  but  this  is  a  React  book  so  we’ll  concentrate on how React approaches components, data flow and code reuse.   Over  the  next  few  sections  we’ll  take  a  high-level  look  at  how  React  helps  developers   build such apps, highlighting five key features of React:      Building UI from reusable, composable components     Describing UI using JSX - a blend of HTML-style templating and JavaScript     Making the most of JavaScript without introducing too many idiomatic constraints        Helping manage the fetching of code, assets and data   Intelligently synchronizing state and UI   Building a UI from components   1.1.1  The Facebook example in figure 1.1 shows a rich, hierarchical, multi-layered user interface  that  React  can  help  you  design  and  code.  But,  for  now,  let’s  start  with  something  a  bit  simpler to get a feel for the features of React.   Say you want to build a quiz app to help learners test themselves on facts they’ve been  studying.  Your  component  should  be  able  to  show  and  hide  questions  and  show  and  hide  answers. One question and answer pair might look something like figure 1.3.   Figure 1.3. Part of a quiz app showing a question and an answer.    Manning Publications Co.  To comment go to  liveBook      3   You  could  create  a  component  for  the  question  section  and  a  component  for  the  answer  section.  But  the  structure  of the  two  components  is  the same:  figure 1.4  shows  how each  has a title, some text to show and hide, and a button to do the showing and hiding.   Figure 1.4. Each section has the same features: a title, some text and a button.         React makes it easy to define a single component, say a TextToggle component, that you  can use for both the question and the answer. You pass the title and text and whether the  text  should  be  shown  to  each  of  your  TextToggle  components.  You  pass  the  values  as  properties  or props , something like this:            Wait!  What  now?  Is  that  HTML?  XML?  JavaScript?  Well,  programming  with  React  is  programming in JavaScript. But, React provides an HTML-like syntax for describing your UI  called JSX. Before running your app, the JSX needs to be preprocessed to convert it into the  actual  JavaScript  that  creates  the  elements  of  your  user  interface.  At  first  it  seems  a  bit  strange,  mixing  HTML  with  your  JavaScript,  but  it  turns  out  the  convenience  is  a big plus.  And  once  your  code  finally  runs  in  the  browser   or  other  environment   it  really  is  just  JavaScript. A package called Babel is almost always used to compile the code you write into  the code that will run. You can find out more about Babel at bablejs.io.   This  chapter  only  offers  a  high-level  overview  of  React,  so  we  won’t  explore  JSX  any  further here. It’s worth mentioning up front though because it’s a widely used part of React  development. In fact, in my opinion, React’s JavaScriptiness is one of its appeals - although  other opinions are available - and, for the most part, it doesn’t introduce many constraints.  While  best  practices  have  emerged  and  continue  to  do  so,  being  a  good  JavaScript  programmer and being a good React programmer are very similar skills.   So,  say  you’ve  created  the  TextToggle  component;  what’s  next?  With  React  you  can  define new components made up of existing components. You can encapsulate the question  card, showing the question and the answer, as its own QuestionCard component. And if you  want  to  show  multiple  questions  at  once,  your  Quiz  component  UI  could  be  made  up  of  multiple QuestionCard components. Figure 1.5 shows two QuestionCard components making  up  a  Quiz  component.  The  Quiz  component  is  a  container  for  QuestionCards  and  has  no  visible presence apart from the cards it contains.    Manning Publications Co.  To comment go to  liveBook   4         Figure 1.5. A Quiz component showing two QuestionCard components.   So,  the  Quiz  component  is  made  up  of  QuestionCard  components,  and  they,  in  turn,  are  made up of TextToggle components which are made up of standard HTML elements, an h2,  a p and a button, say. Ultimately, it’s all native UI elements. Figure 1.6 shows the simple  hierarchy for your Quiz component.   Figure 1.6. Quiz component hierarchy   React makes this component creation and composition much easier. And once you’ve crafted  your  components,  you  can  reuse  them  and  share  them  easily  too.  Imagine  a  learning  resource site with different pages for different topics. On each page, you could include your  Quiz component, just passing it the quiz data for that topic.   There  are  many  React  components  available  to  download  in  package  management  repositories  like  npm.  There’s  no  need  to  recreate  common  use  cases,  simple  or  complex,  when well-used,  well-tested examples  of  drop-down  menus,  date pickers, rich  text  editors,  and probably quiz templates too, are ready and waiting to be used.   React  also  provides  mechanisms  and  patterns  for  passing  your  app’s  data  to  the  components that need them. In fact, that synchronization, of state and UI, goes to the heart  of what React is and does.   React synchronizes state and UI   1.1.2  React keeps an app’s user interface synchronized with its data. The data held in your app at  any moment is called the app’s state and might include, for example, current posts, details  about the logged in user, whether comments are shown or hidden, or the contents of a text    Manning Publications Co.  To comment go to  liveBook   5   input field. If new data arrives over the network or a user updates a value via a button or  text  input,  React  works  out  what  changes  need  to  be  made  to  the  display  and  efficiently  updates it. React intelligently schedules the order and timing of the updates to optimize the  perceived performance of your app and improve the user experience. Figure 1.7 represents  this idea, that React responds to a change in a component’s state by re-rendering the user  interface.      Figure 1.7 When a value in a component’s state changes, React re-renders the user interface.   But updating state and re-rendering is not a one-off task. A visitor using your app is likely to  cause a multitude of state changes and React will need to repeatedly ask your components  for the latest UI that represents the latest state values. It’s your components’ job to convert  their  state  and  props   the  properties  passed  to  them   into  a  description  of  their  user  interface.  React  then  takes  those  UI  descriptions  and  schedules  updates  to  the  DOM   the  browser’s Document Object Model  where necessary. At various points this book uses cycle  diagrams  and  accompanying  step-by-step  descriptions  to  highlight  the  repeating  nature  of  these updates, as shown in the Cycle Diagrams section on pages mm and nn.   CYCLE DIAGRAMS  DOUBLE PAGE SPREAD ON PAGES MM AND NN   To represent the ongoing cycle of state changes and UI updates, this book uses circular cycle  diagrams  to  illustrate  the  interactions  between  your  components  and  React.  This  section’s  figure  is  a  simple  example,  showing  how  React  calls  your  component  code  when  the  component first appears and when a user updates a value.    Manning Publications Co.  To comment go to  liveBook   6   Figure: React calls and re-calls your component to generate a description of its UI using the latest state.   The cycle diagrams are accompanied by tables describing the diagrams’ steps in more detail.  The diagram and table pair don’t necessarily cover everything that is happening but pull out  the  key  steps  to  help  you  understand  the  similarities  and  differences  related  to  how  components work in different scenarios. For example, this section’s figure doesn’t show how  the  event  handler  works  with  React  to  update  the  state;  that  detail  will  be  added  in  later  diagrams when introducing the relevant React hooks.       Manning Publications Co.  To comment go to  liveBook   7   Step   What happens?   Discussion   React calls the component.   1   2   3   4   5   6   7   8   9   The component specifies an  event handler.   To generate the UI for the page, React traverses the tree of  components, calling each one. React will pass each  component any props set as attributes in the JSX.   The event handler may listen for user clicks, timers firing or  resources loading, for example. The handler will change the  state when it runs later. React will hook up the handler to the  DOM when it updates the DOM in step 4.   The component returns its UI.   The component uses the current state value to generate its  user interface and returns it, finishing its work.   React updates the DOM   The event handler fires.   React compares the description of the UI the component  returns with the current description of the app’s UI. It  efficiently makes any necessary changes to the DOM and sets  up or updates event handlers as necessary.   An event fires and the handler runs. The handler changes the  state.   React calls the component.   React knows the state value has changed so must recalculate  the UI.   The component specifies an  event handler.   This is a new version of the handler and may use the newly  updated state value.   The component returns its UI.   The component uses the current state value to generate its  user interface and returns it, finishing its work.   React updates the DOM   React compares the description of the UI the component  returns with the previous description of the app’s UI. It  efficiently makes any necessary changes to the DOM and sets  up or updates event handlers as necessary.   The illustrations also use consistent icons to represent key objects and actions discussed in  the surrounding text, such as components, state values, event handlers and UI.   STATE IN THE QUIZ APP  Looking  back  at  the  Facebook  page  in  figure  1.1,  you  can  appreciate  that  the  page  as  a  whole  requires  a  lot  of  state,  with  new  posts  being  loaded  and  users  liking  posts,  adding  comments, and interacting with components in a variety of ways. Some of that state, like the  current user, may be shared across many components, whereas other state, like a comment,  may be local to a post.   In  the  Quiz  app,  you  have  a  question  and  answer  component,  a QuestionCard,  shown  again in figure 1.8. Users can show and hide each question and answer and move to the next  available question.    Manning Publications Co.  To comment go to  liveBook   8         Figure 1.8. QuestionCard: A question and answer component. The answer is hidden.   The QuestionCard component state includes the information needed to display the current  question and answer:      The question number     The number of questions     The question text     The answer text     Whether the question is hidden or shown     Whether the answer is hidden or shown   Clicking  the  answer’s  Show  button  changes  the  state  of  the  component.  Maybe  an  isAnswerShown  variable  switches  from false  to true.  React  will  notice  that  the  state  has  changed  and  will  update  the displayed  component  to  show  the  answer  text  and  toggle the  button’s text from Show to Hide  figure 1.9 .   Figure 1.9. The question and answer component with the answer shown.   Clicking  the  Next  button  changes  the  question  number.  It  will  switch  from  question  1  to  question 2, as shown in figure 1.10. If the questions and answers for the whole quiz are in  memory, React can update the display straight away. If they need to be loaded from a file or    Manning Publications Co.  To comment go to  liveBook   9   service, while the data is fetched React can wait before updating the UI or, if the network is  slow, show a loading indicator like a spinner.      Figure 1.10. The question and answer component showing the second question. The answer has been hidden.   The simple Quiz app example doesn’t need much state to perform its duties. Most real-world  apps are more complicated. Deciding where state should live - whether a component should  manage  its  own  state,  whether  some  components  should  share  state,  and  whether  some  state  should  be  globally  shared  -  is  an  important  part  of  building  apps.  React  provides  mechanisms for all three scenarios and there are published packages, like Redux, MobX, and  Apollo Client, for example, that offer approaches to manage state via a data store outside of  your components.   In the past, whether or not your component managed some of its own state determined  what  method  of  component  creation  you  would  use;  React  provides  two  main  methods:  function components and class components, as discussed in the next section.   Component Types   1.1.3  To define a component, React lets you use two JavaScript structures: a function or a class.  Before  React  Hooks,  you  would  use  a  function  when  the  component  didn’t  need  any  local  state  you would pass it all its data via props .   function MyComponent   props   {     Maybe work with the props in some way.     Return the UI incorporating prop values.  }   You would use a class when the component needed to manage its own state, perform side  effects   like  loading  its  data  or  getting  hands-on  with  the  DOM ,  or  directly  respond  to  events.   class MyComponent extends React.Component {    constructor  props  {      super props ;        this.state = {           Set up state here.                                       A      }    Manning Publications Co.  To comment go to  liveBook   10     }      componentDidMount    {         Perform a side effect like loading data.                     B    }      render    {         Return the UI using prop values and state.                   C    }  }   A Class components set up their state in a constructor function  B Class components can include methods for various stages in their lifecycle  C Class components have a render method that returns their UI  The addition of React Hooks means you can now use function components to manage state  and side effects.   function MyComponent   props   {       Use local state.    const [value, setValue] = useState initialValue ;                A    const [state, dispatch] = useReducer reducer, initialState ;     A      useEffect    => {         Perform side effect.                                        B    } ;      return         {value} and {state.message}                              C     ;  }   A Use hooks to manage state  B Use hooks to manage side effects  C Return the UI directly from the function  The React team recommends the use of functions for components in new projects  although  there is no plan to remove class components, so need for big rewrites of existing projects .  Table 1.1 lists the component types and their descriptions.      Component Type   Description   Stateless function component   A JavaScript function that is passed properties and returns UI.   Function component   A JavaScript function that is passed properties and uses hooks to  manage state and perform side effects as well as returning UI.   Class component   A JavaScript class that includes a render method that returns UI. It  may also set up state in its constructor function and manage state  and perform side effects in its lifecycle methods.   Function  components  are  just  JavaScript  functions  that  return  a  description  of  their  user  interface.  When  writing  components,  developers  usually  use  JSX  to  specify  the  UI.  The  UI    Manning Publications Co.  To comment go to  liveBook   11   might  depend  on  properties  passed  to  the  function.  With  stateless  function  components,  that’s  where  the  story  ends:  they  turn  properties  into  UI.  More  generally,  function  components can now include state and work with side effects.   Class  components  are  built  using  the  JavaScript  class  syntax,  extending  from  a  React.Component  or  React.PureComponent  base  class.  They  have  a  constructor  function,  where  state  can  be  initialized,  and  a  number  of  methods  that  React  calls  as  part  of  the  component lifecycle, for instance when the DOM has been updated with the latest component  UI  or  when  the  properties  passed  to  the  component  change.  They  also  have  a  render  method that returns a description of the component’s UI. Class components were the way to  create stateful components that could cause side effects.   We’ll  see  in  section  1.3  how  function  components  with  hooks  provide  a  better  way  of  creating stateful components and managing side effects than classes. First, let’s take a more  general look at what’s new in React and how the new features make working with React even  better.   Component side effects  React components generally transform state into UI. When component code performs actions outside of this main  focus, perhaps fetching data like blog posts or stock prices from the network, setting up a subscription to an online  service, or directly interacting with the DOM to focus form fields or measure element dimensions, we describe those  actions as component side effects. We want our app and its components to behave predictably, so should make sure  any necessary side effects are deliberate and visible. As we’ll see in chapter 5, React provides the useEffect hook to  help us set up and manage side effects in our functional components.   1.2  What’s new in React?  React 16 included a re-write of core functionality that has paved the way for a steady rollout  of new library features and approaches. We explore a number of the newest additions in the  chapters that follow. The new features include:      Stateful function components  useState, useReducer      Context API  useContext      Cleaner side effect management  useEffect      Simple but powerful code reuse patterns  Custom Hooks      Code splitting  React.lazy      Faster initial loading and intelligent rendering  Concurrent Mode      Better feedback for loading states  Suspense, useTransition      Powerful debugging, inspection and profiling  Dev Tools and Profiler      Targeted error handling  Error Boundaries    The  words  starting  with  ‘use’,  useState,  useReducer,  useContext,  useEffect  and  useTransition,  are  examples  of  React  hooks.  They  are  functions  that  you  can  call  from  React  function  components  and  that  hook  into  key  React  functionality:  state,  lifecycle  and  context.  React  hooks  let  you  add  state  to  function  components,  cleanly  encapsulate  side  effects and reuse code across your project. By using hooks, you do away with the need for    Manning Publications Co.  To comment go to  liveBook   12   classes,  reducing  and  consolidating  your  code  in  an  elegant  way.  Section  1.3  will  discuss  React components and hooks in a little more detail.   Concurrent  Mode  and  Suspense  provide  the  means  to  be  more  deliberate  about  when  code,  data  and  assets  are  loaded  and  to  wrangle  loading  states  and  fallback  content  like  spinners in a coordinated manner. The aim is to improve the user experience as applications  load and states change and to improve the developer experience, making it easier to hook  into  these  new  behaviors.  React  can  pause  the  rendering  of  expensive  but  non-urgent  components  and  switch  to  urgent  tasks,  like  reacting  to  user  interactions,  to  keep  your  application responsive, and smooth the perceived path for user productivity.   The  React  documentation  at  reactjs.com  is  a  great  resource,  providing  clear,  well- structured explanations of the philosophy, API and recommended use of the library as well as  blog  posts  from  the  team  and  links  to  live  code  examples,  conference  talks  on  the  new  features,  and  other  React-related  resources.  While  this  book  will  concentrate  on  hooks,  Suspense  and  Concurrent  Mode,  do  check  out  the  official  docs  to  find  out  more  about  the  other additions to React.   1.3  React hooks can add state to function components  As discussed in section 1.1.2, one of React’s core strengths is how it synchronizes application  and component state with the User Interface. As the state changes, due to user interactions  or  data  updates  from  the  system  or  network,  React  intelligently  and  efficiently  works  out  what changes should be made to the DOM in a browser or to the UI more generally in other  environments.   The state could be local to a component, raised to a component higher in the tree and  shared  amongst  siblings  via  properties,  or  global  and  accessed  via  React’s  Context  mechanism  or  higher  order  components   functions  that  take  a  component  as  an  argument  and  return  a  new  component  that  wraps  the  passed-in  component  but  that  has  extra  functionality . For a component to have state, it used to be that you’d use a class component  with the JavaScript class extending from React.Component. Now, with React hooks, you can  add state to function components.   Stateful function components: less code, better organization   1.3.1  Compared to classes, function components with hooks encourage cleaner, leaner code that  can be easily tested, maintained and reused. The function component is a JavaScript function  that returns a description of its user interface. That UI depends on properties passed in and  state managed or accessed by the component. Figure 1.11 shows a diagram representing a  function component.    Manning Publications Co.  To comment go to  liveBook   13      Figure 1.11. A Quiz function component with state and encapsulated code for loading data and managing a  subscription to a service.   The component is a Quiz component that performs a couple of side effects:           It  loads  its  own  question  data  -  both  initial  data  and  new  questions  when  the  user  chooses a new question set.  It subscribes to a user service - the service provides updates about other quiz users  currently online so the user can join a team or challenge a rival.   In  JavaScript,  functions  can  contain  other  functions,  so  the  component  can  contain  event  handlers  that  react  to  user  interactions  with  the  UI,  for  example  to  show,  hide  or  submit  answers or to move to the next question. Within the component, you can easily encapsulate  side effects, like fetching the question data or subscribing to the user service. You can also  include  clean-up  code  for  those  side  effects  to  cancel  any  unfinished  data  fetching  and  unsubscribe from the user service. Using hooks, those features can even be extracted into  their own functions outside of the component, ready for reuse or sharing.   Here are some of the results of using the new function component approach rather than   the older class-based approach:    Manning Publications Co.  To comment go to  liveBook   14   less code         better code organization with related code kept together along with any clean-up code     extraction of features to external functions that can be reused and shared     more easily testable components     no need to call super  in a class constructor     no need to work with this and bind handlers     simpler lifecycle model      local state is in scope for handlers, side effect functions and the returned UI   All of the items in that list facilitate writing code that’s easier to understand and so easier to  work with and maintain. That’s not to say there aren’t nuances that could trip up developers  working  with  the  new  approaches  for  the  first  time,  but  I’ll  highlight  those  nuances  as  we  delve more deeply into each concept and their connections throughout this book.   React  Hooks  in  Action  outlines  the  functional  approach  to  component  building  going  forwards,  rather  than  using  classes.  However,  it’s  sometimes  worth  comparing  the  new  methods with the old to motivate adoption and because it’s interesting  and, in the case of  hooks, a little cool!  to see the difference. If you’re new to React and have never seen the  code for class components, don’t worry. Rest assured that the function components we’ll be  using  for  the  rest  of  the  book  are  the  preferred  approach  going  forward.  The  following  discussion should still give you an idea of how this new approach simplifies and organizes the  code needed to create React components.   The  title  of  this  section  is  Stateful  function  components:  less code,  better organization.  Than what? Well, with class components, state was set up in the constructor function, event  handlers were bound to this, and side effect code was split across multiple lifecycle methods   componentDidMount,  componentWillUnmount,  componentWillUpdate,  and  so  on .  It  was  common  for  code  relating  to  different  effects  and  features  to  sit  side  by  side  in  a  lifecycle  method. You can see in figure 1.12 how the Quiz class component code for loading question  data  and  subscribing  to  the  user  service  is  split  across  methods  and  how  some  methods  include a mix of code for the two different tasks.    Manning Publications Co.  To comment go to  liveBook   15      Figure 1.12. A class component with code spread across lifecycle methods, and a function component with  the same functionality but with less, better organized code.   Function components with hooks no longer need all the lifecycle methods because effects can  be  encapsulated  into  hooks. The  change  leads  to  neater, better organized  code  as seen  in  the  Quiz  function  component  in  figure  1.12.  The  code  has  been  much  more  sensibly  organized  with  the  two  different  side  effects  separated  and  their  code  consolidated  in  one  place  for  each  effect.  The  improved  organization  makes  it  easier  to  find  the  code  for  a    Manning Publications Co.  To comment go to  liveBook   16   particular effect, see how a component works and maintain it in the future. In fact, keeping a  feature or effect’s code in one place makes it much easier to extract into an external function  of its own and that’s what we’ll discuss next.   Custom hooks: easier code reuse   1.3.2  Function components with hooks encourage you to keep related side effect logic in one place.  If the side effect is a feature that many components will need, you can take the organization  a  step  further  and  extract  the  code  into  its  own  external  function;  you  can  create  what  is  called  a  custom  hook.  Figure  1.13  shows  how  the  question  loading  and  user  service  subscription  tasks  for  the  Quiz  function  component  could  be  moved  into  their  own  custom  hooks.  Any  state  that  is  used  solely  for  those  tasks  can  be  moved  into  the  corresponding  hook.      Figure 1.13. The code for fetching question data and for subscribing to a user service can be extracted into  custom hooks. The accompanying state can also be managed by the hooks.   There  is  no  magic  here,  it  just  how  functions  usually  work  in  JavaScript:  the  function  is  extracted from the component and then called from the component. Once you have a custom  hook, you aren’t restricted to calling it from your original component, you can use it across  many components, share it with your team or publish it for others to use. Figure 1.14 shows  the  new  super-slim  Quiz  function  component  using  the  useUsers  custom  hook  and  the  useFetch custom hook to carry out the user service subscription and question fetching tasks  that,  previously,  it carried out  on  its  own. But,  there’s  now  a second  component,  the Chat  component,  that  makes  use  of  the  useUsers  custom  hook  too.  Hooks  make  this  kind  of  feature  sharing  much  easier  in  React;  custom  hooks  can  be  imported  and  used  wherever  they are needed in your portfolio of applications.    Manning Publications Co.  To comment go to  liveBook   17      Figure 1.14. You can extract code into Custom Hooks for reuse and sharing. The Quiz component calls both  the useUsers and useFetch hooks. The Chat component calls the useUsers hook.   Each custom hook can maintain its own state, whatever it needs to perform its duties. And  because hooks are just functions, if components need access to any of the hook’s state, the  hook can include the state in its return value. For example, a custom hook that fetches user  info  for  a  specified  id  could  store  the  fetched  user  data  locally  but  return  it  to  any  components that call the hook. Each hook call encapsulates its own state, just like any other  function.    Manning Publications Co.  To comment go to  liveBook   18      Figure 1.15. usehooks.com has many examples of Custom Hooks.   To get a sense of the variety of common tasks that programmers have easily abstracted into  custom hooks, take a look at useHooks.com  figure 1.15 . It showcases a number of easy to  use recipes, including:      useRouter - wraps the new hooks made available by React Router.     useAuth  -  enables  any  component  to  get  the  current  auth  state  and  re-render  if  it      useEventListener  -  abstracts  the  process  of  adding  and  removing  event  listeners  to   changes.   components.      useMedia - makes it easy to use media queries in your component logic.   It’s  well  worth  researching  on  sites  like  usehooks.com  or  in  package  repositories  like  npm  whether hooks exist that fit your use cases before rolling your own. If you already make use  of  libraries  or  frameworks  for  common  scenarios  like  data  fetching  or  state  management,  check  the  latest  versions  to  see  if  they’ve  introduced  hooks  to  make  working  with  them  easier. We’ll take a look at a few such packages in the next section.    Manning Publications Co.  To comment go to  liveBook   19   Third party hooks provide ready-made, well-tested functionality   1.3.3  Sharing  functionality  across  components  is  not  new,  it’s  been  an  essential  part  of  React  development  for  some  time. Hooks offer  a  much cleaner way of  sharing  code  and  hooking  into  functionality  than  the  older  methods  of  Higher  Order  Components  and  Render  Props  which often lead to highly nested code  “wrapper hell”  and false code hierarchies.   Third party libraries that work with React have been quick to release new versions that  make  the  most of  hook’s  simpler  API  and  more  direct methods of  integration.  We’ll  take  a  very brief look at three examples in this section:      React Router for page navigation     Redux as an application data store     React Spring for animation   REACT ROUTER  React Router provides components to help developers manage navigation between pages in  their apps. Its custom hooks make it easy to access common objects involved in navigation:  useHistory, useLocation, useParams,  and useRouteMatch.  For  example, useParams gives  access to any parameters matched in a page’s URL:  URL:   quiz :title :qnum  Code:  const { title, qnum } = useParams  ;  REDUX  For some applications, a separate store for state might be appropriate. Redux is a popular  library  for  creating  such  stores  and  it  is  often  combined  with  React  via  the  React  Redux  library.  Since  version  7.1,  React  Redux  offers  hooks  to  make  interacting  with  the  store  easier:  useSelector,  useDispatch,  and  useStore.  For  example,  useDispatch  lets  you  dispatch  an  action  to  update  the  state  in  the  store.  Say  you  have  an  application  to  build  question sets for quizzes and you want to add a question:  const dispatch = useDispatch  ;  dispatch { type: "add question", payload:  * question data *  } ;  The  new  custom  hooks  remove  some  of  the  boilerplate  code  that  was  associated  with  connecting a React application to a Redux store. React also has a built-in hook, useReducer,  which might provide a simpler model for dispatching actions to update state and remove the  perceived need for Redux in some cases.   REACT SPRING  React Spring is a spring-based animation library that currently provides five hooks to access  its  functionality:  useSpring,  useSprings,  useTrail,  useTransition,  and  useChain.  For  example, to animate between two values you can opt for useSpring:  const props = useSpring {opacity: 1, from: {opacity: 0}} ;  React hooks have made it easier for library authors to provide developers with simpler APIs  that  don’t  clutter  their  code  with  potentially  deeply  nested  false  component  hierarchies.  Similarly,  a  couple  of  other  new  React  features,  Concurrent  Mode  and  Suspense,  enable    Manning Publications Co.  To comment go to  liveBook   20   library  authors  and  app  developers  to  better  manage  asynchronous  processes  within  their  code and provide smoother, more responsive user experiences.   1.4  Better UX with Concurrent Mode and Suspense  We  want  to  develop  great  experiences  for  our  users  that  help  them  interact  with  our  applications  smoothly  and  enjoyably.  That  might  mean  them  getting  a  job  done  in  a  productivity  app,  connecting  with  friends  on  a  social  platform  or  capturing  a  crystal  in  a  game. Whatever their goal, the interfaces we design and code should be a means to an end  rather than a stumbling block. But, our apps may need to load a lot of code, fetch a lot of  data and try to manipulate the data to provide the information the user needs, even as they  switch quickly from view to view, scrolling and clicking and tapping as they go.   A  large  part  of  the  motivation  for  the  rewrite  of  React  for  version  16  was  to  build  the  architecture  to  cope  with  the  multiple  demands  put  upon  a  user  interface  as  it  loads  and  manipulates data while users continue interacting with the application. Concurrent Mode is a  core  piece  of  that  new  architecture  and  Suspense  components  fit  the  new  mode  naturally.  But what problems do they solve?   Say you have an app that shows products in a long list and has a text box that users type  in to filter the list. Your app updates the list as the user types. Each keystroke triggers the  code  to  filter  the  list  anew,  requiring  React  to  draw  the  updated  list  components  to  the  screen.  The  expensive  filtering  process  and  recalculation  and  updating  of  the  UI  hogs  the  processing time, reducing the responsiveness of the text box. The experience for the user is  one of a lagging, slow text box that doesn’t show their text as they type. Figure 1.16, while  obviously not being a perfect representation of how a browser might schedule code to run,  does illustrate the point that long-running operations can slow down updates to the screen,  causing a poorer experience for users.   Figure 1.16. Without Concurrent Mode, interactions like keystrokes are blocked by long-running updates.       Manning Publications Co.  To comment go to  liveBook   21   Wouldn’t  it  be  great  if  the  app  could  prioritize  the  text  box  updates  and  keep  the  user  experience smooth, pausing and restarting the filtering duties around the typing? Well, let’s  cut the jank and say hello to Concurrent Mode.   Concurrent Mode   1.4.1  With Concurrent Mode, React can schedule tasks in a more granular way, pausing its work  building elements, checking for differences and updating the DOM for previous state changes  to  make  sure  it  responds  to  user  interactions,  for  example.  In  the  filtering  app  example  above, React can pause rendering of the filtered list to make sure the text the user is typing  appears in the text box.   So how does Concurrent Mode enable this magic? The new React architecture breaks its  tasks into smaller units of work, providing regular points for the browser or operating system  to inform the application that a user is trying to interact with it. React’s scheduler can then  decide what jobs to do based on the priority of each. Reconciling and committing changes to  one part of the component tree can be paused or abandoned to make sure components with  higher priority are updated first.      Figure 1.17. In Concurrent Mode, React can pause longer running updates to quickly react to user interactions.   It’s not just user interactions that can benefit from this intelligent scheduling, responses to  incoming data, lazily loaded components or media, or other asynchronous processes can also  enjoy a smoother user interface upgrade. Concurrent Mode enables a couple of new hooks,  useTransition  and  useDeferredValue,  that  improve  the  user  experience,  smoothing  the  change  from  one  view  to  another  or  one  state  to  another.  It  also  goes  hand-in-hand  with  Suspense, both a component for rendering fallback content and a mechanism for specifying  that a component is waiting for something, like loading data.   Suspense   1.4.2  As  we  have  seen,  React  applications  are  built  from  components  in  a  hierarchical  tree.  To  display the current state of your app on screen, using the DOM for instance, React traverses  your components and creates element trees, descriptions of the intended UI, in memory. It  compares the latest tree with the previous one and intelligently decides what DOM updates    Manning Publications Co.  To comment go to  liveBook   22   need to be made to realize the intended UI. Concurrent mode lets React pause processing of  parts  of  the  element  tree,  either  to  work  on  higher  priority  tasks  or  because  the  current  component isn’t ready to be processed.   Components built to work with Suspense can now suspend if they are not ready to return  their UI  remember components are either functions or have a render method and convert  properties and state into UI . They might be waiting for component code or assets or data to  load and just don’t yet have the information they need to fully describe their UI. React can  pause processing of a suspended component and carry on traversing the element tree. But  how does that look on the screen? Will there be a hole in your user interface?   As  well  as  specifying  a  mechanism  for  components  to  suspend,  React  also  provides  a  Suspense component that you can use to plug holes that suspended components have left in  your  user  interface.  Wrap  sections  of  your  UI  in  Suspense  components  and  use  their  fallback properties to let React know what content to show if one or more of the wrapped  components suspends.    }>                  Suspense  allows  the  developer  to  deliberately  manage  loading  states  for  multiple  components,  either  showing  fallbacks  for  individual  components,  groups  of  components  or  the app as a whole. It provides a mechanism for library authors to update their APIs to work  with  the  Suspense  component,  so  their  asynchronous  features  can  make  full  use  of  the  loading state management that Suspense provides.   1.5  React’s new publication channels  To enable application developers and library authors to make the most of stable features in  production  but  still  prepare  for  upcoming  features,  the  React  team  has  started  publishing  code in separate channels:      Latest: stable semver release.     Next: tracks the master branch of React development.     Experimental: includes experimental APIs and features.   For production, developers should stick with the Latest release - it’s the one you get when  installing  React  from  npm   or  another  package  manager .  Much  of  Concurrent  Mode  and  Suspense for data fetching are on the experimental channel at the time of writing. They are  in the pipeline but there may be changes to the API. The React and Relay  for data fetching   teams  have  been  using  many  of  the  experimental  features  on  the  new  facebook.com   in  beta  for some time. Such active use enables them to develop a strong understanding of the  new approaches in context and at scale. By opening up the discussion of new features early  and  making  them  available  in  an  experimental  channel,  the  React  team  enable  library  authors to test integrations and new APIs and application developers to start adapting to new  mindsets and nuances.    Manning Publications Co.  To comment go to  liveBook   23   1.6  Who is this book for?  This  book  is  for  experienced  JavaScript  developers  who  want  to  learn  about  the  latest  features in React. It focuses on React hooks, Concurrent Mode and Suspense, using plenty of  code examples to get you up to speed and ready to use these features in your own projects   although  not  necessarily  in  production  yet  for  those  features  currently  in  React’s  experimental channel . As well as providing simple, practical examples, the book also spends  a  little  time  probing  a  bit  deeper  into  the  reasoning  behind  some  of  the  features  and  the  nuances that developers would do well to be aware of.   This  is  not  an  introduction  to  React  as  a  whole  and  won’t  cover  the  React  ecosystem,  build  tools,  styling  or  testing  in  any  detail.  The  reader  should  have  a  knowledge  of  basic  React  concepts  and  be  able  to  create,  build  and  run  a  React  application.  The  book  will  occasionally use class component examples as comparisons to the new function component  approach but will not focus on teaching the class-based approach, higher order components  or render props in any depth.  Don’t worry if you don’t know all those terms - you don’t need  to know about them to learn the new concepts.    Readers should be comfortable with some of the more recent JavaScript syntax additions,  like const and let, object and array destructuring, default parameters, the spread operator  and  array  methods  like  map,  filter  and  reduce.  Some  of  the  comparisons  with  class  components will obviously be using JavaScript’s class syntax so familiarity with that would be  useful but is not essential.   1.7  Getting started  The  code  examples  for  the  book’s  main  example,  a  bookings  app,  are  on  GitHub  at  https:  github.com jrlarsen react-hooks-in-action  and  are  [will  be]  downloadable  from  the  book’s page at Manning.com. Each step in the example apps development is on a separate  git  branch  and  the  book’s  code  listings  include  the  name  of  the  relevant  branch.  Smaller,  standalone React examples are hosted on codesandbox.io and a few simple vanilla JavaScript  examples are on JS Bin. Links to sandboxes and bins will accompany the book’s listings.   You’ll need a code editor and a system with Node.js installed but we’ll get to that as we   walk through a project in chapter 2. Let’s get going!   1.8  Summary  1 React is evolving   1.1 What is React?                              1.1.1 Building a UI from components   1.1.2 React synchronizes state and UI   1.1.3 Component Types   1.2 What’s new in React?   1.3 React hooks can add state to function components    Manning Publications Co.  To comment go to  liveBook   24   1.3.1 Stateful function components: less code, better organization   1.3.2 Custom Hooks: easier code reuse   1.3.3 Third party hooks provide ready-made, well-tested functionality   1.4 Better UX with Concurrent Mode and Suspense                                                1.4.1 Concurrent Mode   1.4.2 Suspense   1.5 React’s new publication channels   1.6 Who is this book for?   1.7 Getting started   1.8 Summary    Manning Publications Co.  To comment go to  liveBook   25       Managing component state with the  useState hook   This chapter covers      Asking React to manage component state values by calling useState     Changing state values and triggering re-renders with an updater function     Using the previous state to help generate new state values     Managing multiple pieces of state     Considering how React and components interact to persist and update state and   synchronize state and UI   If you’re building React apps, then you’re expecting the data your app uses to change over  time. Whether it’s fully server-rendered, a mobile app or all in a browser, your application’s  user interface should represent the current data or state at the time of rendering. Sometimes  multiple  components  throughout  the  app  will  use  the  data,  and  sometimes  a  component  doesn’t  need  to  share  its  secrets  and  can  manage  its  own  state  without  the  help  of  mammoth,  application-wide  state-store  behemoths.  In  this  chapter,  we’ll  keep  it  personal  and  concentrate  on  components  taking  care  of  themselves,  without  regard  for  other  components around them.   Figure 3.1 shows a very basic illustration of React’s job: it should use the current state to  render the UI. If the state changes, React should re-render the UI. The illustration shows a  name in a friendly message. When the name value changes, React updates the UI to show  the  new  name  in  its  message.  We  usually  want  the  state  and  UI  to  always  be  in  sync   although we might choose to delay synchronization during state transitions - when fetching  the latest data, for example .    Manning Publications Co.  To comment go to  liveBook   26   Figure 3.1 When you change a value in a component, React should update the UI.      React  provides  a  small  number  of  functions,  or  hooks,  to  enable  it  to  track  values  in  your  components  and  keep  the  state  and  UI  in  sync.  For  single  values  it  gives  us  the  useState  hook and that’s the hook we explore in this chapter. We look at how to call the hook, what it  returns,  and  how  we  use  it  to  update  the  state,  triggering  React  to  update  the  UI.  Components often need more than one piece of state to do their jobs, so we see how we can  call useState multiple times to handle multiple values. It’s not just a matter of documenting  the useState API - you can go to the official React docs for that - we use the discussion of  the useState hook to help us better understand what function components are and how they  work. To that end, we finish the chapter with a review of the key concepts met as our code  listings have evolved.   Talking  of  code  listings,  we  start  work  on  the  app  that  will  form  the  main  example  throughout React Hooks in Action. The example acts as a consistent context in which we use  React hooks to solve common coding problems. There’s a little bit of housekeeping to set up  the app but once that’s done we’re able to concentrate on a single component for the rest of  the chapter.   3.1  Setting up the bookings manager app  Your fun but professional company has a number of resources that can be booked by staff:  meeting rooms, AV equipment, technician time, table football and even party supplies. One  day, the boss asks you to set up the skeleton of an app for the company network that lets  staff  book  the  resources.  The  app  should  have  three  pages,  for  bookings,  bookables  and  users, as shown in figure 3.2.    Manning Publications Co.  To comment go to  liveBook   27   Figure 3.2 The Bookings app has three pages, for Bookings, Bookables and Users.   By the end of section 3.1 you’ll be able to display each page and use the links to navigate  between  them.  The  project  folder  at  the  end  of  the  section  will  include  public  and  src  folders that look like those in figure 3.3.      Figure 3.3 The public and src folders after our initial setup.      You can see how the sub-folders inside the components folder correspond to the three pages.  There are six jobs to do to get the app into the shape shown in the figure:   1.  Use create-react-app to generate the skeleton for our bookings app.  2.  Remove the create-react-app generated files we won’t be using.  3.  Edit four of the files that are left, in the public and src folders.  4.  Install a few packages from npm.    Manning Publications Co.  To comment go to  liveBook   28   5.  Add a ‘database’ file to give the app some data to display.  6.  Create sub-folders for each page and put the page components in them.   First things first: we need a React app!   Generating the app skeleton with create-react-app   3.1.1  React’s  create-react-app  utility  generates  projects  with  preset  linting  and  compilation  workflows set up. It also comes with a development server that’s perfect for us as we work  through the ever-evolving stages of our app. Let’s use create-react-app to generate a new  React  project  called  react-hooks-in-action.  We  don’t  need  to  install  create-react-app,  we can run it from its repository using the npx command:  npx create-react-app react-hooks-in-action   It’ll take a little while to do its thing and you should end up with a whole bunch of generated  files  in  a  react-hooks-in-action  folder.  We  don’t  need  all  of  them  for  our  app,  so  let’s  quickly  delete  a  few.  From  the  public  folder  inside  the  react-hooks-in-action  folder,  remove  all  but  index.html.  From  the  src  folder,  remove  all  but  App.css,  App.js  and  index.js. Figure 3.4 highlights the files to remove.   Figure 3.4 Our project doesn’t need many of the default files generated by create-react-app.      Figure 3.5 shows the four main files left, in the public and src folders. We use them to run  our app, importing the components we build throughout the book.    Manning Publications Co.  To comment go to  liveBook   29   Figure 3.5 The four files we need to set up, in the public and src folders.      The  four files  are  set  up  for React’s demo page,  not  our bookings  app.  It’s  time  for  a  few  tweaks.   3.1.2  Our little workhorse files will get the app up and running. Let me introduce you to:   Editing the four key files       public index.html - the web page that contains the app.      src App.css - some styles to organize elements on the page.      src components App.js - the root component that contains all the others.      src index.js  -  the  file  that  imports  the  App  component  and  renders  it  to  the   index.html page.   You  can  find  the  code  examples  for  the  ongoing  bookings  example  app  on  GitHub  at  https:  github.com jrlarsen react-hooks-in-action, with branches set up for each evolution of  the  code.  Each  listing  for  the  example  app  includes  the  name  of  the  branch  to  checkout  linked  to  the  GitHub  repo.  For  example,  to  get  the  code  for  the  first  branch,  enter  the  command:   git checkout 0301-pages   Okay, let’s get started with our first code listings.   INDEX.HTML  Inside the public folder, edit the index.html file. A lot of the create-react-app generated  boilerplate can come out. The div element with an id of root must stay, it’s the container  element for the app. React will render the App component into that div. You can also set the  title for the page, as has been done in listing 3.1.   Branch: 0301-pages, File:  public index.html   Listing 3.1 The HTML skeleton for the bookings app                             Manning Publications Co.  To comment go to  liveBook   30        Bookings App                                            A                                                                   B           A Set the title for the page  B Make sure there is a div with an id of root  That’s all we need for the web page. The App component will appear in the div, and all our  other components - for bookable items, bookings, users and their separate pages - will be  managed by the App component.  APP.CSS  React  Hooks  in  Action  isn’t  here  to  teach  you  CSS,  so  it  won’t  focus  on  listings  of  styles.  There  will  be  times  when  CSS  is  used  in  combination  with  events  in  components,  when  loading  data  for  example,  and  the  relevant  styles  will  be  highlighted  at  those  times.  The  stylesheet will develop over time, so, if you’re interested, take a look in the repo. The initial  styles  can  be  found  at:  Branch:  0301-pages,  File:   src App.css.   If  you’re  not  particularly  interested in the evolution of the CSS throughout the project but want to code-along with the  JavaScript, just grab the App.css file from the finished project.    The styles use CSS grid properties to position the main components on each page, and   some CSS variables to define common colors for text and backgrounds.   APP.JS  The App component is the root component for our application. It displays the header with its  links and user-picker drop-down, as shown in figure 3.6.   Figure 3.6 The header with three links and a drop-down list.   It also sets up routes to the three main pages, as shown in listing 3.2. The router shows the  appropriate page to the user by matching the URL with a page component. The App.js file  has been moved to a new components folder. It imports a number of components that we  create later in the chapter.   Branch: 0301-pages, File:  src components App.js      Listing 3.2 The App component  import React from "react";    import {                                                                A    BrowserRouter as Router,                                              A    Routes,                                                               A    Route,                                                                A    Manning Publications Co.  To comment go to  liveBook   31     Link                                                                  A  } from "react-router-dom";                                              A    import ".. App.css";    import {FaCalendarAlt, FaDoorOpen, FaUsers} from "react-icons fa";      B    import BookablesPage from ". Bookables BookablesPage";                  C  import BookingsPage from ". Bookings BookingsPage";                     C  import UsersPage from ". Users UsersPage";                              C  import UserPicker from ". Users UserPicker.js";                         C    export default function App    {    return                                                                     D                                                                                            E                                                           E                     Bookings                                  E                                                                    E                                                            F                                          Bookables                                                                                                                                          G                     Users                                                                                                                                H                                                                               I             } >          J             } >        K             } >                L                                ;  }   A Import the routing elements from react-router-dom  B Import the icons for the navigation links  C Import the separate page components and the UserPicker  D Wrap the app in a Router component to enable routing  E Use Link components along with the Router    Manning Publications Co.  To comment go to  liveBook   32   F Use the ‘to’ attribute to specify where the link goes  G Use imported icons to decorate the links  H Place the UserPicker in the header  I Wrap the collection of Route components in a Routes component  J Use a Route for each path you want to match  K Match a path to display a particular page component  L Specify the component to display for the matched path  The app uses React Router version 6 to manage the display of its three pages. At the time of  writing, React Router 6 is a beta release available via React Router’s next channel. Install it  like this:   npm i history react-router-dom@next   out   more   about   Find  page   https:  github.com ReactTraining react-router . We use the Link component to display our  page  links  in  the  header  and  Route  elements  to  conditionally  display  page  components  depending on the matched URL. For example, if the user visits  bookings the BookingsPage  component will be displayed.   GitHub   Router   React   on   its    } >   For now, you don’t need to worry about React Router, it’s just managing the links and the  display of our page components. We make much more use of it in chapter 11 when we start  to  use  some  of  the  custom  hooks  it  provides  to  access  matched  URLs  and  query  string  parameters.   As  you  can  see  in  figure  3.7,  we’ve  decorated  the  header  links  with  icons  from  Font   Awesome  https:  fontawesome.com .      Figure 3.7 The header includes Font Awesome icons beside each link.   The icons are available as part of the react-icons package, so we need to install the package:  npm i react-icons  The react-icons GitHub page  https:  github.com react-icons react-icons  includes details of  the icon sets available in the package along with links to relevant licensing information.   The  App  component  also  imports  the  three  page  components,  BookablesPage,  BookingsPage and UsersPage, and the UserPicker component. We create those in section  3.1.4.    Manning Publications Co.  To comment go to  liveBook   33   INDEX.JS  React needs a JavaScript file to act as a way in to the application. In the src folder, edit the  index.js file to look like listing 3.3. It imports the App component and renders it into the  root div seen in the index.html file back in listing 3.1.   Branch: 0301-pages, File:  src index.js   Listing 3.3 The top-level JavaScript file  import React from "react";  import ReactDOM from "react-dom";  import App from ". components App";                                       A    ReactDOM.render      ,                                                                B    document.getElementById "root"                                          C   ;   A Import the App component for the current version of the app  B Specify App as the component to render  C Specify where to render the App component  And that’s the four existing files tweaked! We still need to create the page components for  the App component to import and the UserPicker drop-down for the header. First, the app  will need some bookables and users to show. Let’s give it some data.   Adding a database file for the application   3.1.3  Our application needs a few different types of data, including users, bookables and bookings.  We start off by importing all of the data from a single JSON file, static.json. We just need  some  bookables  and  users  to  show  in  lists, so  the  initial  data  file  isn’t  too  complicated,  as  you can see in listing 3.4.   Branch: 0301-pages, File:  src static.json   Listing 3.4 The bookings app data structure  {    "bookables": [  * array of bookable objects *  ],                     A      "users": [  * array of user objects *  ],                             B      "bookings": [],                                                       C      "sessions": [                                                         D      "Breakfast",      "Morning",      "Lunch",      "Afternoon",      "Evening"    ],      "days": [                                                             E      "Sunday",      "Monday",    Manning Publications Co.  To comment go to  liveBook   34       "Tuesday",      "Wednesday",      "Thursday",      "Friday",      "Saturday"    ]  }   A Assign an array of bookables data to the bookables property  B Specify the users who can use the app  C Leave the bookings empty for now  D Configure the available sessions  E Configure the days of the week  Each element in the array of bookables is an object that looks something like this:   {    "id": 3,    "group": "Rooms",    "title": "Games Room",    "notes": "Table tennis, table football, pinball! Please tidy up!",    "sessions": [0, 2, 4],    "days": [0, 2, 3, 4, 5, 6]  }   The  bookables  are  stored  in  an  array  of  bookable  objects,  assigned  to  the  bookables  property. Each bookable has id, group, title and notes properties. The data in the book’s  code  repo  has  slightly  longer  notes  but  the  structure  is  the  same.  Each  bookable  also  specifies the days and sessions for which it can be booked.   Users are also stored as objects, with this structure:   {    "id": 1,    "name": "Mark",    "img": "user1.png",    "title": "Envisioning Sculptor",    "notes": "With the company for 15 years, Mark has consistently…"  }   The  bookables  will  be  listed  by  the  BookablesPage  component  and  the  users  by  the  UsersPage component. We better get those pages built!   Creating page components and a UserPicker.js file   3.1.4  As  we  add  functionality  to  the  app,  we  use  a  number  of  components  to  encapsulate  that  functionality and to demonstrate different techniques that working with hooks offers. We put  our components in folders related to the page they’re on. Create three new folders within the  components folder and name them Bookables, Bookings and Users. For the skeleton app,  create  three  structurally  identical  placeholder  pages  like  the  one  in  listing  3.5.  Call  them  BookablesPage, BookingsPage and UsersPage.   Branch: 0301-pages, File:  src components Bookables BookablesPage.js   Listing 3.5 The BookablesPage component    Manning Publications Co.  To comment go to  liveBook   35   import React from "react";    export default function BookablesPage   {    return                                            A         Bookables!             ;  }   A Assign each page a class so the CSS file can set out the page as appropriate  We finish off the app setup with a UserPicker component. For now, it just shows the word  Users in a drop-down list. We populate it with data later in the chapter.   Branch: 0301-pages, File:  src components Users UserPicker.js   Listing 3.6 The UserPicker component  import React from "react";    export default function UserPicker   {    return                  Users             ;  }   All the pieces are in place for our ongoing exploration of hooks in the context of the bookings  app. Test that it’s working by starting the create-react-app development server:  npm start   If  all’s  well,  you  can  navigate  between  the  three  pages,  with  each  shouting  its  identity  at  you:  Bookables!  Bookings!  Users!  Let’s  calm  the  Bookables  page  down  by  displaying  the  bookables from the database.   3.2  Storing, using and setting values with useState  Your  React  applications  look  after  some  state:  values  shown  in  the  user  interface,  or  that  help  manage  what’s  shown.  The  state  may  include  posts  on  a  forum,  comments  for  those  posts and whether the comments are shown or not, for example. When users interact with  the  app,  they  change  its  state.  They  may  load  more  posts,  toggle  whether  comments  are  visible  or  add  their  own  comments.  React’s  there  to  make  sure  state  and  UI  are  in-sync.  When  the  state  changes,  React  needs  to  run  the  components  that  use  that  state.  The  components  return  their  UI  using  the  latest  state  values.  React  compares  the  returned  UI  with the existing UI and efficiently updates the DOM as necessary.   Some  state  is  shared  across  the  application,  some  by  a  few  components  and  some  is  managed  locally  by  a  component  itself.  If  components  are  just  functions,  how  can  they  persist  their  state  across  renders?  Are  their  variables  not  lost  when  they  finish  executing?  And how does React know when the variables change? If React is faithfully trying to match  the state and the UI, it definitely needs to know about changes to the state, right?    Manning Publications Co.  To comment go to  liveBook   36   The simplest way to persist state across calls to your components and keep React in the  loop  when  you  change  a  component’s  state  is  the  useState  hook.  The  useState  hook  is  a  function that enlists React’s help to manage state values. When you call the useState hook, it  returns both the latest state value and a function for updating the value. Using the updater  function keeps React in the loop and lets it do its syncy business.   This section introduces the useState hook, covering why we need it and how it’s used. In   particular, we look at:      Why just assigning values to variables doesn’t let React do its job.     How useState returns both a value and a function for updating that value.     Setting an initial value for the state, both directly as a value and lazily as a function.     Using the updater function to let React know you want to change the state.     Making sure you have the latest state when you call the updater function and need to   use an existing value to generate a new value.   That list might seem a little scary, but actually the useState hook is very easy to use  and  you’ll  be  using  it  a  lot!   so  don’t  worry,  we’re  just  covering  all  the  bases.  Before  we  call  useState  for  the  first  time,  let’s  see  what  happens  if  we  just  try  to  manage  the  state  ourselves.   Assigning new values to variables doesn’t update the UI   3.2.1  Figure 3.8 shows what we want from our first attempt at the BookablesList component: a  list of four bookable rooms with the Lecture Hall selected.   Figure 3.8. The Bookables component showing a list of rooms with the selected room highlighted.      To  display  the  list of rooms, the BookablesList  component  needs  to  get  its  hands on  the  data for the list. It imports the data from our static.json database file. The component also  needs  to  track  which  bookable  is  currently  selected.  Listing  3.7  shows  the  code  for  the  component, with a room selection hard-coded by setting bookableIndex to 1.  Notice we’re  on a new git branch.    Branch: 0302-hard-coded, File:  src components Bookables BookablesList.js   Listing 3.7 The BookablesList component with hard-coded selection    Manning Publications Co.  To comment go to  liveBook   37   import React from "react";  import {bookables} from ".. .. static.json";                             A    export default function BookablesList   {      const group = "Rooms";                                                 B      const bookablesInGroup = bookables.filter b => b.group === group ;     C        const bookableIndex = 1;                                               D      return                 {bookablesInGroup.map  b, i  =>                                    E          <li            key={b.title}             className={i === bookableIndex ? "selected" : null}            F          >            <button              className="btn"            >              {b.title}                                  }            ;  }   A Use object destructuring to assign the bookables data to a local variable  B Set the group of bookables to be shown  C Filter the bookables to just those in the group  D Hard-code the index of the selected bookable  E Map over the bookables to create a list item for each one  F Set the class by comparing the current index to the selected index  The component destructures the static.json file, assigning the array of bookables from the  data to a local variable called bookables. We could’ve taken an extra step:  import data from ".. .. static.json";    const {bookables} = data;   But we don’t need the data for anything else, so we did our destructuring directly inside the  import:   import {bookables} from ".. .. static.json";   This destructuring approach is one we use often throughout the book.   With  the  array  of  bookables  in  hand,  we  filter  it  to  get  just  those  bookables  in  the   specified group:   const group = "Rooms";    const bookablesInGroup = bookables.filter b => b.group === group ;    Manning Publications Co.  To comment go to  liveBook   38   The  filter  method  returns  a  new  array  and  we  assign  that  to  the  bookablesInGroup  variable.  We  then  use  the  bookablesInGroup  array  to  generate  the  list  of  bookables  for  display.   To display our new component, we need to wire it into the BookablesPage component.   Listing 3.8 shows the two changes needed.   Branch: 0302-hard-coded, File:  src components Bookables BookablesPage.js   Listing 3.8 The BookablesPage component showing the BookablesList  import React from "react";  import BookablesList from ". BookablesList";                            A    export default function BookablesPage   {    return                                                                    B            ;  }   A Import the new component  B Replace the placeholder text with the component  Have  a  go  at  changing  the  hard-coded  index  value  in BookablesList.  The  component  will  always highlight the bookable with the specified index - so far so good. But, it’s all very well  changing  the code  to change  the  highlighted  room.  What we really  want  is for  the  user  to  change it by clicking on a bookable, so let’s add an event handler to each list item button.  Clicking a bookable should select it and the UI should update to highlight the selected item.  Listing 3.9 includes a changeBookable function and an onClick event handler that calls it.   Branch: 0303-direct-change, File:  src components Bookables BookablesList.js   Listing 3.9 Adding an event handler to the BookablesList component  import React from "react";  import {bookables} from ".. .. static.json";    export default function BookablesList   {    const group = "Rooms";    const bookablesInGroup = bookables.filter b => b.group === group ;      let bookableIndex = 1;                                              A      function changeBookable  selectedIndex  {                           B      bookableIndex = selectedIndex;                                    B      console.log selectedIndex ;                                       B    }                                                                   B      return                 {bookablesInGroup.map  b, i  =>            <li            key={b.title}            className={i === bookableIndex ? "selected" : null}                    >     Manning Publications Co.  To comment go to  liveBook   39             <button              className="btn"              onClick={   => changeBookable i }                         C            >              {b.title}                                  }            ;  }   A Declare the variable with let because it will be assigned new values  B Declare a function that assigns the index of the clicked bookable to the bookableIndex variable  C Include an onClick handler that passes the index of the clicked bookable to the changeBookable function  Clicking on one of the rooms now assigns that room’s index to the bookableIndex variable.  And voila! Oh. Hang on… If you run the code in listing 3.9 and try clicking different rooms,  you’ll  see  that  the  highlighting  doesn’t  change.  But,  the  code  does  update  the  bookableIndex value! You can check the console to see the index being logged. Why is the  new selection not shown on the screen? Why has React not updated the UI? Why do people  always ignore me?   It’s okay, deep breaths. Remember, components are functions that return UI. React calls  the functions to get a description of the UI. How does React know when to call the function  and update the UI? Just because you change the value of a variable within your component  function, doesn’t mean React will notice. If you want to get noticed, you can’t just say “Hello,  World!” to people in your head, you have to say it out loud. Figure 3.9 shows what happens  when you directly change a value in a component: React doesn’t notice - it’s happy whistling  away, polishing its widgets - and the UI stays rock-solid, unchanged.   Figure 3.9 Directly changing a variable in our component code doesn’t update the UI.      So how do we get React’s attention and let it know it has work to do? We use the useState  hook.    Manning Publications Co.  To comment go to  liveBook   40   Calling useState returns a value and an updater function   3.2.2  We want to alert React that a value used within a component has changed so it can re-run  the component and update the UI. Just updating the variable directly won’t do. We need a  way  of  changing  that  value,  some  kind  of  updater  function,  that  triggers  React  to  call  the  component with the new value and get the updated UI, as shown in figure 3.10.      Figure 3.10 Rather than changing a value directly, we call an updater function. The updater function changes  the value and React updates the display with the recalculated UI from the component.   In fact, to avoid our component state value disappearing when the component code finishes  running, we can get React to manage the value for us. That’s what the useState hook is for.  Every time React calls our component to get hold of its UI, the component can ask React for  the  latest  state  value  and  for  a  function  to  update  the  value.  The  component  can  use  the  value  when  generating  its  UI  and  use  the  updater  function  when  changing  the  value,  for  example in response to a user clicking an item in a list.   Calling useState returns a value and its updater function as an array with two elements,   as shown in figure 3.11.     Figure 3.11 The useState function returns an array with two elements: a value and an updater function.    Manning Publications Co.  To comment go to  liveBook   41   You  could  assign  the  returned  array  to  a  variable,  and  then  access  the  two  elements  individually, by index, like this:   const selectedRoomArray = useState  ;                                 A    const selectedRoom = selectedRoomArray[0];                            B    const setSelectedRoom = selectedRoomArray[1];                         C   A The useState function returns an array  B The first element is the value  C The second element is the function for updating the value  But,  it’s  more  common  to  use  array  destructuring  and  assign  the  returned  elements  to  variables in one step:   const [ selectedRoom, setSelectedRoom ] = useState  ;   Array  destructuring  lets  us  assign  elements  in  an  array  to  variables  of  our  choosing.  The  names  selectedRoom  and  setSelectedRoom  are  arbitrary  and  our  choice,  although  it’s  common to start the variable name for the second element, the updater function, with set.  The following would work just as well:   const [ myRoom, updateMyRoom ] = useState  ;   If you want to set an initial value for the variable, pass the initial value as an argument to  the useState function. When React first runs your component, useState will return the two- element array as usual but will assign the initial value to the first element of the array, as  shown in figure 3.12.      Figure 3.12 When the component first runs, React assigns the initial value you pass to useState to the  ‘selected’ variable.   The first time the following line of code is executed within a component, React returns the  value “Lecture Hall” as the first element in the array. The code assigns that value to the  selected variable.  const [ selected, setSelected ] = useState "Lecture Hall" ;   Let’s  update  the  BookablesList  component  to  use  the  useState  hook  to  ask  React  to  manage the value of the selected item’s index. We pass it 1 as the initial index. You should    Manning Publications Co.  To comment go to  liveBook   42   see  the  Lecture  Hall  highlighted  when  the BookablesList  component  first  appears  on  the  screen, as shown again in figure 3.13.   Figure 3.13 The Bookables component with Lecture Hall selected.      Listing  3.10  shows  the  updated  code  for  the  component.  It  includes  an  onClick  event  handler that uses the updater function assigned to setBookableIndex to change the selected  index when a user clicks a bookable.   Branch: 0304-set-index, File:  src components Bookables BookablesList.js   Listing 3.10 Triggering an update when changing the selected room  import React, { useState } from "react";                               A   import {bookables} from ".. db.json";    export default function BookablesList    {     const group = "Rooms";    const bookablesInGroup = bookables.filter b => b.group === group ;    const [ bookableIndex, setBookableIndex ] = useState 1 ;             B        return                 {bookablesInGroup.map  b, i  =>            <li            key={b.title}            className={i === bookableIndex ? "selected" : null}          C           >             <button              className="btn"              onClick={   => setBookableIndex i }                        D            >              {b.title}                                  }            ;  }   A Import the useState hook  B Call useState and assign the returned state value and updater function to variables  C Use the state value when generating the UI    Manning Publications Co.  To comment go to  liveBook   43   D Use the updater function to change the state value  React runs the BookablesList component code, returning the value for bookableIndex from  the  call  to  useState.  The  component  uses  that  value  when  generating  the  UI,  to  set  the  correct  className  attribute  for  each  li  element.  When  a  user  clicks  on  a  bookable,  the  onClick event handler uses the updater function, setBookableIndex, to tell React to update  the value it’s managing. If the value’s changed, React knows it’ll need a new version of the  UI.  React  runs  the  BookablesList  code  again,  assigning  the  updated  state  value  to  bookableIndex, letting the component generate the updated UI. React can then compare the  newly generated UI to the old version and decide how to update the display efficiently.   With useState, React is now listening. I don’t feel so lonely anymore. It’s living up to its  promise of keeping the state in sync with the UI. The BookablesList component describes  the  UI for  a  particular  state and  provides  a  way for  users  to change  the  state. React  then  does  its  magic,  checking  if  the  new  UI  is  different  from  the  old   diffing ,  batching  and  scheduling updates, deciding on an efficient way to update DOM elements and then doing the  deed  and  reaching  out  to  the  DOM  on  our  behalf.  We  fixate  on  the  state,  React  does  its  diffing and updates the DOM.   CHALLENGE 3.1  Create a UsersList component that shows the list of users from the database. Enable the  selection of a user and wire the component into the UsersPage.  CHALLENGE 3.2  Update the UserPicker drop-down list component so that it shows the users as options in  the list. Don’t worry about wiring up any event handlers for now.   The challenge tasks are implemented in the 0305-user-lists branch.  In listing 3.10 we passed an initial value of 1 to useState. A user clicking on a different  bookable replaces that value with another number. What if we want to store something more  complicated, like an object, as state? In that case, we need to be a bit more careful when  updating the state. Let’s see why.   Calling the updater function replaces the previous state value   3.2.3  If you’re coming from the class-based approach to component building in React then you’re  used to state being an object with different properties for different state values. Moving to  function  components,  you  may  try  and  replicate  that  state-as-an-object  approach.  It  may  feel more natural to have a single state object and have new state updates merge with the  existing state. But the useState hook is easy to use and easy to call multiple times, once for  each  state  value  you  want  React  to  monitor.  It’s  worth  getting  used  to  separate  calls  to  useState for each state property, as discussed further in Section 3.4, rather than clinging to  what’s  familiar.  If  you  need  to  work  with  objects  as  state  values  or  want  to  group  some  related  values  together   maybe  a  length  and  width,  for  example ,  you  should  be  aware  of  how  setState  as  a  function  component  updater  function  is  different  from  this.setState  you use with a class component. In this section we take a brief look at updating the state of  an object in the two types of components.    Manning Publications Co.  To comment go to  liveBook   44   THE CLASS COMPONENT APPROACH  With  classes,  you  would  set  up  the  state  as  an  object  in  the  constructor,   or  as  a  static  property on the class :   class BookablesList extends React.Component {    constructor  props  {      super props ;        this.state = {        bookableIndex: 1,        group: "Rooms"      };    }  }   handleClick  index  {    this.setState {      bookableIndex: index    } ;  }   To  update  the  state,  in  an  event  handler  say,  you  would  call  this.setState,  passing  an  object with any changes you want to make:   React  would  merge  the  object  you  passed  to  setState  with  the  existing  state.  In  the  example above, it would update the bookableIndex property but leave the group property  alone, as shown in figure 3.14.      Figure 3.14 In a class component, calling the updater function  this.setState  merges the new properties with  the existing state object.   THE FUNCTION COMPONENT APPROACH  In  contrast,  for  the  new  hooks  approach,  the  updater  function  replaces  the  previous  state  value with the value you pass to the function. Now, that’s straightforward if you have simple  state values, like this:   const [bookableIndex, setBookableIndex] = useState 1 ;    Manning Publications Co.  To comment go to  liveBook   45     setBookableIndex 3 ;     React replaces the value 1 with 3.   But,  if  you  decide  to  store  JavaScript  objects  in  state,  you  need  to  tread  carefully.  The  updater function will replace the old object entirely. Say you initialize the state like this:   function BookablesList    {    const [state, setState] = useState {      bookableIndex: 1,      group: "Rooms"    } ;  }   If you call the updater function, setState, with just the changed bookableIndex property:  function handleClick  index  {    setState {      bookableIndex: index    } ;  }   then you lose the group property. The old state object is replaced by the new one, as shown  in figure 3.15.   Figure 3.15 In a function component, calling an updater function  returned by useState  replaces the old state  value with whatever you pass to the updater function.   So, if you really need to use an object with the useState hook, copy across all the properties  from the old object when you set a new property value:      function handleClick  index  {    setState {      ...state,      bookableIndex: index    } ;  }   Notice  how  the  spread operator, ...state,  is  used  in  the  snippet  above  to  copy  all  of  the  properties from the old state to the new. In fact, to ensure you have the latest state when    Manning Publications Co.  To comment go to  liveBook   46   setting  new  values  based on  old,  you  can pass  a function  as  the  argument  to  the  updater  function, like this:   function handleClick  index  {    setState state => {                      A      return {        ...state,                            B        bookableIndex: index      };    } ;  }   A Pass a function to setState  B Use the old state value when setting the new one  React will pass in the latest state as the first argument. This function version of the updater  function is discussed in more detail in section 3.2.5.   With  that  brief  caveat  about  working  with  objects  out  of  the  way,  there’s  one  more  feature of the useState hook API we need to mention before calling useState multiple times  with  abandon.  Occasionally,  you  might  need  to  hold  off  on  calculating  expensive  initial  values. There’s a function for that.   Passing a function to useState as the initial value   3.2.4  Sometimes, a component may need to do some work to calculate an initial value for a piece  of  state.  Maybe  the  component  is  passed  a  tangled  string  of  data  from  a  legacy  storage  system  and  needs  to  extract  a  nugget  of  useful  info  from  amongst  the  frayed  knots.  Unravelling  the  string  may  take  a  while  and  you  only  want  to  do  the  work  once.  This  approach is wasteful:   function untangle  aFrayedKnot  {       perform expensive untangling manoeuvers    return nugget;  }    function ShinyComponent  { tangledWeb }  {    const [shiny, setShiny] = useState untangle tangledWeb  ;         use shiny value and allow new shiny values to be set  }   Whenever ShinyComponent  runs,  maybe  in  response  to  setting  another  piece  of  state,  the  expensive untangle function runs as well. But, useState only uses its initial value argument  on  the  first  call.  After  the  first  call,  it  won’t  use  the  value  untangle  returns.  Running  the  expensive untangle function again and again is a waste of time.   Luckily,  the  useState  hook  accepts  a  function  as  its  argument,  a  lazy  initial  state,  as   shown in figure 3.16.    Manning Publications Co.  To comment go to  liveBook   47   Figure 3.16 You can pass a function to useState as the initial value. React will use the function’s return value  as the initial value.   React  only  executes  the  function  the  first  time  the  component’s  rendered.  It  uses  the  function’s return value as the initial state.   function ShinyString  { tangledWeb }  {    const [shiny, setShiny] = useState    => untangle tangledWeb  ;         use shiny value and allow new shiny values to be set  }   Use the lazy initial state if you need to undertake expensive work to generate an initial value  for some piece of state.   Using the previous state when setting the new state   3.2.5  It would be great if users could access all the functionality of the BookablesList component  via the keyboard. Let’s add a Next button that cycles through the bookables in the list, as  shown in figure 3.17.    Manning Publications Co.  To comment go to  liveBook         48   Figure 3.17 Clicking the Next button selects the next bookable in the list.   The Next button needs to increment the bookableIndex state value, wrapping back round to  0  when  it  goes  past  the  last  bookable.  Listing  3.11  shows  the  implementation  of  the  Next  button.   Branch: 0306-next-button, File:  src components Bookables BookablesList.js   Listing 3.11 Passing a function to setBookableIndex  import React, { useState } from "react";   import {bookables} from ".. .. static.json";  import {FaArrowRight} from "react-icons fa";                             A    export default function BookablesList    {    const group = "Rooms";    const bookablesInGroup = bookables.filter b => b.group === group ;    const [ bookableIndex, setBookableIndex ] = useState 0 ;      function nextBookable    {                                             B      setBookableIndex i =>  i + 1  % bookablesInGroup.length ;            C    }      return                            {bookablesInGroup.map  b, i  =>              <li              key={b.title}              className={i === bookableIndex ? "selected" : null}            >              <button                className="btn"                onClick={   => setBookableIndex i }              >                {b.title}                                        }                            <button            className="btn"            onClick={nextBookable}                                         D            autoFocus          >                          Next                                 ;  }   A Import a Font Awesome icon  B Create an event handler for the Next button  C Pass the updater function a function to increment the index    Manning Publications Co.  To comment go to  liveBook   49   D Include a button to call the nextBookable function  In  the  event  handler  for  the  Next  button,  nextBookable,  we  call  the  updater  function,  setBookableIndex, passing it a function:  setBookableIndex i =>  i + 1  % bookablesInGroup.length ;   But why not just use the state value for the index that we already have?   setBookableIndex  bookableIndex + 1  % bookablesInGroup.length ;   By using hooks to hand over management of our state values to React, we don’t just ask it  to  update  values  and  trigger  re-renders,  we  also  give  it  permission  to  efficiently  schedule  when  any  updates  take  place.  It  can  intelligently  batch  updates  together  and  ignore  redundant updates. When we want to update a state value based on its previous value, like  in our Next button example, instead of passing the updater function a value to set, we can  pass it a function. React will pass that function the current state value and will use the return  value of that function as the new state value. All the pieces are shown in figure 3.18.      Figure 3.18 Pass the updater function a function that uses the old state value and returns a new state value.   By passing a function, we ensure that any new values that are based on old values have the  latest information with which to work.   Listing 3.11 uses a separate function, nextBookable, for responding to clicks on the Next  button  but  puts  the  handler  for  responding  to  clicks  on  bookables  inline  in  the  onClick  attribute. This is just a personal choice; when a handler does more than just call a simple  updater function, I tend to put it in its own function rather than inline. In the case of listing  3.11,  we  could  just  as  easily  have  the  Next  button  handler  inline  or  the  bookable  click  handler in its own named function.   So, we can call useState to ask React to manage a value for us. But, surely, we’ll need  more  than  a  single  state  value  in  our  component.  Let’s  see  how  to  handle  multiple  state  values as we give users the ability to choose groups in the BookablesList component.    Manning Publications Co.  To comment go to  liveBook   50   3.3  Calling useState multiple times to work with multiple values  Having seen how useState works in some detail, it’s time to get our money’s worth. We’re  not limited to a solitary piece of information, or even a solitary object with many properties.  If we’re interested in multiple values to drive a component’s UI, we can just keep calling that  hook.  useState for  this,  useState  for  that,  useState for  the  other.  We  can  useState  all  the  things!   In  this  section,  we  add  to  the  BookablesList  component,  first  letting  users  switch  between groups of bookables, and then displaying the details about the selected bookable.  Remember, it’s our job to fixate on the state, so we need to work with a number of values:      The selected group.     The selected bookable.     Whether the component has the bookable availability  days and sessions  showing or   not.   By the end of this section, we call useState for all three state values. We embed the values  returned  into  our  UI  and  use  the  updater  functions  to  change  the  state  when  the  user  chooses a group or a bookable or toggles the display of details.   Using a drop-down list to set state   3.3.1  Let’s  start  by  updating  the  BookablesList  component  so  that  users  can  select  a  type  of  resource to book: Rooms or Kit. Two instances of the component are shown in figure 3.19,  the first showing bookables in the ‘Rooms’ group and the second showing bookables in the  ‘Kit’ group.   Figure 3.19 Two views of the Bookables component with a drop-down list for selecting the type of bookable:  the first with ‘Rooms’ selected and the second with ‘Kit’ selected.   We want the user to make two different selections: the group to display, ‘Rooms’ or ‘Kit’, and  the  bookable  within  the  group.  Changing  either  variable  should  update  the  display,  so  we       Manning Publications Co.  To comment go to  liveBook   51   want React to track them both. Should we create some kind of state object to pass to React  via the useState hook? Well, no. The easiest approach is just to call useState twice:  const [ group, setGroup ] = useState "Kit" ;  const [ bookableIndex, setBookableIndex ] = useState 0 ;   React  uses  the  order  of  the  calls  to  determine  which  tracked  variable  is  which.  In  the  previous code snippet, every time the component code is invoked the first call to useState  assigns the first tracked value to the group variable, and the second call to useState assigns  the  second  tracked  value  to  the  bookableIndex  variable.  setBookableIndex  updates  the  second tracked value, and setGroup updates the first.   Your  boss  keeps  glancing  your  way,  so  let’s  get  the  group-picking  functionality   implemented for the BookablesList component. Listing 3.12 shows the latest code.   Branch: 0307-groups, File:  src components Bookables BookablesList.js   Listing 3.12 The BookablesList component with two useState calls  import React, { useState } from "react";   import {bookables} from ".. .. static.json";  import {FaArrowRight} from "react-icons fa";    export default function BookablesList    {    const [group, setGroup] = useState "Kit" ;                         A    const bookablesInGroup = bookables.filter b => b.group === group ;    const [bookableIndex, setBookableIndex] = useState 0 ;             B    const groups = [...new Set bookables.map b => b.group  ];          C      function nextBookable    {      setBookableIndex i =>  i + 1  % bookablesInGroup.length ;    }      return                 <select          value={group}          onChange={ e  => setGroup e.target.value }                   D        >          {groups.map g =>  {g}  }    E                              {bookablesInGroup.map  b, i  =>              <li              key={b.title}              className={i === bookableIndex ? "selected" : null}            >              <button                className="btn"                onClick={   => setBookableIndex i }              >                {b.title}                                        }             Manning Publications Co.  To comment go to  liveBook   52                    <button            className="btn"            onClick={nextBookable}            autoFocus          >                          Next                                 ;  };   A Use the first tracked state value to hold the selected group  B Use the second tracked state value to hold the selected bookable index  C Assign an array of unique group names to the groups variable  D Include an event handler to update the selected group  E Create a drop-down list to show each group in the bookables data  The  code  assigns  the group  variable  the  initial  value  of  “Kit”,  so  the  component  starts  off  showing  the  list  of  bookables  in  the  Kit  group.  When  a  user  selects  a  new  group  from the  drop-down list, the setGroup updater function lets React know the value has changed. To get  the  group  names  for  the  drop-down  list  we  put  the  bookables  data  through  a  few  transformations. First, we create an array of just the group names:   bookables.map b => b.group      array of group names   Then, we create a Set from the array of group names. Sets only contain unique values, so  any duplicates will be discarded:   new Set bookables.map b => b.group       set of unique group names   Finally, we create a new array and spread the Set elements into it. The new array contains  only unique group names. Exactly what we’re after!   [...new Set bookables.map b => b.group  ]     array of unique group names   If  the  JS-Fu  is  a  bit  dense,  you  could  always  create  a getUniqueValues  utility  function  to  make things more readable:   function getUniqueValues  array, property  {    const propValues = array.map element => element[property] ;    const uniqueValues = new Set propValues ;    const uniqueValuesArray = [...uniqueValues];      return uniqueValuesArray;  }    const groups = getUniqueValues bookables, "group" ;   We’ll stick with the terse version because it never changes.   I hope you agree, working with two pieces of state is pretty easy. We just call useState  twice. To update the state we just call the appropriate updater function. The user makes a    Manning Publications Co.  To comment go to  liveBook   53   selection,  an  event  handler  updates  the  state,  React  does  the  diffing  and  tickles  the DOM.  Let’s do it again!   Using a checkbox to set state   3.3.2  Our next job is to add a details section to the component to give our office colleagues a bit  more info about each bookable. We make the display of each bookable’s availability optional.  Figure 3.20 shows the BookablesList component with the Show Details checkbox checked:  the days and sessions for which the bookable is available are visible.   Figure 3.20 The BookablesList component with the availability showing. The Show Details checkbox to the  right of the title is checked.   Figure 3.21 shows the component with the checkbox unchecked: the days and sessions are  hidden.       Manning Publications Co.  To comment go to  liveBook   54   Figure 3.21 The BookablesList component with the availability hidden. The Show Details checkbox to the right  of the title is not checked.   As well as the selected group and the selected bookable index, we now have a third piece of  state: we need to track whether or not the details for the selected bookable are displayed.  Listing 3.13 shows the BookablesList component tracking our three variables via useState  hook calls.   Branch: 0308-bookable-details, File:  src components Bookables BookablesList.js      Listing 3.13 The Bookables component tracking three variables  import React, { useState, Fragment } from "react";                     A   import {bookables, sessions, days} from ".. .. static.json";  import {FaArrowRight} from "react-icons fa";    export default function BookablesList   {    const [group, setGroup] = useState "Kit" ;    const bookablesInGroup = bookables.filter b => b.group === group ;    const [bookableIndex, setBookableIndex] = useState 0 ;    const groups = [...new Set bookables.map b => b.group  ];      const bookable = bookablesInGroup[bookableIndex];                    B      const [hasDetails, setHasDetails] = useState false ;                 C      function nextBookable    {      setBookableIndex i =>  i + 1  % bookablesInGroup.length ;    }      return                             * unchanged UI for list of bookables *              Manning Publications Co.  To comment go to  liveBook   55           {bookable &&                                                     D                                        E                                                               {bookable.title}                                                                         <input                                               F                      type="checkbox"                                    F                      checked={hasDetails}                      onChange={   => setHasDetails has => !has }        G                     >                    Show Details                                                                    {bookable.notes}                 {hasDetails &&                                             H                                    Availability                                                                                          I                      {bookable.days                                     I                        .sort                                            I                        .map d =>  {days[d]}              I                      }                                                  I                                                                     I                                                                      J                      {bookable.sessions                                 J                        .map s =>  {sessions[s]}          J                      }                                                  J                                                                     J                                                   }                                 }            ;  };   A Import React.Fragment to wrap multiple elements  B Assign the currently selected bookable to its own variable  C Use a third tracked state value to hold if the details are shown  D Only show the details if a bookable is selected  E Include a new UI section for the selected bookable’s details  F Let users toggle the details with a checkbox  G Include an event handler to update if the details are shown  H Only show the details if hasDetails is true  I Display a list of available days  J Display a list of available sessions    Manning Publications Co.  To comment go to  liveBook   56   The  component  uses  the  current bookableIndex  to  access  the  selected  bookable  from  the  bookablesInGroup array:  const bookable = bookablesInGroup[bookablesIndex];   There’s no need to call useState to store the bookable object itself because it can be derived  from the index value already in state. The UI includes a new section to show the details of  the  selected bookable.  But,  the  component  shows  the  section  only  if  there’s  a bookable  to  display:   {bookable &&                details UI        }   Similarly, the extra info about the selected bookable is only visible if the hasDetails state  value is true, in other words the checkbox is checked:  {hasDetails &&                Bookable availability        }   It  seems  like  our  work  on  the  BookablesList  component  is  done.  We  have  our  list  of  bookables from the currently selected group and the ability to toggle the display of details for  the  selected  bookable.  But,  before  you  pat  yourself  on  the  back  and  book  out  the  games  room and party supplies, follow these three steps:   1.  Select the Games Room - its details are then displayed.  2.  Switch group to “Kit” - the list of kit bookables is displayed with no bookable selected   and the details disappear.  Which bookable is selected?    3.  Click the Next button - the second item of kit, Wireless mics, is selected and its details   appear.   There’s a whiff of stale data in the air. Can you work out what’s happening? We want user  interactions  to  lead  to  predictable  changes  in  state.  Sometimes,  that  means  a  single  interaction  should  lead  to  multiple  pieces  of  state  changing.  The  next  chapter  investigates  the problem and introduces reducers, a mechanism for orchestrating more complicated state  changes and eliminating stale odors. But, before we switch hooks, we review what building  the  BookablesList  component  has  taught  us  about  function  components  in  general.  And  before that, here’s a challenge!   CHALLENGE 3.3  Update  the UsersList  component  to  show  some  details  for  the  selected  user.  Display  the  user’s name, title and notes. A possible approach is shown in figure 3.22, with code in the  0309-user-details branch of the book’s GitHub repo.    Manning Publications Co.  To comment go to  liveBook   57      Figure 3.22 The UsersList component showing details for the selected user.   3.4  Reviewing some function component concepts  At  this  point,  our  BookablesList  component  is  very  simple.  But  there  are  already  some  fundamental  concepts  at  work,  concepts  that  underpin  our  understanding  of  function  components and React hooks. Having a strong grasp of these concepts will make our future  discussions  throughout  the  book  and  your  expert  use  of  hooks  much  easier.  In  particular,  here are five key concepts:      Components are functions that accept props and return a description of their UI.     React invokes the components. As functions, the components run their code, and end.     Some  variables  may  persist  within  closures  created  by  event  handlers.  Others  are   destroyed when the function ends.      We can use hooks to ask React to manage values for us. React can pass components   the latest values and updater functions for those values.      By using the updater functions, we let React know of changing values. It can re-run   the components to get the latest description of the UI.   In order to discuss concepts with clarity and precision, from time to time we take stock of  the key words and objects we’ve encountered so far. Table 3.1 lists and describes some of  the terms we’ve come across:      Icon   Term   Component      Description   A function that accepts props and returns a description of its  UI.    Manning Publications Co.  To comment go to  liveBook   58      Initial value   The component passes this value to useState. React sets the  state value to this initial value when the component first runs.   Updater function   The component calls this function to update the state value.   Event handler         UI      A function that runs in response to an event of some kind. For  example, a user clicking a bookable. Event handlers often call  updater functions to change the state.  A description of the elements that make up a user interface.  The state values are often included somewhere in the UI.   The component cycle diagram on pages mm and nn shows some of the steps involved when  our  BookablesList  component  runs  and  a  user  clicks  a  bookable.  Its  accompanying  table  discusses each step.    Manning Publications Co.  To comment go to  liveBook   59      Figure 3.23 Stepping through the key moments when using useState   Step   What happens?   Discussion   React calls the component.   1   2   The component calls useState  for the first time.   To generate the UI for the page, React traverses the tree of  components, calling each one. React will pass each  component any props set as attributes in the JSX.  The component passes the initial value to the useState  function. React sets the current value for that useState  call from that component.    Manning Publications Co.  To comment go to  liveBook   60   3   4   5   6   7   8   9   10   11   12   13   14   React returns the current value  and an updater function as an  array.   The component code assigns the value and updater function  to variables for later use. The second variable name often  starts with set. E.g. value and setValue.   The component sets up an event  handler.   The component returns its UI.   The event handler may listen for user clicks, for example.  The handler will change the state when it runs later. React  will hook up the handler to the DOM when it updates the  DOM in step 6.  The component uses the current state value to generate its  user interface and returns it, finishing its work.   React updates the DOM   React updates the DOM with any changes needed.   The event handler calls the  updater function.   An event fires and the handler runs. The handler uses the  updater function to change the state value.   React updates the state value.   React replaces the state value with the value passed by the  updater function.   React calls the component.   The component calls useState  for the second time.   React knows the state value has changed so must  recalculate the UI.   This time, React will ignore the initial value argument.   React returns the current state  value and the updater function.   React has updated the state value. The component needs  the latest value.   The component sets up an event  handler.   This is a new version of the handler and may use the newly  updated state value.   The component returns its UI.   The component uses the current state value to generate its  user interface and returns it, finishing its work.   React updates the DOM   React compares the newly returned UI with the old and  efficiently updates the DOM with any changes needed.   3.5  Summary      Call the useState hook when you want React to manage a value for a component. It  returns an array with two elements: the state value and an updater function. You can  pass in an initial value if required.   const [ value, setValue ] = useState  initialValue  ;       If you need to perform an expensive calculation to generate the initial state, pass it to  useState  in  a  function.  React  will  only  run  the  function  to  get  this  lazy  initial  state    Manning Publications Co.  To comment go to  liveBook   61   when it first calls the component.   const [ value, setValue ] = useState    => { return initialState; } ;      Use  the  updater  function  that  useState  returns  to  set  a  new  value.  The  new  value   replaces the old value. React will schedule a re-render if the value has changed.       If your state value is an object, make sure to copy over unchanged properties from  the  previous  state  when  your  updater  function  is  only  updating  a  subset  of  the  properties.   setValue  newValue  ;   setValue {    ...state,    property: newValue  } ;      To  be  sure  you’re  working  with  the  latest  state  value  when  calling  the  updater  function and setting a new value based on the old one, pass the updater function a  function as its argument. React will pass the function argument the latest state value.   setValue value => { return newValue; } ;    setValue state => {    return {      ...state,      property: newValue    };  } ;       If you have multiple pieces of state, you can call useState multiple times. React uses  the  order  of  the  calls  to  consistently  assign  values  and  updater  functions  to  the  correct variables.   const [ index, setIndex ] = useState 0 ;                        call 1  const [ name, setName ] = useState "Jamal" ;                    call 2  const [ isPresenting, setIsPresenting ] = useState false ;      call 3      Focus  on  the  state  and  how  events  will  update  the  state.  React  will  do  its  job  of   synchronizing the state and the UI.   function Counter    {    const [ count, setCount ] = useState 0 ;                        A      return         { count }                                                  B          setCount c => c + 1 }> +     C            ;  }   A Consider what state the component needs  B Display the state    Manning Publications Co.  To comment go to  liveBook   62   C Update the state in response to events    Manning Publications Co.  To comment go to  liveBook   63       Managing component state with the  useReducer hook   This chapter covers      asking React to manage multiple, related state values by calling useReducer     putting component state management logic in a single location     updating state and triggering re-renders by dispatching actions to a reducer      initializing state with initialization arguments and initialization functions   As your applications grow, it’s natural for some components to handle more state, especially  if  they  supply  different  parts  of  that  state  to  multiple  children.  When  you  find  you  always  need to update multiple state values together or your state update logic is so spread out that  it’s hard to follow, it might be time to define a function to manage state updates for you: a  reducer function.   A simple, common example is for loading data. Say a component needs to load posts for  a  blog  on  things  to do when  stuck  at  home during  a  pandemic.  You  want  to display  some  loading UI when new posts are requested, some error UI if there is a problem, and the posts  themselves when they arrive. The component’s state includes values for:   the loading state - are you in the process of loading new posts?         any errors - has an error been returned from the server or is the network down?      the posts - a list of the posts retrieved.   When the component requests some posts, you might set the loading state to true, the error  state to null and the posts to an empty array. One event causes changes to three pieces of  state. When the posts are returned, you might set the loading state to false and the posts  to  those  returned.  One  event  causes  changes  to  two  pieces  of  state.  You  can  definitely  manage these state values with calls to the useState hook but, when you always respond to    Manning Publications Co.  To comment go to  liveBook   64   an  event  with  calls  to  multiple  updater  functions   setIsLoading, setError  and setPosts,  for example , React provides a cleaner alternative, the useReducer hook.   In this chapter, we start by addressing a problem with the BookablesList component in  the  bookings  app  where  there’s  something  amiss  with  our  state  management.  We  then  introduce  reducers  and  the  useReducer  hook  as  a  way  of  managing  our  state.  Section  4.3  shows how to use a function to initialize the state for a reducer as we start work on a new  component,  the  WeekPicker.  We  finish  the  chapter  with  a  review  of  how  the  useReducer  hook fits in with our understanding of function components.   Can  you  smell  that?  There’s  a  definite  whiff  in  the  air.  Something’s  been  left  out  that   should’ve been tidied up. Something stale. Let’s purge that distracting pong!   4.1  Updating multiple state values in response to a single event  You’re  free  to  call  useState  as  many  times  as  you  want,  once  for  each  piece  of  state  you  need React to manage. But a single component may need to hold many values in state and  it’s often the case that those pieces of state are related; you may want to update multiple  pieces of state in response to a single user action. You don’t want to leave some pieces of  state unattended to when they should really be tidied up.   There’s currently a problem with our BookablesList component when users switch from  one group to another. It’s not a big problem but in this section we discuss what the problem  is, why it’s a problem and how we can solve it using the useState hook. That sets us up for  the useReducer hook in section 4.2.   Taking users out of the movie with unpredictable state changes   4.1.1  We don’t want clunky, unpredictable interfaces preventing users from getting on with tasks.  If the UI keeps pulling their attention away from their desired focus or makes them wait with  no feedback or sends them off down dead ends, their thought process is interrupted, their  work becomes more difficult, and their day is ruined.   It’s like when you’re watching a movie and a strange camera movement, some frenzied  editing, some blatant product placement or Ed Sheeran pulls you out of the story. Your train  of  thought’s  gone.  You  become  overly  aware  that  it’s  a  movie  and  something’s  not  quite  right.  Or  when  you’re  reading  a  book  on  programming  and  a  tortured  simile,  a  strained  attempt  at  humor,  perplexing  asides  or  meta  jokes  pull  you  out  of  the  explanation.  You  become overly aware that it’s a desperate author and something’s not quite right.   Okay, sorry. Back in the room. Let’s see an example. At the end of section 3.3 in the last  chapter, we diagnosed a mild case of jank in our BookablesList component’s UI. Users are  able to choose a group and then select a bookable from that group. The bookable’s details  are  then  displayed.  But,  some  combinations  of  bookable  and  group  selection  lead  to  UI  updates that are a little bit off. If you follow these three steps, you should see the UI updates  shown in figure 4.1:   1.  Select the Games Room - its details are then displayed.  2.  Switch group to “Kit” - the list of kit bookables is displayed with no bookable selected   and the details disappear.    Manning Publications Co.  To comment go to  liveBook   65   3.  Click the Next button - the second item of kit, Wireless mics, is selected and its details   appear.      Figure 4.1 Selecting a bookable, switching groups and then clicking the Next button can lead to unpredictable  state changes.   Switching from the “Rooms” group to the “Kit” group, the component seems to lose track of  which bookable is selected. Clicking the Next button then selects the second item, skipping  the first. It’s not a huge problem, users can still select bookables, but it may be enough to  jar the user out of their focused flow. What’s going on?   It  turns  out  that  the  selected  bookable  and  the  selected  group  aren’t  completely  independent values in our state. When a user selects the Games Room, the bookableIndex  state value is set to 2 - it’s the third item in the list. If they then switch to the Kit group,  which only has two items, with indexes 0 and 1, the bookableIndex value no longer matches  up with a bookable. So, the UI ends up with no bookable selected and no details displayed.  We need to carefully consider the state we want the UI to be in after a user chooses a group.  So, how do we fix our stale index problem and smooth the path for our users?   Keeping users in the movie with predictable state changes   4.1.2  Building  a  bookings  app  for  our  colleagues,  we  want  to  make  its  use  as  frictionless  as  possible. Say a colleague, Akiko, has some clients visiting next week. She’s organizing her  schedule  for  the  visit  and  needs  to  book  the  Meeting  Room  in  the  afternoon  and  then  the  Games  Room  after  work.  Akiko’s  focus  is  on  her  task:  getting  the  schedule  sorted  and  preparing for a great client visit. The bookings app should let her continue to focus on her  task. She should be thinking “I’ll get those rooms booked, and then order the catering,” not  “Um, hang on, which button? Did I click it? Has it frozen? Argh, I HATE COMPUTERS!”   It's  like  when  you’re  watching  a  movie  and  you’re  completely  invested  in  a  character’s  plight.  You  don’t  notice  the  camera  moves  and  the  editing  because  they  help  to  smoothly    Manning Publications Co.  To comment go to  liveBook   66   draw  you  into  the  story.  You’re  no  longer  in  the  movie  theater,  you’re  in  the  world  of  the  film. The artifice melts away and the story is everything. Or when you’re reading a book and  its quirky but relatable characters and propulsive plot pull you into the narrative. It’s almost  as  if  the  book  disappears  and  you  inhabit  the  thoughts,  feelings,  locations  and  actions.  Eventually, you notice yourself, and realize you’ve read 100 pages and it’s almost dark…   Okay,  sorry.  Back  in  the  room.  Let’s  get  back  to  the  example.  After  the  user  selects  a  group, we want the UI to be in a predictable state. We don’t want sudden deselections and  skipped bookables. A simple and sensible approach is to always select the first bookable in  the list when a user chooses a new group, as shown in figure 4.2.   Figure 4.2 Selecting a bookable, switching groups and then clicking the Next button leads to predictable state  changes.   The group and bookableIndex state values are connected: when we change the group, we  change  the  index  as  well.  In  step  2  of  figure  4.2,  notice  how  the  first  item  in  the  list,  Projector,  is  automatically  selected  when  the  group  is  switched.  Listing  4.1  shows  the  changeGroup function setting bookableIndex to zero whenever a new group is set.   Branch: 0401-related-state, File:  src components Bookables BookablesList.js      Listing 4.1 Automatically selecting a bookable when the group is changed  import React, {useState, Fragment} from 'react';   import {bookables, sessions, days} from ".. .. static.json";  import {FaArrowRight} from "react-icons fa";    export default function BookablesList   {     const [group, setGroup] = useState "Kit" ;    const bookablesInGroup = bookables.filter b => b.group === group ;    const [bookableIndex, setBookableIndex] = useState 0 ;    const groups = [...new Set bookables.map b => b.group  ];    const bookable = bookablesInGroup[bookableIndex];    Manning Publications Co.  To comment go to  liveBook   67     const [hasDetails, setHasDetails] = useState false ;      function changeGroup event  {                                         A      setGroup event.target.value ;                                       B      setBookableIndex 0 ;                                                C    }      function nextBookable   {      setBookableIndex i =>  i + 1  % bookablesInGroup.length ;    }      return                            <select            value={group}            onChange={changeGroup}                                        D          >            {groups.map g =>  {g}  }                                     * unchanged list UI *                                    * unchanged button UI *                               {bookable &&                          * unchanged bookable details UI *                     }            ;  }   A Create a handler function to respond to group selection  B Update the group  C Select the first bookable in the new group  D Specify the new function as the onChange handler  Whenever the group is changed, we set the bookable index to zero; when we call setGroup,  we always follow it with a call to setBookableIndex.  setGroup newGroup ;  setBookableIndex 0 ;   This is a simple example of related state. When components start to get more complicated  with multiple events causing multiple state changes, tracking those changes and making sure  all related state values are updated together become more and more difficult.   When state values are related in such a way, either affecting each other or often being  changed together, it can help to move the state update logic into a single place, rather than  spreading the code that performs changes across event handler functions, whether inline or    Manning Publications Co.  To comment go to  liveBook   68   separately defined. React gives us the useReducer hook to help us manage this collocation of  state update logic and we look at that hook next.   4.2  Managing more complicated state with useReducer  As  it  stands,  the  BookablesList  component  example  is  simple  enough  that  you  could  continue to use useState and just call the respective updater functions for each piece of state  within  the  changeGroup  event  handler.  However,  when  you  have  multiple  pieces  of  inter- related state, using a reducer can make it easier to make and understand state changes. In  this section, we introduce how:      A reducer helps you to manage state changes in a centralized, well-defined way with   clear actions that act on the state.      A  reducer  uses  actions  to  generate  a  new  state  from  the  previous  state,  making  it  easier to specify more complicated updates that may involve multiple pieces of inter- related state.      React provides the useReducer hook to let your component specify initial state, access   the current state and dispatch actions to update the state and trigger a re-render.      Dispatching  well-defined  actions  makes  it  easier  to  follow  state  changes  and  to  understand  how  your  component  interacts  with  the  state  in  response  to  different  events.   We start, in Section 4.2.1, with a description of what a reducer is and a simple example of a  reducer that manages incrementing and decrementing a counter. In Section 4.2.2, we build a  reducer  for  the  Bookables  component  that  performs  the  necessary  state  changes  like  switching groups, selecting bookables and toggling bookable details. Finally, in Section 4.2.3,  we  incorporate  our  freshly  minted  reducer  into  the  BookablesList  component  by  using  React’s useReducer hook.   Updating state using a reducer with a pre-defined set of actions   4.2.1  A reducer is a function that accepts a state value and an action value. It generates a new  state value based on the two values passed in. It then returns the new state value, as shown  in figure 4.3.    Manning Publications Co.  To comment go to  liveBook   69      Figure 4.3 A reducer takes a state and an action and returns a new state.   The  state  and  action  can  be  simple,  primitive  values  like  numbers  or  strings,  or  more  complicated  objects.  With  a reducer  you keep  all  of  the  ways of  updating  the  state  in one  place  which  makes  it  easier  to  manage  state  changes,  particularly  when  a  single  action  affects multiple pieces of state.   We  get  back  to  the  BookablesList  component  shortly,  after  a  super-simple  example.  Say your  state’s  just  a counter  and  there’re only  two  actions  you  can  take:  increment  the  counter or decrement the counter. Listing 4.2 shows a reducer that manages such a counter.  The value of the count variable starts at 0 and changes to 1, to 2, and then back to 1.   Code on JSBin: https:  jsbin.com capogug edit?js,console   Listing 4.2 A simple reducer for a counter  let count = 0;    function reducer  state, action  {         A    if  action === "inc"  {                  B      return state + 1;    }    if  action === "dec"  {                  B      return state - 1;    }    return state;                            C  }      Manning Publications Co.  To comment go to  liveBook   70   count = reducer count, "inc" ;                D  count = reducer count, "inc" ;  count = reducer count, "dec" ;                E   A Create a reducer function that accepts the existing state and an action  B Check which action is specified and update state accordingly  C Handle missing or unrecognized actions  D Use the reducer to increment the counter  E Use the reducer to decrement the counter  The reducer handles the incrementing and decrementing actions and just returns the count  unaltered for any other action specified.  Rather than silently ignoring unrecognized actions,  you  could  throw  an  error,  depending  on  the  needs  of  your  application  and  the  role  the  reducer is playing.    That seems like a bit of overkill for our two little actions, but having a reducer makes it  easy to extend. Let’s add three more actions, for adding and subtracting arbitrary numbers  to and from the counter and for setting the counter to a specified value. To be able to specify  extra values with our action, we need to beef it up a bit - let’s make it an object with a type  and a payload. Say we want to add three to the counter, our action looks like this:   {    type: "add",    payload: 3  }   Listing 4.3 shows the new reducer with its extra powers and calls to the reducer passing our  beefed-up actions. The value of the count variable starts at 0 and changes to 3, to -7, to 41,  and finally to 42.   Code on JSBin: https:  jsbin.com kokumux edit?js,console   Listing 4.3 Adding more actions and specifying extra values  let count = 0;    function reducer  state, action  {    if  action.type === "inc"  {                         A      return state + 1;                                  A    }                                                    A    if  action.type === "dec"  {                         A      return state - 1;                                  A    }                                                    A      if  action.type === "add"  {                         B      return state + action.payload;                     B    }                                                    B      if  action.type === "sub"  {                         B      return state - action.payload;                     B    }                                                    B      if  action.type === "set"  {                         B      return action.payload;                             B    }                                                    B      return state;    Manning Publications Co.  To comment go to  liveBook   71   }    count = reducer count, { type: "add", payload: 3 } ;   C  count = reducer count, { type: "sub", payload: 10 } ;  C  count = reducer count, { type: "set", payload: 41 } ;  C  count = reducer count, { type: "inc" } ;               C   A Now check the action type for the two original actions  B Use the action payload to perform the new actions  C Pass an object to specify each action  The last call to the reducer right at the end of listing 4.3 specifies the increment action. The  increment  action  doesn’t  need  any  extra  information  -  it  always  adds  1  to  count  -  so  the  action doesn’t include a payload property.   Let’s  put  these  ideas  of  state  and  actions  with  a  type  and  payload  into  practice  in  the  bookings app by building a reducer for our BookablesList component. Then we can see how  to enlist React’s help to use that reducer to manage the component’s state.   Building a reducer for the BookablesList component   4.2.2  The BookablesList component has four pieces of state: group, bookableIndex, hasDetails  and bookables  imported from static.json  - and four actions to perform on that state -  set the group, set the index, toggle hasDetails, and move to the next bookable. To manage  four  pieces  of  state,  we  can  use  an  object  with  four  properties.  It’s  very  common  to  represent both the state and the action as objects, as shown in figure 4.4.    Manning Publications Co.  To comment go to  liveBook   72      Figure 4.4 Pass the reducer a state object and an action object. The reducer updates the state based on the  action type and payload. The reducer returns the new, updated state.   The BookablesList component imports the bookables data from the static.json file. That  data won’t change while the BookablesList component is mounted and we include it in the  initial state for the reducer, using it to find the number of bookables in each group.   Listing 4.4 shows a reducer for the BookablesList component using objects for both the  the   It’s  exported   the  actions.   its  own   from   in   file,  reducer.js.   state  and   src components Bookables folder.   Branch: 0402-reducer, File:  src components Bookables reducer.js   Listing 4.4 A reducer for the BookablesList component  export default function reducer state, action  {    switch  action.type  {                                            A   B        case "SET_GROUP":                                               C        return {          ...state,          group: action.payload,                                      D          bookableIndex: 0        };        case "SET_BOOKABLE":        return {          ...state,                                                   E    Manning Publications Co.  To comment go to  liveBook   73           bookableIndex: action.payload        };        case "TOGGLE_HAS_DETAILS":        return {          ...state,          hasDetails: !state.hasDetails                               F        };        case "NEXT_BOOKABLE":        const count = state.bookables.filter           b => b.group === state.group         .length;                                                     G          return {          ...state,          bookableIndex:  state.bookableIndex + 1  % count            H        };        default:                                                        I        return state;    }  }   A Use a switch statement to organize the code for each action type  B Specify the action type as the comparison for each case  C Create a case block for each action type  D Update the group and set the bookableIndex to 0  E Use the spread operator to copy existing state properties  F Override existing state properties with any changes  G Count the bookables in the current group  H Use the count to wrap from the last index to the first  I Always include a default case  Each  case  block  returns  a  new  JavaScript  object;  the  previous  state  is  not  mutated.  The  object spread operator is used to copy across properties from the old state to the new. You  then  set  the  property  values  that  need  updating  on  the  object,  overriding  those  from  the  previous state, like this:   return {    ...state,                        A    group: action.payload,           B    bookableIndex: 0                 B  };   A Spread the properties of the old state object into the new one  B Override any properties that need updating  With only four properties in total in our state, we could have set them all explicitly:   return {    group: action.payload,    bookableIndex: 0,    hasDetails: state.hasDetails,               A    bookables: state.bookables                  A  };   A Copy across previous values for unchanged properties    Manning Publications Co.  To comment go to  liveBook   74   Using the spread operator protects the code as it evolves; the state may gain new properties  in the future and they all need to be copied across.   Notice the SET_GROUP action updates two properties. As well as updating the group to be  displayed,  it  sets  the  selected  bookable  index  to  0.  When  switching  to  a  new  group,  the  action  automatically  selects  the  first  bookable  and,  as  long  as  the  group  has  at  least  one  bookable, the component shows the details for the first bookable if the Show Details toggle is  checked.   The  reducer  also  handles  a  NEXT_BOOKABLE  action,  removing  from  the  Bookables  component  the  onus  for  calculating  indexes  when  moving  from  one  bookable  to  the  next.  This is why including the bookables data in the reducer’s state is helpful: we use the count of  bookables  in  a  group  to  wrap  from  the  last  bookable  to  the  first  when  incrementing  bookableIndex.  case "NEXT_BOOKABLE":    const count = state.bookables.filter                                A      b => b.group === state.group     .length;        return {      ...state,      bookableIndex:  state.bookableIndex + 1  % count                  B  };   A Use the bookables data to count the bookables in the current group  B Use the modulus operator to wrap from the last index to the first  We’ve got a reducer set up, but how do we fold it into our component? How do we access the  state object and call the reducer with our actions? We need the useReducer hook.   4.2.3   Accessing component state and dispatching actions with  useReducer   The useState hook lets us ask React to manage single values for our component. With the  useReducer  hook  we  can  give  React  a  bit  more  help  in  managing  values  by  passing  it  a  reducer and the component’s initial state. When events occur in our application, instead of  giving  React  new  values  to  set,  we  dispatch  an  action,  and  React  uses  the  corresponding  code in the reducer to generate a new state before calling the component for the latest UI.   When calling the useReducer hook, we pass it the reducer and an initial state. The hook  returns the current state and a function for dispatching actions, as two elements in an array,  as shown in figure 4.5.    Manning Publications Co.  To comment go to  liveBook   75      Figure 4.5 Call useReducer with a reducer and an initial state. It returns the current state and a dispatch  function. Use the dispatch function to dispatch actions to the reducer.   As we did with useState, here with useReducer we use array destructuring to assign the two  elements  of  the  returned  array  to  two  variables  with  names  of  our  choosing.  The  first  element, the current state, we assign to a variable we call state, and the second element,  the dispatch function, we assign to a variable we call dispatch.  const [ state, dispatch ] = useReducer  reducer, initialState  ;   React only pays attention to the arguments passed to useReducer, in our case reducer and  initialState,  the  first  time  React  invokes  the  component.  On  subsequent  invocations,  it  ignores  the  arguments  but  still  returns  the  current  state  and  the  dispatch  function  for  the  reducer.   Let’s get the useReducer hook up and running in the BookablesList component and start   dispatching some actions! Listing 4.5 shows the changes.   Branch: 0402-reducer, File:  src components Bookables BookablesList.js   Listing 4.5 The BookablesList component using a reducer  import React, {useReducer, Fragment} from "react";                      A   import {bookables, sessions, days} from ".. .. static.json";  import {FaArrowRight} from "react-icons fa";    import reducer from ". reducer";                                        B    const initialState = {                                                  C    group: "Rooms",                                                       C    bookableIndex: 0,                                                     C    hasDetails: true,                                                     C    bookables                                                             C  };                                                                      C    export default function BookablesList    {    Manning Publications Co.  To comment go to  liveBook   76     const [state, dispatch] = useReducer reducer, initialState ;          D      const {group, bookableIndex, bookables, hasDetails} = state;          E      const bookablesInGroup = bookables.filter b => b.group === group ;    const bookable = bookablesInGroup[bookableIndex];    const groups = [...new Set bookables.map b => b.group  ];      function changeGroup  e  {      dispatch {                                                          F        type: "SET_GROUP",                                                F        payload: e.target.value                                           F      } ;                                                                 F    }      function changeBookable  selectedIndex  {      dispatch {        type: "SET_BOOKABLE",        payload: selectedIndex      } ;    }       function nextBookable    {      dispatch { type: "NEXT_BOOKABLE" } ;                                G    }      function toggleDetails    {      dispatch { type: "TOGGLE_HAS_DETAILS" } ;    }      return                               group picker                         {bookablesInGroup.map  b, i  =>                <li              key={b.title}              className={i === bookableIndex ? "selected" : null}              >                <button                  className="btn"                  onClick={   => changeBookable i }                          H                >                  {b.title}                                              }                          Next button                   {bookable &&                                                              Manning Publications Co.  To comment go to  liveBook   77                   {bookable.title}                                                                         <input                      type="checkbox"                      checked={hasDetails}                      onChange={toggleDetails}                              I                     >                    Show Details                                                                  {bookable.notes}               {hasDetails &&                                        details                                }                                 }            ;  }   A Import the useReducer hook  B Import the reducer from listing 4.4  C Specify an initial state  D Call useReducer, passing the reducer and the initial state  E Assign state values to local variables  F Dispatch an action with a type and a payload  G Dispatch an action that doesn’t need a payload  H Call the new changeBookable function  I Call the new toggleDetails function  Listing 4.5 imports the reducer we created in listing 4.4, sets up an initial state object, and  then,  in  the  component  code  itself,  passes  the  reducer  and  initial  state  to  useReducer.  useReducer  returns  the  current  state  and  the  dispatch  function  and  we  assign  them  to  variables, state  and dispatch,  using  array destructuring.  The  listing  uses  an  intermediate  state  variable  and  then  destructures  the  state  object  into  individual  variables,  group,  bookableIndex,  bookables  and  hasDetails,  but  you  could  do  the  object  destructuring  directly inside the array destructuring:   const [    {group, bookableIndex, bookables, hasDetails},    dispatch  ] = useReducer reducer, initialState ;   In  the  event  handlers,  the  BookablesList  component  now  dispatches  actions  rather  than  updating  individual  state  values  via  useState.  We  use  separate  event  handler  functions   changeGroup,  changeBookable,  nextBookable,  toggleDetails   but  you  could  easily  dispatch  actions  inline  within  the  UI.  For  example,  you  could  set  up  the  Show  Details  checkbox like this:    Manning Publications Co.  To comment go to  liveBook   78          <input       type="checkbox"       checked={hasDetails}       onChange={   => dispatch { type: "TOGGLE_HAS_DETAILS" } }      >     Show Details       Either  approach  is  fine,  as  long  as  you   and  your  team   find  the  code  easy  to  read  and  understand.   Although the example is simple, you should appreciate how a reducer can help structure  your code, your state mutations and your understanding, particularly as the component state  becomes more complex. If your state is complex and or the initial state is expensive to set  up or is generated by a function you’d like to reuse or import, the useReducer hook has a  third argument you can use. Let’s check it out.   4.3  Generating the initial state with a function  We saw in chapter 3 that we can generate the initial state for useState by passing a function  to the hook. Similarly, with useReducer, as well as passing an initialization argument as the  second  argument,  we  can  pass  an  initialization  function  as  the  third  argument.  The  initialization function uses the initialization argument to generate the initial state, as shown  in figure 4.6.      Figure 4.6 The initialization function for useReducer uses the initialization argument to generate the reducer’s  initial state.   As usual, useReducer returns an array with two elements: the state and a dispatch function.  On  the  first  call,  the  state  is  the  return  value  of  the  initialization  function.  On  subsequent  calls, it is the state at the time of the call.   const [ state, dispatch ] = useReducer reducer, initArgument, initFunction ;   Use  the  dispatch  function  to  dispatch  actions  to  the  reducer.  For  a  particular  call  to  useReducer,  React  will  always  return  the  same  dispatch  function.   Having  an  unchanging    Manning Publications Co.  To comment go to  liveBook   79   function is important when re-renders may depend on changing props or dependencies, as  we see in later chapters.    In  this  section  we  put  useReducer’s  initialization  function  argument  to  use  as  we  start  work on a second component for the bookings app, the WeekPicker component. We split the  work into five subsections:   Introducing the WeekPicker component.         Creating utility functions to work with dates and weeks.     Building the reducer to manage dates for the component.     Creating WeekPicker, passing an initialization function to the useReducer hook.     Updating BookingsPage to use WeekPicker.   Introducing the WeekPicker component   4.3.1  So  far  in  the  bookings  app,  we’ve  been  concentrating  on  the  BookablesList  component,  displaying  a  list  of  bookables.  To  set  the  groundwork  for  actually  booking  a  resource,  we  need  to  start  thinking  about  calendars;  in  the  finished  app,  our  users  will  pick  a  date  and  session from a bookings grid calendar, as shown in figure 4.7.   Figure 4.7 The bookings page will include a list of bookables, a bookings grid and a week picker.   Let’s  start  small  and  just  consider  the  interface  for  switching  between  one  week  and  the  next. Figure 4.8 shows a possible interface for picking the week to show in the bookings grid.  It includes:      The start and end dates for the selected week.     Buttons to move to the next and previous weeks.     A button to show the week containing today’s date.       Manning Publications Co.  To comment go to  liveBook   80      Figure 4.8 The WeekPicker component shows the start and end dates for the chosen week and has buttons to  navigate between weeks.   Later in the book we add an input for jumping straight to a specific date. For now, we stick  with  our  three  buttons  and  week  date  text.  To  get  the  start  and  end  dates  for  a  specified  week, we need a couple of utility functions to wrangle JavaScript’s date object. Let’s conjure  those first.   Creating utility functions to work with dates and weeks   4.3.2  Our bookings grid will show one week at a time, running from Sunday to Saturday. On any  particular date, we show the week that contains that date. Let’s create objects that represent  a week, with a particular date in the week and the dates for the start and end of the week:   week = {    date,           A    start,          B    end             C  };   week = {    date,      2020-04-01         A    start,     2020-03-29         A      };   A JavaScript Date object for a particular date  B Date object for the start of the week containing date  C Date object for the end of the week  For example, take Wednesday 1st April, 2020. The start of the week was Sunday 29th March,  2020 and the end of the week was Saturday 4th April, 2020.   A Assign each property a JavaScript Date object for the specified date  Listing  4.7 shows  a couple of  utility  functions,  one  to  create  a  new date  from  an  old date,  offset by a number of days, and the second to generate the week objects. The file is called  date-wrangler.js and is in a new  src utils folder.   Branch: 0403-week-picker, File:  src utils date-wrangler.js   Listing 4.7 Date-wrangling utility functions  export function addDays  date, daysToAdd  {    const clone = new Date date.getTime   ;    clone.setDate clone.getDate   + daysToAdd ;                       A    return clone;    Manning Publications Co.  To comment go to  liveBook   81   }    export function getWeek  forDate, daysOffset = 0  {    const date = addDays forDate, daysOffset ;                        B    const day = date.getDay  ;                                        C      return {      date,      start: addDays date, -day ,                                     D      end: addDays date, 6 - day                                      E    };  }   A Shift the date by the number of days specified  B Immediately shift the date  C Get the day index for the new date. E.g. Tuesday = 2  D E.g. if it’s Tuesday, shift back by 2 days  E E.g. if it’s Tuesday, shift forward by 4 days  The getWeek function uses the getDay method of JavaScript’s Date object to get the day of  the week index of the specified date: Sunday is 0, Monday is 1, …, Saturday is 6. To get to  the start of the week, the function subtracts the same number of days as the day index: For  Sunday  it  subtracts  0  days,  for  Monday  it  subtracts  1  day,  …,  for  Saturday  it  subtracts  6  days.  The  end  of  the  week  is  6 days  after  the  start of  the  week,  so  to  get  the  end of the  week the function performs the same subtraction as for the start of the week but also adds  6. We can use the getWeek function to generate a week object for a given date:  const today = new Date  ;  const week = getWeek today ;     A   A Get the week object for the week containing today’s date  We can also specify an offset number of days as the second argument if we want the week  object for a date relative to the date in the first argument.   const today = new Date  ;  const week = getWeek today, 7 ;  A   A Get the week object for the week containing the date a week from today  The getWeek function lets us generate week objects as we navigate from week to week in the  bookings app. Let’s use it to do just that in the reducer.   Building the reducer to manage dates for the component   4.3.3  A reducer helps us to centralize the state management logic for our WeekPicker component.  In a single place we can see all of the possible actions and how they update the state:      Move to the next week by adding 7 days to the current date.     Move to the previous week by subtracting 7 days from the current date.     Move to today by setting the current date to today’s date.     Move to a specified date by setting the current date to the action’s payload.    Manning Publications Co.  To comment go to  liveBook   82   For  each  action,  the  reducer  returns  a  week  object  as  described  in  the  previous  section.  Although  we  only  really  need  to  track  a  single  date,  we  would  need  to  generate  the  week  object  at  some  point  and  abstracting  the  week  object  generation  along  with  the  reducer  seems sensible to me. You can see how the possible state changes translate to a reducer in  listing 4.8. We put the weekReducer.js file in the Bookings folder.   Branch: 0403-week-picker, File:  src components Bookings weekReducer.js   Listing 4.8 The reducer for WeekPicker  import { getWeek } from ".. .. utils date-wrangler";                    A    export default function reducer  state, action  {    switch  action.type  {      case "NEXT_WEEK":        return getWeek state.date, 7 ;                                    B      case "PREV_WEEK":        return getWeek state.date, -7 ;                                   C      case "TODAY":        return getWeek new Date   ;                                       D      case "SET_DATE":        return getWeek new Date action.payload  ;                         E      default:        throw new Error `Unknown action type: ${action.type}`     }  }   A Import the getWeek function  B Return a week object for 7 days ahead  C Return a week object for 7 days before  D Return a week object for today  E Return a week object for a specified date  The reducer imports the getWeek function to generate the week object for each state change.  Having the getWeek function available to import means we can also use it as an initialization  function when we call the useReducer hook in the WeekPicker component.   Passing an initialization function to the useReducer hook   4.3.4  The WeekPicker component lets users navigate from week to week to book resources in the  company.  We  set  up  the  reducer  in  the  last  section;  now  it’s  time  to  use  it.  The  reducer  needs an initial state, a week object. Listing 4.9 shows how we can use the getWeek function  to  generate  the  initial  week  object  from  a  date  we  pass  to  WeekPicker  as  a  prop.  The  WeekPicker.js file is also in the Bookings folder.   Branch: 0403-week-picker, File:  src components Bookings WeekPicker.js   Listing 4.9 The WeekPicker component  import React, {useReducer} from "react";  import reducer from ". reducer";  import {getWeek} from ".. .. utils date-wrangler";                      A    export default function WeekPicker  {date}  {                           B    const [week, dispatch] = useReducer reducer, date, getWeek ;          C    Manning Publications Co.  To comment go to  liveBook   83       return                 <button          onClick={   => dispatch {type: "PREV_WEEK"} }                   D        >Previous         <button          onClick={   => dispatch {type: "TODAY"} }                       D        >Today         <button          onClick={   => dispatch {type: "NEXT_WEEK"} }                   D        >Next         {week.start.toDateString  } - {week.end.toDateString  }           E            ;  }   A Import the getWeek date-wrangler function  B Receive the initial date as a prop  C Generate the initial state, passing date to getWeek  D Dispatch actions to the reducer to switch weeks  E Use the current state to display the date info  Our  call  to  useReducer  passes  the  specified  date  to  the  getWeek  function.  The  getWeek  function  returns  a  week  object  that  is  set  as  the  initial  state.  We  assign  the  state  that  useReducer returns to a variable called week.  const [week, dispatch] = useReducer reducer, date, getWeek ;   As well  as  letting  us reuse  the getWeek  function  to generate  state   in  the  reducer  and the  WeekPicker component , the initialization function  useReducer’s third argument  also allows  us to run expensive state generation functions once only, on the initial call to useReducer.   At last, a new component! Let’s hook it up to our App.   Updating BookingsPage to use WeekPicker   4.3.5  Listing  4.10  shows  an  updated  BookingsPage  component  that  imports  and  renders  the  WeekPicker component. The resulting page is shown in figure 4.9.    Manning Publications Co.  To comment go to  liveBook   84      Figure 4.9 The BookingsPage component with the WeekPicker component in place.   Branch: 0403-week-picker, File:  src components Bookings BookingsPage.js   Listing 4.10 The BookingsPage component using WeekPicker  import React from "react";  import WeekPicker from ". WeekPicker";                               A    export default function App   {    return                  Bookings!                                          B            ;  }   A import the WeekPicker component  B Include the WeekPicker in the UI, passing it the current date  BookingsPage  passes  the  WeekPicker  component  the  current  date.  The  week  picker  first  appears  showing  the  start  and  end  dates  of  the  current  week,  from  Sunday  to  Saturday.  Have a go navigating from week to week and then click the Today button to jump back to the  present week. It’s a simple component but helps drive the bookings grid in chapters to come.  And it provides an example of useReducer’s initialization function argument.   Before  this  chapter’s  formal  Summary  section,  let’s  briefly  recap  some  of  the  key   concepts we’ve encountered, building our understanding of function components and hooks.    Manning Publications Co.  To comment go to  liveBook   85   4.4  Reviewing some useReducer concepts  A bit more jargon has crept into this discussion, so just in case all the actions, reducers and  dispatch functions are causing some dizziness, Table 4.1 describes the terms with examples.  Take a breather!      Icon   Term   Description   Initial State   The values of variables  and properties when the  component first runs.   Information that the  reducer uses to update  the state.   A function React passes  the current state and an  action. It creates a new  state from the current  state depending on the  action.   The values of variables  and properties at a  particular point in  execution.  A function for dispatching  actions to the reducer.  Use it to tell the reducer  what action to take.   Example  {    group: "Rooms",    bookableIndex: 0,    hasDetails: false  }  {    type: "SET_BOOKABLE",    payload: 1  }    state, action  => {       check action         update state based       on action type and       action payload         return new state  };  {    group: "Rooms",    bookableIndex: 1,    hasDetails: false  }  dispatch {    type: "SET_BOOKABLE",    payload: 1  } ;   Action   Reducer            State   Dispatch  function         Once we pass the reducer and initial state to React via our call to useReducer, it manages  the state for us. We just have to dispatch actions and React will use the reducer to update  the state depending on which action it receives. Remember, our component code returns a  description of its UI. Having updated the state, React knows it may need to update the UI, so  it will call our component code again, passing it the latest state and the dispatcher function  when useReducer is called. To reinforce the functional nature of our components, Figure 4.10  on pages mm and nn illustrates each step when React first calls the Bookables component  and  a  user  then  fires  an  event  by  selecting  a  group,  choosing  a  bookable  or  toggling  the  Show Details checkbox.    Manning Publications Co.  To comment go to  liveBook   86   Figure 4.10 Stepping through the key moments when using useReducer.   Table 4.2 lists the steps from Figure 4.10, describing what is happening and including short  discussions of each one.         1   Step  What happens?   Discussion   React calls the component.   To generate the UI for the page, React traverses the tree of  components, calling each one. React will pass each  component any props set as attributes in the JSX.    Manning Publications Co.  To comment go to  liveBook   87   2   3   4   5   6   7   8   9   10   11   12   13   The component calls  useReducer for the first time.   React returns the current state  and the dispatch function as an  array.   The component sets up an event  handler.   The component returns its UI.   The event handler dispatches an  action.   React calls the reducer.   The component passes the initial state and the reducer to the  useReducer function. React sets the current state for the  reducer as the initial state.   The component code assigns the state and dispatch function  to variables for later use. The variables are often called  state and dispatch, or the state may be destructured into  further variables.  The event handler may listen for user clicks, timers firing or  resources loading, for example. The handler will dispatch an  action to change the state.  The component uses the current state to generate its user  interface and returns it, finishing its work. React compares  the new UI to the old and updates the DOM.  An event fires and the handler runs. The handler uses the  dispatch function to dispatch an action.   React passes the current state and the dispatched action to  the reducer.   The reducer returns the new  state.   The reducer uses the action to update the state and returns  the new version.   React calls the component.   React knows the state has changed so must recalculate the  UI.   This time, React will ignore the arguments.   The component calls  useReducer for the second time.   React returns the current state  and the dispatch function.   The component sets up an event  handler.   The component returns its UI.   The state has been updated by the reducer and the  component needs the latest values. The dispatch function is  the exact same function as React returned for the previous  call to useReducer.  This is a new version of the handler and may use some of the  newly updated state values.   The component uses the current state to generate its user  interface and returns it, finishing its work. React compares  the new UI to the old and updates the DOM.   Each time it needs the UI, React invokes the component code. The component function runs  to completion and local variables are created during execution and destroyed or referenced  in  closures  when  the  function  ends.  The  function  returns  a  description  of  the  UI  for  the  component.  The  component  uses  hooks,  like  useState  and  useReducer,  to  persist  state  across  invocations  and  to  receive  updater  and  dispatch  functions.  Event  handlers  call  the    Manning Publications Co.  To comment go to  liveBook   88   updater functions or dispatch actions in response to user actions and React can update the  state and call the component code again, restarting the cycle.   4.5  Summary       If you have multiple pieces of inter-related state, consider using a reducer to clearly  define the actions that can change the state. A reducer is a function to which you pass  the current state and an action. It uses the action to generate a new state. It returns  the new state.   function reducer   state, action   {       use the action to generate a new state from the old state.       return newState.  }      Call the useReducer hook when you want React to manage the state and reducer for a  component.  Pass  it  the  reducer  and  an  initial  state.  It  returns  an  array  with  two  elements: the state and a dispatch function.   const [ state, dispatch ] = useReducer  reducer, initialState  ;      Call the useReducer hook with an initialization argument and an initialization function  to  generate  the  initial  state  when  the  hook  is  first  called.  The  hook  automatically  passes  the  initialization  argument  to  the  initialization  function.  The  initialization  function  returns  the  initial  state  for  the  reducer.  This  is  useful  when  initialization  is  expensive or when you want to use an existing function to initialize the state.   const [ state, dispatch ] = useReducer  reducer, initArg, initFunc  ;      Use the dispatch function to dispatch an action. React will pass the current state and  the action to the reducer. It will replace the state with the new state generated by the  reducer. It will re-render if the state has changed.   dispatch  action  ;      For  anything more  than  the most basic  actions,  consider following  common  practice   and specify the action as a JavaScript object with type and payload properties.   dispatch { type: "SET_NAME", payload: "Jamal" } ;      React  always  returns  the  same  dispatch  function  for  a  particular  call  to  useReducer  within  a  component.   If  the  dispatch  function  changed  between  calls  it  could  cause  unnecessary re-renders when passed as a prop or included as a dependency for other  hooks.   In  the  reducer,  use  if  or  switch  statements  to  check  for  the  type  of  action  dispatched.       function reducer   state, action   {    switch  action.type  {      case "SET_NAME":    Manning Publications Co.  To comment go to  liveBook   89         return {          ...state,          name: action.payload        }      default:        return state;           or return new Error `Unknown action type: ${action.type}`     }  }   In the default case, either return the unchanged state  if the reducer will be  combined with other reducers, for example  or throw an error  if the reducer should  never receive an unknown action type .    Manning Publications Co.  To comment go to  liveBook   90       Working with side effects   This chapter covers   recognizing types of side effects in components         wrapping side effects with the useEffect hook     controlling when an effect runs by specifying a dependency list        using an effect to fetch data for a component   returning a clean-up function from an effect   React transforms our data into UI. Each component plays its part, returning its contribution  to  the  overall  user  interface.  React  builds  the  tree  of  elements,  compares  it  with  what’s  already  rendered  and  commits  any  necessary  changes  to  the  DOM.  When  state  changes,  React  goes  through  the  process  again  to  update  the  UI.  React’s  really  good  at  efficiently  deciding what should update and scheduling any changes. Sometimes, however, we need our  components to reach outside of this data flow process and directly interact with other APIs.  An action that impinges on the outside world in some way is called a side effect. Common  side effects include:      Setting the page title imperatively     Working with timers like setInterval or setTimeout     Measuring the width or height or position of elements in the DOM     Logging messages to the console or other service     Setting or getting values in local storage     Fetching data or subscribing and unsubscribing to services   Whatever our components are trying to achieve, it would be risky for them to simply ignore  React  and  try  to  perform  their  tasks  blindly.  It’s  much  better  to  enlist  React’s  help  to  schedule such side effects effectively, considering when and how often they should run, even  as React does its job of rendering each component and committing changes to the screen.    Manning Publications Co.  To comment go to  liveBook   91   React  provides  the  useEffect  hook  so  that  we  can  better  control  side  effects  and  integrate  them into the lifecycles of our components.   In this chapter we get to grips with how the useEffect hook works. We start, in section  5.1, by trying out some simple examples that highlight calling the hook, controlling when it  runs and specifying how to clean up any effects when a component unmounts. In section 5.2  we  set  up  a  simple  server  for  data  in  the  bookings  app  example  and  create  some  components to practice fetching that data. Finally, in section 5.3, we switch our bookings app  over from importing database files to fetching data from a server.   The useEffect hook is our gateway to safe interactions with the outside world. Let’s take   our first steps on the path.   5.1  Exploring the useEffect API with simple examples  Some  of  our  React  components  are  super-friendly,  reaching  out  to  say  “hi”  to  APIs  and  services outside of React. Although they’re eternally optimistic and like to think the best of  all  those  they  meet,  there  are  some  safeguards  to  be followed.  In  this  section, we  look  at  setting  up  side  effects  in  ways  that  won’t  get  out  of  hand.  In  particular,  we  explore  these  four scenarios:      Running side effects after every render     Running an effect only when a component mounts      Cleaning up side effects by returning a function     Controlling when an effect runs by specifying dependencies   To focus on the API we create some super-simple component examples, rather than jumping  straight into the bookings app as a context. First up, let’s say “Bonjour, les side-effect.”   Running side effects after every render   5.1.1  Say  you  want  to  add  a  random  greeting  to  the  page’s  title  in  the  browser.  Clicking  your  friendly component’s “Say Hi” button should generate a new greeting and update the title.  Three such greetings are shown in figure 5.1.   Figure 5.1 Clicking the Say Hi button updates the page title with a random greeting.       Manning Publications Co.  To comment go to  liveBook   92   The  document  title’s  not  part  of  the  document  body  and  isn’t  rendered  by  React.  But,  the  title’s accessible via the document property of the window. You can set the title like this:  document.title = "Bonjour";   Reaching out to a browser API in this way is considered a side effect and we can make that  explicit by wrapping the code in the useEffect hook:   useEffect    => {    document.title = "Bonjour";  } ;   Listing 5.1 shows a SayHello component that updates the page title with a random greeting  whenever the user clicks the “Say Hi” button.   Live: https:  jhijd.csb.app, Code: https:  codesandbox.io s sayhello-jhijd   Listing 5.1 Updating the browser title  import React, { useState, useEffect } from "react";                     A    export default function SayHello    {    const greetings = ["Hello", "Ciao", "Hola", "こんにちは"];      const [ index, setIndex ] = useState 0 ;      useEffect    => {                                                     B      document.title = greetings[index];                                  C    } ;        function updateGreeting    {      setIndex Math.floor Math.random   * greetings.length  ;    }      return  Say Hi   };   A Import the useEffect hook  B Pass the useEffect hook a function, the effect  C Update the browser title from inside the effect  The component uses a randomly generated index to pick a greeting from an array. Whenever  the  updateGreeting  function  calls  setIndex,  React  re-renders  the  component   unless  the  index  value  doesn’t  change . React  runs  the  effect function  within  the  useEffect  hook  after  every render, updating the page title as required. Notice that the effect function has access  to the variables within the component because it’s in the same scope. In particular, it uses  the values of the greetings and index variables. Figure 5.2 shows how you pass an effect  function as the first argument to the useEffect hook.    Manning Publications Co.  To comment go to  liveBook   93   Figure 5.2 Passing an effect function to the useEffect hook.      When  you  call  the  useEffect  hook  in  this  way,  without  a  second  argument,  React  runs  the  effect  after  every  render.  But,  what  if  you  only  want  to  run  an  effect  when  a  component  mounts?   Running an effect only when a component mounts   5.1.2  Say you want to use the width and height of the browser window, maybe for some groovy  animation  effect.  To  test  out  reading  the  dimensions,  you  create  a  little  component  that  displays the current width and height, just like in figure 5.3.   Figure 5.3 Displaying the width and height of a window as it’s resized.      Listing  5.2  shows  the code  for  the component.  It  reaches  out  to read  the innerWidth  and  innerHeight properties of the window object, so, once again, we use the useEffect hook.   Live: https:  gn80v.csb.app , Code: https:  codesandbox.io s windowsize-gn80v    Manning Publications Co.  To comment go to  liveBook   94   Listing 5.2 Resizing the window  import React, { useState, useEffect } from "react";    export default function WindowSize    {    const [ size, setSize ] = useState getSize   ;      function getSize    {                                                 A      return {        width: window.innerWidth,                                         B        height: window.innerHeight                                        B      };    }      useEffect    => {      function handleResize    {        setSize getSize   ;                                               C      }        window.addEventListener 'resize', handleResize ;                    D    }, [] ;                                                               E        return  Width: {size.width}, Height: {size.height}   };   A Define a function that returns the dimensions of the window  B Read the dimensions from the window object  C Update the state, triggering a re-render  D Register an event listener for the resize event  E Pass an empty array as the dependency argument  Within useEffect, the component registers an event listener for resize events.  window.addEventListener 'resize', handleResize ;  Whenever the user resizes the browser, the handler, handleResize, updates the state with  the new dimensions by calling setSize.  function handleResize    {    setSize getSize   ;  }   By calling the updater function, the component kicks off a re-render. We don’t want to keep  re-registering  the  event  listener  every  time  React  calls  the  component.  So,  how  do  we  prevent the effect from running after every render? The trick is the empty array passed as  the second argument to useEffect, as illustrated in figure 5.4.    Manning Publications Co.  To comment go to  liveBook   95      Figure 5.4 Passing an empty dependency array causes the effect function to run once, when the component  mounts.   As  we  see  in  section  5.1.4,  the  second  argument  is  for  a  list  of  dependencies.  React  determines whether to run an effect by checking if the values in the list have changed since  the last time the component called the effect. By setting the list to an empty array, the list  will  never  change,  and  we  cause  the  effect  to  run  only  once,  when  the  component  first  mounts.   But, hang on a second, alarm bells should be ringing. We registered an event listener…  we shouldn’t just leave that listener listening away, like a zombie shambling in a crypt for all  eternity.  We  need  to  perform  some  cleaning  up  and  unregister  the  listener.  Let’s  wrangle  those zombies.   Cleaning up side effects by returning a function   5.1.3  We  have  to  be  careful  not  to  make  a  mess  when  we  set  up  long-running  side  effects  like  subscriptions, data requests, timers and event listeners. To avoid zombies eating our brains  so  our  memories  start  to  leak,  or  ghosts  shifting  the  furniture  unexpectedly,  we  should  carefully undo any effects that may cause undead echoes of our actions to live on.   The  useEffect  hook  incorporates  a  simple  mechanism  for  cleaning  up  our  effects.  Just  return a function from the effect. React runs the returned function when it’s time to tidy up.  Listing  5.3  updates  our  window-measuring  app  to  remove  the  resize  listener  when  it’s  no  longer needed.   Live: https:  b8wii.csb.app , Code: https:  codesandbox.io s windowsizecleanup-b8wii   Listing 5.3 Resizing the window  import React, { useState, useEffect } from "react";    export default function WindowSize    {    const [ size, setSize ] = useState getSize   ;      function getSize    {      return {        width: window.innerWidth,        height: window.innerHeight      };    Manning Publications Co.  To comment go to  liveBook   96     }      useEffect    => {      function handleResize    {        setSize getSize   ;      }        window.addEventListener 'resize', handleResize ;        return    => window.removeEventListener 'resize', handleResize ;    A    }, [] ;        return  Width: {size.width}, Height: {size.height}   };   A Return a clean-up function from the effect  Because the code passes useEffect an empty array as the second argument, the effect will  run only once. When the effect runs, it registers an event listener. React keeps hold of the  function the effect returns and calls it when it’s time to clean up. In listing 5.3, the returned  function  removes  the  event  listener.  Our  memory  won’t  leak.  Our  brains  are  safe  from  zombie effects.   Figure  5.5  shows  this  latest  step  in  our  evolving  knowledge  of  the  useEffect  hook:   returning a clean-up function.      Figure 5.5 Return a function from the effect. React will run the function to clean up after the effect.   Because the clean-up function’s defined within the effect, it has access to the variables within  the  effect’s  scope.  In  listing  5.3,  the  clean-up  function  can  remove  the  handleResize  function because handleResize was also defined within the same effect.  useEffect    => {    function handleResize    {                                          A      setSize getSize   ;    }      Manning Publications Co.  To comment go to  liveBook   97     window.addEventListener 'resize', handleResize ;      return    => window.removeEventListener 'resize', handleResize ;    B  }, [] ;   A Define the handleResize function  B Reference the handleResize function from the clean-up function  The React hooks approach, where components and hooks are just functions, makes good use  of  the  inherent  nature  of  JavaScript,  rather  than  too  heavily  relying  on  a  layer  of  idiosyncratic  APIs  conceptually  divorced  from  the  underlying  language.  That  does  mean,  however, that you need a good grasp of scope and closures to best understand where to put  your variables and functions.   React  runs  the  clean-up  function  when  it  unmounts  the  component.  But  that’s  not  the  only time it runs it. Whenever the component re-renders, React calls the clean-up function  before running the effect function, if the effect runs again. If there are multiple effects that  need to run again, React calls all of the clean-up functions for those effects. Once the clean- up is finished, React re-runs the effect functions as needed.   We’ve  seen  the  two  extremes:  running  an  effect  only  once  and  running  an  effect  after  every  render.  What  if  we  want  more  control  over  when  an  effect  runs?  There’s  one  more  case to cover. Let’s populate that dependency array.   Controlling when an effect runs by specifying dependencies   5.1.4  Figure  5.6  is  our  final  illustration  of  the  useEffect  API,  including  dependency  values  in  the  array we pass as the second argument.      Figure 5.6 When calling useEffect, you can specify a list of dependencies and return a clean-up function.   Each time React calls a component, it keeps a record of the values in the dependency arrays  for calls to useEffect. If the array of values has changed since the last call, React runs the  effect. If the values are unchanged, React skips the effect. This saves the effect from running  when  the  values  it  depends  on  are  unchanged  and  so  the  outcome  of  its  task  will  be  unchanged.    Manning Publications Co.  To comment go to  liveBook   98   Let’s look at an example. Say you have a user picker that lets you select a user from a  drop-down menu. You want to store the selected user in the browser’s local storage so that  the page remembers the selected user from visit to visit, as shown in figure 5.7.      Figure 5.7 Once you select a user, refreshing the page automatically reselects the same user.   Listing 5.4 shows the code to achieve the desired effect. It includes two calls to useEffect,  one to get any stored user from local storage, and one to save the selected user whenever  that value changes.   Live: https:  c987h.csb.app , Code: https:  codesandbox.io s userstorage-c987h      Listing 5.4 Using Local Storage  import React, { useState, useEffect } from "react";    export default function UserStorage    {    const [ user, setUser ] = useState "Sanjiv" ;      useEffect    => {      const storedUser = window.localStorage.getItem "user" ;            A        if  storedUser  {        setUser storedUser ;      }    }, [] ;                                                              B      useEffect    => {                                                    C      window.localStorage.setItem "user", user ;                         D    }, [user] ;                                                          E      return          setUser e.target.value }>         Jason     Manning Publications Co.  To comment go to  liveBook   99          Akiko          Clarisse          Sanjiv             ;  };   A Read the user from local storage  B Only run this effect when the component first mounts  C Specify a second effect  D Save the user to local storage  E Run this effect whenever the user changes  The  component  works  as  expected,  saving  changes  to  local  storage  and  automatically  selecting the saved user when the page is reloaded.   But,  to  get  a better feel for how  the function  component  and  its  hooks  manage  all  the  pieces,  let’s  run  through  the  steps  for  the  component  as  it  renders  and  re-renders  and  a  visitor to the page selects a user from the list. We look at two key scenarios:   1.  The visitor first loads the page. There is no user value in local storage. The visitor   selects a user from the list.   2.  The visitor refreshes the page. There is a user value in local storage.   As we go through the steps, notice how the dependency lists for the two effects determine  when the effect functions run.   THE VISITOR FIRST LOADS THE PAGE  When the component first runs, it renders the drop-down list of users with Sanjiv selected.  Then the first effect runs. No user is in local storage, so nothing happens. Then the second  effect runs. It saves Sanjiv to local storage.   1.  The user loads the page.  2.  React calls the component.  3.  The useState call sets the value of user to Sanjiv.  It’s the first time the component   has called useState, so the initial value is used.    4.  React renders the list of users with Sanjiv selected.  5.  Effect 1 runs but there is no stored user.  6.  Effect 2 runs, saving Sanjiv to local storage.   React calls the effect functions in the order they appear in the component code. When the  effects run, React keeps a record of the values in the dependency lists, [] and ["Sanjiv"] in  this case.   When the visitor selects a new user, say Akiko, the onChange handler calls the setUser  updater function. React updates the state and calls the component again. This time, effect 1  doesn’t run because its dependency list hasn’t changed, it’s still []. But, the dependency list  for effect 2 has changed from ["Sanjiv"] to ["Akiko"] so effect 2 runs again, updating the  value in local storage.   1.  The user selects Akiko.  2.  The updater function sets the user state to Akiko.    Manning Publications Co.  To comment go to  liveBook   100   3.  React calls the component.  4.  The useState call sets the value of user to Akiko.  It’s the second time the component   has called useState, so the latest value, set in step 8, is used.    5.  React renders the list of users with Akiko selected.  6.  Effect 1 doesn’t run  [] = [] .  7.  Effect 2 runs  ["Sanjiv"] != ["Akiko"] , saving Akiko to local storage.   THE VISITOR REFRESHES THE PAGE  With local storage set to Akiko, if the user reloads the page, effect 1 will set the user state to  the stored value, Akiko, as we saw in figure 5.7. But, before React calls the component with  the new state value, effect 2 still has to run with the old value.   1.  The user refreshes the page.  2.  React calls the component.  3.  The useState call sets the value of user to Sanjiv.  It’s the first time the component   has called useState, so the initial value is used.    4.  React renders the list of users with Sanjiv selected.  5.  Effect 1 runs, loading Akiko from local storage and calling setUser.  6.  Effect 2 runs, saving Sanjiv to local storage.  7.  React calls the component  because effect 1 called setUser, changing the state .   8.  The useState call sets the value of user to Akiko.  9.  React renders the list of users with Akiko selected.  10. Effect 1 doesn’t run  [] = [] .  11. Effect 2 runs  ["Sanjiv"] != ["Akiko"] , saving Akiko to local storage.   In  step 6,  effect  2  was  defined  as  part  of  the  initial  render,  so  it  still  uses  the  initial user  value, Sanjiv.   By  including  user  in  the  list  of  dependencies  for  effect  2,  we’re  able  to  control  when   effect 2 runs: only when the value of user changes.   Summarizing the ways to call the useEffect hook   5.1.5  Table 5.1 collects the different use cases for the useEffect hook into one place, showing how  the different code patterns lead to different execution patterns.   Call pattern   No second argument   Code pattern  useEffect    => {       perform effect  } ;   Execution pattern   Run after every render.    Manning Publications Co.  To comment go to  liveBook   101   Empty array as  second argument   useEffect    => {       perform effect  }, [] ;   Run once, when the  component mounts.   Dependency array as  second argument   useEffect    => {     perform effect     that uses dep1 and dep2  }, [dep1, dep2] ;   Run whenever a value in the  dependency array changes.   Return a function   useEffect    => {     perform effect  return    => { * clean-up * };  }, [dep1, dep2] ;   React will run the clean-up  function when the  component unmounts and  before re-running the effect.   CHALLENGE 5.1  On CodeSandbox  or anywhere you prefer , create an app that updates the document title as  the window is resized. It should say “Small” or “Medium” or “Large” depending on the size of  the window.   Now that we’ve seen what the useEffect hook can do, it’s time to fetch some data. Let’s   make our app data available via a server rather than as a file import.   5.2  Fetching data  So  far  in  React  Hooks  in  Action,  we’ve  been  importing  data  for  the  bookings  app  example  from the static.json file. But, it’s more common to fetch data from a server. To make our  examples a little more realistic, let’s start doing just that. Rather than reach out to a public  server, we run a JSON server locally, using a new db.json file outside of the src folder. We  then create a component that fetches data from that server. We cover:      Creating the new db.json file.     Setting up a JSON server using the json-server package.     Building a component to fetch data from our server, displaying a list of users.     Taking care when using async and await within an effect.   Creating the new db.json file   5.2.1  In  chapters  3  and  4,  we  imported  data  from  the  static.json  file.  For  our  server,  copy  across  the  bookings,  users  and  bookables  data  to  a  new  db.json  file  in  the  root  of  the  project.  Leave  the  days  and  sessions  arrays  in  static.json  -  we  treat  that  as  config  information and continue to import it.      db.json  {    Manning Publications Co.  To comment go to  liveBook   102     bookings: [ * empty * ],    users: [ * user objects * ],    bookables: [ * bookable objects * ]  }       static.json  {    days: [ * names of days * ],    sessions: [ * session names * ]  }   In later chapters, we start updating the database file by sending POST and PUT requests. The  create-react-app  development  server  restarts  whenever  files  within  the  src  folder  change.  Having  the db.json file  outside of src  avoids  unnecessary  restarts  as we  test  adding new  bookables and making bookings.   Setting up a JSON server   5.2.2  Until  now,  we’ve  been  importing  data  for  the  BookablesList,  UsersList  and  UserPicker  components from a JSON file, static.json.  import { bookables } from ".. .. static.json";  import { users } from ".. .. static.json";   To  better  exemplify  the  kinds  of  data  fetching  tasks  we  perform  in  a  real  application,  we  want to make our data available via http. Luckily, we don’t need to spin up a real database  for our data, we can instead make use of the json-server npm package. This package is a  really handy, easy way of serving up JSON data as a mock REST API. There’s a user guide at  https:  github.com typicode json-server, where you can see just how flexible the package is.  To install the package globally using npm, enter the command:   npm install -g json-server   Then, from within the root of our project, start the server with the command:   json-server --watch db.json --port 3001   You should be able to query our database on localhost:3001. Figure 5.8 shows the terminal  output on my machine when I start up the server.    Manning Publications Co.  To comment go to  liveBook   103      Figure 5.8 The output when running json-server. Properties from within the db.json file have been turned into  endpoints for fetchable resources.   We’ve  made our db.json file  JSON  data  available  over  http  via  URL  endpoints. Comparing  the data from the file to figure 5.8, you can see the server has turned each property from  the  JSON  object  into  an  endpoint.  For  example,  to  get  the  list  of  users,  navigate  to  localhost:3001 users  and  to  localhost:3001 users 1. Nice! You can test out the requests in a browser. The results of  the two requests just mentioned are shown in figure 5.9: first, the list of user objects in an  array, and second, the user object with an id of 1.   id  of  1,  navigate   the  user  with  an   to  get    Manning Publications Co.  To comment go to  liveBook   104   Figure 5.9 Two browser responses showing our bookings app data is now available via http.      Let’s try out our server and fetch some data from within a useEffect hook.   Fetching data within a useEffect hook   5.2.3  To  introduce  data  fetching  from  within  a  useEffect  hook,  we  update  the  UserPicker  component  to  fetch  the  users  from  our  JSON  database.  Figure  5.10  shows  the  expanded  drop-down list with the four users.      Figure 5.10 Displaying a list of users fetched from the database.   Remember, React calls effect functions after rendering, so the data won’t be available for the  first render; we set an empty list of users as the initial value and return alternative UI for the  loading state. Listing 5.5 shows the code to fetch the list of users and display it in the drop- down.   Branch: 0501-user-picker, File:  src components Users UserPicker.js   Listing 5.5 The UserPicker component fetching data  import React, {useState, useEffect} from "react";   import {FaSpinner} from "react-icons fa";    export default function UserPicker    {    const [users, setUsers] = useState null ;    Manning Publications Co.  To comment go to  liveBook   105       useEffect    => {                                                     A        fetch "http:  localhost:3001 users"                                 B        .then resp => resp.json                                           C        .then data => setUsers data  ;                                    D      }, [] ;                                                               E       if  users === null  {      return                          F    }      return                 {users.map u =>             {u.name}           }            ;  };   A Fetch the data from inside an effect function  B Make the request to the database using the browser’s fetch API  C Convert the JSON string returned into a JavaScript object  D Update the state with the loaded users  E Include an empty dependency array to load the data once, when the component is first mounted  F Return alternative UI while the users load  The  UserPicker  code  uses  the  browser’s  fetch  API  to  retrieve  the  list  of  users  from  the  database, parses the response as JSON, and calls setUsers to update the local state with the  result. The component initially renders a Font Awesome spinner placeholder, before replacing  it with the list of users. If you want to add some latency to the fetch calls, to better see any  loading  states,  start  the  JSON  server  with  a  delay  flag.  This  snippet  delays  responses  for  3000ms or three seconds:   json-server --watch db.json --port 3001 --delay 3000   The effect in listing 5.5 runs only once, when the component mounts. We’re not expecting  the  list  of  users  to  change,  so  there’s  no  need  to  manage  the  re-loading  of  the  list.  The  following  list  shows  the  sequence  of  steps  involved  in  fetching  data  from  an  effect  in  this  way:   1.  React calls the component.  2.  The useState call sets the users variable to null.  3.  The useEffect call registers the data-fetching effect function with React.  4.  The users variable is null, so the component returns the spinner icon.  5.  React runs the effect, requesting data from the server.  6.  The data arrives, and the effect calls the setUsers updater function, triggering a re-  render.   7.  React calls the component.  8.  The useState call sets the users variable to the returned list of users.    Manning Publications Co.  To comment go to  liveBook   106   9.  The empty dependency array, [], for useEffect is unchanged, so the hook call does   not re-register the effect.   10. The users array has 4 elements  it’s not null , so the component returns the drop-  down UI.   This  method  of  fetching  data,  where  the  component  renders  before  it  even  kicks  off  a  request for data, is called fetch on render. There are other methods that can sometimes offer  a smoother experience for your users, and we take a look at some of those in Part 3. But,  depending on the complexity and stability of the data source and your application’s needs,  the simplicity of fetching within a call to the useEffect hook might be perfectly adequate and  quite appealing.   CHALLENGE 5.2  Update the UsersList component on the UsersPage to fetch the users data from the server.  The 0502-users-list branch has the challenge solution code for the updated component.   Working with async and await   5.2.4  The  fetch  call  in  listing  5.5  returns  a  promise  and  the  listing  uses  the  promise’s  then  method to process the response.   fetch "http:  localhost:3001 users"     .then resp => resp.json       .then data => setUsers data  ;    JavaScript also offers async functions and the await keyword for working with asynchronous  responses, but there are some caveats when combining them with the useEffect hook. As an  initial attempt to convert our data-fetching to async-await, we might try:   useEffect async    => {    const resp = await fetch "http:  localhost:3001 users" ;    const data = await  resp.json   ;    setUsers data ;  }, [] ;   But that approach fires a couple of warnings from React, as shown in figure 5.11.    Manning Publications Co.  To comment go to  liveBook   107     Figure 5.11 Our async-await data-fetching effect causes React to issue some warnings.   The key messages from the browser are:      Warning:  An  effect  function  must  not  return  anything  besides  a  function,  which  is       used for clean-up.  It looks like you wrote useEffect async    => ...  or returned a Promise. Instead,  write the async function inside your effect and call it immediately.      Effect  callbacks  are  synchronous  to  prevent  race  conditions.  Put  the  async  function   inside.   async functions return a promise by default. Setting the effect function as async will cause  trouble because React is looking for the return value of an effect to be a clean-up function.  To  solve  the  issues,  remember  to  put  the async  function  inside  the  effect  function,  rather  than making the effect function async itself:  useEffect    => {    async function getUsers   {                        A      const resp = await fetch url ;                   B      const data = await  resp.json   ;                B      setUsers data ;    }    getUsers  ;                                        C  }, [] ;   A Define an async function  B Wait for asynchronous results  C Call the async function    Manning Publications Co.  To comment go to  liveBook   108   Having  set  up  the  JSON  server,  tried  an  example  of  the  fetch-on-render  data-fetching  method with the useEffect hook, and taken a moment to consider async-await syntax, we’re  ready to update the bookings app to fetch data for the BookablesList component.   5.3  Fetching data for the BookablesList component  In  the  last  section,  we  saw  how  a  component  can  load  data  after  its  initial  render  by  including the fetching code within a call to the useEffect hook. More complicated applications  consist of many components and multiple queries for data that could use multiple endpoints.  You  might  try  to  smooth  that  complexity  by  moving  state  and  its  associate  data-fetching  actions into a separate data store and then connecting components to the store. But, it may  also be that situating the data fetching within the components that consume the data will be  a more direct and understandable approach for your app. We consider different approaches  in Chapter 10 when we look at custom hooks, and in Part 3 when we look at models for data  fetching.    For now, we keep things simple and get the BookablesList component to load its own   data. We develop its data-fetching capability over four steps:      Examining the data-loading process.     Updating the reducer to manage loading and error states.     Creating a helper function to load data.     Loading the bookables.   Examining the data-loading process   5.3.1  The UserPicker component, in section 5.2, used the fetch API to load the list of users from  the JSON database server. For the BookablesList component, we consider loading and error  states  as  well  as  the  bookables  themselves.  What  exactly  do  we  want  the  updated  component to do?   After the component first renders, it will fire off a request for the data it needs. At this  point,  before  any  data  has  loaded,  there  are  no  bookables  or  groups  to  display,  so  the  component will show a loading indicator, as shown in figure 5.12.      Figure 5.12 The BookablesList component shows a loading indicator while the data is loading   If there’s a problem loading the data - maybe network, server, authorization or missing file  issues - the component will display an error message like the one in figure 5.13.    Manning Publications Co.  To comment go to  liveBook   109      Figure 5.13 The BookablesList component shows an error message if there was a problem loading data   If  everything  goes  well  and  the  data  arrives,  it’ll  be  displayed  in  the  UI  we  developed  in  chapters 3 and 4. The “Meeting Room” bookable from the “Rooms” group is selected and its  details are showing. Figure 5.14 shows the expected result.      Figure 5.14 The BookablesList component shows the list of bookables once the data has loaded   At this point, the user will be able to interact with the app, selecting groups and bookables,  cycling  through  the  bookables  with  the  Next  button  and  toggling bookable  details  with  the  Show Details check box.   In  chapter  4,  we  created  a  reducer  to  help  manage  the  BookablesList  component’s   state. How should we update the reducer to cope with the new functionality?   Updating the reducer to manage loading and error states   5.3.2  We’ve  seen  what  we’re  trying  to  achieve,  now  we  need  to  consider  the  component  state  needed to drive such an interface. To enable the loading indicator and the error message, we  add two more properties to the state: isLoading and error. The full initial state now looks  like this:    Manning Publications Co.  To comment go to  liveBook   110   {      group: "Rooms",      bookableIndex: 0,      hasDetails: true,      bookables: [],      isLoading: true,      error: false    }   The  component  will  start  loading  data  after  the  first  render,  so  we  set isLoading  to true  right from the start. Our initial UI will be the loading indicator.   To change the state in response to data-fetching events, we add three new action types   to the reducer:      FETCH_BOOKABLES_REQUEST - the component initiates the request     FETCH_BOOKABLES_SUCCESS - the bookables arrive from the server     FETCH_BOOKABLES_ERROR - something went wrong   We discuss the new action types further after listing 5.8, which shows them in our updated  reducer.   Branch: 0503-bookables-list, File:  src components Bookables reducer.js   Listing 5.8 Managing loading and error states in the reducer  export default function reducer  state, action  {    switch  action.type  {      case "SET_GROUP": return {  * unchanged *  }      case "SET_BOOKABLE": return {  * unchanged *  }      case "TOGGLE_HAS_DETAILS": return {  * unchanged *  }      case "NEXT_BOOKABLE": return {  * unchanged *  }        case "FETCH_BOOKABLES_REQUEST":        return {          ...state,          isLoading: true,          error: false,          bookables: []                                                  A        };        case "FETCH_BOOKABLES_SUCCESS":        return {          ...state,          isLoading: false,          bookables: action.payload                                      B        };        case "FETCH_BOOKABLES_ERROR":        return {          ...state,          isLoading: false,          error: action.payload                                          C        };        default:        return state;    }    Manning Publications Co.  To comment go to  liveBook   111   }   A Clear the bookables when requesting new data  B Pass the loaded bookables to the reducer via the payload  C Pass the error to the reducer via the payload   FETCH_BOOKABLES_REQUEST  When  the  component  sends  off  its  request  for  the  bookables  data,  we  want  to  show  the  loading indicator in the UI. As well as setting isLoading to true, we make sure there are no  existing bookables and clear out any error message.   FETCH_BOOKABLES_SUCCESS  Woohoo!  The  bookables  have  arrived  and  are  in  the  action’s  payload.  We  want  to  display  them, so set isLoading to false and assign the payload to the bookables state property.  FETCH_BOOKABLES_ERROR  Boo! Something went wrong and the error message is in the action’s payload. We want to  display the error message, so set isLoading to false and assign the payload to the error  state property.   You  can  see  how  there’s  a  lot  of  interrelated  state  changes  going  on  for  each  action;   having a reducer to group and centralize those changes is really helpful.   Creating a helper function to load data   5.3.3  When  the  UserPicker  component  fetched  its  data,  it  didn’t  worry  about  loading  states  or  error messages, it just went right ahead and called fetch from within a useEffect hook. Now  that we’re doing a bit more to give users some feedback while data is loading, it might be  better to create some dedicated data-fetching functions. There are three key tasks we want  our data code to perform:      Send the request     Check the response for errors     Convert the response to a JavaScript object   The getData function in listing 5.9 performs the three tasks, as required. We discuss each  task in more detail after the listing. The file api.js has been added in the utils folder.   Branch: 0503-bookables-list, File:  src utils api.js   Listing 5.9 A function for fetching data  export default function getData  url  {                               A      return fetch url                                                    B      .then resp => {          if  !resp.ok  {                                                 C          throw Error "There was a problem fetching data." ;            D        }          return resp.json  ;                                             E      } ;    Manning Publications Co.  To comment go to  liveBook   112   }   A Accept a url argument  B Pass the url on to the fetch function  C Check if there is a problem with the response  D Throw an error for any problems  E Convert the response JSON string into a JavaScript object   SEND THE REQUEST  The getData function accepts one argument, the url, and passes it on to the fetch function.   The fetch function also accepts a second argument, an init object, but we won’t be using  that  fetch  API  on  MDN:  https:  developer.mozilla.org en-US docs Web API Fetch_API. fetch returns a promise that  should resolve to a response object from which we can get our data.   find  out  more  about   for  now.   You   can   the   CHECK THE RESPONSE FOR ERRORS  We  call  then  on  the  promise  that  fetch  returns,  setting  up  a  function  to  do  some  initial  processing of the response.   return fetch url     .then resp => {         do some initial processing of the response    } ;   First,  we  check  the  status  of  the  response  and  throw  an  error  if  it’s  not  ok   i.e.  the  http  status code is not in the range 200 to 299 .   if  !resp.ok  {    throw Error "There was a problem fetching data." ;  }   Responses  with  status  codes  outside  of  the  200  to  299  range  are  valid  and fetch  doesn’t  automatically  throw  any  errors  for  them.  We  do  our  own  check  and  throw  an  error  if  necessary. We don’t catch any errors here; the calling code should set up any catch blocks it  needs.   CONVERT THE RESPONSE TO A JAVASCRIPT OBJECT  If  the response  passes  muster,  we  convert  the  JSON  string  the  server  has  returned  into a  JavaScript object by calling the response’s json method. The json method returns a promise  that resolves to our data object and we return that promise from the function.   return resp.json  ;   The getData  function  does some  pre-processing of  the response  from fetch,  a  little  like  a  piece  of  middleware.  Components  that  use  getData  won’t  need  to  make  these  pre- processing  checks  and  changes  themselves.  Let’s  see  how  the  BookablesList  component  can use our data-fetching function to load the bookables for display.    Manning Publications Co.  To comment go to  liveBook   113   Loading the bookables   5.3.4  It’s  time  to  reap  the  benefits  of  all  those  preparations.  Listing  5.10  shows  the  latest  BookablesList  component  file.  The  code  imports  our  new  getData  function  and  uses  it  within a useEffect hook that runs once, when the component first mounts. It also includes  the isLoading and error state values and some associated UI for when data is loading or  there is an error message to display.   Branch: 0503-bookables-list, File:  src components Bookables BookablesList.js   Listing 5.10 The BookablesList component loading its own data  import React, {useReducer, useEffect, Fragment} from "react";   import {sessions, days} from ".. .. static.json";  import {FaArrowRight, FaSpinner} from "react-icons fa";  import reducer from ". reducer";    import getData from ".. .. utils api";                                 A    const initialState = {    group: "Rooms",    bookableIndex: 0,    hasDetails: true,    bookables: [],    isLoading: true,                                                     B    error: false                                                         B  };    export default function BookablesList    {    const [state, dispatch] = useReducer reducer, initialState ;       const {group, bookableIndex, bookables} = state;    const {hasDetails, isLoading, error} = state;                        C      const bookablesInGroup = bookables.filter b => b.group === group ;    const bookable = bookablesInGroup[bookableIndex];    const groups = [...new Set bookables.map b => b.group  ];      useEffect    => {        dispatch {type: "FETCH_BOOKABLES_REQUEST"} ;                       D        getData "http:  localhost:3001 bookables"                          E          .then bookables => dispatch {                                    F          type: "FETCH_BOOKABLES_SUCCESS",                               F          payload: bookables                                             F        }            .catch error => dispatch {                                       G          type: "FETCH_BOOKABLES_ERROR",                                 G          payload: error                                                 G        }  ;      }, [] ;      function changeGroup  event  {}    function changeBookable  selectedIndex  {}    Manning Publications Co.  To comment go to  liveBook   114     function nextBookable    {}    function toggleDetails    {}      if  error  {                                                         H      return  {error.message}                                       H    }                                                                    H      if  isLoading  {                                                     I      return                                                           I         {" "}                       I        Loading bookables...                                             I                                                                      I    }                                                                    I      return    * unchanged UI for bookables and details *   ;  }   A Import the getData function  B Add the new properties to the initial state  C Destructure the new properties from state  D Dispatch an action for the start of the data fetching  E Fetch the data  F Save the loaded bookables in state  G Update state with any error  H Return some simple error UI if there’s an error  I Return some simple loading UI while waiting for data  The call to getData is in the effect function. In section 5.3.3, we saw how getData returns a  promise and can throw an error. So, in listing 5.10, we use both a then and a catch method,  dispatching the appropriate actions, discussed in section 5.3.2, from each. Finally, we use if  statements to return UI for loading and error conditions. If there’s no error and isLoading is  false, we return our existing UI for the list of bookables and bookable details.  CHALLENGE 5.3  Update the UsersList component to use the getData function and to manage loading and  error states. Possible solution code is on the 0504-users-errors branch.   We return to data fetching in chapter 7, when we expand our roster of components in the  bookings  app.  Before  that,  in  the  next  chapter,  we  investigate  another  way  of  managing  state in components: the useRef hook.   5.4  Summary      Sometimes our components reach outside of the React data-flow process and directly  interact with other APIs, most commonly in the browser. An action that impinges on  the outside world in some way is called a side effect.      Common side effects include: Setting the page title imperatively, working with timers  like  setInterval  or  setTimeout,  measuring  the  width  or  height  or  position  of  elements  in  the  DOM,  logging  messages  to  the  console,  setting  or getting  values  in  local storage, and fetching data or subscribing and unsubscribing to services.      Wrap side effects inside an effect function as the first argument to the useEffect hook:    Manning Publications Co.  To comment go to  liveBook   115   useEffect    => {       perform effect  } ;  React runs the effect function after every render.      To  manage  when  an  effect  function  runs,  pass  a  dependencies  array  as  the  second      Pass an empty dependencies array to make React run the effect function once, when   argument to the useEffect hook.   the component mounts:   useEffect    => {       perform effect  }, [] ;  Include  all  of  the  effect  function’s  dependencies  in  the  dependencies  array  to  make  React  run  the  effect  function  whenever  the  values  of  the  specified  dependencies  change.          Return  a clean-up function from  the  effect  that  React will  run  before re-running  the   effect function and when the component unmounts.      Fetch data from within an effect if you’re using the fetch-on-render approach. React  will render the component and then fire the data-fetching code. It will re-render the  component when the data arrives.   useEffect    => {       perform effect       that uses dep1 and dep2  }, [dep1, dep2] ;   useEffect    => {       perform effect    return    => { * clean-up * };  }, [dep1, dep2] ;   useEffect    => {      fetch "http:  localhost:3001 users"         .then resp => resp.json           .then data => setUsers data  ;  }, [] ;      To avoid race conditions and to follow the convention of returning nothing or a clean- up  function  from  the  effect  function,  put  async  functions  inside  the  effect  function.  You can call them immediately, as necessary.   useEffect    => {     async function getUsers   {        const resp = await fetch url ;        const data = await  resp.json   ;        setUsers data ;    }    getUsers  ;    Manning Publications Co.  To comment go to  liveBook   116   }, [] ;      Put  separate  side  effects  into  separate  calls  to  useEffect.  It  will  be  easier  to  understand  what  each  effect  does,  easier  to  control  when  the  effects  run  by  using  separate dependencies lists, and easier to extract the effects into custom hooks.  If, on re-render, multiple  effects  are going  to run, React will  call  all of  the  clean-up  functions for the re-running effects before it runs any effects themselves.        Manning Publications Co.  To comment go to  liveBook   117       Managing component state with the  useRef hook   This chapter covers      calling the useRef hook to obtain a ref     updating a ref by assigning values to its current property     updating state without triggering re-renders     setting the ref attribute in JSX to assign DOM element references to a ref     accessing DOM element properties and methods via a ref   While most of the values stored by your component will be directly represented in the user  interface  of  your  application,  there  will  be  times  when  you  use  a  variable  only  for  the  mechanics  of  your  app  rather  than  for  consumption  by  users.  You  may  want  to  use  setTimeout  or setInterval  as  part  of  an  animation,  so  you  need  to  keep  hold  of  the  ids  they return. Or, you may want to work with DOM form elements as uncontrolled inputs, so  you  need  to  keep  hold  of  references  to  those  elements.  Either  way,  you  may  not  need  to  display these values to the user and so changing them shouldn’t automatically trigger a re- render.   In this chapter we start with two examples that explore changing state without updating  the  UI:  first  a  comparison  of  managing  state  with  useState  and  useRef,  then  a  longer  example as we manage timers for the BookablesList component’s new Presentation Mode.  The  second  half  of  the  chapter  has  two  more  examples,  this  time  exploring  references  to  DOM  elements:  automatically  setting  focus  in  the  BookablesList  component  and  reading  the date from a text box for the WeekPicker component. The mix of examples will give you a  good understanding of how the useRef hook helps you manage state in your components.   Okay, 1, 2, 3, let’s go!    Manning Publications Co.  To comment go to  liveBook   118   6.1  Updating state without causing a re-render  In this section, we use a simple Counter component to introduce refs as a way of persisting  state across renders. With the useState hook, calling a state value’s updater function usually  triggers a re-render. With the useRef hook, we can update our value without a corresponding  change to the UI. We start by looking at how the Counter component behaves when a user  clicks away on its buttons, incrementing the counters  but not necessarily the UI , and the  code required to make it behave that way. Then, having seen useRef in action, we focus on  the new hook’s API.   Comparing useState and useRef when updating state values   6.1.1  Figure  6.1  shows  four  screenshots  of  the  Counter  component  UI  with  two  buttons,  one  labeled  count  and  one  labeled ref.current.  Each  button  also  has  a  counter  appended  to  its  button text. The buttons behave in different ways. Clicking the ‘count’ button increments its  counter,  as  you  can  see  in  the  figure  which  shows  the  original  component  and  the  result  when  it’s  clicked  three  times.  The  button  counter  goes  up  from  1  to  2  to  3  to  4.  Each  increase is accompanied by a re-render, so the Counter component shows the latest value.   Figure 6.1 Clicking the count button increases the count by 1 each time. Because the event handler  increments the count by calling its updater function, React re-renders the component after each change.   Figure  6.2  shows  the  result  when  you  then  click  the  ‘ref.current’  button  three  times.  Its  counter doesn’t seem to change, the component shows 1 then 1 then 1. In fact, the value  does  increase, from  1  to 2  to 3  to  4.  It’s  just  that changing  the  ‘ref.current’ value  doesn’t  cause React to re-render, so the Counter component continues to show an old value.   Figure 6.2 Clicking the ref.current button three times seems to have no effect. In fact, the event handler does  increment ref.current to 2, then 3, then 4, but React does not re-render the component.    Manning Publications Co.  To comment go to  liveBook         119   Clicking  the  ‘count’  button  one  more  time  increments  its  counter  from  4  to  5.  React  re- renders the component to show the latest value, shown in figure 6.3. Doing so also updates  the value shown by the ‘ref.current’ button and it jumps to 4, its current value.   Figure 6.3 Clicking the count button one more time increases the count to 5. React re-renders the component  which now shows the latest values of count and ref.current.   In previous chapters we’ve seen how to implement a button like the ‘count’ button using the  useState hook. How do we implement the ‘ref.current’ button, where state is persisted across  renders but updating the ref doesn’t cause a re-render? Listing 6.1 shows the code for the  button example, including a call to the useRef hook for the first time.   Live: https:  gh6xz.csb.app , Code: https:  codesandbox.io s counterstatevsref-gh6xz      Listing 6.1 Comparing useState and useRef when updating state  import React, { useRef, useState } from "react";    export default function Counter   {    const [count, setCount] = useState 1 ;                               A    const ref = useRef 1 ;                                               B      const incCount =    => setCount c => c + 1 ;                         C      const incRef =    => ref.current++;                                  D      return                  count: {count}                E                  ref.current: {ref.current}      F            ;  }   A Initialize the count value with useState  B Initialize the ref value with useRef  C Define a handler that calls setCount to increment count  D Define a handler that updates the current property of the ref  E Call the handler for the count value  F Call the handler for the ref value  So, why do the buttons behave differently? Well, one uses the useState hook and one uses  the useRef hook.    Manning Publications Co.  To comment go to  liveBook   120   The ‘count’ button gets React to manage its counter state value by calling useState. The  button’s  event  handler  changes  the  counter  with  the  state  value’s  updater  function,  setCount. Calling the updater function changes the state and also triggers a re-render. React  persists  the  state  across  renders,  each  time  passing  it  back  to  the  component  where  it  is  assigned to the count variable.   The ‘ref.current’ button gets React to manage its counter state value by calling useRef.  The hook returns an object, a ref, which we use to store the state value. Changing the value  stored on the ref doesn’t trigger a re-render. React persists the state across renders, each  time  passing  the  same  ref  object  back  to  the  component  where  it  is  assigned  to  the  ref  variable.   Both  buttons  in  listing  6.1  include  a  state  value  in  their  button  text,  {count}  and  {ref.current},  and call a handler function when the user clicks them. But what’s with the  .current business? Let’s take a closer look at how to work with useRef.   Calling useRef   6.1.2  In listing 6.1, we obtain a ref from React by calling useRef, passing it an initial value of 1.  We assign the ref to a variable, ref:  const ref = useRef 1 ;   The useRef function returns an object with a current property, as shown in figure 6.4. Every  time React runs the component code, each call to useRef will return the same ref object for  that call.   Figure 6.4 useRef returns an object with a current property.      The  first  time  React  invokes  the  component  code,  it  assigns  the  initial  value  you  pass  the  useRef function to the ref object’s current property.  const ref1 = useRef "Towel" ;  const ref2 = useRef 42 ;    ref1.current;     "Towel"    Manning Publications Co.  To comment go to  liveBook   121   ref2.current;     42   On  subsequent  renders,  React  assigns  the  same  ref  objects  to  the  respective  variables,  based on the order of the useRef calls. You can persist state values by assigning them to the  current properties of the refs:  ref1.current = "Babel Fish";  ref2.current = "1,000,000,000,000";   Assigning new values to the current properties of the ref objects doesn’t trigger a re-render.  But,  as  React  always returns  the  same  ref objects,  the  new values  are  available  when  the  component runs again.   Okay, the button example was a bit simple and a bit weird - who want’s broken buttons?   The time has come for a bit more complexity.   6.2  Storing timer ids with a ref  In the previous section, we saw how we can use the useRef hook to maintain state across  renders  for  our  function  components.  To  update  the  ref  returned  from  useRef,  we  set  its  current property to the value we want to store. Changing the current property in this way  doesn’t cause a re-render of the component. In this section, we look at a more complicated  example, using the useRef hook to enlist React’s help managing the ids of timers. We return  to the bookings app as our context.   So as not to swamp the discussion of useRef with component implementation details, we   break the example into four subsections:   Introducing Presentation Mode for the BookablesList component.         Updating the reducer to include state for Presentation Mode.     Updating the BookablesList component to use the latest reducer.     Managing timers for Presentation Mode with the useRef hook.   By breaking the explanation up this way, we can more easily focus on each key detail and, in  particular, make space for a clear discussion of the timer code and its ref in section 6.2.4.  Let’s enter Presentation Mode and automatically progress to the next section…   Introducing Presentation Mode for the BookablesList component   6.2.1  Say your boss wants you to create a Presentation Mode for the BookablesList component.  Before the user selects their first bookable, the component should automatically select each  bookable  in  turn  on  a  timer,  showing  its  details,  as  you  can  see  in  figure  6.5.  Your  boss  thinks this would be great for that foyer screen the company bought last year.    Manning Publications Co.  To comment go to  liveBook   122      Figure 6.5 In Presentation Mode, the application will automatically advance to each bookable in turn, showing  its details.   Left  alone  in  Presentation  Mode,  the  component  cycles  through  all  of  the  bookables  in  a  group,  wrapping  back  to  the  first  when  it  leaves  the  last.  As  soon  as  a  user  selects  a  bookable, either  by  clicking  one  directly  or  by  using  the  Next  button,  the  component  exits  Presentation  Mode  and  only  re-enters  it  if  the  user  refreshes  the  page.  But,  choosing  a  different group, switching from ‘Rooms’ to ‘Kit’ for example, or toggling the display of details  by clicking the Show Details checkbox, shouldn’t exit Presentation Mode. Table 6.1 lists the  desired behaviors after different events.   Continue Presentation Mode   The component loads   The user selects a bookable   The user uses the Next button   The user switches groups   The user toggles bookable details   Yes   No   No   Yes   Yes      After      We’ll use timers to schedule when the component should move on to the next bookable. If  the user switches groups, automatically moving the selected bookable to the first in the new  group, we have to cancel the current timer and set up a new one to give the newly selected  bookable its allotted time. But, we’re getting ahead of ourselves! One step at a time.    Manning Publications Co.  To comment go to  liveBook   123   Updating the reducer to include state for Presentation Mode   6.2.2  To model Presentation Mode for the BookablesList component, we add an extra state value  for the reducer called isPresenting. We check that isPresenting is true before firing up  any timers for Presentation Mode. The initial value of isPresenting is false but switches to  true when the bookables load. Then, if the user selects a bookable or uses the Next button,  the value switches back to false.   Switching  off  Presentation  Mode  when  the  user  directly  selects  a  bookable  is  easy  to  handle,  just  set isPresenting  to false  in  the SET_BOOKABLE  action.  But,  both  a  timer   in  Presentation Mode  and the user  by clicking the Next button  can cause the movement from  one bookable to the next, by dispatching the NEXT_BOOKABLE action. So, the NEXT_BOOKABLE  action needs to know whether it’s a timer or a user dispatching it; it needs to know whether  to stop presenting or not. You can see the reducer using the NEXT_BOOKABLE action’s payload  to set isPresenting in listing 6.2.   Branch: 0601-presentation-reducer, File:  src components Bookables reducer.js   Listing 6.2 The updated reducer for Presentation Mode  export default function reducer  state, action  {    switch  action.type  {      case "SET_GROUP": return {  * unchanged *  };        case "SET_BOOKABLE":        return {          ...state,          bookableIndex: action.payload,          isPresenting: false                                             A        };        case "TOGGLE_HAS_DETAILS": return {  * unchanged *  };        case "NEXT_BOOKABLE":        const count = state.bookablesByGroup[state.group].length;        return {          ...state,          bookableIndex:  state.bookableIndex + 1  % count,          isPresenting: action.payload                                    B        };         case "FETCH_BOOKABLES_REQUEST": return {  * unchanged *  };        case "FETCH_BOOKABLES_SUCCESS":        return {          ...state,          isLoading: false,          bookables: action.payload,          isPresenting: true                                              C        };        case "FETCH_BOOKABLES_ERROR": return {  * unchanged *  };        default:        return state;    }    Manning Publications Co.  To comment go to  liveBook   124   }   A Leave presentation mode when directly selecting a bookable  B Set the isPresenting state property via the payload  C Start Presentation Mode when the bookables load  When dispatching the NEXT_BOOKABLE action, the component code will now include a payload  to specify whether to remain in presentation mode or not. To stay in Presentation Mode, set  the payload to true:   dispatch {    type: "NEXT_BOOKABLE",    payload: true  } ;   dispatch {    type: "NEXT_BOOKABLE",    payload: false  } ;   To exit Presentation Mode, set the payload to false:   While  the  bookables  are  still  loading,  the  BookablesList  component  shows  a  loading  indicator. There are no bookables to cycle through at this point, so isPresenting should be  false until the bookables appear.   Let’s  incorporate  the  new  reducer  into  the  BookablesList  component  before  we   implement the timer functionality for Presentation Mode.   Updating the BookablesList component to use the latest reducer   6.2.3  We have an updated reducer, ready to work with the isPresenting state value to represent  whether the component is in Presentation Mode or not. To get most of the component code  out  of  the  way  before  we  focus  on  the  timer  code,  let’s  create  a  BookablesList  version  that’s ready for the timers but that doesn’t include them yet. You can see the code relating  to the presentation state value in three places in listing 6.3.   Branch: 0601-presentation-reducer, File:  src components Bookables BookablesList.js   Listing 6.3 The BookablesList component using the new reducer, without timers  import React, {useReducer, useEffect, Fragment} from "react";  import {sessions, days} from ".. .. static.json";  import {FaArrowRight, FaSpinner} from "react-icons fa";  import reducer from ". reducer";  import getData from ".. .. utils api";    const initialState = {    group: "Rooms",    bookableIndex: 0,     bookables: [],    hasDetails: true,    isLoading: true,    error: false,    isPresenting: false                                                    A  };    Manning Publications Co.  To comment go to  liveBook   125     export default function BookablesList    {    const [state, dispatch] = useReducer reducer, initialState ;      const {group, bookableIndex, bookables} = state;    const {hasDetails, isLoading, error, isPresenting} = state;            B      const bookablesInGroup = bookables.filter b => b.group === group ;    const bookable = bookablesInGroup[bookableIndex];    const groups = [...new Set bookables.map b => b.group  ];      useEffect    => {  * load bookables *  }, [] ;      function changeGroup  event  {  * unchanged *  }    function changeBookable  selectedIndex  {  * unchanged *  }      function nextBookable    {      dispatch {        type: "NEXT_BOOKABLE",        payload: false                                                     C      } ;    }      function toggleDetails    {  * unchanged *  }         unchanged UI for error, loading and bookables  }   A Include an isPresenting property in the initial state  B Assign the isPresenting value to a local variable  C Include a payload to end Presentation Mode  Our  component’s  state  now  includes  an  isPresenting  value.  Because  the  bookables  still  have to be loaded when the component first runs, we need to set isPresenting to false in  the initial state we pass to the useReducer hook:   const initialState = {    group: "rooms",    bookableIndex: 0,     bookables: {},    hasDetails: true,    isLoading: true,    error: false,    isPresenting: false  };   To then use the isPresenting state value to flag whether to set up a timer for Presentation  Mode, we include it in our destructuring statements, assigning it to a variable of the same  name:   const {hasDetails, isLoading, error, isPresenting} = state;   The nextBookable function now includes a payload in the action it dispatches to the reducer.  function nextBookable    {    dispatch {      type: 'NEXT_BOOKABLE',    Manning Publications Co.  To comment go to  liveBook   126       payload: false    } ;  }   The Next button calls the nextBookable function. If the user clicks the Next button we want  to tell the reducer to end Presentation Mode, so the payload is false. We’re now ready to  use the isPresenting value when setting up the timer. Tick, tock, on to the last step…   Managing timers for Presentation Mode with the useRef hook   6.2.4  The  last  step  on  our  Presentation  Mode  journey  is  to  add  in  the  timer  code.  Listing  6.4  updates the BookablesList component code from listing 6.3, including two new functions to  create  and  clear  a  timer, scheduleNext  and clearNextTimeout.  The  added  code  performs  the following five tasks:      Using a ref to hold the timer id.     Checking if isPresenting is true or false.      If isPresenting  is true  and  there’s  no  timer, setting  up a  timer  to  select  the  next  bookable.  If isPresenting is false, clearing any existing timer.         When  switching  groups  and  isPresenting  is  true,  restarting  the  timer  so  that   Presentation Mode shows the first item in the new group for its full, allotted time.   In  the  listing,  we  assign  the  ref  the  useRef  hook  returns  to  the  timerRef  variable.  The  variable’s occurrences are highlighted in bold, along with the code that calls the timer-related  functions. There’s a discussion of the new code after the listing.   Branch: 0602-presentation-timer, File:  src components Bookables BookablesList.js   Listing 6.4 Using the new reducer with timers  import React, {useReducer, useEffect, useRef, Fragment} from "react";    A  import {sessions, days} from ".. .. static.json";  import {FaArrowRight, FaSpinner} from "react-icons fa";  import reducer from ". reducer";  import getData from ".. .. utils api";    const initialState = {  * unchanged *  };    export default function BookablesList    {           unchanged variable setup      const timerRef = useRef null ;                                         B      useEffect    => {  * load data *  }, [] ;      useEffect    => {                                                      C        if  isPresenting  {                                                  D        scheduleNext  ;                                                    D      } else {                                                             D        clearNextTimeout  ;                                                D      }                                                                    D    Manning Publications Co.  To comment go to  liveBook   127       } ;      function changeGroup  event  {      dispatch {        type: "SET_GROUP",        payload: event.target.value      } ;        if  isPresenting  {                                                  E        clearNextTimeout  ;                                                E        scheduleNext  ;                                                    E      }                                                                    E    }      function changeBookable  selectedIndex  {  * unchanged *  }    function nextBookable    {  * unchanged *  }    function toggleDetails    {  * unchanged *  }      function scheduleNext    {      if  timerRef.current === null  {        timerRef.current = setTimeout    => {                              F          timerRef.current = null;          dispatch {            type: "NEXT_BOOKABLE",            payload: true          } ;        }, 3000 ;      }    }      function clearNextTimeout    {      clearTimeout timerRef.current ;                                      G      timerRef.current = null;                                             H    }         unchanged UI for error, loading and bookables  }   A Import the useRef hook  B Assign a ref to the timeRef variable  C Run an effect after every render to manage Presentation Mode  D Set or clear the timer depending on if the component is in Presentation Mode  E Restart the timer if a user switches groups in Presentation Mode  F Assign the timer id to the ref’s timerRef.current property  G Clear the timer for the id held in the ref  H Set the value held in the ref to null  The code uses the ref and the new functions to perform the five tasks listed at the start of  this subsection. Let’s look at each task in more detail.   USING A REF TO HOLD THE CURRENT TIMER ID  When we set up a timer, the browser’s setTimeout method returns us an id. We can use the  id  to clear  the  timer  if  necessary   if  the  user  selects  a  bookable,  clicks  the  Next  button  or  switches groups . We need to store the id but there’s no need to re-render the component    Manning Publications Co.  To comment go to  liveBook   128   whenever we update the id value in state, so we don’t want to use the useState hook. We  use the useRef hook instead, so we need to import it.   import React, {useReducer, useEffect, useRef, Fragment} from "react";   We call useRef, passing it null as the initial value because there’s no timer yet. Every time  the component runs, useRef returns us the same ref object, which we assign to the timerRef  variable.   const timerRef = useRef null ;   We use the ref to store our timer id by assigning the id to the ref’s current property.  timerRef.current = setTimeout  * wibbly-wobbly, timey-wimey stuff * , 3000 ;   When we don’t need the id anymore, we set the property back to null.  timerRef.current = null;   Ok, we have our ref. We now need to know whether we should be setting or clearing timers;  are we in Presentation Mode?   CHECKING IF ISPRESENTING IS TRUE OR FALSE  If we’re in Presentation Mode then isPresenting will be true. If that’s the case and there’s  no  timer  already  running,  we  need  to  set  up  a  new  timer  to  schedule  selecting  the  next  bookable.  If  we’re  no  longer  in  Presentation  Mode  then  we  should  make  sure  any  existing  timer  is  cleared  and  our  ref’s  set  back  to  null.  We  offload  the  nitty-gritty  to  functions  to  make the code read nicely.   Our job is usually to fixate on the state and let React worry about updating the DOM. When  we directly interact with the browser in some way - setting the document title, initiating data  fetching, or creating timers, for example - our actions are considered to be component side  effects.  As  we  saw  in  chapter  5,  it’s recommended  to  put  such  actions  inside  a call  to  the  useEffect hook, so that’s what we do.   if  isPresenting  {    scheduleNext  ;  } else {    clearNextTimeout  ;  }   useEffect    => {    if  isPresenting  {      scheduleNext  ;    } else {      clearNextTimeout  ;    }  } ;   The call to useEffect doesn’t include a dependency list as its second argument, so the effect  code will run after every render. Depending on whether we’re in Presentation Mode or not,    Manning Publications Co.  To comment go to  liveBook   129   we call functions to manage the timer. Let’s look at the scheduleNext function and set up  our first timer.   SETTING UP A TIMER  If the component’s in Presentation Mode when it runs, it calls the scheduleNext function to  set up a timer. But, if there’s already a timer set up, there’s no need to create a new one.   function scheduleNext    {    if  timerRef.current === null  {                            A      timerRef.current = setTimeout    => {                     B        timerRef.current = null;        dispatch {          type: "NEXT_BOOKABLE",                                C          payload: true                                         C        } ;      }, 3000 ;    }  }   A Check if a timer is already running  B If there’s no timer, set one up and assign the id to timerRef.current  C When the timer fires, move to the next bookable, staying in Presentation Mode  When  the  timer  fires  after  three  seconds,  the  scheduled  function  sets  the  ref’s  current  property  back  to  null  -  the  timer  has  done  its  job  -  and  dispatches  the  NEXT_BOOKABLE  action with a payload of true. The component’s reducer receives the action, selects the next  bookable  and  keeps  the  component  in  Presentation  Mode,  and  React  triggers  a  re-render.  The component code runs again, calling scheduleNext and setting up the next timer.  CLEARING ANY TIMER  If  a  user  directly  selects  a  bookable  or  clicks  the  Next  button,  the  component  should  exit  Presentation  Mode.  If  a  user  switches  groups  while  in  Presentation  Mode,  the  component  needs to clear any existing timer and start a new one for the newly selected bookable. Either  way,  the  component  needs  to  clear  the  current  timer.  The  clearNextTimeout  function  performs that duty.   function clearNextTimeout    {    clearTimeout timerRef.current ;    timerRef.current = null;  }   The function calls the browser’s clearTimeout function, passing it the timer id stored in the  ref.  It  then  sets  the  ref’s  current  property  back  to  null.  The  component  calls  the  clearNextTimeout  function  whenever  it  runs  and isPresenting  is false.  We  could  check  that timerRef.current is not null before running the clearNextTimeout function body, but  I don’t think there’s any harm in not checking either.   Our  last  task  is  to  avoid “taking  users  out of  the  movie” when  they switch  groups.  We   need to restart the timer.    Manning Publications Co.  To comment go to  liveBook   130   RESTARTING THE TIMER WHEN SWITCHING GROUPS  It’s  quite  possible  that  a  timer  is  already  running  when  the  user  switches  groups.  Maybe  there’s only half a second left before the timer fires, dispatching the NEXT_BOOKABLE action.  The component will show the bookables for the new group, with the first bookable selected  and  then,  when  the  timer  fires  sooner  than  expected,  the  selection  will  jump  to  the  next  bookable.   If the component is in Presentation Mode and a user switches groups, we need to restart   the timer to stop any perceived jumpiness in the interface.   function changeGroup  e  {    dispatch {      type: "SET_GROUP",      payload: e.target.value    } ;      if  isPresenting  {      clearNextTimeout  ;                  A      scheduleNext  ;                      B    }  }   A Clear the currently running timer  B Start a new timer  The changeGroup  function  checks  for  Presentation  Mode  and  then,  if  necessary,  clears  the  previous timer before starting a new one.   CHALLENGE 6.1  Create a Presentation Mode for the UsersList component. Make it exit Presentation Mode as  soon  as  a  visitor  selects  a  user  from  the  list.  Solution  code  is  on  the  0603-users-timer  branch.  Note: the UsersList component doesn’t have groups or a Next button or a Show  Details checkbox; only selecting a user will stop Presentation Mode.    This  section  looked  in  detail  at  using  a  ref  to  store  state  so  that  updating  the  state  doesn’t  cause  the  component  to re-render.  There’s  no  need  to  re-run  the  component  code  when  setting  and  clearing  the  timer  id,  so  using  a  ref  to store  its value makes sense.  The  next section looks at a very common use case for refs, keeping references to DOM elements.   6.3  Keeping references to DOM elements  If you’re an old hand at working with refs, you may have been surprised at the use we put  them to in section 6.2, updating state without re-rendering. If that’s the case, you’re back in  your element in this section, where we call on the useRef hook to help us store references to  buttons and form fields. Such references to DOM elements let us interact with the elements  directly,  bypassing  the  usual React state-to-UI  flow.  In  particular,  we  look  at  two common  use cases:      Setting focus on an element in response to an event.     Reading the value of an uncontrolled text box.    Manning Publications Co.  To comment go to  liveBook   131   We  see  how  to  get  React  to  automatically  assign  DOM  element  references  to  our  refs’  current  properties  so  we  can  manipulate  or  read  from  those  elements  directly.  Both  examples use components from the bookings app. In section 6.3.2 we add a text box to the  WeekPicker  component.  But  first,  we  focus  on  the  BookablesList  component,  making  it  easier for users to move from one bookable to the next using the keyboard.   Setting focus on an element in response to an event   6.3.1  Your boss is back with a new suggestion for the bookings app. Wouldn’t it be great if when a  user  chooses  a  bookable,  the  focus  automatically  shifts  to  the  Next button?  Then  the user  could  just  hit  the  space  bar  to  move  from  bookable  to  bookable!  Figure  6.6  shows  the  situation.      Figure 6.6 When a user selects a bookable, the focus is automatically set on the Next button.   We  could  add  an  extra  piece  of  state,  maybe  nextHasFocus,  and  re-render  whenever  it  changes to give the Next button focus. But the browser has a focus method, so if we just  had a reference to the button element we could call focus and the job would be done.  const nextButtonEl = document.getElementById "nextButton" ;    nextButtonEl.focus  ;   But,  having  chosen  to  use  React,  we  prefer  to  stay  within  its  state-to-UI  flow  as  much  as  possible.  The  timing  of  directly  reaching  out  to  the  DOM  with  getElementById  could  get  tricky  as  React  updates  the  DOM  in  response  to  state  changes.  Also,  it’s  common  for  the  same  component  to  be  used multiple  times  in  an  app,  so using  multiple  instances of  what  should  be  unique  id  attributes  to  identify  component  elements  ends  up  causing  problems  rather than solving them. Fortunately, React provides a way of automatically assigning DOM  element references to refs created with the useRef hook.    Manning Publications Co.  To comment go to  liveBook   132   Listing 6.5 shows the BookablesList component code with three additions to enable our   desired Next button focus behavior. We:   1.  Create a new ref, nextButtonRef, to hold a reference to the Next button element.  2.  Use the special ref attribute in the JSX to ask React to automatically assign a   reference to the button element to nextButtonRef.current.   3.  Use our reference, nextButtonRef.current, to set the focus on the Next button.   Branch: 0604-set-focus, File:  src components Bookables BookablesList.js   Listing 6.5 Using a ref to set focus  import React, {useReducer, useEffect, useRef, Fragment} from 'react';  import {sessions, days} from ".. .. static.json";  import {FaArrowRight, FaSpinner} from "react-icons fa";  import reducer from ". reducer";  import getData from ".. .. utils api";    const initialState = {  * unchanged *  };    export default function BookablesList    {       unchanged variable setup      const timerRef = useRef null ;    const nextButtonRef = useRef  ;                                      A      useEffect    => {  * load data *  }, [] ;    useEffect    => {  * manage timer *  } ;      function changeGroup  event  { *  unchanged *  }      function changeBookable  selectedIndex  {      dispatch {        type: "SET_BOOKABLE",        payload: selectedIndex      } ;      nextButtonRef.current.focus  ;                                     B    }      function nextBookable    {  * unchanged *  }    function toggleDetails    {  * unchanged * }      function scheduleNext    {  * unchanged *  }    function clearNextTimeout    {  * unchanged *  }      if  error  {      return  {error.message}     }      if  isLoading  {      return           {" "}        Loading bookables...           }      return      Manning Publications Co.  To comment go to  liveBook   133                                        {groups.map g =>  {g}  }                                    {  * unchanged *  }                                  <button              className="btn"              onClick={nextBookable}              ref={nextButtonRef}                                    C              autoFocus            >                              Next                                            {bookable &&                         {  * unchanged *  }                    }            ;  }   A Call useRef and assign the ref to the nextButtonRef variable  B Use the ref to focus the Next button  C Assign nextButtonRef to the ref attribute in JSX  In  listing  6.5,  we  call  the  useRef  hook  and  assign  the  ref  it  returns  to  the nextButtonRef  variable:   const nextButtonRef = useRef  ;   We don’t assign an initial value; we are going to get React to automatically assign a value to  the nextButtonRef.current property for us. We need to focus the Next button, so, rather  than reaching out into the DOM ourselves, we assign our ref to the special ref attribute of  the button in the JSX for the user interface:   <button    className="btn"    onClick={nextBookable}    ref={nextButtonRef}    autoFocus  >          Next        Manning Publications Co.  To comment go to  liveBook   134   Once  React  has  created  the  button  element  for  the  DOM,  it  assigns  a  reference  to  the  element  to  the  nextButtonRef.current  property.  We  use  that  reference  in  the  changeBookable function to focus the button by calling the element’s focus method:  function changeBookable  selectedIndex  {    dispatch {      type: "SET_BOOKABLE",      payload: selectedIndex    } ;    nextButtonRef.current.focus  ;  }   The  component  calls  the  changeBookable  function  whenever  a  user  directly  selects  a  bookable in the list of bookables. So, directly selecting a bookable will shift focus to the Next  button. That’s exactly what the boss wanted! Good job.   This example shows how you can create a ref using the useRef hook and then ask React  to  assign  a reference  for  a  DOM  element  to  that  ref.  I’ll  admit  it’s  a  little  contrived,  but  it  does  show  the  steps  involved.  Do  be  careful  when  programmatically  setting  the  focus  of  elements  on  the  page;  be  sure  it  doesn’t  confound  users’  expectations,  making  your  app  harder to use. It’s a valid technique but may require careful user testing.   Managing a text box via a ref   6.3.2  In chapter 4, we introduced the WeekPicker component as a way to navigate from week to  week in the bookings app. The user could click on Prev and Next buttons to switch weeks or  click  the  Today  button  to  display  the  week  containing  the  current  day’s  date.  Chapter  4’s  version of WeekPicker is in figure 6.7.   Figure 6.7 The WeekPicker component from chapter 4 with buttons for switching weeks and jumping to the  week containing today’s date.   But,  if  someone working  at  the  company  wants  to  book  a  meeting  room  for  an event  in  a  couple  of  months,  they  have  to  click  the Next  button  again  and  again  until  they reach  the  date they want. It would be better if they could enter a specific date and jump straight to  that week. Figure 6.8 shows an improved WeekPicker UI with a text box and a Go button.       Manning Publications Co.  To comment go to  liveBook   135   Figure 6.8 The WeekPicker component with a text box and a Go button, for direct date entry.   The  reducer  for  the WeekPicker  component  already  has  a  SET_DATE  action;  let’s  put  it  to  use.  Listing  6.6  highlights  the  SET_DATE  action  that  sets  the  state  to  a  week  object  containing the date in the payload.   Branch: 0605-text-box, File:  src components Bookings weekReducer.js      Listing 6.6 Setting a date in the WeekPicker reducer  import { getWeek } from ".. .. utils date-wrangler";    export default function reducer  state, action  {    switch  action.type  {      case "NEXT_WEEK":        return getWeek state.date, 7 ;      case "PREV_WEEK":        return getWeek state.date, -7 ;      case "TODAY":        return getWeek new Date   ;      case "SET_DATE":                                                   A        return getWeek new Date action.payload  ;                        B      default:        throw new Error `Unknown action type: ${action.type}`     }  }   A Include a case for setting specific dates  B Return a week object containing the date specified in the payload  With the reducer ready to go, we can update the WeekPicker component itself, as shown in  listing 6.7, where we add a text box and Go button to the UI, a ref for the text box and a  goToDate handler function for the Go button.   Branch: 0605-text-box, File:  src components Bookings WeekPicker.js   Listing 6.7 The WeekPicker with a text box and Go button  import React, {useReducer, useRef} from "react";  import reducer from ". weekReducer";  import {getWeek} from ".. .. utils date-wrangler";  import {    FaChevronLeft,    FaCalendarDay,    FaChevronRight,    FaCalendarCheck  } from "react-icons fa";      Manning Publications Co.  To comment go to  liveBook   136   export default function WeekPicker  {date}  {    const [week, dispatch] = useReducer reducer, date, getWeek ;    const textboxRef = useRef  ;                                          A      function goToDate    {                                                B      dispatch {                                                          C        type: "SET_DATE",                                                 C        payload: textboxRef.current.value                                 D      } ;    }      return                               Prev button             Today button                         <input              type="text"              ref={textboxRef}                                              E              placeholder="e.g. 2020-09-02"             >                                 F                              Go                                        Next button                            {week.start.toDateString  } - {week.end.toDateString  }                     ;  }   A Create a ref to hold the reference to the text box  B Define a handler for the Go button  C Dispatch the SET_DATE action  D Use the ref to get the text value in the text box  E Add a text box with a ref attribute to the UI  F Add the Go button to the UI  After it renders the component and updates the DOM, React assigns a reference to the input  element,  our  text  box,  to  the  textboxRef  variable’s  current  property.  The  goToDate  function uses that reference to grab the text from the text box when the user clicks the Go  button.   function goToDate    {    dispatch {      type: "SET_DATE",      payload: textboxRef.current.value    } ;  }    Manning Publications Co.  To comment go to  liveBook   137   So,  textboxRef.current  holds  a  reference  to  the  input  element,  the  text  box,  and  then  textboxRef.current.value is the text in the text box.  UNCONTROLLED COMPONENTS  The text in the WeekPicker text box is part of our component’s state. In this example, our  component  is  not  managing  the  text  box  state.  Our  component  is  not  interested while  the  user types characters into the text box, although the browser does show the new characters  as the user types. Only when the user clicks the Go button do we read the text state from  the DOM, via our ref, and dispatch it to the reducer. Components that let the DOM manage  their state in this way are called uncontrolled components.   While  the  WeekPicker  example  demonstrates  how  to  use  a  ref  with  a  form  field,  the  approach  doesn’t  really  fit  with  the  philosophy  of  managing  state  with  useState  and  useReducer  and  then  displaying  that  state  in  the  UI.  React  recommends  using  controlled  components that make the most of React’s help managing the state.   CONTROLLED COMPONENTS  To convert the WeekPicker component to be fully controlled, we could take back the text box  state from the DOM, using a call to the useState hook instead:   const [dateText, setDateText] = useState "" ;   We  could  then set  the dateText  state  as  the value  property  for  the  text  box  and  use  the  accompanying updater function, setDateText, to change the state whenever the user types  in the text box:   return             <input        type="text"        value={dateText}                                               A        onChange={ e  => setDateText e.target.value }                  B       >         Go         ;   A Use the dateText state as the value for the text box  B Update the dateText state whenever the user types in the text box  Finally, in the goToDate function, we would no longer need the reference to the text box and  could simply dispatch the dateText value to the reducer.  function goToDate    {    dispatch {      type: "SET_DATE",      payload: dateText    } ;  }   With controlled components, the data flow is from the component to the DOM, in line with  the standard React approach.    Manning Publications Co.  To comment go to  liveBook   138   In  this  chapter,  we’ve  seen  how  refs can be  used  to manage  state,  updating  it  without  causing re-renders, and how the JSX ref attribute asks React to automatically assign a DOM  element reference to a previously created ref, allowing us to work with the element directly.  The  most  involved  example was for  Presentation Mode  where  we  stored  timer  ids  in  a  ref.  Before the chapter’s summary, the next section reviews some of the key concepts of using  the useRef hook with function components.   6.4  Reviewing some useRef concepts  Figure 6.9 shows some of the key steps involved when the bookables have loaded and the  BookablesList  component  switches  to  Presentation Mode.  The  component  uses  a  timer  to  repeatedly move the highlight from one bookable to the next. Table 6.2 discusses the steps  one by one.    Manning Publications Co.  To comment go to  liveBook   139      Figure 6.9 In Presentation Mode, the component sets up a timer. When the timer fires, it updates the index of  the bookable to be shown. That change in state causes the component code to be invoked again, repeating  the cycle.   Table 6.2 lists each step and provides a short discussion of what is happening at that point.      1   Step   What happens?   Discussion   React calls the component.   To generate the UI for the page, React traverses the tree of  components, calling each one. React will pass each    Manning Publications Co.  To comment go to  liveBook   140   The component sets up a  timer.   The component returns its UI.   The timer fires.   React passes the action to  the reducer, updating the  state.  React calls the component.   The component sets up a  timer.   The component returns its UI.   The timer fires.   component any props set as attributes in the JSX.   In Presentation Mode, the selected bookable index will be  automatically incremented after a set delay. The function to  increment the index is set to run using a timer.   The component uses the current index value to generate its  user interface and returns it, finishing its work. React  updates the DOM as required.   The timer will call the function it was given, dispatching an  action to increment the index.   React passes the action to the reducer, updating the state.  Because the state has changed, React needs to recalculate  the UI, so…  There is a new bookable index value, so React calls the  component again to get the UI corresponding to that index.   We need a new timer to increment the index. But that code  is already present in the component. Just running the  component again will set up a new timer.  The component uses the current index value to generate its  user interface and returns it, finishing its work. React  compares the new UI with the old and updates the DOM as  required.  The timer will call the function it was given, dispatching an  action to increment the index.   2   3   4   5   6   7   8   9   10   React passes the action to  the reducer, updating the  state.   React passes the action to the reducer, updating the state.  Because the state has changed, React needs to recalculate  the UI, so…   6.5  Summary      Call  the  useRef  hook when  you want React  to  manage  a state  value but  don’t want  changes  to  the  value  to  trigger  a  re-render.  For  example,  use  it  for  storing  ids  for  setTimeout and setInterval or for references to DOM elements. You can pass it an  initial value if required. It returns an object with a current property set to the initial  value.   const ref = useRef  initialValue  ;  ref.current;    initialValue      A call to useRef will return the same ref object each time the component runs. Persist   values in the ref across renders by assigning them to the ref’s current property.    Manning Publications Co.  To comment go to  liveBook   141   ref.current = valueToStore;      React  can  automatically  assign  DOM  element  references  to  your  ref’s  current   property. Assign your ref variable to an element’s ref attribute in JSX.   const myRef = useRef  ;                              A    ...    return       Click Me!            B   ;    ...    myRef.current;                                       C   A Create a ref  B Specify the ref in the JSX ref attribute  C The current property will now reference the button element      Use the ref to interact with the DOM element. For example, set focus on the element.   myRef.current.focus  ;      Components that read their state from the DOM are called uncontrolled components.   You can use refs to access and update the state.      React  recommends  you  use  controlled  components.  Use  the  useState  hook  or  the  useReducer  hook  to  manage  the  state  and  get  React  to  update  the  DOM  with  the  latest  state  values.  Your  component  will  be  the  one  source  of  truth  rather  than  splitting state between the component and the DOM.    Manning Publications Co.  To comment go to  liveBook   142       Managing application state   This chapter covers   lifting state up the component tree to make it more widely available      passing shared state to those components that need it     coping when state isn’t passed down - the props are missing        passing dispatch and updater functions to child components     calling dispatch and updater functions to update parent state     considering dispatch and updater functions as dependencies of effects   Up to this point, we’ve seen how components can manage their own state with the useState,  useReducer  and  useRef  hooks  and  load  state  data  with  the  useEffect  hook.  It’s  common,  however, for components to work together, using shared state values to generate their UI.  Each  component  may  have  a  whole  hierarchy  of  descendant  components  nested  within  it,  chirping and chirruping to be fed data, so state values may need to reach deep down into the  descendant depths. In this chapter we investigate concepts and methods for deciding how to  manage the availability of state values for child components that need to consume them, by  lifting  state  to common  parents.  In  chapter  9 we’ll see  how  and  when React’s  Context  API  can be used to make values available directly to components that need them. Here, we stick  to using props to pass state down to children.   We start, in section 7.1, with a new Colors component that shares a selected color with  three  child  components.  We  see  how  to  update  the  shared  state,  managed  by  the  parent,  from  a  child.  The  rest  of  the  chapter  uses  the  bookings  app  example  to  explore  two  approaches to sharing state: passing a state object and a dispatch function for a reducer to  the children and passing a single state value and its updater function to the children. Both  approaches  are  common patterns  and  help  to  highlight  some  common questions regarding  state, props, effects and dependencies.    Manning Publications Co.  To comment go to  liveBook   143   7.1  Passing shared state to child components  When  different  components  use  the  same  data  to  build  their  UI,  the  most  explicit  way  to  share that data is to pass it as a prop from parent to children. In this section we introduce  passing  props   in  particular  passing  the  state  value  and  updater  function  returned  by  useState   by  looking  at  a  new  example,  a  Colors  component,  shown  in  figure  7.1.  The  component includes three UI sections:      a list of colors with the selected color highlighted        a bar with a background set to the selected color   text showing the selected color   Clicking a color in the list  one of the circles  highlights that selection and updates the text  and  in  action  on  codesandbox   https:  hgt0x.csb.app  .   the  color  bar.  You  can  see   the  component      Figure 7.1 The Colors component. When a user selects a color, the menu, text and color bar all update.    It’s a simple example but illustrates the basic concepts nicely. Also, we return to the Colors  component in chapter 9 when we use the Context API and the useContext hook to share the  selected color and the color-selection updater function.   Passing state from a parent by setting props on the children   7.1.1  Listing  7.1  shows  the  code  for  the Colors  component.  It  imports  three  child  components:  ColorPicker,  ColorChoiceText  and ColorSample.  Each  child  needs  the  selected  color,  so    Manning Publications Co.  To comment go to  liveBook   144   the Colors component holds that state and passes it to them as a prop, an attribute in the  JSX.  It  also  passes  the  available  colors  and  the  setColor  updater  function  to  the  ColorPicker component.   Live: https:  hgt0x.csb.app , Code: https:  codesandbox.io s colorpicker-hgt0x   Listing 7.1 The Colors component  import React, {useState} from "react";    import ColorPicker from ". ColorPicker";                                A  import ColorChoiceText from ". ColorChoiceText";                        A  import ColorSample from ". ColorSample";                                A    export default function Colors    {    const availableColors = ["skyblue", "goldenrod", "teal", "coral"];    B      const [color, setColor] = useState availableColors[0] ;               B      return                 <ColorPicker          colors={availableColors}                                        C          color={color}                                                   C          setColor={setColor}                                             C         >                                          C                                              C            ;  }   A Import the child components  B Define state values  C Pass the appropriate state values to the child components as props  The  Colors  component  passes  down  two  types  of  props:  state  values  to  be  used  in  the  children’s UI, colors and color, and a function to update the shared state, setColor. Let’s  look at state values first.   Receiving state from a parent as a prop   7.1.2  Both  the  ColorChoiceText  component  and  the  ColorSample  component  display  the  currently selected color. ColorChoiceText includes it in its message and ColorSample uses  it to set the background color. They receive the color value from the Colors component, as  shown in figure 7.2.    Manning Publications Co.  To comment go to  liveBook   145         Figure 7.2 The Colors component passes the current color state value to the child components.   Colors  is  the  closest  shared  parent  of  the  child  components  that  share  the  state,  so  we  manage  the  state  within  Colors.  Figure  7.3  shows  the  ColorChoiceText  component  displaying a message that includes the selected color. The component simply uses the color  value as part of its UI; it doesn’t need to update the value.   Figure 7.3 The ColorChoiceText component includes the selected color in its message.   The ColorChoiceText component’s code is in listing 7.2. When React calls the component, it  passes it, as the component’s first argument, an object containing all of the props set by the  parent. The code here destructures the props, assigning the color prop to a local variable of  the same name.   Live: https:  hgt0x.csb.app , Code: https:  codesandbox.io s colorpicker-hgt0x   Listing 7.2 The ColorChoiceText component  import React from "react";    export default function ChoiceText { color }  {                     A    return color ?                                                    B       The selected color is {color}!                            C      :         No color has been selected!                               D       }   A Receive the color state from the parent as a prop  B Check that there is a color  C Use the prop in the UI  D Return alternate UI if the parent doesn’t set a color    Manning Publications Co.  To comment go to  liveBook   146   What if the parent doesn’t set a color prop? The ColorChoiceText component is happy for  there to be no color prop, it returns alternate UI saying no color was selected.   The ColorSample component, shown in figure 7.4, displays a bar with its background set   to the selected color.   Figure 7.4 The ColorSample component displays a bar of the selected color.      ColorSample takes a different approach to a missing prop. It returns no UI at all! In listing  7.3 you can see the component checking for the color value. If it’s missing, the component  returns null and React renders nothing at that point in the element tree.   Live: https:  hgt0x.csb.app , Code: https:  codesandbox.io s colorpicker-hgt0x   Listing 7.3 The ColorSample component  import React from "react";    export default function ColorSample { color }  {                       A    return color ?                                                       B      <div        className="colorSample"        style={{ background: color }}       >      : null;                                                            C  }   A Receive the state from the parent as a prop  B Check that there is a color  C Don’t render any UI if there’s no color  You  could  set  a  default  value  for  color  as  part  of  the  props  destructuring.  Maybe  if  the  parent doesn’t specify a color then it should be white?   function ColorSample { color = "white" }  {                            A    return        <div        className="colorSample"        style={{ background: color }}       >     ;  }   A Specify a default value for the prop  A  default  value  will  work  for  some  components,  but  for  our  color-based  components  that  need to share state, we’d have to make sure all of the defaults were the same. So, we either  have alternate UI or no UI. If the component just won’t work without a prop and a default  doesn’t make sense, you can throw an error explaining that the prop is missing.    Manning Publications Co.  To comment go to  liveBook   147   Although  we  won’t  explore  them  in  this  book,  you  can  also  use  PropTypes  to  specify  expected  props  and  their  types.  React  will  use  the  PropTypes  to   warn of  problems  during   https:  reactjs.org docs typechecking-with-proptypes.html .  Alternatively,  development.  use  TypeScript  type-check  your  whole  application.   https:  www.typescriptlang.org    than  JavaScript  and   rather   Receiving an updater function from a parent as a prop   7.1.3  The  ColorPicker  component  uses  two  state  values  to  generate  its  UI:  a  list  of  available  colors and the selected color. It displays the available color values as list items and the app  uses CSS to style them as a row of colored circles, as you can see in figure 7.5. The selected  item, “goldenrod” in the figure, is styled larger than the others.      Figure 7.5 The ColorPicker component displays a list of colors and highlights the selected color.   The  Colors  component  passes  the  ColorPicker  component  the  two  state  values  it  uses.  Colors also needs to provide some way to update the selected color for all three children. It  delegates  that  responsibility  to  the  ColorPicker  component  by  passing  it  the  setColor  updater function, as illustrated in figure 7.6.   Figure 7.6 The Colors component passes two state values to ColorPicker. It also passes the setColor updater  function, so the color state value can be set from the child.       Manning Publications Co.  To comment go to  liveBook   148   Listing  7.4  shows  the ColorPicker  component destructuring  its  props  argument,  assigning  the three props to local variables: colors, color and setColor.   Live: https:  hgt0x.csb.app , Code: https:  codesandbox.io s colorpicker-hgt0x   Listing 7.4 The ColorPicker component  import React from "react";    export default function ColorPicker {colors = [], color, setColor}  {    A    return                 {colors.map c =>            <li            key={c}            className={color === c ? "selected" : null}            style={{ background: c }}            onClick={   => setColor c }                                    B          >            {c}                     }            ;  }   A Receive the state and updater function from the parent as props  B Use the updater function to set the parent’s state  The destructuring syntax includes a default value for colors:  {colors = [], color, setColor}   The ColorPicker  component  iterates  over  the  colors  array  to  create  a  list  item  for  each  available color. Using an empty array as a default value causes the component to return an  empty unordered list if the parent component doesn’t set the colors prop.   More  interesting   for  a  book  about  React  hooks   are  the  color  and  setColor  props.   These props have come from a call to useState in the parent.  const [color, setColor] = useState availableColors[0] ;   The ColorPicker doesn’t care where they’ve come from, it just expects a color prop to hold  the current color and a setColor prop to be a function it can call to set the color somewhere.  ColorPicker uses the setColor updater function in the onClick handler for each list item.  By calling the setColor function, the child component, ColorPicker, is able to set the state  for  the parent component, Colors.  The  parent  then  re-renders,  updating  all  of  its children  with the newly selected color.   We created the Colors component from scratch, knowing we needed shared state to pass  down to child components. Sometimes we work with existing components and, as a project  develops, realize they hold state that other siblings may also need. The next sections look at  a couple of ways of lifting state up from children to parents to make it more widely available.    Manning Publications Co.  To comment go to  liveBook   149   7.2  Breaking components into smaller pieces  React  gives  us  the  useState  and  useReducer  hooks  as  two  ways  of  managing  state  in  our  apps.  Each  hook  provides  a means  to  update  the  state,  triggering  a  re-render.  As our  app  develops,  we  balance  the  convenience  of  being  able  to  access  local  state  directly  from  a  single  component’s  effects,  handler  functions  and  UI  against  the  inconvenience  of  that  component’s state becoming bloated and tangled, with state changes from one part of the UI  triggering re-renders of the whole component. New components in the app may want a piece  of  the  existing  state  pie,  so  we  now  need  to  share  state  that,  previously,  one  component  encapsulated.  Do  we  lift  state  values  and  updater  functions  up  to  parents?  Or  maybe  lift  reducers and dispatch functions? How does moving state around change the structure of the  existing components? In this section, we continue building out the bookings app example as  a context for these questions. In particular we explore:      Seeing components as part of a bigger app.     Organizing multiple components within a page’s UI.     Creating a BookableDetails component.   The concepts encountered are nothing new for existing React developers. Our aim here is to  consider if and how they change when using React hooks.   Seeing components as part of a bigger app   7.2.1  In chapter 6, we left the BookablesList component doing double duty: displaying a list of  bookables for the selected group and displaying details for the selected bookable. Figure 7.7  shows the component with the list and details visible.   Figure 7.7 The previous BookablesList component, from Chapter 6, showed the list of bookables and the  details of the selected bookable   The component managed all of the state: the bookables, the selected group and the selected  bookable, and flags for displaying details, Presentation Mode, loading state and errors. As a  single function component with no child components, all of the state was in local scope and    Manning Publications Co.  To comment go to  liveBook      150   available to use when generating the returned UI. But, toggling the Show Details checkbox  would  cause  a  re-render  of  the  whole  component  and  we  had  to  think  carefully  about  persisting timer ids across renders when in Presentation Mode.   We also need a list of bookables on the bookings page. There’ll be various components  vying  for  screen  real  estate  and  we  want  the  flexibility  to  be  able  to  display  the  list  of  bookables  separately  from  the  bookable  details,  as  shown  in  figure  7.8  where  the  list  of  bookables  is  on  the  left.  In  fact,  we  might  not  want  to  display  the  bookable  details  at  all,  saving that information for the dedicated bookables page.       Figure 7.8 The list of bookables  on the left  is also used on the bookings page.   To be able to use the list and details sections of the BookableList UI independently, we’ll  create  a  separate  component  for  the  details  of  the  selected  bookable.  The BookablesList  component will continue to display the groups, list of bookables and Next button but the new  BookableDetails component will display the details and manage the Show Details checkbox.  The  BookablesPage  component  currently  imports  and  renders  the  BookablesList  component. We need to do a bit of re-jigging to use the new version of the list along with the  BookableDetails component.   Organizing multiple components within a page’s UI   7.2.2  Both the BookablesList and the BookableDetails components need access to the selected  bookable. We create a BookablesView component to wrap the list and details and to manage  the  shared  state.  Table  7.1  lists  our  proliferating  bookables  components  and  outlines  how  they work together.    Manning Publications Co.  To comment go to  liveBook   151   Component   Purpose   BookablesPage   BookablesView   BookablesList   BookableDetails   Shows the BookablesView component  and later a form for adding and  editing bookables .  Groups the BookablesList and BookableDetails components and  manages their shared state.  Shows a list of bookables by group and lets the user select a bookable, either by  clicking or using the Next button. Has a Presentation Mode for automatically  cycling through the list.  Shows the details of the selected bookable with a checkbox to toggle the display  of the bookable’s availability.   In  sections  7.3  and  7.4,  we  look  at  two  approaches  to  lifting  the  state  up  to  the  BookablesView component:      Lifting the existing reducer from BookablesList to the BookablesView component.     Lifting the selected bookable from BookablesList to the BookablesView component.  First,  as  shown  in  listing  7.5,  we  update  the  page  component  to  import  and  show  BookablesView rather than BookablesList.   Branch: 0701-lift-reducer, File: src components Bookables BookablesPage.js   Listing 7.5 The BookablesPage component  import React from "react";  import BookablesView from ". BookablesView";                          A    export default function BookablesPage   {    return                                                                  B            ;  }   A Import the new component  B Use the new component  On separate repo branches, we’ll create a different version of the BookablesView component  for each of the two state sharing approaches we take. The BookableDetails component will  be the same either way, so let’s build that first.   Creating a BookableDetails component   7.2.3  The new BookableDetails component performs exactly the same task as the second half of  the old BookablesList component UI: it displays the details of the selected bookable and a  checkbox for  toggling  part of  that  info. Figure 7.9  shows the BookableDetails  component  with the checkbox and bookable title, notes and availability.    Manning Publications Co.  To comment go to  liveBook   152   Figure 7.9 The BookableDetails component with checkbox, title, notes and availability.      As illustrated in figure 7.10, the BookablesView component passes in the selected bookable  so that BookableDetails has the information it needs to display.   Figure 7.10 BookablesView manages the shared state and passes the selected bookable to BookableDetails.   The  code  for  the  new  component  is  in  listing  7.6.  The  component  receives  the  selected  bookable as a prop but manages its own hasDetails state value.   Branch: 0701-lift-reducer, File: src components Bookables BookableDetails      Listing 7.6 The BookableDetails component  import React, {useState} from "react";   import {days, sessions} from ".. .. static.json";    export default function BookableDetails  { bookable }  {            A    Manning Publications Co.  To comment go to  liveBook   153     const [ hasDetails, setHasDetails ] = useState true ;             B      function toggleDetails    {      setHasDetails has => !has ;                                     C  }      return bookable ?                             {bookable.title}                                       <input                type="checkbox"                onChange={toggleDetails}                              D                checked={hasDetails}                                  E               >              Show Details                                            {bookable.notes}             {hasDetails &&                                                F                        Availability                                             {bookable.days                  .sort                    .map d =>  {days[d]}                  }                                              {bookable.sessions                  .map s =>  {sessions[s]}                  }                                                }             : null;  }   A Receive the current bookable via props  B Use local state to hold the hasDetails flag  C Use the updater function to toggle the hasDetails flag  D Toggle the hasDetails flag when the checkbox is clicked  E Use the hasDetails flag to set the checkbox  F Use the hadDetails flag to show or hide the availability section  No other components in BookablesView care about the hasDetails state value, so it makes  good sense to encapsulate it completely within BookableDetails. If a component is the sole  user of some state, putting that state within the component seems like an obvious approach.    Manning Publications Co.  To comment go to  liveBook   154   BookableDetails is a simple component that just displays the selected bookable. As long  as  it  receives  that  state  value,  it’s  happy.  Exactly  how  the  BookablesView  component  manages  that  state  is  more  of  an  open  question;  should  it  call  useState  or  useReducer  or  both? The next two sections explore two approaches. Section 7.4 makes quite a few changes  to do away with the reducer. First, section 7.3 takes an easier path and makes use of the  existing reducer in BookablesList, lifting it up into the BookablesView component.   7.3  Sharing the state and dispatch function from useReducer  We  already  have  a  reducer  that  manages  all  of  the  state  changes  for  the  BookablesList  component. The state the reducer manages includes the bookables data, the selected group  and  the  index  of  the  selected  bookable,  along  with  flags  for  loading  states,  errors  and  Presentation Mode. If we move the reducer up into the BookablesView component, we can  use  the  state  the  reducer  returns  to  derive  the  selected  bookable  and  pass  it  to  the  child  components, as illustrated in figure 7.11.      Figure 7.11 BookablesView manages the state with a reducer and passes the selected bookable to its  children.   While BookableDetails needs only the selected bookable, BookablesList needs the rest of  the  state  the  reducer  returns  and  a  way  to  continue  dispatching  actions  as  users  select  bookables and switch groups. Figure 7.11 also shows BookablesView passing the reducer’s  state and dispatch function to BookablesList.   Lifting the state up from BookablesList into the BookablesView component is relatively   straightforward. We complete it in three steps:      Managing state in the BookablesView component.     Removing an action from the reducer.     Receiving state and dispatch in the BookablesList component.   Let’s start by updating the BookablesView component to take control of the state.    Manning Publications Co.  To comment go to  liveBook   155   Managing state in the BookablesView component   7.3.1  The BookablesView component needs to import its two children. It can then pass them the  state they need and the means to update that state if required. In listing 7.7, you can see  the imports for the new components, the state that BookablesView is managing, the call to  the useReducer hook and the UI as JSX, with state values and the dispatch function set as  props.   Branch: 0701-lift-reducer, File: src components Bookables BookablesView   Listing 7.7 Moving the bookables state into the BookablesView component  import React, {useReducer, Fragment} from "react";    import BookablesList from ". BookablesList";                             A  import BookableDetails from ". BookableDetails";                         A    import reducer from ". reducer";                                         B    const initialState = {                                                   C    group: "Rooms",    bookableIndex: 0,    bookables: [],    isLoading: true,    error: false,    isPresenting: false  };    export default function BookablesView    {     const [state, dispatch] = useReducer reducer, initialState ;           D      const bookablesInGroup = state.bookables.filter                        E      b => b.group === state.group                                         E     ;                                                                     E    const bookable = bookablesInGroup[state.bookableIndex];                E      return                                   F                                      G            ;   }   A Import all the components that make up the UI  B Import the reducer that BookablesList was using  C Set up the initial state without hasDetails  D Manage the state and reducer within BookablesView  E Derive the selected bookable from state  F Pass state and dispatch to BookablesList  G Pass the selected bookable to BookableDetails  The BookablesView component imports the child components it needs and sets up the initial  state  that  used  to  live  in  the BookablesList  component.  We’ve  removed  the  hasDetails  property  from  the  state;  the  new  BookableDetails  component  manages  its  own  state  for  whether to show details or not.    Manning Publications Co.  To comment go to  liveBook   156   Removing an action from the reducer   7.3.2  With the BookableDetails component happily toggling its own details, the reducer no longer  needs  to  handle  an  action  for  toggling  a  shared  hasDetails  state  value,  so  the  following  case can be removed from reducer.js:  case "TOGGLE_HAS_DETAILS":    return {      ...state,      hasDetails: !state.hasDetails    };   Apart from that, the reducer can stay as it is. Nice!   Receiving state and dispatch in the BookablesList component   7.3.3  The  BookablesList  component  needs  a  few  tweaks.  Instead  of  relying  on  its  own  local  reducer  and  actions,  it’s  now  dependent  on  the  BookablesView  component   or  any  other  parent  component  that  renders  it .  The  code  for  BookablesList  is  relatively  long,  so  we  consider it section by section. The structure of the code looks like this:   import React, {useEffect, useRef} from 'react';  import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  { state, dispatch }  {            1. Variables          2. Effects          3. Handler functions          4. Timer helpers          5. UI    }   The  following  four  subsections  discuss  any  changes  that  are  necessary.  If  you  stitch  the  pieces together, you’ll have the complete component.   VARIABLES  Apart from the two new props, state and dispatch, there are no additions to the variables  in  the  BookablesList  component.  But,  with  the  reducer  lifted  up  to  the  BookablesView  component and the need to display the bookable details removed, there are some deletions.  Listing 7.8 shows what’s left.   Branch: 0701-lift-reducer, File: src components Bookables BookablesList   Listing 7.8 BookablesList: 1. Variables  import React, {useEffect, useRef} from 'react';  import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  { state, dispatch }  {            A    const {group, bookableIndex, bookables} = state;    Manning Publications Co.  To comment go to  liveBook   157     const {isLoading, error, isPresenting} = state;      const bookablesInGroup = bookables.filter b => b.group === group ;    const groups = [...new Set bookables.map b => b.group  ];      const timerRef = useRef null ;    const nextButtonRef = useRef  ;            2. Effects          3. Handler functions          4. Timer helpers          5. UI  }   A Assign the state and dispatch props to local variables  The  reducer  and  its  initial  state  are gone,  as  is  the hasDetails  flag. Finally,  we  no  longer  need to display the bookable details, so we removed the bookable variable.  EFFECTS  The  two  effects  are pretty  much  unchanged  apart from  one  small detail.  In  listing 7.9  you  can see that we have added the dispatch function to the first effect’s dependency array.   Branch: 0701-lift-reducer, File: src components Bookables BookablesList   Listing 7.9 BookablesList: 2. Effects  import React, {useEffect, useRef} from 'react';  import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  { state, dispatch }  {            A       1. Variables      useEffect    => {      dispatch {type: "FETCH_BOOKABLES_REQUEST"} ;        getData "http:  localhost:3001 bookables"         .then bookables => dispatch {          type: "FETCH_BOOKABLES_SUCCESS",          payload: bookables        }          .catch error => dispatch {          type: "FETCH_BOOKABLES_ERROR",          payload: error        }  ;    }, [dispatch] ;                                                        B      useEffect    => {      if  isPresenting  {        scheduleNext  ;      } else {        clearNextTimeout  ;      }    } ;            3. Handler functions          4. Timer helpers    Manning Publications Co.  To comment go to  liveBook   158           5. UI  }   A Assign the dispatch prop to a local variable  B Include dispatch in the dependency array for the effect  In  the  previous  version,  when  we  called  useReducer  from  within  the  BookablesList  component and assigned the dispatch function to the dispatch variable, React knew that the  identity of the dispatch function would never change, so it didn’t need to be declared as a  dependency for the first effect. Now that a parent component passes dispatch in as a prop,  BookablesList doesn’t know where it comes from so can’t be sure it won’t change. Leaving  dispatch out of the dependency array prompts a warning in the browser console like the one  in figure 7.12.      Figure 7.12 React warns us when dispatch is missing from the dependency array.   Including dispatch in the dependency array is good practice here; we know it won’t change   at least for now , so the effect won’t run unnecessarily.  Later in the book, we look at using  the useCallback hook to maintain a consistent identity for functions passed in as props.    HANDLER FUNCTIONS AND TIMER HELPERS  Now that the details for the selected bookable are shown by a different component, we can  remove the toggleDetails handler function. Everything else stays the same. Easy!  UI  Goodbye  bookableDetails  div!  We  completely  cut  out  the  second  section  of  the  UI,  for  displaying the bookable details. Listing 7.10 shows the updated, super-slim BookablesList  UI.   Branch: 0701-lift-reducer, File: src components Bookables BookablesList   Listing 7.10 BookablesList: 5. UI  import React, {useEffect, useRef} from 'react';  import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  { state, dispatch }  {       1. Variables          2. Effects               3. Handler functions          4. Timer helpers      if  error  {      return  {error.message}     Manning Publications Co.  To comment go to  liveBook   159     }      if  isLoading  {      return           {" "}        Loading bookables...           }      return                            {groups.map g =>  {g}  }                              {bookablesInGroup.map  b, i  =>              <li              key={b.title}              className={i === bookableIndex ? "selected" : null}            >              <button                className="btn"                onClick={   => changeBookable i }              >                {b.title}                                        }                            <button            className="btn"            onClick={nextBookable}            ref={nextButtonRef}            autoFocus          >                          Next                                 ;  }   All  that’s  left  in  the  UI  is  the  list  of  bookables  with  its  associated  group  picker  and  Next  buttons. So, we also remove the Fragment component that was grouping the two big chunks  of UI.   With  the  bookable  details  off  on  their  own  adventures  and  the  reducer  lifted  up  to  the  parent,  the  changes  to  the  BookablesList  component  mostly  took  the  form  of  deletions.  One key addition was the inclusion of dispatch in the dependency array for the data-loading  effect.  Housing  the  state  in  the  BookablesView  component   or  maybe  even  higher  up  the  component  tree   seems  easy.  Stick  all  the  data  there  and  pass  a  dispatch  function  to  any  descendant components that need to make changes to the state. It’s a valid approach, and  one used by popular state-store libraries like Redux. But before throwing all the state up to    Manning Publications Co.  To comment go to  liveBook   160   the top of the app, even if most components don’t care about most of the state that ends up  there, let’s investigate an alternative.   7.4  Sharing the state value and updater function from useState  In this section we try a different approach. We lift only the state that needs to be shared: the  selected  bookable.  Figure  7.13  shows  the  BookablesView  component  passing  the  selected  bookable  to  its  two  child  components.  The  BookableDetails  and  BookablesList  components still get exactly what they need, and rather than giving BookablesView a whole  load of state it doesn’t need to share, BookablesList will manage the rest of the state and  functionality that it needs: the loading indicators, errors and Presentation Mode.       Figure 7.13 BookablesView manages only the shared state. It passes the bookable to the BookableDetails  component. It passes the bookable and its updater function to BookablesList.   Lifting  the  selected  bookable  up  from  BookablesList  into  the  BookablesView  component  requires much less work in BookablesView but a number of changes in BookablesList. We  complete the changes in two steps:      Managing the selected bookable in the BookablesView component.     Receiving the bookable and updater function in BookablesList.   The BookablesList component still needs some way to let BookablesView know that a user  has selected a new bookable. BookablesView passes BookablesList the updater function for  the  selected  bookable.  Let’s  take  a  closer  look  at  the  latest  code  for  the  BookablesView  component.   Managing the selected bookable in the BookablesView component   7.4.1  As you can see in listing 7.11, the BookablesView component in this version is very simple;  it doesn’t have to deal with the reducer, initial state or deriving the selected bookable from  state. It includes a single call to the useState hook, to manage the selected bookable state  value.  It  then  passes  the  selected  bookable  to  both  children  and  the  updater  function  to  BookablesList. When a user selects a bookable, the BookablesList component can use the  updater function to let BookablesView know that the state has changed.    Manning Publications Co.  To comment go to  liveBook   161   Branch: 0702-lift-bookable, File:  src components Bookables BookablesView.js   Listing 7.11 Putting the selected bookable in the BookablesView component  import React, {useState, Fragment} from "react";    import BookablesList from ". BookablesList";  import BookableDetails from ". BookableDetails";    export default function BookablesView    {    const [bookable, setBookable] = useState  ;                            A      return                       B                                      C            ;  }   A Manage the selected bookable as a state value  B Pass the bookable and its updater function down  C Pass the bookable down  BookablesView no longer needs to do the filtering of the bookables for the current group or  grab  the  current  bookable  from  that  filtered  list.  Let’s  see  how BookablesList  changes  to  adapt to the new approach.   Receiving the bookable and updater function in BookablesList   7.4.2  By letting the BookablesView component manage the selected bookable, we change how the  BookablesList  component  works.  In  the  reducer  version,  BookablesView  stored  the  bookableIndex and group as part of state. Now, with BookablesList receiving the bookable  directly, those state values are no longer needed. The selected bookable looks something like  this:   {    "id": 1,    "group": "Rooms",    "title": "Meeting Room",    "notes": "The one with the big table and interactive screen.",    "days": [1, 2, 3],    "sessions": [1, 2, 3, 4, 5, 6]  }   It  includes  an id  and  a group  property. Whatever  group  the  selected  bookable  is  in  is the  current group; we don’t need a separate group state value. Also, it’s easy to find the index of  the  selected  bookable  within  the  array  of  bookables  in  its  group;  we  don’t  need  a  bookableIndex state value. With the group, bookableIndex and hasDetails state values no  longer  needed,  resulting  in  a  smaller,  simpler  state,  let’s  switch  back  to  using  calls  to  useState rather than a reducer.   There are changes to all sections of the BookablesList component, so we consider the   code section by section. The structure of the code looks like this:    Manning Publications Co.  To comment go to  liveBook   162   import React, {useEffect, useRef} from 'react';  import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  { bookable, setBookable }  {            1. Variables          2. Effects          3. Handler functions          4. Timer helpers          5. UI    }   Each  of  the  next  five  subsections  will  discuss  one  of  the  code  sections.  If  you  stitch  the  pieces together, you’ll have the complete component.   VARIABLES  The BookablesList component now receives the selected bookable as a prop. The selected  bookable includes an id and a group property. We use the group property to filter the list  and the id to highlight the selected bookable.   Listing  7.12  shows  the  updated  BookablesList  component  receiving  bookable  and  setBookable as props and setting up four pieces of local state by calling useState four times.   Branch: 0702-lift-bookable, File:  src components Bookables BookablesList.js   Listing 7.12 BookablesList: 1. Variables  import React, {useState, useEffect, useRef} from "react";                A   import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  { bookable, setBookable }  {      B    const [bookables, setBookables] = useState [] ;                        C    const [error, setError] = useState false ;                             C    const [isPresenting, setIsPresenting] = useState false ;               C    const [isLoading, setIsLoading] = useState true ;                      C      const group = bookable?.group;                                         D      const bookablesInGroup = bookables.filter b => b.group === group ;    const groups = [...new Set bookables.map b => b.group  ];      const nextButtonRef = useRef  ;         2. Effects       3. Handler functions       4. Timer helpers       5. UI  }   A Import useState rather than useReducer  B Receive the selected bookable and updater function as props  C Manage state with calls to the useState hook  D Use the selected bookable to filter the bookables list    Manning Publications Co.  To comment go to  liveBook   163   Listing  7.12  grabs  the  current  group  from  the  selected  bookable  by  using  the  optional  chaining operator, ?., a recent addition to JavaScript:  const group = bookable?.group;   If  there  is  no  bookable  selected,  the  expression  bookable?.group  returns  undefined.  It  saves us checking if the bookable exists before accessing the group property:  const group = bookable && bookable.group;   Until a bookable is selected, the group will be undefined and bookablesInGroup will be an  empty array. We need to select a bookable as soon as the bookables data is loaded into the  component. Let’s look at the loading process.   EFFECTS  We still have two effects to run for the BookablesList component:      On mount: Loading the bookables data.     After every render: Setting up a timer if the component’s in Presentation Mode.   Listing 7.13 shows the updated effect code. Both effect functions are very different to their  reducer-version counterparts. We discuss them after the listing.   Branch: 0702-lift-bookable, File  src components Bookables BookablesList.js   Listing 7.13 BookablesList: 2. Effects  import React, {useState, useEffect, useRef} from 'react';  import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  {bookable, setBookable}  {       1. Variables      useEffect    => {      getData "http:  localhost:3001 bookables"           .then bookables => {          setBookable bookables[0] ;                                       A          setBookables bookables ;                                         B          setIsLoading false ;          setIsPresenting true ;                                           C        }           .catch error => {          setError error ;          setIsLoading false         } ;                                                                D      }, [setBookable] ;                                                     E        useEffect    => {      if  isPresenting  {                                                  F          const id = setTimeout nextBookable, 3000 ;                         G    Manning Publications Co.  To comment go to  liveBook   164           return    => clearTimeout id ;                                     H        }  } ;       3. Handler functions     4. Timer helpers     5. UI   A Use the setBookable prop to select the first bookable  B Use the local updater function to set the bookables state  C Start the component in Presentation Mode  D If there’s an error, set the error state  E Include the external function in the dependency list  F Check if the component is in Presentation Mode  G Assign the timer id to a local variable  H Return a clean-up function to clear the timer  The  first  effect  still  uses  the  getData  utility  function,  created  in  chapter  5,  to  load  the  bookables. But, instead of dispatching actions to a reducer, the effect makes use of all five of  the  listing’s  updater  functions:  setBookable  -  passed  in  as  a  prop  -  and  setBookables,  setIsPresenting, setIsLoading and setError - from local calls to useState.   When  the  data  loads,  it  assigns  the  data  to  the  bookables  state  value  and  calls   setBookable with the first bookable in the array.  setBookable bookables[0] ;  setBookables bookables ;  setIsLoading false ;  setIsPresenting true ;   Now  that  the  data  has  loaded,  the  effect  also  kicks  off  Presentation  Mode  by  setting  isPresenting to true. React is able to sensibly respond to multiple state update calls, like  the  four  just  listed.  It  can  batch  updates  to  efficiently  schedule  any  re-renders  and  DOM  changes needed.   As  we  saw  with  the dispatch  prop  in  the  reducer version  in section  7.3, React doesn’t  trust  functions  passed  in  as  props  to  be  the  same  on  each  render.  In  this  version,  BookingsView  passes  in  the  setBookable  function  as  a  prop,  so  we  include  it  in  the  dependency array for the first effect.   If an error was thrown in the course of loading the data, the catch method sets it as the   error state value:   catch error => {    setError error ;    setIsLoading false ;   ;   The  first  effect  still  has  a  fair  bit  to  do  in  this  version  of  BookablesList,  but  the  second  effect seems to have lost a bit of weight. We discuss this more in the Timer helpers section,  but  the  new  BookablesList  component’s  timer  code  is  much  simpler  than  the  previous  version  ref-spotters may have noticed the absence of the timerRef variable . It assigns the    Manning Publications Co.  To comment go to  liveBook   165   timer id to a local variable within the second effect function and clears the timeout for that id  in the clean-up function the effect returns.   const id = setTimeout nextBookable, 3000 ;  return    => clearTimeout id ;   The  timer  will  call  the  nextBookable  function  after  three  seconds.  This  compact  code  highlights the elegance of the useEffect hook compared to the multiple lifecycle methods of  class components.   HANDLER FUNCTIONS  In the previous version of the BookablesList component, the handler functions dispatched  actions  to  the  reducer.  In  this  new  version,  the  handler  functions’  key  task  is  to  set  the  bookable.  Sometimes  they  end  Presentation  Mode  too.  In  listing  7.14,  notice  how  each  handler function includes a call to setBookable.   Branch: 0702-lift-bookable, File  src components Bookables BookablesList.js   Listing 7.14 BookablesList: 3. Handler functions  import React, {useState, useEffect, useRef} from 'react';  import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  {bookable, setBookable}  {     1. Variables     2. Effects      function changeGroup  event  {      const bookablesInSelectedGroup = bookables.filter         b => b.group === event.target.value                                A       ;      setBookable bookablesInSelectedGroup[0] ;                            B    }      function changeBookable  selectedBookable  {      setBookable selectedBookable ;      setIsPresenting false ;                                              C      nextButtonRef.current.focus  ;    }      function nextBookable  stopPresenting  {                               D      if  stopPresenting   {        setIsPresenting false ;                                            E      }        const i = bookablesInGroup.indexOf bookable ;      const nextIndex =  i + 1  % bookablesInGroup.length;      const nextBookable = bookablesInGroup[nextIndex];      setBookable nextBookable ;    }       4. Timer helpers     5. UI  }    Manning Publications Co.  To comment go to  liveBook   166   A Filter for the selected group  B Set the bookable to the first in the new group  C If a user directly selects a bookable, end Presentation Mode  D Accept an argument to specify the end of Presentation Mode  E End Presentation Mode if necessary  The current group is derived from the selected bookable; we no longer have a group state  value.  So,  when  a  user  chooses  a  group  from  the  drop-down,  the  changeGroup  function  doesn’t directly set the new group. Instead, it selects the first bookable in the chosen group.   setBookable bookablesInSelectedGroup[0] ;   The setBookable updater function is from the BookablesView component and triggers a re- render  of  BookablesView.  BookablesView,  in  turn,  re-renders  the  BookablesList  component,  passing  it  the  newly  selected  bookable  as  a  prop.  The  BookablesList  component  uses  the  bookable’s group  and id  properties to  select  the correct  group  in  the  drop-down, show just the bookables in the group, and to highlight the selected bookable in  the list.   There’re no surprises in the changeBookable function: it sets the selected bookable, ends   Presentation Mode, and moves focus to the Next button.   As well  as  setting  the  bookable  to  the  next  in  the  current  group, wrapping  back  to  the   first if necessary, the nextBookable function sometimes ends Presentation Mode.  function nextBookable  stopPresenting  {    if  stopPresenting  {                              A      setIsPresenting false ;    }         set next bookable  }   A Use the argument to determine whether to end Presentation Mode  The function uses its argument to determine whether to end Presentation Mode:      As we saw in the last section, the timer effect sets up a timer that calls nextBookable  with  no  argument,  so  stopPresenting  will  be  undefined.  The  timer  doesn’t  end  Presentation Mode.      As we’ll see in the next section, the Next button calls nextBookable with an argument  of  true,  so  stopPresenting  will  be  true.  The  Next  button  does  end  Presentation  Mode.   TIMER HELPERS  There’s no listing in this section because the timer functions are no more. They have ceased  to be. They’ve expired and gone to meet their maker. The second effect function is all that  we need to manage the timers now. But why the sudden brevity?   When the BookablesList component was in charge of both the list of bookables and the  details for the selected bookable, its job was a little more complicated. In Presentation Mode,  with a timer running, if the user toggled the display of details, then the component would re- render. But, the currently running timer had to be persisted across the renders, so we made    Manning Publications Co.  To comment go to  liveBook   167   use of a call to the useRef hook. Our code involved setting and checking the ref’s current  property. Now, with the selected bookable’s details managed by a separate component, all of  the timer management code can go in the one effect function:   useEffect    => {    if  isPresenting  {      const id = setTimeout nextBookable, 3000 ;      return    => clearTimeout id ;    }  }  * no dependency array *   ;   The  BookablesList  component  will  only  re-render  if  the  selected  bookable  changes.  Choosing  a  group,  clicking  a  bookable,  and  clicking  the  Next  button  all  select  a  new  bookable,  leading  to  a  re-render.  When  the  component re-renders,  the  timer  effect  always  runs  because  we  don’t  specify  a  dependency  array  as  a  second  argument  for  the  effect.  Before running the effect, React will call the clean-up function from the previous render, if  one was set,  clearing  any  existing  timer.  When  the  effect runs,  if  the  component  is  still  in  Presentation  Mode,  the  effect  will  set  a  new  timer  and  return  the  associated  clean-up  function for that new timer.   Here’s  a  step-by-step  rundown  of  what  happens  when  the  BookablesList  component  mounts, loads its data and automatically progresses to the second bookable before the user  clicks the Next button, manually moving to the third bookable.   1.  The page loads and the component renders for the first time.  2.  The component displays the loading UI because there are no bookables yet.   Figure 7.14 When the component mounts, it shows a loading indicator.      3.  The first effect runs, requesting the bookables data.  4.  The second effect runs, but we are not in Presentation Mode so it does nothing.  5.  The data loads and the then method in the first effect function adds the bookables to   state, starts Presentation Mode, sets isLoading to false, and sets a bookable.   6.  The component re-renders, displaying the list of bookables with the first bookable   highlighted.    Manning Publications Co.  To comment go to  liveBook   168         Figure 7.15 Once the bookables load, the component displays them in a list, with the first selected.   7.  The first effect doesn’t run because the setBookable function hasn’t changed.  8.  The second effect runs. We are in Presentation Mode, so it sets up a timer and returns   a clean-up function. React holds on to the clean-up function.   9.  Three seconds later, the timer fires. It calls nextBookable which calls the   setBookable updater function, selecting the second bookable.   10. The component re-renders, displaying the list of bookables with the second bookable   highlighted.   Figure 7.16 With no user interactions, the component moves on to the second bookable automatically.   11. The first effect doesn’t run because the setBookable function hasn’t changed.  12. The second effect will run. First, React calls the stored clean-up function, clearing the  previous timer. Then it runs the effect. We are still in Presentation Mode, so it sets up  a timer and returns a new clean-up function. React holds on to the clean-up function.    Manning Publications Co.  To comment go to  liveBook   169   13. The user clicks the Next button. It calls nextBookable which ends Presentation Mode   and calls the setBookable updater function, selecting the third bookable.    14. The component re-renders, displaying the list of bookables with the third bookable   highlighted.      Figure 7.17 The user clicked the Next button, moving the component to the third bookable and ending  Presentation Mode. No new timer is set.   15. The first effect doesn’t run because the setBookable function hasn’t changed.  16. The second effect will run. First, React calls the stored clean-up function, clearing the  previous timer. Then it runs the effect. We are no longer in Presentation Mode, so no  new timer is set.   17. The component sits, waiting for an event.   Notice the screenshots always appear between the render and the first effect. The effects fire  in order after React updates the display. React calls all clean-up functions before re-running  any effects.   UI  We  no  longer  have  the bookableIndex  value  in  state.  Listing  7.15  shows  how  we  use  the  bookable id instead.   Branch: 0702-lift-bookable, File  src components Bookables BookablesList.js   Listing 7.15 The BookablesList component  import React, {useState, useEffect, useRef} from 'react';  import {FaArrowRight, FaSpinner} from "react-icons fa";  import getData from ".. .. utils api";    export default function BookablesList  {bookable, setBookable}  {     1. Variables     2. Effects     3. Handler functions     4. Timer helpers    Manning Publications Co.  To comment go to  liveBook   170       if  error  {      return  {error.message}     }      if  isLoading  {      return           {" "}        Loading bookables...         }      return                            {groups.map g =>  {g}  }                              {bookablesInGroup.map  b  =>              <li              key={b.title}              className={b.id === bookable.id ? "selected" : null}         A            >              <button                className="btn"                onClick={   => changeBookable b }                          B              >                {b.title}                                        }                            <button            className="btn"            onClick={   => nextBookable true }                             C            ref={nextButtonRef}            autoFocus          >            Next                                ;  }   A Use the id to check if a bookable should be highlighted  B Pass the bookable to the changeBookable handler function  C Call nextBookable with an argument of true to end Presentation Mode  Some key changes to the UI occur in the list of bookables. Here’s the code that generates  the list items:   {bookablesInGroup.map  b  =>      <li      key={b.title}      className={b.id === bookable.id ? "selected" : null}    >    Manning Publications Co.  To comment go to  liveBook   171       <button        className="btn"        onClick={   => changeBookable b }      >        {b.title}                }   The code iterates through the bookables in the same group as the selected bookable. One by  one,  the  bookables  in  the  group  are  assigned  to  the  b  variable.  The  bookable  variable  represents  the  selected  bookable.  If  b.id  and  bookable.id  are  the  same,  the  current  bookable in the list should be highlighted, so we set its class to "selected".  className={b.id === bookable.id ? "selected" : null}   When a user clicks a bookable to select it, the onClick handler passes the whole bookable  object, b, to the changeBookable function, rather than just the bookable’s index.  onClick={   => changeBookable b }   When  a  user  clicks  on  the  Next  button,  the  onClick  handler  passes  true  to  the  nextBookable function:  onClick={   => nextBookable true }   Passing true ends Presentation Mode. Once the user takes control of bookable selection, we  stop the timer from automatically moving the selection on.   And  that’s  the  BookablesList  component  without  a  reducer  again.  There  were  a  few  changes  but,  with  its  more  focused  role  of  just  listing  bookables,  it’s  also  simpler  overall.  Which  approach  do  you  find  easier  to  understand?  Dispatching  actions  to  a  reducer  in  the  parent or managing most of the state in the component that uses it? In the first approach,  we moved the reducer up to the BookablesView component without making many changes.  Could  we  have  simplified  the  state  held  in  the  reducer  in  the  same  way  we  did  for  the  variables in the second approach? Whichever implementation you prefer, this chapter gave  you a chance to practice calling the useState, useReducer and useEffect hooks and consider  some of the nuances of passing dispatch and updater functions to child components.   CHALLENGE 7.1  Split  the  UsersList  component  into  UsersList  and  UserDetails  components.  Use  the  UsersPage  component  to  manage  the  selected  user,  passing  it  to  UsersList  and  UserDetails.   In the next chapter we develop the bookings page and call the useMemo hook to avoid   expensive computations.   7.5  Summary       If  components  share  the  same  state  value,  lift  the  value  up  to  the  closest  shared  ancestor component in the component tree and pass the state down via props.    Manning Publications Co.  To comment go to  liveBook   172   const [bookable, setBookable] = useState  ;  return                             ;      Pass  the  updater function returned  by  useState  to  child components  if  they  need  to   update the shared state.   const [bookable, setBookable] = useState  ;  return        Destructure the props parameter, assigning properties to local variables.   export default function ColorPicker {colors = [], color, setColor}  {    return           UI that uses colors, color and setColor     ;  }       Consider using default values for props. If the prop isn’t set, the default value will be   used.   export default function ColorPicker {colors = [], color, setColor}  {    return           iterate over colors array     ;  }      Check for undefined or null prop values. Return alternative UI if appropriate.   export default function ChoiceText {color}  {    return color ?         The selected color is {color}!       :         No color has been selected!        }      Return null if it is appropriate to render nothing.     To  let  a  child  component  update  the  state  managed  by  a  parent,  pass  the  child  an  updater function or a dispatch function. If the function is used in an effect, include the  function in the effect’s dependency list.    Manning Publications Co.  To comment go to  liveBook   173
