Django Crash Course  Covers Python 3.8 and Django 3.x  Daniel Roy Greenfeld, Audrey Roy Greenfeld  2020-03-10  Contents  Copyright  Introduction  Why Learn Django? . . . . . . . . . . . . . . . . . . . When the Going Gets Tough . . . . . . . . . . . . . . This Book is intended for Django 3.x and Python 3.8 . How This Book is Structured . . . . . . . . . . . . . . Conventions Used in this Book . . . . . . . . . . . . .  1 The Ultimate Django Setup  1.1 Goal: A Professional-Quality Development Envi- ronment . . . . . . . . . . . . . . . . . . . . . . . 1.2 Core Concepts . . . . . . . . . . . . . . . . . . . 1.3 Step 1: Install Conda . . . . . . . . . . . . . . . .  1  22  23 24 26 26 27 27  29  29 30 31   1.4 Step 2: Install Visual Studio Code . . . . . . . . 1.5 Step 3: Installing Git . . . . . . . . . . . . . . . . 1.6 Step 4: Installing PostgreSQL . . . . . . . . . . . 1.7 Summary . . . . . . . . . . . . . . . . . . . . . .  I Hello, World in Django  2 Hello, World in Django  2.1 The “Hello, World” of Python . . . . . . . . . . . “Hello, World” of Django: Simple on Purpose . . 2.2 2.3 Projects Goals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.4 Prerequisites  3 Preparation: Install Dependencies  3.1 What’s a Dependency? . . . . . . . . . . . . . . . 3.2 Set Up a New Conda Environment . . . . . . . . 3.3 Install Django . . . . . . . . . . . . . . . . . . . . 3.4 Summary . . . . . . . . . . . . . . . . . . . . . .  4 Generate a Starter Django Project  4.1 Anatomy of a Bare-Bones Django Project . . . . 4.2 manage.py . . . . . . . . . . . . . . . . . . . . . . 4.3 settings.py . . . . . . . . . . . . . . . . . . . . . . 4.4 Other Settings . . . . . . . . . . . . . . . . . . . 4.5 Exercise . . . . . . . . . . . . . . . . . . . . . . .  34 35 36 37  38  38 39 40 40 40  42 42 42 43 44  45 45 46 47 48 49  2   5 Create a Database and Run the Project  5.1 Ensure We Are in the Hellodjango project . . . . . 5.2 Creating the Database . . . . . . . . . . . . . . . 5.3 Start Up Runserver . . . . . . . . . . . . . . . . . 5.4 Runserver Has Started Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.5 Success!  6 Create a Django-Superuser  6.1 Stop runserver if It Is Still Running . . . . . . . . 6.2 Run createsuperuser . . . . . . . . . . . . . . . . . 6.3 Summary . . . . . . . . . . . . . . . . . . . . . .  7 Practice Using the Admin  7.1 Restart runserver . . . . . . . . . . . . . . . . . . 7.2 Visit the Admin . . . . . . . . . . . . . . . . . . . 7.3 Log in as Our Superuser . . . . . . . . . . . . . . 7.4 Explore the Admin . . . . . . . . . . . . . . . . . 7.5 Recreating the Hello, World in Django Database 7.6 Summary . . . . . . . . . . . . . . . . . . . . . .  8 Generate a Homepage App  8.1 Stop runserver if Needed . . . . . . . . . . . . . . 8.2 Generate a Starter Django App . . . . . . . . . . 8.3 Anatomy of a Simple 1-App Django Project . . . 8.4 Exercise . . . . . . . . . . . . . . . . . . . . . . . 8.5 Main Django Project vs Django Apps . . . . . .  50 50 50 51 52 52  53 53 54 54  55 55 55 56 56 57 57  59 59 59 59 60 60  3   9 Prepping the Project for Templates  9.1 Configure Your Templates . . . . . . . . . . . . . 9.2 Save! . . . . . . . . . . . . . . . . . . . . . . . . . 9.3 Lists? Dictionaries? . . . . . . . . . . . . . . . .  10 Add a Simple Homepage View  10.1 Get to Know URL Routing . . . . . . . . . . . . 10.2 Add a URL Pattern for the Homepage . . . . . . 10.3 Double-Check the Code . . . . . . . . . . . . . . 10.4 Terminology: “Wire in the URL” . . . . . . . . . 10.5 Refresh the Page and Trigger an Error . . . . . .  11 Create Our First Django Template  11.1 Create a Templates Directory . . . . . . . . . . . 11.2 Add Index Template . . . . . . . . . . . . . . . . 11.3 Start Up Runserver . . . . . . . . . . . . . . . . . 11.4 View the First Page . . . . . . . . . . . . . . . . 11.5 Recap . . . . . . . . . . . . . . . . . . . . . . . . 11.6 Understanding Views and the Templateview Class  12 Working With Variables in Templates  12.1 Our First Templated Value . . . . . . . . . . . . 12.2 What Is my_statement? . . . . . . . . . . . . . . . . 12.3 Extend HomepageView . . . . . . . . . . . . . . . 12.4 Refresh the Homepage . . . . . . . . . . . . . . .  61 61 62 62  64 64 65 66 67 67  69 69 69 70 70 71 71  73 73 73 74 74  4   12.5 Exercise: Play Around! . . . . . . . . . . . . . . 12.6 Common Questions . . . . . . . . . . . . . . . . .  13 Calling View Methods From Templates  13.1 Define a View Method . . . . . . . . . . . . . . . 13.2 Call the View Method From index.html . . . . . 13.3 Reload the Homepage . . . . . . . . . . . . . . .  14 Our First Project is Complete!  14.1 Summary . . . . . . . . . . . . . . . . . . . . . . 14.2 Next Steps . . . . . . . . . . . . . . . . . . . . .  II EveryCheese  15 The EveryCheese Project  15.1 Prerequisites . . . . . . . . . . . . . . . . . . . . 15.2 Prepare the EveryCheese Programming Environ- ment . . . . . . . . . . . . . . . . . . . . . . . . . 15.3 Create a New Virtual Environment . . . . . . . . 15.4 Reactivating Conda Environments . . . . . . . . 15.5 Summary . . . . . . . . . . . . . . . . . . . . . .  16 Using Cookiecutter and Template  16.1 Install the Cookiecutter Library . . . . . . . . . . 16.2 Cookiecutter Project Templates . . . . . . . . . . 16.3 Using django-crash-starter . . . . . . . . . . . . .  75 75  77 77 77 78  80 80 80  82  83 83  83 84 84 85  86 86 88 88  5   16.4 What Happened? . . . . . . . . . . . . . . . . . . 16.5 Tips and Troubleshooting . . . . . . . . . . . . . 16.6 A Little Cookiecutter Background . . . . . . . .  17 Exploring the Generated Boilerplate  17.1 Some Basic Components . . . . . . . . . . . . . . 17.2 Summary . . . . . . . . . . . . . . . . . . . . . .  18 Starting Up Our New Django Project  18.1 Let’s Run the Project . . . . . . . . . . . . . . . 18.2 Go Into the EveryCheese Directory . . . . . . . . 18.3 Start PostgreSQL if Needed . . . . . . . . . . . . 18.4 Create the Database . . . . . . . . . . . . . . . . 18.5 How to Create It . . . . . . . . . . . . . . . . . . 18.6 Install the Dependencies . . . . . . . . . . . . . . 18.7 Run the Migrations . . . . . . . . . . . . . . . . . 18.8 Start Up Runserver . . . . . . . . . . . . . . . . .  19 Cheese Boilers  90 91 92  93 93 94  95 95 95 96 97 97 98 98 99  100  20 Initializing the Git Repo Committing and Push-  ing 101 20.1 Why? . . . . . . . . . . . . . . . . . . . . . . . . 101 20.2 We’ll Use GitHub . . . . . . . . . . . . . . . . . . 101 20.3 Create the GitHub Project . . . . . . . . . . . . 101 20.4 Examine the GitHub Instructions . . . . . . . . . 103 20.5 Verify That the Files Got Committed . . . . . . 104  6   21 Git Is Not for Stinky Cheeses  105  22 What We Get From The Users App  106 22.1 Register a Normal User . . . . . . . . . . . . . . 106 22.2 Verify Our Email . . . . . . . . . . . . . . . . . . 107 22.3 Why Are Emails Printed in the Console? . . . . 109 22.4 Explore the User Profile . . . . . . . . . . . . . . 110 22.5 Edit User Data . . . . . . . . . . . . . . . . . . . 111 22.6 Introducing UserUpdateView . . . . . . . . . . . . . 111 22.7 Introducing UserDetailview . . . . . . . . . . . . . 112 22.8 Understand the Name Field . . . . . . . . . . . . 113 22.9 Understand the Code for UserUpdateView . . . . . . 114 22.10Add Email Addresses . . . . . . . . . . . . . . . . 115 22.11What About the Code? . . . . . . . . . . . . . . 116  23 Adding User Bios  117 23.1 Add a Bio Field . . . . . . . . . . . . . . . . . . . 117 23.2 Create and Run Migrations . . . . . . . . . . . . 117 23.3 Update UserUpdateView . . . . . . . . . . . . . . 118 23.4 Try It Out . . . . . . . . . . . . . . . . . . . . . . 118  24 Adding Bio to User Detail Template  121 24.1 Update the User Detail Template . . . . . . . . . 121 24.2 Add Line Breaks . . . . . . . . . . . . . . . . . . 122 24.3 Commit Our Work . . . . . . . . . . . . . . . . . 123  7   25 Introducing Tests  124 25.1 Why Test? . . . . . . . . . . . . . . . . . . . . . . 124 25.2 Running Tests . . . . . . . . . . . . . . . . . . . . 124 25.3 What Does a Test Look Like? . . . . . . . . . . . 126 25.4 The Test Foundations . . . . . . . . . . . . . . . 126 25.5 The Actual Test . . . . . . . . . . . . . . . . . . 127 25.6 Using the assert KeyWord . . . . . . . . . . . . . 128 25.7 Introducing coverage.py . . . . . . . . . . . . . . 129 25.8 Using coverage.py . . . . . . . . . . . . . . . . . . 129 25.9 Generate an HTML Coverage Report . . . . . . . 130 25.10More Users App Tests . . . . . . . . . . . . . . . 131 25.11Summary . . . . . . . . . . . . . . . . . . . . . . 131  26 User Profile Cheese  132 26.1 Avatars Will Fit Into Cheese Holes . . . . . . . . 132  27 The Cheeses App and Model  133 27.1 Make Sure We’re at the Project Root . . . . . . . 133 27.2 Create an App Called Cheeses . . . . . . . . . . 133 27.3 Move It Into the Project . . . . . . . . . . . . . . 133 27.4 Set the Cheese Config . . . . . . . . . . . . . . . 134 27.5 Add It to the List of Installed Apps . . . . . . . 134 27.6 Add the Cheese Model . . . . . . . . . . . . . . . 135 27.7 Create and Run the Initial Cheese Migration . . 138  8   28 Trying Out the Cheese Model  140 . . . . . . . . . . . . . . . . . . 140 28.1 Let’s Try It Out! 28.2 Django Shell vs. Shell Plus . . . . . . . . . . . . 140 28.3 Create a Cheese . . . . . . . . . . . . . . . . . . . 140 28.4 Evaluate and Print the Cheese . . . . . . . . . . 141 28.5 View the Cheese’s Name . . . . . . . . . . . . . . 141 28.6 Add a String Method . . . . . . . . . . . . . . . . 142 28.7 Try It Again . . . . . . . . . . . . . . . . . . . . 142 28.8 Commit Our Work . . . . . . . . . . . . . . . . . 143  29 Tests and Test Coverage  144 29.1 Check Test Coverage . . . . . . . . . . . . . . . . 144 29.2 Create a Module for Cheese Model Tests . . . . . 146 29.3 Let’s Test the __str__   Method. . . . . . . . . . 147 29.4 Enter “The Game of Test Coverage” . . . . . . . 148 29.5 Rules of the Game . . . . . . . . . . . . . . . . . 148 29.6 What’s the Point of All This Anyway? . . . . . . 149 29.7 Commit the Cheese Model Tests . . . . . . . . . 150 29.8 Summary . . . . . . . . . . . . . . . . . . . . . . 150  30 The Cheeserator  151  31 Adding Cheeses to the Admin  152 31.1 We Need a Superuser . . . . . . . . . . . . . . . . 152 31.2 Go to the Admin . . . . . . . . . . . . . . . . . . 152  9   31.3 Explore the Admin So Far . . . . . . . . . . . . . 153 31.4 Register Cheese Model With the Admin . . . . . 153 31.5 Find Colby . . . . . . . . . . . . . . . . . . . . . 153 31.6 Enter More Cheeses via the Admin . . . . . . . . 154 31.7 Some Notes About the Django Admin . . . . . . 156 31.8 Commit Changes . . . . . . . . . . . . . . . . . . 156 31.9 Summary . . . . . . . . . . . . . . . . . . . . . . 157  32 Behind the Curtain 32.1 We Are in Control  158 . . . . . . . . . . . . . . . . . 158  33 Class Based View Fundamentals  160 33.1 The Simplest Class-Based View . . . . . . . . . . 160 33.2 Adding More HTTP Methods . . . . . . . . . . . 161 33.3 Advantages of Class Based Views . . . . . . . . . 162 33.4 Composition . . . . . . . . . . . . . . . . . . . . . 162 33.5 Composition Part II . . . . . . . . . . . . . . . . 163 33.6 Intelligent Defaults . . . . . . . . . . . . . . . . . 164 33.7 Standardized HTTP Method Handling . . . . . . 164 33.8 Tips for Writing Class-Based Views . . . . . . . . 165  34 Writing the Cheese List View  166  35 Wiring in the List View Url  167 . . . . . . . . . . . 167 35.1 Define Cheese URL Patterns 35.2 Include Cheese URLs in Root URLConf . . . . . 167 35.3 See the View in Action . . . . . . . . . . . . . . . 167  10   169 36 The Cheese List Template . . . . . . . . . . . . . 169 36.1 Create the List Template 36.2 Fill in the Template . . . . . . . . . . . . . . . . 169 36.3 See the List in Action . . . . . . . . . . . . . . . 170 36.4 Add a Nav Link to the Cheese List . . . . . . . . 171 36.5 Explaining the cheeses:list Name . . . . . . . . . 172 36.6 Commit Our Work . . . . . . . . . . . . . . . . . 173  37 Add the CheeseDetailView  174 37.1 Add the CheeseDetailView URL Pattern . . . . . 174 37.2 Link List Items to Detail Pages . . . . . . . . . . 175  38 The Cheese Detail Template  177 . . . . . . . . . . 177 38.1 Add a Cheese Detail Template 38.2 Visit Cheese Detail . . . . . . . . . . . . . . . . . 178 38.3 Commit Our Work . . . . . . . . . . . . . . . . . 178  39 Where to Dip Class Based Views  179  40 Writing Factories for Tests  180 40.1 Produce Cheese Test Data From Factories . . . . 180 40.2 Define a CheeseFactory . . . . . . . . . . . . . . . . 180 40.3 Try Out CheeseFactory . . . . . . . . . . . . . . . . 181 40.4 Delete the Bogus Cheese . . . . . . . . . . . . . . 182 40.5 Commit the Changes . . . . . . . . . . . . . . . . 183  11   41 Why Use Factories  185 41.1 Factories and Unit Testing . . . . . . . . . . . . . 185 41.2 Approach 1: Calling Create   . . . . . . . . . . . 185 41.3 Approach 2: Calling CheeseFactory   . . . . . . . . 186 41.4 Other Uses . . . . . . . . . . . . . . . . . . . . . 187 41.5 Learn More About Factory Boy . . . . . . . . . . 187  42 Using Factories in Tests  188 42.1 Passing in Field Values Explicitly . . . . . . . . . 188 42.2 Bulk Generation . . . . . . . . . . . . . . . . . . 188 42.3 Reviewing Our Cheeses . . . . . . . . . . . . . . 189 42.4 Cheese Cleanup . . . . . . . . . . . . . . . . . . . 189 42.5 Replacing the Direct Cheese Model Call in Our  Existing Test . . . . . . . . . . . . . . . . . . . . 190 42.6 Removing the Name Entirely . . . . . . . . . . . 191 42.7 Commit Our Work . . . . . . . . . . . . . . . . . 192 42.8 Summary . . . . . . . . . . . . . . . . . . . . . . 192  43 How Our Cheese Objects Feel About Your Tests193  44 Finding and Adding a Third Party Countries App195 44.1 Country of Origin . . . . . . . . . . . . . . . . . . 195 44.2 Benefiting From Open Source . . . . . . . . . . . 197 44.3 Check Django Packages . . . . . . . . . . . . . . 197 44.4 Review Django Countries on GitHub . . . . . . . 198 44.5 Look for the Release Number on PyPI . . . . . . 198  12   44.6 Install It . . . . . . . . . . . . . . . . . . . . . . . 198 44.7 Implement in cheeses models.py . . . . . . . . . 200 . . . . . . . . . . . . . . . . . . . . . 201 44.8 Migrations!  45 Display Cheese Country Data  203 45.1 Add Cheese Countries in the Admin . . . . . . . 203 45.2 Display Country in Cheese Detail . . . . . . . . . 204 45.3 Run the Tests . . . . . . . . . . . . . . . . . . . . 205 45.4 Update CheeseFactory . . . . . . . . . . . . . . . . 205 45.5 Verify That CheeseFactory Works . . . . . . . . . . 206 45.6 Commit Our Work . . . . . . . . . . . . . . . . . 207  46 Implement Cheese Creation by Users  208 46.1 Add a Cheese Creation View . . . . . . . . . . . 208 46.2 Add the Corresponding URL Pattern . . . . . . . 209 46.3 Specify the Desired Form Fields . . . . . . . . . . 212 46.4 Define the Cheese Form Template . . . . . . . . . 212 46.5 Submit the Form . . . . . . . . . . . . . . . . . . 214 46.6 Implement Get_absolute_url   . . . . . . . . . . . 214 46.7 Resubmit the Form . . . . . . . . . . . . . . . . . 216 46.8 Link to the Add Cheese Form . . . . . . . . . . . 218 46.9 Commit the Changes . . . . . . . . . . . . . . . . 219  13   47 Use Django Crispy Forms for Better Display  221 47.1 Isn’t as_p   Enough? . . . . . . . . . . . . . . . . 221 47.2 A Quick History Lesson . . . . . . . . . . . . . . 222 47.3 Crispy Forms and Cookiecutter Django . . . . . 223 47.4 Our Non-Crispy Form . . . . . . . . . . . . . . . 223 47.5 Use the Crispy Template Tag . . . . . . . . . . . 223 47.6 Reload the Add Cheese Form . . . . . . . . . . . 225 47.7 Commit the Changes . . . . . . . . . . . . . . . . 225  48 Understand View Mixins and LoginRequired-  227 Mixin 48.1 User-Generated Content and Accountability . . . 227 48.2 Try Accessing the Add Cheese Form Anonymously 227 48.3 Require Login . . . . . . . . . . . . . . . . . . . . 228 48.4 Try Accessing It as Cheesehead . . . . . . . . . . 230 48.5 View Mixins . . . . . . . . . . . . . . . . . . . . . 230 48.6 Commit the Changes . . . . . . . . . . . . . . . . 231  49 Add a Creator Field and Update Our Cheese  Records 232 49.1 Add a Creator Field . . . . . . . . . . . . . . . . 232 49.2 Make and Apply the Migration . . . . . . . . . . 233 49.3 Commit the Changes . . . . . . . . . . . . . . . . 234  14   50 Track and Display the Cheese Creator  235 50.1 Set the Cheese Creator After Form Validation . . 235 50.2 Display the Creator on the Cheese Detail Pages . 236 50.3 Try It Out . . . . . . . . . . . . . . . . . . . . . . 237 50.4 Commit the Changes . . . . . . . . . . . . . . . . 238  51 Update the Cheese Factory  239 51.1 Run the Tests . . . . . . . . . . . . . . . . . . . . 239 51.2 Modify Cheese Factory . . . . . . . . . . . . . . . 239 51.3 Run the Tests, Again . . . . . . . . . . . . . . . . 240 51.4 Try CheeseFactory in the Shell . . . . . . . . . . . 240 51.5 Delete the Random Cheese . . . . . . . . . . . . 241 51.6 Delete the Random User . . . . . . . . . . . . . . 241 51.7 Commit the Changes . . . . . . . . . . . . . . . . 242  52 Update the Cheese Model Tests  243 52.1 Test Get_absolute_url   . . . . . . . . . . . . . . . 243 52.2 Commit the Changes . . . . . . . . . . . . . . . . 244  53 Test All the Cheese Views  245 53.1 What to Test? . . . . . . . . . . . . . . . . . . . 245 53.2 Start With Imports . . . . . . . . . . . . . . . . . 245 53.3 The First Cheese View Tests . . . . . . . . . . . 246 53.4 Really Test the Cheese List View . . . . . . . . . 250 53.5 Test the Cheese Detail View . . . . . . . . . . . . 251  15   53.6 Test the Cheese Create View . . . . . . . . . . . 252 53.7 Commit the Changes . . . . . . . . . . . . . . . . 253 53.8 Conclusion . . . . . . . . . . . . . . . . . . . . . 253  54 Test All the Cheese URL Patterns  255 54.1 Add the Imported Cheese . . . . . . . . . . . . . 255 54.2 Write Our First Fixture . . . . . . . . . . . . . . 255 54.3 Test the Cheese List URL Pattern . . . . . . . . 256 54.4 Test the Add Cheese URL Pattern . . . . . . . . 256 54.5 Test the Cheese Detail URL Pattern . . . . . . . 257 54.6 Commit the Changes . . . . . . . . . . . . . . . . 258  55 Adding a CheeseUpdateView and Form Recycling259 55.1 Add the CheeseUpdateView . . . . . . . . . . . . 259 55.2 Wire in the URL Pattern . . . . . . . . . . . . . 260 55.3 Try It in the Browser . . . . . . . . . . . . . . . . 260 55.4 What Happened?!? . . . . . . . . . . . . . . . . . 262 55.5 Link to the Update Form . . . . . . . . . . . . . 265 55.6 Try It in the Browser . . . . . . . . . . . . . . . . 265 55.7 Make Login Required . . . . . . . . . . . . . . . . 265 55.8 Commit the Changes . . . . . . . . . . . . . . . . 266  56 Test the Cheese Forms and Update View  268 56.1 Refactoring our Cheese Fixture . . . . . . . . . . 268 56.2 Test the Add Cheese Page Title . . . . . . . . . . 269  16   56.3 Test That CheeseUpdateView Is a Good View . . . . 270 56.4 Test That a Cheese Updates Correctly . . . . . . 271 56.5 Commit the Changes . . . . . . . . . . . . . . . . 272  57 EveryCheese is the Foundation!  273 57.1 Summary . . . . . . . . . . . . . . . . . . . . . . 273 57.2 Next Steps After This Book . . . . . . . . . . . . 274 57.3 Giving Us Feedback . . . . . . . . . . . . . . . . 275  III Aftermatter  58 Troubleshooting  276  276  58.1 Troubleshooting Conda Installations on Pre-  Catalina OSX . . . . . . . . . . . . . . . . . . . . 276  58.2 Troubleshooting Conda Installations on Catalina  or higher OSX . . . . . . . . . . . . . . . . . . . 276 58.3 Troubleshooting PostgreSQL: Role Does Not Exist 277 58.4 Troubleshooting PostgreSQL: Cannot Create  Database  . . . . . . . . . . . . . . . . . . . . . . 278 58.5 Troubleshooting PsycoPG2 . . . . . . . . . . . . 278 58.6 Troubleshooting GCC Errors on the Mac . . . . 278 58.7 Troubleshooting the MS Visual Studio Build  Tools Error . . . . . . . . . . . . . . . . . . . . . 279  59 Changelog  280 59.1 Beta Changelog 2020-03-10 . . . . . . . . . . . . 280 59.2 Beta Changelog 2020-03-06 . . . . . . . . . . . . 280  17   59.3 Beta Changelog 2020-03-03 . . . . . . . . . . . . 281 59.4 Beta Changelog 2020-02-26 . . . . . . . . . . . . 281 59.5 Beta Changelog 2020-02-22 . . . . . . . . . . . . 281 59.6 Beta Changelog 2020-02-21 . . . . . . . . . . . . 282 59.7 Beta Changelog 2020-02-19 . . . . . . . . . . . . 282 59.8 Alpha Changelog 2020-02-14 . . . . . . . . . . . . 283 59.9 Alpha Changelog 2020-02-11 . . . . . . . . . . . . 284 59.10Alpha Changelog 2020-02-07 . . . . . . . . . . . . 284 59.11Alpha Changelog 2020-02-05 . . . . . . . . . . . . 284 59.12Alpha Changelog 2020-02-04 . . . . . . . . . . . . 285 59.13Alpha Changelog 2020-02-03 . . . . . . . . . . . . 285  60 Acknowledgements  286 60.1 Tech Reviewers . . . . . . . . . . . . . . . . . . . 286 60.2 Contributors to 3.x Beta . . . . . . . . . . . . . . 287 60.3 Contributors to 3.x Alpha . . . . . . . . . . . . . 287 60.4 Typesetting . . . . . . . . . . . . . . . . . . . . . 288  List of Figures  1 2  3 4  Two Scoops Travels the World . . . . . . . . . . Scientific Cheese-Based Diagram Explaining Why To Learn Django . . . . . . . . . . . . . . . . . . Let’s start with the basics. . . . . . . . . . . . . . It worked! Hooray! . . . . . . . . . . . . . . . . .  23  24 38 53  18   5 6 7 8 9  70 75 78 92  Stinky cheeses getting kicked out by a foot.  Greetings, Hello World . . . . . . . . . . . . . . . Greetings . . . . . . . . . . . . . . . . . . . . . . Greeting with view method . . . . . . . . . . . . The Tasty Cookiecutter Logo . . . . . . . . . . . Illustration of cheese boiler, and the location of its boilerplate . . . . . . . . . . . . . . . . . . . . 100 10 Create repository on GitHub . . . . . . . . . . . 102 11 . . . 105 12 Registration form . . . . . . . . . . . . . . . . . . 107 13 Verify email page . . . . . . . . . . . . . . . . . . 108 14 Verification email in console window . . . . . . . 109 15 Page with Confirm button . . . . . . . . . . . . . 110 16 Minimal user profile . . . . . . . . . . . . . . . . 111 17 UserUpdateView . . . . . . . . . . . . . . . . . . 112 18 UserDetailView . . . . . . . . . . . . . . . . . . . 113 19 UserUpdateView With Bio . . . . . . . . . . . . . 119 20 UserDetailView Without Bio . . . . . . . . . . . 120 21 UserDetailView With Bio . . . . . . . . . . . . . 122 22 No line breaks in UserDetailView . . . . . . . . . 123 23 A block of user profile cheese . . . . . . . . . . . 132 24 Slugs are awesome! . . . . . . . . . . . . . . . . . 137 25 94% coverage . . . . . . . . . . . . . . . . . . . . 144 26 Cheese model coverage . . . . . . . . . . . . . . . 145 27 The Cheeserator device for manipulating cheese. 151  19   28 Cheeses on the Django admin index page . . . . 154 29 Add cheese in the Django admin . . . . . . . . . 155 30 The cheese behind the curtain . . . . . . . . . . . 158 31 TemplateDoesNotExist . . . . . . . . . . . . . . . 168 32 Cheese list . . . . . . . . . . . . . . . . . . . . . . 170 33 Cheese List With Nav Link . . . . . . . . . . . . 172 34 Missing cheese_detail.html TemplateDoesNotEx-  ist exception . . . . . . . . . . . . . . . . . . . . . 176 . . . . . . . . . . . . . . . . . . . . 178 35 Cheese detail 36 Dipping CBVs in fondue. . . . . . . . . . . . . . 179 37 Django admin list of cheeses, including bogus cheese183 38 A good cheese that passed its test. . . . . . . . . 194 39 Django Packages’ countries grid . . . . . . . . . . 197 40 Django Countries README on GitHub . . . . . 199 41 Cheese country data in the admin . . . . . . . . 203 42 No cheese found! . . . . . . . . . . . . . . . . . . 209 43 Need Fields Attribute . . . . . . . . . . . . . . . 211 44 Cheese Form Template Does Not Exist . . . . . . 213 45 Add Cheese Form . . . . . . . . . . . . . . . . . . 215 46 No URL to Redirect To . . . . . . . . . . . . . . 216 47 Resubmit Cheese . . . . . . . . . . . . . . . . . . 217 48 Cheese Detail for Havarti . . . . . . . . . . . . . 217 49 Cheese List With Add Cheese Button . . . . . . 219 50 Cheese form with unstyled form fields . . . . . . 221  20   51 Add Cheese Form . . . . . . . . . . . . . . . . . . 224 52 Add Cheese Form, Rendered With Crispy Forms 226 53 Add Cheese Form, As Anonymous User . . . . . 228 54 Incognito Redirect to Sign In Page . . . . . . . . 230 55 Cheese Detail With Creator . . . . . . . . . . . . 238 56 Pre-populated Add Cheese Form . . . . . . . . . 261 57 Cheese Detail With Update Button . . . . . . . . 266  21   Copyright  Django Crash Course Covers Python 3.8 and Django 3.x Copy- right   2020 Daniel Roy Greenfeld, Audrey Roy Greenfeld, and Roy Greenfeld, Inc. All Rights Reserved Published by Two Scoops Press, an imprint of Roy Greenfeld, Inc. 9410 Owensmouth Ave. Studio 1 Chatsworth, CA 91311 BETA CCD-2020-03-10 The only authorized vendor or distributor for this product is Roy Greenfeld, Inc. Support this book by only purchasing or getting it from https:  www.roygreenfeld.com products django-crash-course  22   Introduction  Figure 1: Two Scoops Travels the World  Once upon a time, we traveled the world doing Django train- ing for companies. These private training sessions were custom- designed for companies needing to get engineers up and running fast with Django. Engineers who’ve been through this training describe them as compressing months of learning Django on your own into the span of one intense, exhausting week. Django Crash Course is the foundation portion of our corporate training sessions. It’s the first and sometimes the second day of our corporate training, for which we charge $3000 an attendee. When people pay that much for a workshop, they make sure they’re getting their money’s worth. They take detailed notes, study every code sample as if it were gold, and appreciate every minute of it. They also complete every single part of the course, including the diﬀicult or tedious parts.  23       If you do follow that same pattern with this book you will learn. Trust us. Once you’ve gone through this book, you’ll be ready for the forthcoming Django Crash Course extension series. Like this book, these are patterned after our corporate training, specifically intermediate-to-advanced material from days 3, 4, and 5. They build directly off the foundations laid in this book, readying you for the serious work of professional Django development.  Why Learn Django?  In today’s world, one might ask what’s the point of learning a 17-year old application framework. Here are three reasons why:  Figure 2: Scientific Cheese-Based Diagram Explaining Why To Learn Django  24       Reason 1 - Django is Mature  Started in 2003, Django isn’t some new framework that hasn’t accounted yet for all common edge cases. Rather Django’s main- tainers have handled those edge cases at least once. Instead, the maintainers are worried that Django is now old enough to be interested in dating and has a US driving learner’s permit. We like to think of Django like a delicious aged cheese like Boerenkaas Gouda, with a sweet, intense flavor that only comes with maturity.  Reason 2 - Django is Python  Python is an immensely popular programming language and is by far 1 in the field of data science. Python is easy to learn yet powerful in execution. It has a gigantic global community of users and hundreds of thousands of libraries to draw on, includ- ing Pandas, Numpy, Keras, and of course, Django. We like to think of Python like Mozzarella, arguably one of the most popular cheeses in the world. Its use in pizza as the base cheese makes mozzarella such a universal cheese much in the same way that Django’s use of Python makes it such a universal platform.  Reason 3 - Django is Proven  No tool remains popular for as long as Django unless it proves itself. Because it is so proven, Django is relied on by startups building dreams, science and fintech efforts presenting their data, and of course, tech giants like Instagram. We like to think of Django as the cheese on pie-sliced pizza, a dish proven around the world. No matter where one goes on the planet, a slice of cheese pizza is always available. That’s because  25   pizza is proven, much like Django is proven as an application framework. Now that we know why to learn Django, let’s get started!  When the Going Gets Tough  We’ve tried to minimize the tedious parts, but sometimes it takes getting past that sort of material to break through to the fun stuff. We’ve also tried to keep the diﬀiculty level manageable, but sometimes you’ll find things you don’t understand, and you’ll have to experiment and research concepts. We’ve put so much love over the years into these materials, it- erating and hand-crafting them with the utmost care. Yet you may find errors or omissions. This is not the final version of the book, so remember, you can help us make it even better. We hope you have fun with this book. We’ve had fun putting it together for you.  This Book is intended for Django 3.x and Python 3.8  This book should work well with the Django 3.x series, less so with Django 2.x and so on. As for the Python version, this book is tested on Python 3.8. Most code examples should work on Python 3.7.x and 3.6.x, but some exceptions may have to be worked through.  26   How This Book is Structured  After this introduction chapter, Django Crash Course1 is struc- tured in three parts:  The Ultimate Django Setup Our simple but comprehensive guide for setting up computers for building Django projects.  Hello, World in Django Getting comfortable with the basics  of Django development.  The EveryCheese Project A gentle but deep introduction to techniques and patterns used by professional Django devel- opers. It’s also the foundation of the Extension Series.  Conventions Used in this Book  We use code examples like the following throughout the book:  class Cheese:  def __init__ self, aged=False :  self.aged = aged  To keep these snippets compact, we sometimes violate the PEP 8 conventions on comments, line spacing, and line length. Code samples will eventually be made available at : https:  github.com roygreenfeld django-crash-course We use the following typographical conventions throughout the book:    Constant width for code fragments or commands. 1https:  www.roygreenfeld.com collections two-scoops-press products django-  crash-course  27     Italic for filenames.   Bold when introducing a new term or important word.  Boxes containing notes, warnings, tips, and little anecdotes are also used in this book:    Something You Should Know  Tip boxes give handy advice    Some Dangerous Pitfall  Warning boxes help you avoid common mistakes and pit- falls.  We also use tables to summarize information in a handy, concise way:  Table 1: Three Delicious Kinds of Cheese  Name Parmesan Cheddar Raclette  Country of Origin Italy England Switzerland France  Hardness hard semi-soft semi-hard  28       1 The Ultimate Django Setup  This is how we like to set things up on our computers, as of 2020. Daniel uses a MacBook Air, and Audrey uses a MacBook Pro. We also share a Microsoft Surface Pro for Windows development and testing. We’ve worked through Django setup countless times, both for ourselves and for students. Over the years our preferences have evolved. This is the latest iteration of how we like to set up our computers  and those of our students and readers  for Django development.    This chapter is a work in progress!  We’ve put a lot of work into this chapter, yet we know from experience that some people will run into challenges, or bugs, and errors. In that case, please let us know at our issue tracker at https:  github.com roygreenfeld django- crash-course issues.  1.1 Goal: A Professional-Quality Develop-  ment Environment  The goal of this chapter is to get our computer fully set up for optimal Django development on Mac or Windows. This isn’t just a toy set up for educational purposes; it’s the real setup used by professional web developers and data scientists, and one which we can use to develop real-world Django projects. Make sure we:    Are comfortable using the command line.  through a command line tutorial such as TODO.  If not, work  29       Have a computer with at least a gigabyte  1 GB  of hard    Have a fast internet connection. We’re going to be here for  drive space.  a little while.  1.2 Core Concepts  1.2.1 Keep Tooling Updated  This book encourages us to use the latest versions of all available tools. If we have an outdated version of any particular tool, upgrade it whenever possible. Don’t worry, this guide shows how to make those updates.  1.2.2 Perfection Is Impossible  When installing developer tools, it’s extremely common for an install to fail partway, leaving crumbs on our system. While it can be frustrating, it’s part of life as a developer. The more experience we gain as a developer, the more we learn to live with an imperfect system full of crumbs from half-installed tools all over our operating system’s nooks and crannies. It’s alright, though. If it’s any consolation, as we gain more experience with Django and related tooling, we’ll gain an intuition for when we can delete these crumbs. We don’t need a pristine, untouched operating system to set up Django and all its dependencies properly. We’ve had stu- dents purchase expensive new computers before our training, then panic when they accidentally install something the wrong way. Please don’t buy a new laptop just to work with Django. Try installing these tools on whatever computer that’s available at home, school, or work.  30   Some may think their setup is too broken and unrecoverable to work with. There’s a 99% chance that’s not true. Just work with it and let’s give it our best try.  1.2.3 Take Detailed Notes  We highly recommend keeping a journal of:    All the commands typed in at the command line, and their  results    What is installed via GUI installers  This can be as simple as a text file in a notes directory named 2020-02-01.txt. Detailed notes are our best guard against things going wrong. Even if our notes are mostly just copy-pasted commands and out- put from our terminal that we don’t understand, that’s alright. The important thing is that we maintain a record of changes. With that, let’s get started!  1.3 Step 1: Install Conda  Conda is the tool we use for virtual environments. Virtual environments allow us to do things like run one project with Django 3.0 and another with Django 2.2 on the same ma- chine.  Is Conda already installed? Here’s how to check:  31       – Windows: Open the Start Menu and choose the Ana- If we find it, that means Conda is  conda Prompt. installed.  – Mac: Open a terminal and type conda -V.  ∗ If the response says something like conda 4.8.1, Conda is installed and now we know its version. ∗ If that doesn’t work, type . ~ .bash_profile and hit return. Once that’s done, try conda -V again.  If any of these are true, skip forward to Updating Existing Conda Installation.    Experienced with Conda Alternatives?  More advanced readers might already be proficient with tools like virtualenv, poetry, pyenv, docker, or other environmental control tools. If that’s the case, they can use those tools with small adjustments to the instructions we provide. Do note that we cannot provide any dependency- related support for people using the book with a tool that isn’t Conda.  1.3.1 Installing Conda on Windows  1. Go  to  windows-installers  https:  docs.conda.io en latest miniconda.html  2. Find the Python 3.7 versions. 3. Click the link with 64-bit in the name and download the  executable file.  4. On the computer double-click the .exe file. If we are unsure about any setting, accept the defaults. We can change them later.  32     5. Follow the instructions on the screen. 6. When installation is finished, from the Start menu, open  the Anaconda Prompt.  7. In the Anaconda prompt, type conda list and press enter.  1.3.2 Installing Conda on Mac  1. Go  to  macosx-installers  https:  docs.conda.io en latest miniconda.html  2. Find the Python 3.7 versions. 3. Click the link with 64-bit pkg in the name and download. 4. On the computer double-click the .pkg file. 5. Follow the instructions on the screen. If unsure about any  setting, accept the defaults. We can change them later.  6. When the installation is finished, open a terminal window. 7. Type conda list and press enter.  If there is a problem, depending on the Mac go to:    Troubleshooting Conda Installations on Pre-Catalina OSX   Troubleshooting Conda Installations on Catalina or higher  OSX  1.3.3 Installing Conda on Linux  1. Go to https:  docs.conda.io en latest miniconda.htmllinux-  installers  2. Find the Python 3.7 versions. 3. Click the link with 64-bit in the name and download. 4. On the computer, open a terminal. Go to the directory where you saved the file: cd ~ Downloads Make the file exe- cutable: chmod a+x Miniconda3-latest-Linux-x86_64.sh Execute the file: . Miniconda3-latest-Linux-x86_64.sh.  33   5. Follow the instructions on the screen. If unsure about any  setting, accept the defaults. We can change them later.  6. When the installation is finished, close the current terminal  window and open a new one.  7. Type conda list and press enter.  1.3.4 Updating Existing Conda Installation  To update a Conda installation, enter this command:  conda update conda  1.4 Step 2: Install Visual Studio Code  Visual Studio Code  VSCode  is a source code editor. Developed by Microsoft as an open-source project  github.com Microsoft vscode2 , according to Stack Overflow’s 2019 Developer Survey it is the most popular developer environment in the world.  reference: insights.stackoverflow.com survey 20193 . We like VSCode because it is open source, features built-in source control management, and has a huge number of exten- sions.  tool    1.4.1 If VSCode is already installed.  Then skip to section on Step 3: Installing Git.  2https:  github.com Microsoft vscode 3https:  insights.stackoverflow.com survey 2019  34     1.4.2 Installing VSCode on Windows  1. Go to https:  code.visualstudio.com download. 2. Click the Windows download button. 3. On the computer double-click the .exe file. If unsure about any setting, accept the defaults. We can change them later.  4. Follow the instructions on the screen. 5. When the installation is finished, from the Start menu,  open VSCode.  TODO: Setup SSH keys via ask_pass to work with VSCode.  1.4.3 Installing VSCode on Mac  1. Go to https:  code.visualstudio.com download. 2. Click the Mac download button. 3. On the computer double-click the .zip file. 4. Move the file inside to the Applications folder. 5. Follow the instructions on the screen. If unsure about any  setting, accept the defaults. We can change them later.  6. Launch Visual Studio Code from the  Applications direc-  7. Open the Command Palette  fn+F1  and type ‘shell com- mand’ to find the Shell Command: Install 'code' command in PATH command.  tory.  TODO: Consider looking into setting up SSH keys via ask_pass to work with VSCode  1.5 Step 3: Installing Git  Git4 is the predominant version control system used by the pro- fessional software development community.  4https:  git-scm.com   35   If Git is already installed. Then skip to Step 4: Installing PostgreSQL.  1.5.1 Installing Git on Windows and Mac  The easiest way to install Git on both Windows and Mac is to install GitHub’s desktop client. We can find links to either the Windows or Mac downloads at https:  desktop.github.com. Even though we are installing the desktop client, the command- line utility should also be installed at the same time.  If the GitHub Desktop client doesn’t work Should a problem arise with the Git installation from the Desktop client, the git-scm site has excellent instructions to consider: https:  git-scm.com book en v2 Getting-Started- Installing-Git  1.6 Step 4: Installing PostgreSQL  1.6.1 Installing PostgreSQL on Windows  The easiest way to install PostgreSQL on Windows is to go the EnterpriseDB download page at https:  www.enterprisedb.com  downloads postgres-postgresql-downloads and choose the 12.x Win- dows installation. Download the executable and install it.  1.6.2 Installing PostgreSQL on Mac  The best way to install PostgreSQL on the Mac is by following these steps:  36           1. Go to https:  postgresapp.com 2. Click on the “Downloads” tab 3. Choose the most recent release and download it. This  should be the first download option on the page  4. Once downloaded, open the dmg file locally 5. Move the Postgres file in the opened dmg to our  Applica-  tions folder like we would any other application  Once that’s done, we need to configure our $PATH so that we can use PostgreSQL easily on the command-line. To do that, execute this in the terminal:  sudo mkdir -p  etc paths.d && \ echo  Applications Postgres.app Contents Versions latest bin  \ sudo tee  etc paths.d postgresapp  We need to close the terminal window and open a new one for the changes to take effect.  1.7 Summary  Getting a computer setup for development is a bit of work, but worth the effort. Now that we’re done, let’s move on and crash into coding some Django!  37   Part I Hello, World in Django  Figure 3: Let’s start with the basics.  2 Hello, World in Django  When most people learn how to ride a bicycle, they are given the simplest model. Only one gear, simple brakes, and nothing more. Yet the skills we learn on that bicycle stay with us for the rest of our life. Think of this project as our first bicycle. It’s not fancy, it won’t do much. Yet it’s going to provide us with the skills needed to start truly understanding Django.  38       In programming terms, minimal projects like this are called “Hello, World” programs5.  2.1 The “Hello, World” of Python  For example, this is a “Hello, World” program in Python.  print "Hello, world!"   We would save it as hello.py and then run it by typing python hello.py at the command line. Then it would print out:  Hello, world!  As we can see, this program is not a very useful program. It doesn’t do anything except show us how to print a string. But it’s useful if we’re a programmer new to Python, trying to un- derstand what a Python program looks like. It teaches us:    How a very simple Python program is run   The basic Python syntax for printing the string “Hello,    Whether Python is available to run Python programs, or  if we have a problem with our setup  world!”  Likewise, a “Hello, World” Django project would teach us how a very simple Django project works and is run, and it can help us make sure that we have Django set up correctly.  5https:  en.wikipedia.org wiki %22Hello,_World!%22_program  39   2.2 “Hello, World” of Django: Simple on Pur-  pose  The project will be simple, but it will expose the foundations needed to begin your Django journey. We’ll want to keep it on hand as a reference project, one that we go back to on later projects to remind ourselves how the basics are done. What we won’t be doing is expanding this Hello, World project to become a real-world project that does anything meaningful. Just like we wouldn’t use our first bicycle to enter a serious race, this project isn’t meant for serious use. The foundations just aren’t there in the boilerplate code. Later in this book, we’ll show us how to develop a realistic, fully- featured Django project. Be patient. Study the foundations, and we’ll be equipped to get even more out of the later projects in this book. Onward and upward!  2.3 Projects Goals    Get a taste of working with Conda, pip, and Django to-  gether    Understand the minimum Django project   Understand a minimal Django app   Use a minimal Django template   Understand the minimal template components: context  data and method calls  2.4 Prerequisites  We will need to have our computer ready for software develop- ment. If we don’t have it ready, go to The Ultimate Django  40   Setup chapter.  2.4.1 Still Learning to Code?  This book is best once we already know at least a little program- ming. If we are still learning to code, we will benefit from going through at least one intro to programming tutorial before this one. It’s fine if we don’t know everything about Python or HTML when we start this project. Just having a taste of writing simple Python and HTML is fine. We will learn a lot just by following along and doing the exercises.  41   3 Preparation: Install Dependencies  3.1 What’s a Dependency?  A dependency is a package that a project requires in order to run. In our case, the only dependency we will need to install is Django.  3.2 Set Up a New Conda Environment  Create and activate a hellodjango conda environment. First, we’ll need access to the command line:    Windows: Open the Start Menu and choose Anaconda  Prompt.    Mac: Open a terminal window.  In the terminal window, type the following:  conda create -n hellodjango python=3.8  The screen will then display a message that should look similar to this:  The following NEW packages will be INSTALLED:   Proceed  [y] n ?  Type y and hit return. Depending on our computer, internet speed, and if we have done this before, the computer will process for 5 seconds to 5 minutes,  42   then return us to the command-line. Once that’s done, we type this at the command-line:  After that, our command-line should look like something like:  conda activate hellodjango   hellodjango  $  If it’s not exactly what we see above, that’s okay. Just so long as it’s prefixed with  hellodjango , then it’s been done correctly. For the rest of this course, we should always keep the hellodjango conda environment active.  If We Lose the Hellodjango Terminal Don’t worry. We can reactivate the conda environment with these simple instructions:  – Windows: Open the Start Menu and choose Ana-  conda Prompt.  – Mac: Open a terminal window.  In the terminal window, type the following: conda activate hellodjango  3.3 Install Django  Install the latest version of Django into our conda env:  43       pip install django  Collecting django  Collecting pytz  We should see something like this happen:  ████████████████████████████████ 7.4MB 4.4MB s  Collecting sqlparse>=0.2.2  Downloading https:  files.pythonhosted.org packages 55 d1 8ade70e65fa157e1903fe4078305ca53b6819ab212d9fbbe5755afc8ea2e Django-3.0.2-py3-none-any.whl  7.4MB   Downloading https:  files.pythonhosted.org packages ef 53 900f7d2a54557c6a37886585a91336520e5539e3ae2423ff1102daf4f3a7 sqlparse-0.3.0-py2.py3-none-any.whl  Downloading https:  files.pythonhosted.org packages e7 f9 f0b53f88060247251bf481fa6ea62cd0d25bf1b11a87888e53ce5b7c8ad2 pytz-2019.3-py2.py3-none-any.whl  509kB   ████████████████████████████████ 512kB 15.6MB s  Collecting asgiref~=3.2  Installing collected packages: sqlparse, pytz, asgiref, django Successfully installed asgiref-3.2.3 django-3.0.2 pytz-2019.3 sqlparse-0.3.0  Downloading https:  files.pythonhosted.org packages a5 cb 5a235b605a9753ebcb2730c75e610fb51c8cab3f01230080a8229fa36adb asgiref-3.2.3-py2.py3-none-any.whl  3.4 Summary  We just created the hellodjango conda environment. While it doesn’t seem like much, this is a big deal. As we make more and more projects, isolating versions of libraries like Django from project to project becomes very important. We also installed Django and its dependencies. This gave us a tool called django-admin, which lets us run management com- mands. We’ll be using that in the chapters ahead.  44   4 Generate a Starter Django Project  First, let’s make certain we are within the hellodjango conda en- vironment. To do this, check that the command-line is prefixed with hellodjango. Once we’ve done that, type the following:  django-admin startproject hellodjango  This creates a minimal Django project called hellodjango. Type ls on Mac or dir on Windows to check that there’s now a hel- lodjango directory in our current working directory.  4.1 Anatomy of a Bare-Bones Django Project  Open the newly-created project in Visual Studio Code. At the command-line, type:  Take a look at the files that were created. We should see a file structure that looks like this:  code hellodjango  hellodjango ├── hellodjango │   ├── __init__.py │   ├── asgi.py │   ├── settings.py │   ├── urls.py │   └── wsgi.py └── manage.py  45   This is the minimal Django project that startproject creates by default. Let’s look at a few modules.  4.2 manage.py  This manage.py module is something we call to run various Django commands that we’ll be teaching during this project and other projects to follow.  ! Usr Bin Env Python """Django's command-line utility for administrative tasks.""" import os import sys  def main  :  try:  os.environ.setdefault 'DJANGO_SETTINGS_MODULE',  'hellodjango.settings'   from django.core.management import execute_from_command_line  except ImportError as exc:  raise ImportError   "Couldn't import Django. Are you sure it's installed" "and available on your PYTHONPATH environment variable?" "Did you forget to activate a virtual environment?"    from exc  execute_from_command_line sys.argv   if __name__ == '__main__':  main    46   Don’t worry if this code doesn’t make any sense at this time. In fact, for most Django projects this code is never touched by developers.  4.3 settings.py  The settings.py module is much larger than the manage.py mod- ule. It’s where we can globally change Django’s behavior via settings. These settings are special variables identified by their UPPERCASE nature. In Django this is more than just a convention, all formally defined settings must be UPPERCASE and are considered to be constants.    How Django Settings Are Constants  While Python normally doesn’t allow for constant-style variables, this is a special case. The way that the django.conf.settings module works, Django needs to restart for their value to be picked up by the rest of a project. In local development this can happen so fast we barely notice, which is convenient there. Deployment into QA and production is a different story, but that topic is outside the scope of this book. We’ll cover it in our forthcoming deployment extensions.  Here’s an important setting, SECRET_KEY:   SECURITY WARNING: Keep the Secret Key Used  in Production Secret! SECRET_KEY = '39 b-_1aga9eauydabb  b^4+1hmao'  Every time a new Django project is created, a new SECRET_KEY is generated as well. This is part of the security system of Django,  47     and this value is critical for keeping a Django project secure and unhacked. If that sounds like a heavy responsibility, that’s because it is. In later projects we’ll cover how to safely manage SECRET_KEY and other security related settings. In fact, let’s cover another important setting, DEBUG:   SECURITY WARNING: Don't Run With Debug  Turned on in Production! DEBUG = True  When DEBUG is set to True, we get very sophisticated and very understandable debug messages while we are developing. In pro- duction, however, it must be set to False.    Any Django setting with a SECURITY WARNING must be taken seriously. Doing so ensures that our projects are much safer from evil people who want to do bad things.  4.4 Other Settings  One thing to note is that many sections inside settings.py have comments with links to the oﬀicial documentation. As we get more familiar with Django, we’ll find these links invaluable. Ex- ample:   Internationalization  https:  docs.djangoproject.com en 3.0 topics i18n   LANGUAGE_CODE = 'en-us'  TIME_ZONE = 'UTC'  48     USE_I18N = True  USE_L10N = True  USE_TZ = True  If a setting or group of settings doesn’t have a reference to the Django documentation, it’s still possible to look it up. In many cases we can enter the word “Django” and the name of the setting into Google or other search engines and get a result. Try this with ALLOWED_HOSTS.  4.5 Exercise  Look up each setting from settings.py in the following docs:    Settings topic overview6   Settings reference docs7  For now, don’t change anything. Instead, take a few minutes to jot down notes on the ones we think are interesting or important. In the future we’ll modify these settings to empower our projects to do great things.  6https:  docs.djangoproject.com en stable topics settings  7https:  docs.djangoproject.com en stable ref settings   49   5 Create a Database and Run the  Project  5.1 Ensure We Are in the Hellodjango project  If not done so yet, cd into the outer hellodjango folder:  List the contents of the directory, using ls on Mac Linux or dir on Windows, to ensure we are in the same directory as manage.py. We should see this output:  cd hellodjango  hellodjango manage.py  The current directory should contain an inner hellodjango direc- tory and a manage.py file.  5.2 Creating the Database  When we run the migrate command for the first time, a database gets created, and some starter tables in the database are set up. At the command line, type:  python manage.py migrate  We will see output that looks something like this:  50   Operations to perform:  Apply all migrations: admin, auth,  contenttypes, sessions  Running migrations:  Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_a... OK Applying admin.0003_logentry_add_acti... OK Applying contenttypes.0002_remove_con... OK Applying auth.0002_alter_permission_n... OK Applying auth.0003_alter_user_email_m... OK Applying auth.0004_alter_user_usernam... OK Applying auth.0005_alter_user_last_lo... OK Applying auth.0006_require_contenttyp... OK Applying auth.0007_alter_validators_a... OK Applying auth.0008_alter_user_usernam... OK Applying auth.0009_alter_user_last_na... OK Applying auth.0010_alter_group_name_m... OK Applying auth.0011_update_proxy_permi... OK Applying sessions.0001_initial... OK  Now if we type ls on Mac Linux or dir on Windows, we will see this output:  db.sqlite3 hellodjango manage.py  What’s that new file? db.sqlite3 is the database that got created.  5.3 Start Up Runserver  At the command line, type this to start up Django’s development server:  51   python manage.py runserver  We should see something like this:  Watching for file changes with StatReloader Performing system checks...  System check identified no issues   0 silenced .  January 25, 2020 - 19:34:39 Django version 3.x using settings 'hellodjango.settings' Starting development server at:  http:  127.0.0.1:8000   Quit the server with CONTROL-C.  This means that the development server is now running on our computer.  5.4 Runserver Has Started Up  To go to our Django site, visit 127.0.0.1:80008 in a browser.  5.5 Success!  8http:  127.0.0.1:8000  If we see this, our Django project is now running on runserver  the local development server .  52   Figure 4: It worked! Hooray!  6 Create a Django-Superuser  In order to log into the Django admin, we need to create a Django superuser. Ordinary users will not be able to access the admin.  6.1 Stop runserver if It Is Still Running  Go to your terminal window. If runserver is still running, use CTRL-c to stop it. Note: Make sure to press Control-c, not Command-c.  53       6.2 Run createsuperuser  Enter a username, email, and password for our Django superuser. For this minimal project, use the values of admin for the username, admin@example.com for the email, and create an eight  8  or more character password.  python manage.py createsuperuser Username  leave blank to use 'scoopy' : admin Email address: admin@example.com Password: Password  again : Superuser created successfully.    Copy this password into a password manager!  It’s bad practice to use simplistic passwords, even for local development. We want to promote strong security habits and this is one of them. Also, don’t stick passwords into plaintext or spreadsheet files. Instead, lean on secure pass- word managers like 1Password or open source options.  6.3 Summary  We just created a superuser for a Django project. Out of the box this superuser has access to Django’s admin tool. This allows them to make changes to database records, including the user list. As one might imagine, this is a very powerful role and not to be taken lightly.  54     7 Practice Using the Admin  7.1 Restart runserver  If runserver isn’t on, restart it in the shell:  python manage.py runserver  7.2 Visit the Admin  In our browser, go to 127.0.0.1:8000 admin 9  the previous URL +  admin  . We should see the admin login page:  9http:  127.0.0.1:8000 admin   55       Since we are not logged in, the Django admin redirects us to its login screen.  7.3 Log in as Our Superuser  Enter the Django superuser’s username “admin” and password now. Then click “Log In”.  7.4 Explore the Admin  In a barebones Django project, the admin is empty except for the Authentication and Authorization tools:  Explore everything in the Admin. Click on various things, try entering data, and get a feel for what the Django admin has provided so far. Don’t worry if things break, we can and will quickly recreate the database. In fact, we cover that in the next section.  56       7.5 Recreating the Hello, World in Django  Database  Let’s recreate the database.  7.5.1 Step 1: Stop Runserver  At the command-line, type ctrl-c. This should stop the server.  7.5.2 Step 2: Delete the Database  In Visual Studio Code, find and right-click on the db.sqlite3 database file. Choose the Delete option.  7.5.3 Step 3: Recreate the Database and Superuser  At the command-line, run migrate again:  python manage.py migrate  Once the database is created, we can recreate the superuser:  python manage.py createsuperuser  7.6 Summary  In this chapter we familiarized ourselves with not just the Django admin, but also creating the superuser. We even deleted the database and recreated the Django admin user. This should  57   give us confidence about exploring systems in the future. Part of being a good developer is knowing that if we can restore a system easily, that gives us the luxury of being able to explore how to break it.  58   8 Generate a Homepage App  8.1 Stop runserver if Needed  If we still have the Django development server running, stop it with CTRL+c.  8.2 Generate a Starter Django App  Use the startapp management command to create a new Django app called homepage:  python manage.py startapp homepage  If something goes wrong If this doesn’t work, double-check that we’re still inside the outer hellodjango project directory, at the same level as manage.py.  8.3 Anatomy of a Simple 1-App Django  Project  The startapp command created a new directory in our project called homepage. Switch back to Visual Studio Code. Expand the homepage direc- tory to see what files it contains. We should see this directory file structure:  59       hellodjango ├── db.sqlite3 ├── hellodjango │   ├── __init__.py │   ├── asgi.py │   ├── settings.py │   ├── urls.py │   └── wsgi.py ├── homepage │   ├── __init__.py │   ├── admin.py │   ├── apps.py │   ├── migrations │   │   └── __init__.py │   ├── models.py │   ├── tests.py │   └── views.py └── manage.py  8.4 Exercise  What files are in the new Django app created by startapp? Study the files of our new homepage app. Don’t touch them yet, just get familiar with the code inside each one.  8.5 Main Django Project vs Django Apps    A Django project is a folder containing all the code   Python, templates, etc.  needed to run a website.   A Django app is a folder within a Django project.   Django apps are isolated components that do one specific  thing in a Django project.    Combining Django apps is one of the primary things we  do when we build a Django project.  60   9 Prepping the Project for Templates  Before we can start writing views that use templates, we need to modify our project’s settings.  9.1 Configure Your Templates  Search the settings.py module for the TEMPLATES setting. It’s a list of dictionaries that looks like this:  'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], 'APP_DIRS': True, 'OPTIONS': {  'context_processors': [  'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages',  TEMPLATES = [ {  ],  },  }, ]  Notice how DIRS is an empty list. As of now, Django doesn’t know where to look for templates. We’ll change that. Go ahead and modify that slightly, by adding os.path.join BASE_DIR, "templates"  to the DIRS list on the fourth line. Here’s how it should look:  61   TEMPLATES = [ {  ],  },  }, ]  9.2 Save!  'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join BASE_DIR, "templates" ], 'APP_DIRS': True, 'OPTIONS': {  'context_processors': [  'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages',  This change tells Django to look inside a templates directory within the base directory of our project, which we’ll create later in this book.  As always, let’s not forget to save our work! Save settings.py so that Django’s development server picks up the change we made.  9.3 Lists? Dictionaries?  We mentioned some Python terms in this lesson. While we assume in this book that readers already know the basics of Python, here’s a recap in case we forgot what these terms mean.  62   9.3.1 What’s a Python List?  In Python, a list consists of comma-separated values wrapped in square brackets. For example:  ['Ice cream!', 2, 'cones', 3, 4]  Lists are one of the most important and frequently-used data types in Python. If we’re new to lists, we’ll greatly benefit from going through the Lists section of the oﬀicial Python tutorial10. The rest of that tutorial is highly recommended.  9.3.2 What’s a Python Dictionary?  A set of key: value pairs. For example, here’s a dict of ice cream flavors, where the keys are the flavors in English and the values are the corresponding flavors in Spanish:  {'vanilla': 'vainilla', 'chocolate mint': 'choco menta', 'coffee': 'café'}  If we’re not familiar with dicts in Python, we strongly rec- ommend going through the Dictionaries section of the oﬀicial Python tutorial11. Type the examples into the Python shell and get comfortable adding and retrieving values. 10https:  docs.python.org 3 tutorial introduction.htmllists 11https:  docs.python.org 3.8 tutorial datastructures.htmldictionaries  63   10 Add a Simple Homepage View  Open the views.py file of the homepage app. Remove the code that is there and replace it with the following:  from django.views.generic import TemplateView  class HomepageView TemplateView : template_name = 'index.html'  Congrats, we’ve written our first Django view! What we’ve done:    We created the Python class HomepageView   HomepageView subclassed TemplateView   Associated the index.html template with the class  10.1 Get to Know URL Routing  In the same inner hellodjango directory containing settings.py, there’s also a file called urls.py. Let’s open it up in the text editor. Notice that it defines a list of urlpatterns:  """hellodjango URL Configuration  The `urlpatterns` list routes URLs to views. For more information please see:  https:  docs.djangoproject.com en 3.0 topics http urls   Examples: Function views  1. Add an import:  from my_app import views  64   2. Add a URL to urlpatterns:  path '', views.home, name='home'   Class-based views  1. Add an import: 2. Add a URL to urlpatterns:  from other_app.views import Home  path '', Home.as_view  , name='home'   Including another URLconf  1. Import the include   function: from django.urls import include, path 2. Add a URL to urlpatterns:  path 'blog ', include 'blog.urls'    """ from django.contrib import admin from django.urls import path  urlpatterns = [  path 'admin ', admin.site.urls ,  ]  Right now, there’s only one item in the urlpatterns list: a URL pattern for admin . That corresponds to the Django admin UI, which we saw earlier. When a browser requests a page starting with admin   i.e. matching the regular expression 'admin ' , it gets routed by the server to admin.site.urls. In a typical Django project, this file will be full of URL routes. But it starts almost empty.  10.2 Add a URL Pattern for the Homepage  First, import a new HomepageView into urls.py. Right below the Django imports in urls.py, add this line:  from homepage.views import HomepageView  Then add this URL pattern to the urlpatterns list, right after the one for the Django admin:  65   path '', HomepageView.as_view  , name='home' ,  What we’ve done thus far:    When a browser requests a page matching the blank value  of ' '  that is, the root at http:  127.0.0.1:8000     Route it to HomepageView.as_view  .   And name this route home  Remember how we defined a HomepageView class in the views.py of our homepage app? That’s what we’re importing here.  HomepageView.as_view   generates a callable object The callable object is analogous to a function. Django calls this object by passing in an HttpRequest generated by the user, and then the object returns an HttpResponse. Django supplies the HttpResponse back to the user. Don’t worry if this doesn’t make sense yet. Much later in this book we go over this explicitly in the testing chapters.  10.3 Double-Check the Code  Putting it all together, the code part of urls.py should now look like this:  from django.contrib import admin from django.urls import path  from homepage.views import HomepageView  66       urlpatterns = [  ]  path 'admin ', admin.site.urls , path '', HomepageView.as_view  , name='home' ,    10.4 Terminology: “Wire in the URL”  Sometimes we refer casually to defining a URL pattern as wiring in a URL for a view. When we say “Wire in the URL”, that means to associate the Django view we just wrote with a web location on our site.  10.4.1 Start Up Runserver Again  If Django isn’t running runserver, start it up:  python manage.py runserver  10.5 Refresh the Page and Trigger an Error  We’re going to purposefully trigger an error. That’s okay. We’re doing it intentionally. Go back to the browser, and refresh http:  127.0.0.1:8000. If we did things right, we should see an error page with a header that says:  TemplateDoesNotExist at    67     If we see that above error, we are doing it right! Specifically, our view is correctly wired into the urls.py module, but its template, index.html, doesn’t exist yet. Don’t worry, we’ll demonstrate how to do that in the next chapter.  68   11 Create Our First Django Template  Templates are what Django uses to generate the HTML that is shown in browsers.  11.1 Create a Templates Directory  At the same level as manage.py, create a templates directory:  We can do this through the text editor GUI if we prefer. Our project file structure should now look like this:  mkdir templates  hellodjango  ├── hellodjango  ├── homepage  ├── templates  └── manage.py  11.2 Add Index Template  Inside of templates , create a file called index.html containing the following:   Greetings   Hello, world!   As of now, this is just plain HTML.  69   11.3 Start Up Runserver  If runserver isn’t running, go ahead and start it now:  python manage.py runserver  11.4 View the First Page  Open the browser and go to 127.0.0.1:800012. What we see should look something like the image below.  Figure 5: Greetings, Hello World  The error went away because we created the template that Home- pageView was looking for. 12http:  127.0.0.1:8000  70       11.5 Recap  We now have a homepage. Here’s how it works:    Our browser requests 127.0.0.1:800013   Django’s development server looks up where to route the  request    Since the index was requested, it matches the path of ''   Therefore the matching URL pattern is:  path '', HomepageView.as_view  , name='home' ,    HomepageView is the view corresponding to that URL:  class HomepageView TemplateView : template_name = 'index.html'    It’s a TemplateView, so it renders its template and returns  the result    We see the page in the browser!  11.6 Understanding Views and the Template-  view Class    Views are how a Django project communicates with the user. They send out web pages, JSON, spreadsheets, PDFs, and so much more.  13http:  127.0.0.1:8000  71     Templates are often used by views to render HTML for    A TemplateView renders a Django template and sends it to  web pages.  a browser.  72   12 Working With Variables in Tem-  plates  Without variables we would not have a dynamic web applica- tion, there would be no way to interact with the data in the database, essentially we would have a standard static website. For example, we couldn’t log in to a website to get results for just the things we care about. By using variables, web pages can display content specific to each user.  12.1 Our First Templated Value  Right now, templates index.html is a Django template that only contains static HTML. But it can also contain variables that get populated dynamically from Python code. Open up templates index.html and add the following line at the end:   {{ my_statement }}   The curly braces around my_statement mean that it won’t be displayed on the page as-is. Instead, it’ll be evaluated on the Python side and then the result will be displayed.  12.2 What Is my_statement?  At this point we haven’t defined my_statement yet in our Python code. It can be any of the following:    A Python expression, such as a string, number, or instan-  tiated object    A function or method call  73   12.3 Extend HomepageView  Open up the homepage app’s views.py again. So far, the Home- pageView is this:  class HomepageView TemplateView : template_name = 'index.html'  We’re now going to show you how to define a view method called get_context_data  . This is a special method that lets you pass variables to your template. Right below template_name = 'index.html', add a blank line. Then below it, add this method to your HomepageView class:  def get_context_data self, **kwargs :  context = super  .get_context_data **kwargs  context['my_statement'] = 'Nice to see you!' return context  Look carefully at the line involving my_statement. There, you defined a context variable called my_statement. You assigned it the value of Nice to see you!. Note that context is a Python dictionary. my_statement is a key, and Nice to see you! is its corresponding value.  12.4 Refresh the Homepage  Go back to the browser, and refresh 127.0.0.1:800014.  If run- server isn’t still running from before, start it up again.  The value of {{ my_statement }} should now be replaced with Nice to see you!  14http:  127.0.0.1:8000  74   Figure 6: Greetings  12.5 Exercise: Play Around!  Go ahead and modify the context data, either by changing the value of my_statement or adding new keys and values. This prac- tice is important. Django developers working with templates get very experienced working with get_context_data.  12.6 Common Questions  12.6.1 What Is a Method?  A method is a Python function that’s a member of a class. In our example, get_context_data   is a function that’s a member of the HomepageView class.  75       Further reading:  in-python15    stackoverflow.com questions 3786881 what-is-a-method-  15https:  stackoverflow.com questions 3786881 what-is-a-method-in-python  76   13 Calling View Methods From Tem-  plates  The standard Django way to add data to a template’s context is via get_context_data  . Here’s an alternative approach. Here, we’re going to add data by calling a method and displaying the result.  13.1 Define a View Method  Add the following say_bye method to the HomepageView class:  class HomepageView TemplateView :  Don't add this line!  ...  Don't add this line! def say_bye self :  add this line  return 'Goodbye'  and this line too!  13.2 Call the View Method From index.html  Add this to the bottom of our index template:   {{ view.say_bye }}   Notice something strange: in the template, we call the say_bye   method, but there are no parentheses after it. That’s because Django templates intelligently check to see if something can be called as a method.  77   13.3 Reload the Homepage  Go back to the browser, and refresh 127.0.0.1:800016. We should now see the return value of say_bye   displayed on our homepage.  Figure 7: Greeting with view method    How Is a View Method Different From Context  Data? It’s the difference between evaluating a variable and eval- uating a function call.  Context data Variables used in the template.  16http:  127.0.0.1:8000  78         View methods Functions that we can call from the tem-  plate.  For now it’s a small distinction. Typically projects rely on Context Data, but there are advanced use cases for using view methods instead.  79   14 Our First Project is Complete!  Congratulations! By now we understand what makes up a very minimal Django project. We recommend keeping the hellodjango project we created as a reference project, so we can refer back to it when we need to revisit how Django views, templates, and URL patterns work together.  14.1 Summary  We started off with a barebones Django project that we gener- ated with django-admin startproject. We created a database and started up Django’s development server. Then we created a Django superuser so that we could access the Django admin. We explored the admin UI. Next, we added a simple Django app to the project. We called it “homepage” and explored what files it gave us to start with. After that, we learned about views and templates in Django. We created our first view by subclassing TemplateView. We connected it to a URL pattern and a simple static HTML tem- plate. Finally, we turned the static HTML template into a dynamic one. We learned how to put variables into the template and populate them in our Python code. We also learned how to call view methods from our template.  14.2 Next Steps  Now that we’ve finished the Hello, World in Django project, let’s move on to the EveryCheese on the next page. It’s a much  80   deeper dive into Django development and is based on real-world project development.  81   Part II EveryCheese  82   15 The EveryCheese Project  We’re your friendly hosts, Daniel and Audrey, and we love cheese. This tutorial is based on real-world project development, teaching the fundamentals needed to build professional projects. It includes:    Type-along lesson plans to cover core concepts   Code examples for each section   Tutorial project code that prepares students for more ad-  vanced techniques  15.1 Prerequisites  We will need to have our computer ready for software develop- ment. If it isn’t ready, follow the instructions in the chapter called The Ultimate Django Setup. We’ll want to have basic Django experience before starting. If the reader hasn’t ever touched Django before, we recommend the previous project in this book, Hello World in Django.  15.2 Prepare the EveryCheese Programming  Environment  As mentioned earlier in this book, Conda is a tool for creating isolated Python environments. We use it with pip in this lesson. If this is starting to feel familiar, that’s a good thing. Being practiced at isolating programming environments is a critical skill for any serious developer.  83   15.3 Create a New Virtual Environment  Create and activate a new Conda environment called everycheese:  conda create -n everycheese python=3.8 conda activate everycheese  After that, our command-line should look like something like:   everycheese  $    Don’t reuse pre-existing Conda envs for new  projects! It’s always good to start fresh with a new Conda env. This way old and new projects won’t collide. We’ll still be able to maintain successful but older projects and experiment with the latest and greatest pieces of technology.  15.4 Reactivating Conda Environments  Sometimes we need to reactivate our conda environment. There’s lots of reasons to do this, including:    Our computer needed to restart for any reason   We just bought a new computer   Sometimes a second  or third  terminal window is very  useful  84     To do this, in the terminal type:  conda activate everycheese  15.5 Summary  If this feels like a repetition of what we did in the Hello, World in Django tutorial, that’s intentional on our part. We can’t re- inforce enough the importance of knowing how to easily move from one programming environment to another. It’s a founda- tion every software developer should know, be they coding with Django, Python, JavaScript, or pretty much anything else.  85   16 Using Cookiecutter and Template  The first tool we install into our projects is Cookiecutter, which we’ll be using in future extensions and books.  16.1 Install the Cookiecutter Library  Installing it the first time may take up to 30 seconds, as you might not have Cookiecutter’s dependencies already cached on your system. At the command line, type:  conda install -c conda-forge cookiecutter  There will be output along these lines:  Collecting package metadata  current_repodata.json : done Solving environment: done   Proceed  [y] n ?  Type y and then press the return button. We should see some- thing like:  Downloading and Extracting Packages  84 KB requests-2.22.0  148 KB certifi-2019.11.28 future-0.18.2  715 KB python-dateutil-2.8.  220 KB     100%    100%    100%    100%  86    214 KB cffi-1.13.2  32 KB markupsafe-1.1.1  591 KB cryptography-2.8  14 KB poyo-0.5.0  170 KB chardet-3.0.4  61 KB click-7.0 pycparser-2.19  172 KB ca-certificates-2019  145 KB  91 KB jinja2-2.10.3  8 KB whichcraft-0.6.1 idna-2.8  102 KB  370 KB binaryornot-0.4.4  1.9 MB openssl-1.1.1d  83 KB pyopenssl-19.1.0 urllib3-1.25.7  160 KB  10 KB jinja2-time-0.2.0  23 KB six-1.14.0  83 KB cookiecutter-1.7.0 arrow-0.15.5  97 KB  27 KB pysocks-1.7.1     100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%    100%  At this time, when we install Cookiecutter, 23 other packages are also installed. These are Cookiecutter’s dependencies and are necessary for Cookiecutter to do its magic. These are the beginning of the tools we’ll be using to create the Everycheese project. Now that we have Cookiecutter installed, let’s use it! This lesson is all about using Cookiecutter with django-crash-starter to create a project skeleton.  87   16.2 Cookiecutter Project Templates  A Cookiecutter project template is a version control repository containing a bunch of files. Those files are used to generate a starter project of some sort. In Cookiecutter parlance, these templates are called Cookiecutters. The django-crash-starter project template is at: https:  github. com roygreenfeld django-crash-starter. It provides the foundation for this project and the various Crash Course Extensions.  16.3 Using django-crash-starter  Let’s go!  16.3.1 Go to Our Projects Directory  Using the command line, navigate to the place on the computer our coding projects are kept. For example, we keep ours in a directory called projects inside our home directory. We would go into ~ projects:  cd ~ projects   On Windows:  cd c:\projects  Change directories as needed now, so that we are in the right place to create a new Django project.  88   16.3.2 Run the Cookiecutter Command  Here, use the django-crash-starter template to power Cookiecut- ter. Type this at our command line:  cookiecutter gh:roygreenfeld django-crash-starter  This means:    Run the command called cookiecutter now.   Use https:  github.com roygreenfeld django-crash-starter as  the Cookiecutter project template.  When we first run this command, the result should look like:  Cloning into 'django-crash-starter'... remote: Counting objects: 3955, done. remote: Compressing objects: 100%  142 142 , done. remote: Total 3955  delta 85 , reused 0  delta 0 , pack-reused 3811 Receiving objects: 100%  3955 3955 , 722.02 KiB  0 bytes s, done. Resolving deltas: 100%  2425 2425 , done. Checking connectivity... done. project_name [EveryCheese]:  That last line is a prompt asking for the name of the project. Default values are in the brackets. For example, by default, our project is going to be called “EveryCheese”. Go ahead and hit enter for each value.  89   project_name [EveryCheese]: project_slug [everycheese]: description [The Ultimate Cheese Index!]: author_name [Your name here]: domain_name [everycheese.com]: email [your-name-here@example.com]: timezone [UTC]: windows [n]: Select database: 1 - PostgreSQL 2 - SQLite Choose from 1, 2 [1]:  Let’s not worry if we don’t understand what every single value means. We’ll learn more as we progress through this book.  16.4 What Happened?  We’ve now used django-crash-starter to generate boilerplate code for our Django project! A directory called everycheese  should have been generated in our current working directory. Check that it exists by typing ls on Mac or dir on Windows at the command-line. We should see the following:  everycheese   If it’s there, you’re ready to move on to the next lesson.  90   16.5 Tips and Troubleshooting  16.5.1 Delete and Re-Clone!  If you have used django-crash-starter before, we may see this message when we run cookiecutter:  You've cloned  Users audreyr .cookiecutters   django-crash-starter before. Is it okay to delete and re-clone it? [yes]:  We can hit Return to accept the default of [yes].  Note: The only time we wouldn’t want to pick [yes] is if we manually edited the files in that directory for some strange rea- son and didn’t want them to be overwritten. It’s best not to edit files in ~ .cookiecutters , though.   16.5.2 Unfamiliar Options  If django-crash-starter offers us an option that we haven’t listed above, go with the defaults for that option.  It may change after the printing of this book! We’ll try not to change it too much.   16.5.3 Fear of Making a Mistake  Don’t worry about accidentally generating our project with the wrong django-crash-starter options. That’s because we can always look through the django-crash- starter source tree to see what code would have been generated if we had picked a different option. The next lesson will give us some insight into this.  91   Figure 8: The Tasty Cookiecutter Logo  16.6 A Little Cookiecutter Background  Cookiecutter is a popular cross-platform project template gen- erator created by author Audrey Roy Greenfeld in the summer of 2013. The simplicity of the UI hides a sophisticated frame- work that can be extended easily for use in frameworks and other tools. Because of this combination of simple UI and extendability, there are approximately 3500 project templates powered by Cookiecutter on GitHub, and an unknown number of private ones. In the past six years, we’ve yet to work for an employer or consulting client who wasn’t using Cookiecutter.  92       17 Exploring the Generated Boiler-  plate  Now we’re going to explore the boilerplate that Cookiecutter generated from the following components:    The django-crash-starter project template.   The values you entered.  17.1 Some Basic Components  Open everycheese  in your text editor. If you’re using VS Code, you can do this by typing:  code everycheese   17.1.1 Readme  If we go into README.md, we’ll see that the header, EveryCheese, comes from what we entered as project_name. Every Django project that we work on has a README which provides an overview of the project. You’ll want to add more to the starter file. Typically it will also include a list of features of the project.  17.1.2 Settings  Notice that a config  directory got generated. Among other things, inside is a settings  directory with a bunch of settings files for different purposes:  93   base.py Any settings that are used identically in all places local.py Local development on our computers production.py Live production server settings  If we go into everycheese config settings base.py, we can see that a value was set for TIME_ZONE:  TIME_ZONE = 'UTC'  This value came from what we entered as timezone during the django-crash-starter prompts. For everything that Cookiecutter asked questions about, it has filled out the values throughout the project.  17.1.3 Contributors  If we go into config settings base.py, we can see that this got placed in there:  ADMINS = [ "Your name here", "your-name-here@example.com" ]  Whoa, that’s not quite right! Or is it? When we created our project using Cookiecutter, we accepted the default values. Those are the ones now seen in the base.py settings file. Go ahead and change those values to match your name.  17.2 Summary  django-crash-starter is more than just README and configura- tion. It comes with a users  app for account management in-  94   cluding django-allauth preconfigured, templates that work with Bootstrap right out of the box. This kind of boilerplate normally takes forever to get right. For- tunately, django-crash-starter gets it out of the way. There’s a lot to cover. We’ll get to explaining more of it in the next chapter and the rest of this book.  18 Starting Up Our New Django  Project  The code in everycheese  is a real Django project with tons of working features.  18.1 Let’s Run the Project  We can run EveryCheese, just like any other Django project. Let’s make that happen!  18.2 Go Into the EveryCheese Directory  Navigate into the main everycheese  directory:  cd everycheese  Generally, this is where we’ll be working. Now, if we type ls, we should see a bunch of files and directories. One of these should be manage.py.  95   createdb: could not connect to database postgres: could not connect to server: No such file or directory Is the server running locally and accepting connections on Unix domain socket " tmp .s.PGSQL.5432"?  18.3 Start PostgreSQL if Needed  Different PostgreSQL installers make different decisions about whether PostgreSQL automatically runs as a service upon sys- tem startup. To check if PostgreSQL is running, try typing this:  createdb  If PostgreSQL isn’t running, we’ll see an error message along the lines of this:  And if PostgreSQL is not already running, we’ll need to start PostgreSQL:    On Mac: Open up Applications > Postgres.app17   On Windows: PostgreSQL is most likely running as a ser- vice that automatically starts when Windows starts. If not, start it manually by choosing it from the Start Menu.   On Linux: Start the service if it’s not already running with  sudo service postgresql start  We’ll need PostgreSQL running to create a PostgreSQL database. 17http:  postgresapp.com   96   18.4 Create the Database  18.4.1 What to Name It?  Let’s look at the common settings file, inside of config settings . If we open up base.py and look for the DATABASES setting, we can see that the database is called everycheese:  DATABASES = {  }   Raises ImproperlyConfigured Exception if DATABASE_URL Not in os.environ 'default': env.db 'DATABASE_URL', default='postgres:   everycheese' ,  This is the default, which is used by local.py for local develop- ment. If we open up local.py, we’ll see that there is no DATABASES setting in there, and so it defaults to the above. In production, we do not provide a default, as we can see in production.py. We have to handle that ourselves. We’ll explain more about that when we get around to deployment.  18.5 How to Create It  To create a database called everycheese, we can type this at the command line:  createdb everycheese  If there are any problems, one of the following troubleshooting segments might prove useful:    Troubleshooting PostgreSQL: Role Does Not Exist   Troubleshooting PostgreSQL: Cannot Create Database  97   18.6 Install the Dependencies  Inside of the requirements  directory are the environment-specific requirement files for our project:    base.txt for any packages that are used in all places.   local.txt for packages required for local development on  our computer.    production.txt for our live production server packages.   test.txt for any packages needed just for the tests.  Make sure our everycheese Conda environment is active. If it isn’t active, follow the instructions in Reactivating Conda Envi- ronments. Then install the local requirements:  pip install -r requirements local.txt  If there are problems installing the dependencies, we may cover the solutions in our Troubleshooting appendix:    Troubleshooting PsycoPG2   Troubleshooting GCC Errors on the Mac   Troubleshooting the MS Visual Studio Build Tools Error  18.7 Run the Migrations  Whenever we set up a Django project, we want to run migrate in case any migrations need to be run. Type this at the command line:  98   python manage.py migrate  18.8 Start Up Runserver  Finally, start Django’s local development server so we can see the project in action:  python manage.py runserver  Open a web browser to 127.0.0.1:800018. We should see a bare- bones EveryCheese website running. 18http:  127.0.0.1:8000  99   19 Cheese Boilers  When cheese is melted in industrial processing, it goes into cheese boilers. Cheese boilers have boilerplates. Do not remove the boilerplate while a cheese boiler is in operation, or else the cheese will flow out of the boiler.  Figure 9: Illustration of cheese boiler, and the location of its boilerplate  100       20 Initializing the Git Repo Commit-  ting and Pushing  We’ve generated a bunch of starting Django project boilerplate and seen the barebones site running on the development server. Before we move on, we’ll walk us through creating a repo so we can start saving our changes periodically.  20.1 Why?  We’re going to be building upon this code and changing a lot of files. The problem is that it’s easy to break things and lose our work. That’s where version control comes in.  20.2 We’ll Use GitHub  We’re going to create a private repo for the project on GitHub.    Sign up for a GitHub19 account if we don’t have one yet.   Add an SSH key20 to our GitHub profile, so that we can  push code changes to our repo.  20.3 Create the GitHub Project  Then go to https:  github.com new and fill it out with:    Project name: everycheese 19https:  github.com 20https:  github.com settings keys  101     Description: The ultimate cheese index.   Visibility Level: Private  Click the Create repository button.  Figure 10: Create repository on GitHub  102       20.4 Examine the GitHub Instructions  GitHub provides instructions for adding files from an “Existing folder or Git repository.” We have an existing folder of code. We’re going to skip changing directory into our folder, since we’re already in there. We’re going to walk us through what these instructions actually mean.  20.4.1 Initialize the Local Repo  If we still have runserver running, we can stop it and type these commands in the same terminal. Or we can open a new terminal if prefered. It doesn’t matter. Initialize the current folder as a Git repo:  Add the GitHub remote to the repo as the origin. Replace ou- rusername with our actual GitHub username:  git remote add origin git@github.com:ourusername everycheese.git  20.4.2 Add Our Files  Add all our files to the first commit to the project:  git init  git add .  103   Commit the first commit with a brief, descriptive message:  git commit \ -m "Boilerplate files generated from the `django-crash-starter` project template."  Push our changes:  git push -u origin master  20.5 Verify That the Files Got Committed  In our browser, refresh our project page. Click on Files in the right sidebar and make sure that all our files are there. Go back to our terminal and check the git log as well:  git log  Now we are free to code without worrying about losing our work if we accidentally break something and can’t fix it.  104   21 Git Is Not for Stinky Cheeses  You know what really, absolutely doesn’t belong in a git repo? Stinky cheese!  Figure 11: Stinky cheeses getting kicked out by a foot.  Don’t even try to put it in there! That’s because other files may leave a repo due to the pungent odor. No file wants to be in a stinky cheese-filled repo.  105       22 What We Get From The Users App  django-crash-starter provided us with a simple users app, precon- figured right out of the box. Let’s explore what it gives us.  22.1 Register a Normal User  Start up runserver again:  python manage.py runserver  Go to http:  127.0.0.1:8000 to see the starter EveryCheese web- site. Click on the “Sign Up” link in the navbar. This will bring us to a registration form. This is where the visitors to our website will create their own user accounts. We’re going to try out the website’s registration system now. Enter these values:    email: cheesehead@example.com   username: cheesehead   password: *QjkXCPUm8iuaeP    Copy this password into a password manager!  It’s bad practice to use simplistic passwords, even for local development. We want to promote strong security habits and this is one of them. Also, don’t stick passwords into plaintext or spreadsheet files. Instead, lean on secure pass- word managers like 1Password or open source options.  106     Figure 12: Registration form  22.2 Verify Our Email  When we submit the form, we’ll be asked to verify our email address before we can continue on the website:  107       Figure 13: Verify email page  22.2.1 Grab the Email Confirmation Link  We’re not going to get an email confirmation by regular email. django-crash-starter isn’t set up to send out real emails during local development, and for good reason. We wouldn’t want to accidentally send out emails to real people during local develop- ment. However, django-crash-starter has configured our project to dis- play all outgoing emails in the console, where runserver is run- ning. Go to the console window, the one where we started up runserver. We should see the confirmation email there. Copy paste the email confirmation link into the browser. We will then be taken to a page with a Confirm button. Then click Confirm to confirm the user account.  108       Figure 14: Verification email in console window  22.3 Why Are Emails Printed in the Console?  Open settings local.py in a text editor. Find the EMAIL_BACKEND setting.  109       Figure 15: Page with Confirm button  EMAIL_BACKEND = env 'DJANGO_EMAIL_BACKEND',  default='django.core.mail.backends.console.EmailBackend'   Now open settings production.py and find the EMAIL_BACKEND set- ting. Compare it.  EMAIL_BACKEND = "anymail.backends.mailgun.EmailBackend"  For local development, we use Django’s console email backend, which prints all emails to the console. But in production we switch to the Mailgun backend, which sends out emails to users.  22.4 Explore the User Profile  If needed, sign in with the new account.  110       Click through to the user profile. We might not recognize it as a user profile because of how minimal it is to start. It looks like this:  Figure 16: Minimal user profile  22.5 Edit User Data  Let’s see what user info is editable:  1. Click on My Info. 2. Try giving the user a full name. 3. Click Update and see where the data is displayed in the  user profile.  22.6 Introducing UserUpdateView  Remember where we entered a value for Name of User? That page corresponds to UserUpdateView. An UpdateView is a view for editing an existing object. In this case, the object edited is the User object.  111       Figure 17: UserUpdateView  We’ll show us the code for this shortly. But first, let’s look at a simpler view together.  22.7 Introducing UserDetailview  After entering Name of User, we were redirected back to the user profile. This view is the UserDetailView. A DetailView displays detailed data for a particular object. Here, it displays info about our User object. Open up views.py of the users app and find UserDetailView:  class UserDetailView LoginRequiredMixin, DetailView :  model = User  These Next Two Lines Tell the View to Index  Lookups by Username slug_field = 'username' slug_url_kwarg = 'username'  112       Figure 18: UserDetailView  Some things to notice:    UserDetailView is a subclass of Django’s generic DetailView.   The view can only be accessed by logged-in users because  of LoginRequiredMixin.    We have to explicitly specify the model with model = User.   Note the URL  users cheesehead  and how username is used  as a slug in the URL.  22.8 Understand the Name Field  Where is this Name of User field coming from? Let’s find out. In the text editor, open the models.py of the users app. Note these lines:  class User AbstractUser :  113        First Name and Last Name Do Not Cover Name Patterns  Around the Globe. name = models.CharField _ 'Name of User' ,  blank=True, max_length=255   The name field looks like it corresponds to Name of User. But we have to look at the views to see what’s really going on.  22.9 Understand the Code for UserUpdateView  Open the views.py of the users app now and look for the UserUp- dateView. It looks like this:  class UserUpdateView LoginRequiredMixin  UpdateView :  fields = ['name', ]   We already imported user in the View code above,  remember? model = User   Send the User Back to Their Own Page after a  def get_success_url self :  successful Update  return reverse 'users:detail',  kwargs={  'username': \ self.request.user.username}     def get_object self :  114    Only Get the User Record for the  return User.objects.get   User Making the Request  username=self.request.user.username   This view corresponds to the page where we entered in the name of our user. Note the following:    The fields list contains the fields that are part of the form.  The one field that exists, name, is in this list.    Even though it’s obvious from UserUpdateView that this view affects the User model, we still have to set the view’s model explicitly with model = User.  Study the rest of the views in the users app. Figure out which view corresponds to each page.  22.10 Add Email Addresses  What else can we do?  1. Click on E-Mail. 2. Try adding an email address. Remember, it doesn’t have to be a real email, since the confirmation email will be printed to the console anyway.  3. Check for a confirmation email in the terminal window  where runserver is running.  4. Copy and paste the email verification link into our browser.  Feel free to play around with the other email address manage- ment buttons as well. It’s good to see what they do.  115   22.11 What About the Code?  Where is the code for this email functionality? We may have looked through the users app to try and find it, but it’s not there. That’s because the code is in django-allauth. Let’s look at the template that is used with UserDetailView. The templates for the users app are in templates users . Open user_detail.html in our text editor. Find the HTML for the two buttons:        My Info   E-Mail   Both buttons are actually just HTML links that are styled to look like buttons. The url tag is a built-in template tag that converts a URL name to an absolute path URL. The My Info button points to a URL named update within the users namespace, which is wired up with UserUpdateView in the users urls.py module. We saw how that wiring is done at a fun- damental level back in Get to Know URL Routing. The E-Mail button link points to a URL named account_email. That URL is defined in allauth’s urls.py file, which we can find at https:  github.com pennersr django-allauth blob master allauth  account urls.py. Search for the path   declaration with a name argument of account_email. django-crash-starter came with django-allauth pre-configured with its users app. Since it’s a dependency of the everycheese project that we generated, links in users app templates can go to URLs defined by allauth.  116   23 Adding User Bios  23.1 Add a Bio Field  Out of the box, user profiles are pretty minimal. We’re going to give the User model a bio field to make it a little more interesting. Add this to the User model in the users app models.py:  bio = models.TextField "Bio", blank=True   We can put that line right below the name field.  23.2 Create and Run Migrations  To do this, we can either:    Stop runserver and use the same terminal, or   Open up a new command line tab or window where we run  makemigrations and migrate  Then make and apply our migrations as usual:  python manage.py makemigrations users python manage.py migrate users  Now the User model has a bio field, and the field exists in the database. However, the bio still isn’t on the user update form, and we have no way to edit it. That’s because we still have to update UserUpdateView and UserDetailView.  117   23.3 Update UserUpdateView  In the views.py of the users app, update fields by adding bio to the list:  class UserUpdateView LoginRequiredMixin, UpdateView :  fields = ["name", "bio", ]  Now the form should allow us to modify our user’s bio.  23.4 Try It Out  Start up runserver so that we can try out our new bio field on our site.  python manage.py runserver  Go back to the EveryCheese website in our browser and refresh our user profile page:    http:  127.0.0.1:8000 users cheesehead   Click on the My Info button again. We should see the new bio field. Fill in some text, then click Update to save our bio as shown in the image:  118   Figure 19: UserUpdateView With Bio  As we can see, now users can add and edit their bios. But the bios field still doesn’t show up on user profiles. Notice that UserDetailView still looks like this:  119       Figure 20: UserDetailView Without Bio  But if we try clicking on My Info again, we’ll see that the bio we wrote earlier is there. It has in fact been saved to the User object; it’s just not being shown in UserDetailView yet. We’ll fix that in the next lesson.  120       24 Adding Bio to User Detail Tem-  plate  Let’s allow users to provide some general information about themselves.  24.1 Update the User Detail Template  Go back to our text editor. Open up user_detail.html again  find it with the templates for the users app . Find the place where the user’s name is displayed if it exists. It looks like this:  Below it, add a similar block to display the user’s bio:  {% if object.name %}   {{ object.name }}   {% endif %}  {% if object.bio %}   {{ object.bio }}   {% endif %}  Make sure that the bio is in the same place, before the closing divs. This code says to only display that line if the bio exists. We do this because we don’t want an empty paragraph element if the user has not filled in a bio. Go back to our profile page in the browser. Reload it if necessary. We should now see our bio:  121   Figure 21: UserDetailView With Bio  Looks good so far. But what happens when a user bio has more than one paragraph?  24.2 Add Line Breaks  Now try adding line breaks and a second paragraph to our bio:  Traveler, writer, block of cheese.  What is life without cheese? Nothing.  Save it and look at the user detail page. Notice how the line breaks aren’t preserved. Our poetic multiline bio is all on one line. That’s a problem because a lot of people will probably enter line breaks, expecting them to be preserved. To fix that, change the line displaying the bio to:  122       Figure 22: No line breaks in UserDetailView   {{ object.biolinebreaksbr }}   Now when we reload our profile page in the browser, we should see that the line breaks are displayed properly. If you see line breaks then it’s time for a save point.  24.3 Commit Our Work  We’ve done a lot. Let’s save our work thus far:  git status git add -A git commit -m "Add bio field to User model, views, templates" git push origin master  The -A in git add -A tells git to add all changes, including new files and deletions.  123       25 Introducing Tests  In this lesson we’re going to learn the basics of writing tests against changes we’ve made in our code. Then we’re going to show a few tricks to help ensure we have healthy test writing habits.  25.1 Why Test?  Why are we spending our time writing tests? What’s the point? Well, tests help ensure that our project is more stable in the long run. Specifically:  Fixing bugs on existing projects. Minimize the chances of  our bug fix breaking other things.  Upgrading our software, operating system, even hardware  Formal tests help identify where things are going to break  There are many more reasons why testing is important, but those are two of our favorites.  25.2 Running Tests  To run the test suite in Django is just a management command away. At the command line, type:  coverage run -m pytest  124   As the tests are run, we’ll see text printed out that looks some- thing like:  Test session starts   platform: darwin, Python 3.8.1, pytest 5.3.4, pytest-sugar 0.9.2 django: settings: config.settings.test  from option  rootdir:  Users drg projects everycheese, inifile: pytest.ini plugins: sugar-0.9.2, django-3.8.0 collecting ... everycheese users tests test_forms.py ✓ everycheese users tests test_models.py ✓ everycheese users tests test_urls.py ✓✓✓ everycheese users tests test_views.py ✓✓✓✓ 100% ██████████  12% █▍ 25% ██▌ 62% ██████▍  Results  1.94s : 9 passed  Let’s go over what happened step-by-step:  1. Django created a test database, so there’s no chance of it  hurting our real data.  2. Django ran 8 tests in 1.94 seconds, then reported ‘OK’.  That means all the tests pass.  3. Django finally destroyed the test database, making it pos-  sible to run the tests again with a clean slate.  If any of those 8 tests had failed, Django would have reported the failures to us via error messages. These failure messages indicate where the problem has occurred.  25.2.1 If We Get a LOT of Deprecation Warnings  Should the tests pass but there are dozens of warnings about django.utils.translation.ugettext_lazy  , that’s okay.  125   One of the dependencies we’re relying on may not be updated yet to run on Django 3.0. If these warnings appear, go into the root of the project and find the pytest.ini file. Add this value to the second line, with a space between it and the text that comes before it:  -p no:warnings  25.3 What Does a Test Look Like?  In our text editor or IDE, go to everycheese tests test_user_get_absolute_url:  > Inside there is a single function,  test_models.py.  users  >  >  import pytest  from everycheese.users.models import User  pytestmark = pytest.mark.django_db  def test_user_get_absolute_url user: User :  assert user.get_absolute_url   == f" users {user.username} "  Next, let’s look at each part of this code in detail.  25.4 The Test Foundations  126   import pytest  from everycheese.users.models import User  pytestmark = pytest.mark.django_db    We import pytest21, our favorite testing framework. Think  of it as the Django of testing.    We import the User model from our users models.   We define pytestmark in our module, which drives the test  database system.  25.5 The Actual Test  The function in the module is a test. We know it is tests because it is prefixed with “test_”.  def test_user_get_absolute_url user: User :  assert user.get_absolute_url   == f" users {user.username} "  test_user_get_absolute_url erycheese.users.models.User model’s get_absolute_url   method.  is a validation against  the  ev-    Every model method should have a test  If we add another model method, for example, __str__, we would write a test for that as well. In fact, any time we add any method or function to the project, we write tests for them. Doing it upfront is a good way to ensure improved code stability.  21https:  docs.pytest.org   127     25.6 Using the assert KeyWord  Assert is a Python built-in that lets us run little tests. Let’s go into the Python shell and try it out. Start it by typing python at the command-line:  python Python 3.8.1  default, Jan [Clang 4.0.1  tags RELEASE_401 final ] :: Anaconda Type "help", "copyright", "credits" or "license" >>>  8 2020, 16:15:59   Once inside the Python shell, we can try out the assert keyword:  >>> assert 1 == 1 >>> assert 1 == 2 Traceback  most recent call last :  File " ", line 1, in    AssertionError >>>  By writing functions that use the assert key, we are able to write simple yet effective tests for anything we need in our projects. This tests ensure that if we make any breaking changes to the get_absolute_url   method of our User model, these changes are caught quickly. This is a simple, clear example, which is a good thing. In our experience clarity in testing goes a long way to- wards preserving the stability of a website. If we have to write tests for our tests because our tests are too complex, we’re prob- ably making a mistake. Now that we’ve seen how tests are constructed, let’s write some more.  128     Python shell or Python REPL?  Technically speaking, the Python shell is a REPL22. In- deed, a REPL can be a programming shell, but not neces- sarily. If that sounds confusing  or seems pedantic , just stick with the term “shell”. It’s what most people are familiar with anyway.  Now that we’ve seen how tests are constructed, let’s write some more. But how do we know where to begin writing tests?  25.7 Introducing coverage.py  The coverage.py library is a tool that examines our project for code not covered by tests. This allows us to quickly determine places where we can add meaningful tests. Do keep in mind that coverage.py isn’t perfect and test coverage doesn’t equate to bug free. Nevertheless, test-covered code is always more stable in the long run.  25.8 Using coverage.py  Normally there is a bit of setup, but fortunately for us django- crash-starter has taken care of all the work in advance. All we have to do is run the following at the command line:  coverage report  129     It should display the percentage of test coverage per module and the overall total as shown below:  Miss  Stmts  Name Cover ----------------------------------------------------------- everycheese __init__.py 100% 100% everycheese conftest.py 100% everycheese contrib __init__.py 100% everycheese contrib sites __init__.py everycheese users __init__.py 100% 100% everycheese users admin.py 100% everycheese users apps.py 100% everycheese users forms.py 100% everycheese users models.py everycheese users urls.py 100% everycheese users views.py 100% ----------------------------------------------------------- TOTAL 100%  2 13 0 0 0 12 10 18 9 4 28  0 0 0 0 0 0 0 0 0 0 0  96  0  25.9 Generate an HTML Coverage Report  In addition to the broad coverage report that we just saw, we can generate a more detailed interactive HTML coverage report. Type this:  coverage html  Now open htmlcov index.html in a browser. Notice how we can click on any particular module to see exactly which lines are missing test coverage. Not that there are any missing lines, but as we add code in future chapters this will display code we’ve added that doesn’t have tests yet.  130   25.10 More Users App Tests  There are 3 other modules of tests generated for our starter users app:  Study the comments in those tests to learn how those tests work.    test_forms.py   test_urls.py   test_views.py  25.11 Summary  In this lesson, we covered:  1. Reasons to write tests for our project 2. How to run tests 3. The starter tests that come with the users app 4. How to determine how much of a project is covered by tests  131   26 User Profile Cheese  What if, instead of using a computer or tablet, we could browse the internet with a block of cheese? Our device would technically be a cheese computer, or a “cheese- puter” for short. It would be the ideal device for browsing Ev- eryCheese. On our cheeseputer, here is what the user profile  user detail  page would look like.  Figure 23: A block of user profile cheese  26.1 Avatars Will Fit Into Cheese Holes  We haven’t implemented avatars yet, but when we do in an up- coming Django Crash Course extension, they’ll fit into the holes of our cheeseputer, as shown.  132       27 The Cheeses App and Model  EveryCheese is still missing one thing: cheese! We’re going to start building out the cheese-related functionality by creating a cheeses app. We’ll then create a Cheese model, and we’ll make and apply migrations. Remember, a Django app is a directory within our Django project containing code focused on doing one thing well. A typical Django project contains many Django apps.  27.1 Make Sure We’re at the Project Root  At the command line, let’s check that we are still in the root of the project. If we type ls, we should see a file called manage.py among many others.  27.2 Create an App Called Cheeses  Use startapp to create a new app called cheeses:  python manage.py startapp cheeses  The startapp command creates starting boilerplate for a Django app. After it runs, we’ll see that an app directory called cheeses has been created. Inside, all the familiar Django app files are there, such as models.py.  27.3 Move It Into the Project  The cheeses app was created in the current directory, but the other Django apps aren’t in the current directory. They’re all in an inner everycheese  directory.  133   It’s a common practice in the Django world to keep all our Django apps inside one directory. In the django-crash-starter project layout, the apps directory has the same name as the outer project directory. Move cheeses  to the inner everycheese  directory:  mv cheeses everycheese   We should now have it at the same level as our users app, with all our other Django apps.  27.4 Set the Cheese Config  In the everycheese cheeses apps.py module, change the value of name to be “everycheese.cheeses”. It should look like this:  name = 'everycheese.cheeses'  27.5 Add It to the List of Installed Apps  Open up the common settings file base.py. We can see here that django-crash-starter breaks up the INSTALLED_APPS tuple into DJANGO_APPS, THIRD_PARTY_APPS, and LOCAL_APPS:  INSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS  This is to help keep our apps organized. The naming convention here is:  134   base.    DJANGO_APPS: Apps that are part of the core Django code-    THIRD_PARTY_APPS: Reusable Django apps available from the Python Package Index. Third-party means not part of Django core.    LOCAL_APPS: Django apps that are internal to our Django  project, such as the users app.  Add everycheese.cheeses to LOCAL_APPS:  LOCAL_APPS =       'everycheese.users.apps.UsersConfig', 'everycheese.cheeses.apps.CheesesConfig',   custom users app   cheese info app  Now the cheeses app is installed into the project.  27.6 Add the Cheese Model  Open up cheeses models.py. Delete the placeholder comment saying  Create your models here. It’s fine to delete comments like this – there’s no reason to keep it around. In the Django world, a models.py is obviously where we create our models.  27.6.1 Start the Cheese Model Like Any Other Model  Define a Cheese model which subclasses the TimeStampedModel from django-model-utils. Give it a standard name field.  135   from django.db import models  from model_utils.models import TimeStampedModel  class Cheese TimeStampedModel :  name = models.CharField "Name of Cheese", max_length=255   TimeStampedModel automatically gives the model created and modi- fied fields, which automatically track when the object is created or modified. We like to define all our models as subclasses of TimeStampedModel.  27.6.2 Add an Autopopulating Cheese Slug  Add a slug field. The slug will populate automatically from the name field, rather than requiring the user to enter it.  from django.db import models  from autoslug import AutoSlugField from model_utils.models import TimeStampedModel  class Cheese TimeStampedModel :  name = models.CharField "Name of Cheese", max_length=255  slug = AutoSlugField "Cheese Address",  unique=True, always_update=False, populate_from="name"   136   Figure 24: Slugs are awesome!  27.6.3 Add Description Field  Continuing from above, we’ll give cheeses a description. Add this to the Cheese model:  description = models.TextField "Description", blank=True   This is a TextField because there’s a good chance that users might enter long descriptive text. A good rule of thumb is to use TextField rather than CharField whenever there might be a need for more than 255 characters.  137       27.6.4 Add Firmness Field  Finally, add a firmness field to the same Cheese model. Give it enum-powered choices ranging from soft to hard.  class Cheese TimeStampedModel :  class Firmness models.TextChoices :  UNSPECIFIED = "unspecified", "Unspecified" SOFT = "soft", "Soft" SEMI_SOFT = "semi-soft", "Semi-Soft" SEMI_HARD = "semi-hard", "Semi-Hard" HARD = "hard", "Hard"   Other Fields Here...  firmness = models.CharField "Firmness", max_length=20,  choices=Firmness.choices, default=Firmness.UNSPECIFIED   Note that we defined the firmness constants as variables within the scope of the Cheese model. This allows us to do things like this comparison:  if cheese.firmness == Cheese.Firmness.SOFT:   Do Something  No need to type the above comparison. It’s here just to show what we can do.  27.7 Create and Run the Initial Cheese Migra-  tion  Run makemigrations and migrate:  138   python manage.py makemigrations cheeses python manage.py migrate cheeses  This migration should have created a table for the Cheese model.  139   28 Trying Out the Cheese Model  We’re going to experiment with our Cheese model via shell_plus, an enhanced version of the interactive Django shell.  28.1 Let’s Try It Out!  At the command line, start up shell_plus:  python manage.py shell_plus  28.2 Django Shell vs. Shell Plus  The regular Django shell  python manage.py shell  is the same as starting the Python REPL, but when we run it, it preloads the appropriate Django settings file as specified in manage.py. shell_plus takes this a step further by autoloading all our Django model classes. In the plain Django shell, we would have to type this in order to import the Cheese model class:  >>> from everycheese.cheeses.models import Cheese  However, in shell_plus, the above import is already done for us as a convenience.  28.3 Create a Cheese  Let’s instantiate a Cheese object. Type this now:  140   in [1]: cheese = Cheese.objects.create  ... name='Colby', ... description='Similar to Cheddar but without undergoing the cheddaring process, Colby is a mild, creamy cheese that was first created in 1885 in Colby, Wisconsin.', ... firmness=Cheese.Firmness.SEMI_HARD   Behind the scenes, the above code created a new record in the cheeses_cheese table in the database.  28.4 Evaluate and Print the Cheese  If we evaluate the object that we just instantiated, we get:  Printing the string representation of our object gives us:  in [2]: cheese    in [3]: print cheese  Cheese object  Cheese object? That’s not very descriptive. How do we know which cheese object this refers to? We don’t. It’s also rather insulting to Colby cheese.  28.5 View the Cheese’s Name  To see the actual name of the cheese, type:  141   in [4]: cheese.name 'Colby'  We can make cheese objects print out better. Exit the command line.  28.6 Add a String Method  When Python classes have a __str__   method, that method is called and the result is printed whenever we try to print an instance object. We’re about to see this in action. Open up models.py of our cheeses app again. Add a __str__   method to our Cheese model. This goes at the bottom, after all the fields:  def __str__ self :  return self.name  28.7 Try It Again  Let’s get that cheese object and try to print it again:  python manage.py shell_plus in [1]: cheese = Cheese.objects.last   in [2]: print cheese  Colby  Great! Now when we printed cheese, we got Colby as the string representation of the cheese object. Exit shell_plus again. We’re done using it for now.  142   28.8 Commit Our Work  We’ve made some major changes to EveryCheese, so it’s time to back up our work in version control. Check which files have changed, then add them to a commit.  git status git add everycheese cheeses  git add config settings base.py  Commit the changes and push:  git commit -m "Add cheeses app" git push origin master  143   29 Tests and Test Coverage  29.1 Check Test Coverage  Now’s a good time to recheck test coverage. At the command line:  coverage run -m pytest coverage report coverage html  Open htmlcov index.html in a browser:  Figure 25: 94% coverage  144       Why isn’t our test coverage at 100%? Well, django-crash-starter provided us with 100% test coverage, but adding the cheeses app dropped us to its current score. Click around the coverage report dropped our score. everycheese.cheeses.models.  to find exactly what look at the coverage for  In this case,  Figure 26: Cheese model coverage  The line that dropped our test coverage was this line inside of  145       the __str__   function beginning with return:  def __str__ self :  return self.name  coverage assumes that  You see, imported code like mod- els.CharField just works. There’s no need to test the Cheese model’s fields, because the usage of those fields has already been tested in Django’s codebase. However, the __str__   function that we defined is specific to our code. Coverage.py didn’t find any test coverage for it, so it marked it as uncovered.  29.2 Create a Module for Cheese Model Tests  Django’s startapp command gave our cheeses app a tests.py file by default. However, a single tests module is going to get crowded with code. Let’s turn our tests module into a tests package. In everycheese cheeses , let’s now:    Delete tests.py   Create a directory in its place called tests    Inside of tests, create __init__.py and test_models.py.  Common practice is to delete tests.py and create individual test modules for each file of the app.  Later, the cheeses app may have a test_views.py, test_admin.py, etc.  Note: even though __init__.py is optional on Python 3, create it anyway.  146   29.3 Let’s Test the __str__   Method.  One might say, this is silly! But it’s actually important because we never know, there could one day be code in EveryCheese that relies on the value of __str__   behaving a certain way. If that behavior changes and we don’t catch it in time, it will cause us to be embarrassed in front of our users. Before we can write a test for this, we need to import the pytest library and link it to our database. Start off cheeses tests test_models.py with this:  import pytest   Connects our tests with our database pytestmark = pytest.mark.django_db  Import the Cheese model class, since it’s what’s being tested in this module:  from ..models import Cheese  Here we use a relative import to get Cheese from models.py of the cheeses app. This pattern is the same as that of the users app’s test_models.py. Then add our test function:  def test___str__  :  cheese = Cheese.objects.create   name="Stracchino", description="Semi-sweet cheese that goes well with starches.",  147   firmness=Cheese.Firmness.SOFT,    assert cheese.__str__   == "Stracchino" assert str cheese  == "Stracchino"  This is a good starter example of how to write tests on model methods.  In a later lesson we’ll improve upon this by using a factory, but for now this is a good place to start.  Run coverage.py again:  coverage run -m pytest coverage report coverage html  Open the htmlcov index.html file again. The test coverage of ev- erycheese.cheeses.models should have increased to 100%. If we click through to see the file in detail, we should see that no lines are highlighted for lacking test coverage.  29.4 Enter “The Game of Test Coverage”  Since test coverage is a measure of how much of our project is covered by tests, we can use this value as part of a game. The goal of the game is simple: Get our test coverage score to 100% and keep it there.  29.5 Rules of the Game  Any time we add new code, we’ll be running a coverage report.  148     If the number drops, then we are losing.   If the number is maintained, we draw.   And if the number goes up  even after a drop , then we  are on our way to victory.  The way to maintain our score is by adding more tests to cover things that aren’t covered. That’s the challenge. Every time we add or modify existing code we risk dropping our score, so we’re playing constantly. As for what’s a good coverage percentage, there’s no one correct answer. Read more: What is a reasonable code coverage % for unit tests  and why ?23  29.6 What’s the Point of All This Anyway?  Primarily, it’s a chance to justify eating more cheese. Other, less important things to think about are:  1. Do we want to be able to easily upgrade our site whenever Django or any of the dependencies of our site put out new releases?  2. Do we want our deployments to go smoothly? 3. Are people’s health or finances dependent on our project?  If we answered yes to any of the above, then maximizing our test coverage is in our best interest. 23https:  stackoverflow.com questions 90002 what-is-a-reasonable-code-coverage-  for-unit-tests-and-why  149   29.7 Commit the Cheese Model Tests  git add -A git commit -m "Add Cheese model tests" git push origin master  29.8 Summary  We’ve now covered:  1. Testing the Cheese model 2. The game of test coverage 3. Committing our new cheeses app tests  150   30 The Cheeserator  With Django, we can build absolutely anything imaginable. Now imagine that we wanted to build a contraption called The Cheeserator, a machine for doing whatever we want to do to cheese.  Figure 27: The Cheeserator device for manipulating cheese.  Yes, we can build this with Django. We can do anything.  151       31 Adding Cheeses to the Admin  31.1 We Need a Superuser  Create a Django superuser to get full admin access.  python manage.py createsuperuser  Enter these values:    username: admin   email: admin@example.com   password: Peaui8mUPCXkjQ*    Copy this password into a password manager!  It’s bad practice to use simplistic passwords, even for local development. We want to promote strong security habits and this is one of them. Also, don’t stick passwords into plaintext or spreadsheet files. Instead, lean on secure pass- word managers like 1Password.  31.2 Go to the Admin  Start up runserver if it’s not already running. Go to http:  127.0.0.1:8000 admin. Log in with our superuser ac- count.  152     31.3 Explore the Admin So Far  Look around to see what’s currently available in the Django admin. We’ll notice some functionality that comes with Django by default, and some that comes with django-crash-starter.  31.4 Register Cheese Model With the Admin  Open admin.py of our cheeses app in our text editor. Replace the code in the file with the following:  from django.contrib import admin from .models import Cheese  admin.site.register Cheese   Save the file and go back to the Django admin in our browser. Refresh the page. We should now have an admin UI for entering cheeses, accessible from the Cheeses section:  31.5 Find Colby  Earlier, we created a cheese by calling Cheese.objects.create   in shell_plus. The end result was that a new cheese record was created. In the admin, find the list of cheeses. Colby, the cheese we added earlier, should be the only cheese in the list. As of now, there are 2 ways to create new cheeses in EveryCheese: 1. By writing code that creates cheeses, as we did earlier. 2. By creating cheeses in the Django admin.  153   Figure 28: Cheeses on the Django admin index page  We’ve already created a cheese programmatically; next, we’ll create 3 more via the Django admin.  31.6 Enter More Cheeses via the Admin  Under Cheeses, click on Add. We will be taken to the Add cheese form: Add the following cheeses via the Django admin UI:  1. Camembert   a  Description: A French cheese with a white, powdery rind  and a soft, delicately salty interior.  154       Figure 29: Add cheese in the Django admin   b  Firmness: soft  2. Gouda   b  Firmness: hard  3. Cheddar   a  Description: A Dutch yellow cheese that develops a slight crunchiness and a complex salty toffee-like flavor as it ages.   a  Description: A relatively hard, pale yellow to off-white,  and sometimes sharp-tasting cheese.   b  Firmness: hard  Don’t skip this step. We’ll need these cheeses later in this course.  155       31.7 Some Notes About the Django Admin  31.7.1 Keep People Who Use It to a Small Number.  1. Must be power-users, understanding how models work 2. Not optimized for scaling 3. The Django admin can do a lot of amazing things for a little amount of work. But then we run out of options and are stuck    Don’t Use list_editable. Ever!  As records are tracked not by primary keys but by their position in a displayed list, this is a serious risk. On multi- user projects:  1. Cheeses are created in descending order. 2. Daniel brings up the list field for cheeses and begins  making changes  3. Audrey decides to add the cheese Brie. Since it’s the last item added, it’s the first Cheese returned on a query.  4. Daniel finally saves his cheese changes, but the records he saw all receive the data from the next record, cor- rupting at least 50 records  Django’s default admin display number .  31.8 Commit Changes  git commit -am "Register Cheese model with the admin" git push origin master  156     31.9 Summary  In this lesson we:  1. Created a superuser 2. Learned how to use the Django admin to rapidly create a  barebones cheese management system.  3. Admonished us to keep the volume of users of the admin  system to a small number.  4. Warned against use of list_editable.  157   32 Behind the Curtain  Having access to the Django admin is like having access to the Wizard of Oz’s control panels. It makes us more powerful than we actually are. Imagine if a wedge of cheese had access to the Django admin con- trols of the EveryCheese site. Who knows what might happen. It could be rather dangerous.  Figure 30: The cheese behind the curtain  32.1 We Are in Control  Fortunately for us, we don’t have to create superuser accounts for cheeses if we don’t feel like it. Just say no. If they ask, tell  158       them to follow the yellow brick road back to the refrigerator.  159   33 Class Based View Fundamentals  This lesson will cover:    The Simplest Class-Based View   Advantages of Class-Based Views   Tips for Writing Class-Based Views  There’s no need to type out the examples in this lesson. Just sit back and learn the concepts.  33.1 The Simplest Class-Based View  Here, study the code and observe that:    We create a very simple view by subclassing the base View    It returns an HTTP response consisting of a simple text  class.  string.   No need to type this out, just study it! from django.http import HttpResponse from django.views.generic import View  class MyView View :  def get self, request, *args, **kwargs :  return HttpResponse 'Response to GET request'   The above is analogous to this function-based view  or FBV for short :  160    No need to type this out, just study it! def my_view request, *args, **kwargs :  return HttpResponse 'Response GET request!'   33.2 Adding More HTTP Methods  Just as we can define a get   method to handle GET requests, we can also do the same with other HTTP methods such as POST and DELETE.   No need to type this out, just study it! class MyView View :  def get self, request, *args, **kwargs :  return HttpResponse 'Response to GET request'   def post self, request, *args, **kwargs :  return HttpResponse 'Response to POST request'   def delete self, request, *args, **kwargs :  return HttpResponse 'Response to DELETE request'   The above CBV code is analogous to this FBV approach:   No need to type this out, just study it! def my_view request, *args, **kwargs :  if request.method == 'POST':  return HttpResponse 'Response POST request!'   elif request.method == 'DELETE':  return HttpResponse 'Response DELETE request!'   return HttpResponse 'Response GET request!'   161   Or this FBV approach:   No need to type this out, just study it! def my_view request, *args, **kwargs :  METHOD_DISPATCH = {  'POST': HttpResponse 'Response POST request!' , 'DELETE': HttpResponse 'Response DELETE request!' ,  } DEFAULT = HttpResponse 'Response GET request!'  return METHOD_DISPATCH.get request.method, DEFAULT   Or any number of other FBV approaches. Which makes us won- der, what is the correct FBV approach? Hint: There isn’t a ‘correct’ or ‘standard’ FBV approach. It’s every coder for themselves.  33.3 Advantages of Class Based Views    Composition   Intelligent Defaults   Standardized HTTP method handling   Every action generally has a place to be   Easier than Writing Decorators  33.4 Composition  Here’s an example mixin:  162    No need to type this out, just study it! class BaseProjectMixin object :  def complex_data self, request :   Sophisticated Logic Here return 'sophisticated result'  Every view inheriting from BaseProjectMixin gets a complex_data   method as a result:   No need to type this out, just study it! from django.views.generic import View from .mixins import BaseProjectMixin  class ItemDetailView BaseProjectMixin, View : def get self, request, *args, **kwargs :  value = self.complex_data request  return render request, 'details.html', {'value': value}   class ThingDetailView BaseProjectMixin, View :  def get self, request, *args, **kwargs :  value = self.complex_data request  return render request, 'things.html', {'value': value}   http:  ccbv.co.uk projects Django 3.0 django.views.generic.base  View   33.5 Composition Part II  Various open-source packages expect you to extend the default views they provide. Django REST Framework is the most no- table project to take this approach.  163   33.6 Intelligent Defaults  A CBV-based update view   No need to type this out, just study it! from django.views.generic import UpdateView from .models import Item  class ItemUpdateView UpdateView :  model = Item fields = ['name', 'description', 'price']    Auto-creates form based off Item and fields, called form in  template.    Default template name of items item_form.html.   Item record can be accessed in template as item or object.  https:  ccbv.co.uk projects Django 3.0 django.views.generic.edit  UpdateView   33.7 Standardized HTTP Method Handling   No need to type this out, just study it! from django.http import HttpResponse from django.views.generic import View  class SpecialView View :  def delete self, request, *args, **kwargs :  164   return HttpResponse 'HTTP deletes!'   def post self, request, *args, **kwargs :  return HttpResponse 'HTTP posts!'     Returns HTTP 405 for these HTTP methods:  – GET – PUT – OPTIONS  33.8 Tips for Writing Class-Based Views    Stick with the defaults   Don’t go crazy with multiple inheritance   For authentication and other behaviors: django-braces   For quick reference documentation: https:  ccbv.co.uk   If doing something crazy-sophisticated, drop down to a  basic django.views.generic.View.    For more advanced views:  – GET POST arguments are inside of self.kwargs – You can access the request at self.request  165   34 Writing the Cheese List View  In our text editor, open cheeses views.py. There will be some stub code in there. Replace it with the following:  from django.views.generic import ListView, DetailView  from .models import Cheese  class CheeseListView ListView :  model = Cheese  This is a simple view that lists all the cheeses on a single page. When we import the Cheese model, we use a relative import be- cause we’re importing it from within the same app.  166   35 Wiring in the List View Url  35.1 Define Cheese URL Patterns  In our cheeses app, create a new file called urls.py. Open it in our text editor and add the following code:   everycheese cheeses urls.py from django.urls import path from . import views  app_name = "cheeses" urlpatterns = [  path   route='', view=views.CheeseListView.as_view  , name='list'   ,  ]  35.2 Include Cheese URLs in Root URLConf  In order to make the cheeses app’s URLConf work, we still have to include it in our root URLConf. Open config urls.py and add this line:  path 'cheeses ', include 'everycheese.cheeses.urls', namespace='cheeses'  ,  35.3 See the View in Action  We’re about to trigger an error, but that’s okay!  167   In our web browser let’s navigate to 127.0.0.1:8000 cheeses 24 We should see a TemplateDoesNotExist error:  Figure 31: TemplateDoesNotExist  This is good news! It means:  1. Django’s URL dispatcher found match for 'cheeses ' and  sent the rest of the URL to everycheese.cheeses.urls.  2. The remainder of the URL is a match for '',  so  CheeseListView.as_view   was called.  3. The CheeseListView looked for a template to display, found  nothing, so returned a TemplateDoesNotExist error.  We’ll add that template in the next chapter. 24http:  127.0.0.1:8000 cheeses   168       36 The Cheese List Template  We love looking at lists of cheeses. So much taste and flavor!  36.1 Create the List Template  Let’s create a blank template for CheeseListView:  1. In templates , create a cheeses  directory. This will hold all  the templates for our cheeses app.  2. In templates cheeses , create a file called cheese_list.html  Make sure we have runserver still running. Go to http:  127.0.0.1:8000 cheeses  again. When we load the page, it shows up blank as expected.  36.2 Fill in the Template  Fill cheese_list.html with the following code:  {% extends "base.html" %}  {% block title %}Cheese List{% endblock title %}  {% block content %}   Cheese List      {% for cheese in cheese_list %}    {{ cheese.name }}    {% endfor %}  169     {% endblock content %}  In this template, we display all the cheeses in a bulleted list. We iterate over cheese_list, which CheeseListView automatically provides to the template. This is a built-in copy of the default object_list value that ListView provides by default. If our model was Butter instead of Cheese, then we would access butter_list instead. The TODO links will go to the detail pages for each cheese. We’ll implement them very soon.  36.3 See the List in Action  Refresh http:  127.0.0.1:8000 cheeses  again. We should see the cheese list in action:  Figure 32: Cheese list  170         All the cheeses we entered earlier via the Django admin or  shell should be in the list.    The links should be TODOs. We haven’t implemented them  yet.  36.4 Add a Nav Link to the Cheese List  Open up templates base.html in our text editor. This is the project’s main sitewide base template. Find the code for the navbar:        Home    current                About   Insert a link to the Cheese List page:         Cheeses   Here we use the {% url %} template tag to generate the absolute URL. This is better than linking to the absolute URL directly. The reason is that no matter what we change the link to, the base.html template will pick it up. For example, if we decided  171   to switch the URL from cheeses to les-fromages  French for “cheeses”  in urls.py, we wouldn’t have to go into templates to accomodate that change. Instead, {% url 'cheeses:list' %} would automagically link to 127.0.0.1:8000 les-fromages . In any case, now when we go back to the browser and refresh the Cheese List page, we should see the Cheeses link in the navbar:  Figure 33: Cheese List With Nav Link  Click around the site and then click on cheeses to make sure the link works as expected.  36.5 Explaining the cheeses:list Name  In the previous chapter, inside the cheeses urls.py module we set two important values, the app_name and the path name for the CheeseListView. The specific values we set are seen below:  172        Code inside cheeses urls.py app_name = "cheeses" urlpatterns = [  path   route='', view=views.CheeseListView.as_view  , name='list'   ,  ]  app_name This is how we set the cheeses app name in an explicit manner. Amongst other things, setting this here makes it easy for us as developers to identify which file we are working in.  path name The CheeseListView is given a URL name of list. We do this because it allows us greater flexibility in naming views across a project. Specifically, a too-simple naming approach starts to be uncomfortable on even medium-sized projects.  36.6 Commit Our Work  As always, commit the work!  git add -A git commit -m "Implement cheese list page, add navbar link" git push origin master  173   37 Add the CheeseDetailView  So far we can see the list of cheeses at http:  127.0.0.1:8000  cheeses . Next, let’s make it possible for users to click through to see the detail page for any cheese. Add this to the bottom of cheeses views.py:  class CheeseDetailView DetailView :  model = Cheese  Now we have the view that will power each of the cheese detail pages.  37.1 Add the CheeseDetailView URL Pattern  As usual, after defining a view, the next step is to wire in its corresponding URL pattern. Add this to the urlpatterns list in cheeses urls.py:   URL Pattern for the CheeseDetailView path   route='  ', view=views.CheeseDetailView.as_view  , name='detail'   ,  Our urlpatterns in cheeses urls.py should look like this now:  174   urlpatterns = [  path   route='', view=views.CheeseListView.as_view  , name='list'  route='  ', view=views.CheeseDetailView.as_view  , name='detail'   , path    ,  ]  Now when we visit http:  127.0.0.1:8000 cheeses colby , the re- quested URL will match ' ' where slug is colby.  37.2 Link List Items to Detail Pages  In cheeses cheese_list.html change:     To:     Here we are using the url template tag to generate the absolute URL to each cheese’s detail page. If we refresh http:  127.0.0.1:8000 cheeses  and click on Colby we’ll go to the CheeseDetailView results. However, as we haven’t added a template yet, what we get is the following:  175   Figure 34: Missing cheese_detail.html TemplateDoesNotExist exception  If we see the image above, then we are doing it right. Go to the next chapter where we add the cheese_detail.html html template.  176       38 The Cheese Detail Template  38.1 Add a Cheese Detail Template  In templates cheeses , create a file called cheese_detail.html. Fill in the detail template with this code:  {% block title %}Cheeses: {{ cheese.name }}{% endblock %}   Firmness: {{ cheese.get_firmness_display }}   {% extends "base.html" %}  {% block content %}   {{ cheese.name }}   {% if cheese.firmness %}  {% endif %}  {% if cheese.description %}   {{ cheese.description }}   {% endif %}  {% endblock content %}  Some things to note:    In a DetailView’s template, the object is accessible as the lowercased model name. In this case, the object is cheese.   Before displaying any optional field, we first check if a value    get_firmness_display shows the cheese’s firmness attribute  in an attractive format.  exists.  177   38.2 Visit Cheese Detail  Go back to the cheese list page in our browser. Refresh the page. Click on a cheese in the list. This will take us to the cheese detail page:  Figure 35: Cheese detail  Compare it to the template that we just filled in.  38.3 Commit Our Work  git add -A git commit -m "Implement cheese detail page" git push origin master  178       39 Where to Dip Class Based Views  Class-based views are great. But there’s something about them that is very diﬀicult to understand. That is, most people don’t know where to dip them. Fortunately, we’re about to explain where CBVs should be dipped. Grab a large fondue pot and make some cheese-based fondue. Any cheese will do.  Figure 36: Dipping CBVs in fondue.  179       40 Writing Factories for Tests  It’s fun to describe lots of cheeses. We’ve done it in tests, in the admin, and we’ll be doing it through the course.  40.1 Produce Cheese Test Data From Facto-  ries  However, since we’re building a real site, we’re going to need real amounts of data. Hand coding cheeses and other things into our site works to some degree, but it doesn’t let us test things in quantities of tens, hundred, or thousands. What we’re going to do instead is use a factory. One powered by Factory Boy, a third-party library included in the django-crash- starter library.  40.2 Define a CheeseFactory  Create a new module in our cheeses app’s test directory for fac- tories: cheeses tests factories.py Place the following code inside:  from django.template.defaultfilters import slugify  import factory import factory.fuzzy  from ..models import Cheese  class CheeseFactory factory.django.DjangoModelFactory :  180   name = factory.fuzzy.FuzzyText   slug = factory.LazyAttribute lambda obj: slugify obj.name   description = factory.Faker 'paragraph', nb_sentences=3, variable_nb_sentences=True  firmness = factory.fuzzy.FuzzyChoice   [x[0] for x in Cheese.Firmness.choices]     class Meta:  model = Cheese  CheeseFactory generates Cheese objects  model instances . Think of it like Cheese.objects.create  , but where the cheese data is autogenerated. Observe that:    The name of the cheese is autogenerated using FuzzyText  .   The slug of the cheese is the slugified version of the name.   The cheese’s description is a randomly-generated para-    The cheese’s firmness is randomly selected from all possible  graph.  firmness choices.  40.3 Try Out CheeseFactory  Let’s go to shell_plus and try it out:  python manage.py shell_plus  In the shell, type this:  181   >>> from everycheese.cheeses.tests.factories import CheeseFactory >>> cheese = CheeseFactory   >>> cheese    What’s going on here:  1. We import the CheeseFactory class that we just defined. 2. We instantiate a Cheese object named cheese using Cheese-  Factory.  3. We evaluate the cheese object.  When we evaluate that cheese, we get a funny result. That’s no cheese title! That’s because what CheeseFactory did was create a cheese with random data. While that’s no good for looking at, it’s great for testing. We’ll see shortly how to use factories in unit tests.  40.4 Delete the Bogus Cheese  Because we just created a random cheese with CheeseFactory, it now exists in the database. We can see that it’s there by looking at the list of cheeses in the Django admin: Go to the admin and delete the one bogus cheese from the list:  1. Select the checkbox to the left of the cheese. 2. Choose Action > Delete selected cheeses. 3. Click Go.  Now our database should only contain good cheeses.  182   Figure 37: Django admin list of cheeses, including bogus cheese  40.5 Commit the Changes    All cheese is made in cheese factories  It is our understanding that in English, the term “Cheese Factory” means any place where cheese is made for In other words, cheese factories can non-personal use. mean giant mechanized facilities and small family-run kitchens. It’s important to remember that the word “factory” for making things predates the industrial rev- olution and has its roots in the Latin facio, and before that the fakiō of Proto-Italic and before that θakjō from Proto-Indo-European.  Let’s save our changes:  183         git status git add -A git commit -m "Add a cheese factory" git push origin master  184   41 Why Use Factories  Why are factories so great for unit testing?  41.1 Factories and Unit Testing  Well, suppose that for test purposes we wanted to create a new cheese record containing data for the following fields:    name   slug   description   firmness  For unit-testing purposes, we don’t actually care if name is the name of a real cheese. Likewise, description can just be any ran- dom paragraph, and firmness can be any of the firmness choices that we defined in our Cheese model. Here are 2 ways of creating our test cheese: Call Cheese.objects.create   and pass in values for name, descrip- tion, and firmness  slug will be autogenerated . 2. Call CheeseFactory   without passing in values  since they will all be autogenerated . Let’s compare both approaches.  1.  41.2 Approach 1: Calling Create    First we’ll create a Cheese via Cheese.objects.create  :  185   >>> cheese = Cheese.objects.create  ... name="Stracchino", ... description="Semi-sweet cheese that goes well with starches.", ... firmness=Cheese.Firmness.SOFT,  >>> cheese    Here, we had to type out values for name, description, and firmness and pass them into create  . It took a few lines of code to define a cheese.  41.3 Approach 2: Calling CheeseFactory    Now let’s generate a cheese from the CheeseFactory. One… two… three…  >>> cheese = CheeseFactory   >>> cheese    Here, we didn’t have to explicitly pass values for name, description, or firmness into CheeseFactory  . That means:  1. We didn’t have to look up the Cheese model definition to figure out how the fields were defined. That’s a lot of mental overhead that we saved. We also reduced the risk of making mistakes during cheese creation.  2. Creating a cheese took 1 line of code instead of 4.  Factories like CheeseFactory are much more eﬀicient and less error- prone to create test data with.  186   CheeseFactory doesn’t create real cheeses unless you explicitly give it real values. For unit testing purposes, that’s fine. For example, if you’re testing that cheese.__str__   returns cheese.name, the test checks for equality only. It doesn’t care whether cheese.name is a real cheese.  41.4 Other Uses  Besides unit testing, factories can be used in place of fixtures. For example, suppose you need to generate 5000 cheeses for local development purposes, to see how the site’s UI behaves when it’s well-populated with cheese data. You can call CheeseFactory   in a loop.  41.5 Learn More About Factory Boy  Our preference for testing factories, Factory Boy is a mature li- brary used around the world in tens of thousands of projects. Here’s more information about it:    https:  factoryboy.readthedocs.io    https:  github.com FactoryBoy factory_boy  187   42 Using Factories in Tests  Let’s apply what we covered in the previous chapter.  42.1 Passing in Field Values Explicitly  When using a factory, we can optionally specify the value of one of the fields. For example, try typing this in shell_plus:  >>> cheese = CheeseFactory name="Sample Cheese From Factory"  >>> cheese    Here, we specify that we want the name of our new cheese to be Sample Cheese From Factory. But it could be any name we want. We pass the name argument into CheeseFactory   the same way we would normally pass it into create  .  42.2 Bulk Generation  Let’s use this feature to generate a whole bunch of sample cheeses at once. Here we only create 10 cheeses, but it could be hundreds or more if we needed that many. In shell_plus, type this:  >>> for x in range 10 : ... CheeseFactory name=f"Sample Cheese {x}"   The names of the cheeses we created will be Sample Cheese 1, Sample Cheese 2, Sample Cheese 3, etc.  188   42.3 Reviewing Our Cheeses  In shell_plus, type this:  >>> Cheese.objects.all    If we do this query on cheeses we get some interesting results:    See all those new test cheeses? Ten more of them, all  created by our CheeseFactory.    Since we specified the name in the CheeseFactory   call, the cheeses have our desired names instead of being random characters.  42.4 Cheese Cleanup  Okay, it’s time to clean up our database so we can move on to the next lesson. Let’s delete the fake sample cheeses we just made.  >>> Cheese.objects.filter name__startswith='Sample' .delete    If we prefer, we could delete the fake cheeses via the Django admin, as we did before. But if we had hundreds of cheeses, we’d see why deleting via the REPL can be nice. It would save us from clicking on pages and pages of cheese. In this case, we created the cheeses manually by calling Cheese- Factory   from the REPL. However, if we had called CheeseFac- tory   from a unit test, we wouldn’t need to do this cleanup, as tests clean up the database for themselves. We’ll now see how factories are used in unit tests.  189   42.5 Replacing the Direct Cheese Model Call  in Our Existing Test  One of the tenets of good programming is that we’re not sup- posed to repeat ourselves. If we have to describe building cheeses again and again, that’s going to be a lot of repetition. And that’s where factories come into play. They build test data for us. Let’s change up our test data set of cheese. In cheeses tests test_models.py add this import right after where we imported the Cheese model  from ..models import Cheese :  from .factories import CheeseFactory  Then change this part where we created a cheese via create  :  cheese = Cheese.objects.create   name="Stracchino", description="Semi-sweet cheese that goes well with starches.", firmness=Cheese.Firmness.SOFT,     to this, where we now create a cheese via CheeseFactory  :  cheese = CheeseFactory name="Stracchino"   Putting it all together, the test should look like this:  def test___str__  :  cheese = CheeseFactory name="Stracchino"  assert cheese.__str__   == "Stracchino" assert str cheese  == "Stracchino"  190   Run the test and make sure it passes:  coverage run -m pytest  We should see this output:  coverage run -m pytest   Test session starts  platform: darwin, Python 3.8.1, pytest 5.3.4, pytest-sugar 0.9.2  django: settings: config.settings.test  from option  rootdir:  Users drg projects everycheese, inifile: pytest.ini plugins: sugar-0.9.2, django-3.8.0 collecting ... everycheese cheeses tests test_models.py ✓ everycheese users tests test_forms.py ✓ everycheese users tests test_models.py ✓ everycheese users tests test_urls.py ✓✓✓ everycheese users tests test_views.py ✓✓✓  42.6 Removing the Name Entirely  There’s no need to specify the cheese’s name. Replace the test with this:  def test___str__  :  cheese = CheeseFactory   assert cheese.__str__   == cheese.name assert str cheese  == cheese.name  This is even better than what we had before because:  191  11% █▎ 22% ██▎ 33% ███▍ 67% ██████▋ 100% ███████   1. The code is even shorter. 2. Now we are validating that the value of cheese.__str__   and str cheese is equal to cheese.name rather than a hard- coded string.  3. The value of cheese.name is randomly generated every time we run the test. While in this example it doesn’t mat- ter too much, if we were testing a more complex method, we might discover occasional test failures due to improper Unicode or special character handling.  Run the test again and make sure it passes:  coverage run -m pytest  42.7 Commit Our Work  git add -A git commit -m "Use CheeseFactory in a test" git push origin master  42.8 Summary  A running theme of our course is finding safe ways to acceler- ate how fast we do things. Generating test data is one of the more time consuming parts of writing tests, and factories simply accelerate the process. If we are uncomfortable with values the CheeseFactory stores in particular fields, we can change that by specifying field values during instantiation.  192   43 How Our Cheese Objects Feel  About Your Tests  It’s easy to think of our tests’ cheese objects as merely testing data. But remember, even cheese objects have feelings. When a cheese object passes its tests, it beams proudly with joy and satisfaction.  193   Figure 38: A good cheese that passed its test.  194       44 Finding and Adding a Third Party  Countries App  We’re going to make changes to our Cheese model. It would be interesting to track where a cheese is from. There are different approaches we could take: tracking the country, region, city, etc. What makes this even more complicated is the fact that a cheese’s country can be ambiguous: is it the country where the cheese originally was created, where the cheese is now produced, or where the cheese is available for purchase? It’s always good to limit scope and aim for simplicity, so we’ll do the following:    Add some sort of country field to the Cheese model.   Limit it to the country where the cheese originally came  from. That is, the cheese’s country of origin.  44.1 Country of Origin  To be more explicit, let’s call this field country_of_origin. Let’s now talk about the implementation. To represent a cheese’s country_of_origin value, here are some possible ways we could implement the field:  44.1.1 Option 1: Use a Plain CharField  The easiest way to implement the country_of_origin field would be to define it as a CharField like this:  195   country_of_origin = models.CharField "Country of Origin", max_length=255   There’s a big problem with this implementation, though. With a plain CharField, there are no constraints on what text we en- ter. We might accidentally enter US for one cheese and USA for another cheese. US is different from USA or United States in the database, making it challenging if we later decide to filter cheeses by country.  44.1.2 Option 2: Use a CharField With Choices  Another option would be to specify choices for the country like this:  country_of_origin = models.CharField "Country of Origin", max_length=20,  choices=COUNTRY_CHOICES, default=COUNTRY_UNSPECIFIED   Here, COUNTRY_CHOICES would be a list of all possible countries. While this resolves the problem of having different strings rep- resenting the same country, there’s still a big problem. It takes substantial work to create and maintain a list of countries. Ev- ery now and then, new countries form, countries that were split unite, and more. We could reduce our burden by sticking to the ISO 3166-125 standard list of country names, but then we would still have to keep the EveryCheese country list in sync with the ISO 3166-1 country list. We’d have to check it frequently and keep updating our code. 25https:  en.wikipedia.org wiki ISO_3166-1  196   44.2 Benefiting From Open Source  Option 2 seems the best, but it’s a substantial amount of work. Providing a list of country choices seems like such a common problem. For common problems like this, it’s good to search for an open source solution before attempting to implement any- thing. Open source to the rescue!  44.3 Check Django Packages  First step, go to https:  djangopackages.org and enter countries in the search bar. The top thing that comes up is a grid. Let’s go there:  Figure 39: Django Packages’ countries grid  Scanning the list, we can see Django Countries, a popular pack-  197       age that might fit what we need. Let’s do some analysis off the data Django Packages provides:    Says it’s Production Stable.   Has a good number of stars. This is a tricky value because  popular does not always equate to quality.   It’s maintained and has a history of such.   SmileyChris, aka Chris Beaven, a Django core team mem-  ber, maintains it.  Yeah! Let’s dive in!  44.4 Review Django Countries on GitHub  The instructions look nice and clear:  44.5 Look for the Release Number on PyPI  Let’s grab the version number so we can pin the dependency. We prefix the name of the project with https:  pypi.org project  and check it in our browser thus: https:  pypi.org project django- countries.  As usual, add the package and its version number to require- ments base.txt:  44.6 Install It  django-countries==6.0  198   Figure 40: Django Countries README on GitHub  The reason we choose to add to the common base.txt is that we want the package installed in all environments: local, test, and production. Then pip install the local requirements into our local virtualenv:  pip install -r requirements local.txt  This does the same as if we had typed:  199       pip install django-countries==6.0  44.6.1 Don’t Do This: Copy Paste Installation  This is bad. Really bad. Don’t do it!  1. git clone git@github.com:SmileyChris django-countries.git 2. cd django-countries 3. mv django_countries > everycheese everycheese  Don’t do the above! Why this is bad:    We’ve just lost ALL the advantages of open source. This  is what’s called a HARD fork.    Getting code updates is MUCH harder   Quick testing reversion is MUCH harder   Changes we make to our own Django Countries can will  cause breaking differences between implementations    Makes handling upgrades or installing security patches  MUCH harder  In summary, by cloning instead of extending we are hurting our- selves and whoever follows us in maintaining our projects. Be a good coder and stick to using package installers like pip instead of hard forks. And now back to our normally scheduled EveryCheese lesson…  44.7 Implement in cheeses models.py  that we pip installed our django-countries  Confident re- quirement, we follow the instructions in https:  github.com  SmileyChris django-countries.  200   44.7.1 Installation  Add django_countries to settings base.py’s THIRD_PARTY_APPS set- ting:  THIRD_PARTY_APPS = [  ... "django_countries",  CountryField  ]  44.7.2 Adding the Country Field to the Cheese Model  In cheeses models.py, try_of_origin like this:  import  CountryField and define coun-  from django_countries.fields import CountryField  class Cheese TimeStampedModel :  ... country_of_origin = CountryField "Country of Origin", blank=True   Since CountryField is an extension of CharField, we treat it sim- ilarly. We want country_of_origin to be optional, since it might be unknown for some cheeses, and so we set blank=True. But we don’t set null=True because Django’s convention is to store empty values as the empty string, and to retrieve NULL empty values as the empty string.  See Two Scoops of Django for a more detailed explanation.   44.8 Migrations!  The next stage is creating a database migration. From the com- mand line:  201   python manage.py makemigrations cheeses  Apply the migration:  python manage.py migrate  202   45 Display Cheese Country Data  45.1 Add Cheese Countries in the Admin  Startup runserver if it’s not already running. Then go the Django admin. For each cheese, choose a Country of Origin and save our changes.  Figure 41: Cheese country data in the admin  The countries of origin are:  Cheese Cheddar Gouda  Country of Origin United Kingdom Netherlands  203       Country of Origin  Cheese Camembert France Colby  United States of America  Now each cheese should have country data.  45.2 Display Country in Cheese Detail  At this point, the only place on the site where we can see Country of Origin data is in the Django admin. Let’s change that by showing country data on the cheese detail pages. Put this code into templates cheeses cheese_detail.html after the part where the cheese description is shown:  {% if cheese.country_of_origin %}   Country of Origin: {{ cheese.country_of_origin.name }}      {% endif %}  How this works:  1. As we did before with other fields, we check if the cheese has any value set for country_of_origin before even trying to display it.  2. Then we display the name of  country with cheese.country_of_origin.name. How did we know this would work? We found this usage example in the Django Countries documentation26:  the  26https:  github.com SmileyChris django-countriescountryfield  204   >>> person.country.name 'New Zealand'  Let’s start up the server and see what we get. Voilà, we have cheese Country of Origin displayed.  45.3 Run the Tests  Let’s run the tests in case anything broke:  coverage run -m pytest  The tests still pass:  Test session starts  platform: darwin, Python 3.8.1, pytest 5.3.4, pytest-sugar 0.9.2  django: settings: config.settings.test  from option  rootdir:  Users drg projects everycheese, inifile: pytest.ini plugins: sugar-0.9.2, django-3.8.0 everycheese cheeses tests test_models.py ✓ everycheese users tests test_forms.py ✓ everycheese users tests test_models.py ✓ everycheese users tests test_urls.py ✓✓✓ everycheese users tests test_views.py ✓✓✓  45.4 Update CheeseFactory  Open the cheeses app’s factories.py. Add this field to CheeseFac- tory:  205   country_of_origin = factory.Faker 'country_code'   The Faker documentation for faker.providers.address27 says that we can generate a fake country code like this:  >>> from faker import Faker >>> fake = Faker {'en-US': 1}  >>> fake.country_code    'NI'  Translating that to actual usage on our project, we pass the function name string of country_code into factory.Faker   to get a randomly-selected country code. In future Django Crash Course extensions, we’ll go over even more testing tricks that can be used be with fakes.  45.5 Verify That CheeseFactory Works  Make sure that CheeseFactory still can generate cheeses, and that it sets country_of_origin to random countries correctly. Open shell_plus and type:  from everycheese.cheeses.tests.factories import CheeseFactory for i in range 5 :  cheese = CheeseFactory    Then go to the cheese list in the Django admin. Click on each random new cheese and make sure that it has a random country of origin. When we’re done, delete the new cheeses via the Django admin. 27https:  faker.readthedocs.io en master providers faker.providers.address.html  206   45.6 Commit Our Work  git status git add -A git commit -m "Implement cheese country of origin" git push origin master  207   46 Implement Cheese Creation by  Users  Right now only admins can add, edit, and delete cheese data. But wouldn’t it be nice if users who aren’t admins could enter cheese data too? That would mean EveryCheese could gather content much faster. That’s the whole point of a user-generated content site: the admins don’t have to write all the content themselves. User- generated content means trusting users to enter in real cheeses.  46.1 Add a Cheese Creation View  Open cheeses views.py in our text editor. Remember, this is where we’ll put all our cheese-related views. We’ll be using a CreateView to display a cheese creation form on the EveryCheese website. First, import the CreateView class at the top of the views.py module:  from django.views.generic import CreateView  Define a CheeseCreateView by subclassing CreateView:  class CheeseCreateView CreateView :  model = Cheese  Here we specify its model as Cheese because it will be used for creating Cheese objects.  208   46.2 Add the Corresponding URL Pattern  We want the URL of the cheese form page to be  cheeses add . Therefore, add this URL pattern to cheeses urls.py in the url- patterns list:  path    ,  route='add ', view=views.CheeseCreateView.as_view  , name='add'  Where should we add it? Well, let’s first try adding it to the bottom, after CheeseDetailView. Put it there, start up runserver if needed, and then open our browser http:  127.0.0.1:8000 cheeses  add . We will see this:  Figure 42: No cheese found!  Look closely at that page and note that it says:  209       Raised by: everycheese.cheeses.views.CheeseDetailView  Oddly enough, it looks like the URL is matching CheeseDetail- View when it should be matching CheeseCreateView. Django thinks we’re looking for the Cheese Detail page for a cheese with the slug of add. Django tries each URL pattern in order until it finds a match. When it finds the first match, it calls the corresponding view. Here the first match is CheeseDetailView because add  matches '  '. Django never gets to the CheeseCreateView which comes next. Look closely at cheeses urls.py until we understand how this all works. Then move the URL pattern for CheeseCreateView up before CheeseDetailView. Our code should now be:  from django.urls import path  from . import views  app_name = "cheeses" urlpatterns =    path    , path    ,  route=' ', view=views.CheeseListView.as_view  , name='list'  route='add ', view=views.CheeseCreateView.as_view  , name='add'  210   route='  ', view=views.CheeseDetailView.as_view  , name='detail'  path    ,     Return to our browser and refresh the page. We will see a new error:  Figure 43: Need Fields Attribute  That’s because when we use a CreateView, we need to specify a fields attribute.  211       46.3 Specify the Desired Form Fields  The fields attribute tells the CreateView which of the model’s fields should appear on the form page. Open cheeses models.py. Take a look at our Cheese model. There are a number of fields. What do we want in the cheese creation form? The values a user should fill out for a cheese are:    name   description   firmness   country_of_origin  We don’t want a user to enter a slug, because that should be au- tomatically generated from the value of name. We also don’t want a user to enter anything for the created and modified fields inher- ited from TimeStampedModel because those values are automatically taken care of for us. Open cheeses views.py again. Add this attribute to CheeseCreate- View:  fields = ['name', 'description', 'firmness',  'country_of_origin']  Refresh the page in our browser. We should get a new error:  46.4 Define the Cheese Form Template  In templates cheeses , create a new file called cheese_form.html. Put this code inside:  212   Figure 44: Cheese Form Template Does Not Exist  {% extends "base.html" %}  {% block title %}Add Cheese{% endblock %}  {% block content %}  Add Cheese     {% csrf_token %} {{ form.as_p }}  Save     {% endblock %}  213       Here’s what’s going on:    Each item in the fields list is turned into the appropriate  HTML label input, as part of the form.    Each label input pair is displayed in a   element.   When the user clicks Save, the form sends a POST request  to the same URL with the form data.  46.5 Submit the Form  Save the file and go back to our browser. Refresh the page. We should now see the Add Cheese form: Try entering a cheese:    Name: Havarti   Description: A mild, buttery cheese that comes in loaves  or blocks.    Firmness: Semi-Soft   Country of Origin: Denmark  Click Save. Be forewarned as we’re going to generate an error page:  46.6 Implement Get_absolute_url    Whenever we define a CreateView, we also need to define a get_absolute_url   method on the corresponding model if one doesn’t exist yet. Open cheeses models.py in our text editor. Add the method to the Cheese class:  214   Figure 45: Add Cheese Form  def get_absolute_url self :  """Return absolute URL to the Cheese Detail page.""" return reverse 'cheeses:detail', kwargs={"slug": self.slug}   We’ll also need to add an import to the top of cheeses models.py to make this method work:  215       Figure 46: No URL to Redirect To  from django.urls import reverse  Now our CheeseCreateView will use this method. When a user fills out the Add Cheese form and submits the data, Django will create the cheese and redirect them to the Cheese Detail page for the cheese that they just created.  46.7 Resubmit the Form  Let’s go back to our browser and resubmit the form: The submission will go through. Then we’ll be redirected to the Cheese Detail page for the cheese that we just created:  216       Figure 47: Resubmit Cheese  Figure 48: Cheese Detail for Havarti  217           Congrats! Our CheeseCreateView now lets users create new cheeses.  46.7.1 Troubleshooting Non-ASCII Names  This can occur when we enter a cheese with non-ascii characters like Κεφαλοτύρι and that generates this error: django slug is defined before trying to ensure uniqueness. This may occur if we created the EveryCheese project before February 20th, 2020. If this happens, the solution is to install the Unidecode library thus:  pip install unidecode==1.1.1  Don’t forget to add the library to our project’s require- ments base.txt file. Here’s how it looks in the django-crash-starter: https:  github.com roygreenfeld django-crash-starter blob master  %7B%7Bcookiecutter.project_slug%7D%7D requirements base.txt  46.8 Link to the Add Cheese Form  The form works, but users still need a way to get to it. Open templates cheeses cheese_list.html in our text editor and add this button link to the bottom of the page:     Don't see a cheese listed here?     <a class="btn btn-primary"  href="{% url 'cheeses:add' %}" role="button">  Add Cheese        218   Make sure we put the button inside of the content block, before {% endblock content %}. Now when we click on Cheeses in the navbar, we should see the button at the bottom of the page:  Figure 49: Cheese List With Add Cheese Button  Click on the button to make sure that it brings up the Add Cheese form.  46.9 Commit the Changes  We’ve done a lot this lesson. It’s time to commit:  git status git add -A  219       git commit -m "First pass at working Add Cheese form" git push origin master  220   47 Use Django Crispy Forms for Bet-  ter Display  If we’re observant, we’ll have noticed that the Add Cheese form controls aren’t lined up properly.  Figure 50: Cheese form with unstyled form fields  47.1 Isn’t as_p   Enough?  Even if we use Django’s built-in form display methods as_p  , as_table  , or as_ul  , there’s no way to format the form so that  221       it uses Bootstrap’s form styles properly.  47.2 A Quick History Lesson  Django started as a project in 2003, back when the internet was a lot simpler. Then it was enough for a form to work. It didn’t have to be pixel-perfect. This was the time before HTML form UI toolkits like Bootstrap. Flash forward to January of 2009. Daniel Roy Greenfeld, em- ployed at NASA28 at the time, was given a task. He had to convert around 70 Django forms from using as_table   to some- thing that would match the Section 508 Web Content Accessi- bility Guidelines29. Rather than convert them manually, which would be both tedious and error-prone, Daniel elected to write a custom template filter to do the work. And thus was django-uni-form30 born! The project rapidly grew in features31. Over time support for formsets, custom layouts, and other features was added. The project increased in popularity32. The code having grown organically had a few problems. Daniel and Miguel Araujo, the other major contributor at the time, be- gan a rewrite. One issue was that the library only supported an obscure JavaScript CSS library, and Bootstrap was becom- ing much more popular. Eventually Daniel decided to hand the project off to Miguel, who in accepting it took Audrey Roy Greenfeld’s suggestion for a new form library name: django- crispy-forms33. 28https:  www.nasa.gov  29https:  www.section508.gov create web-content 30https:  pydanny.blogspot.com 2009 01 django-uni-form-lives.html 31https:  pydanny.blogspot.com 2009 02 should-django-uni-form-handle.html 32https:  github.com pydanny-archive django-uni-form 33https:  github.com maraujop django-crispy-forms  222   And that is the superhero origin story for django-crispy-forms.  47.3 Crispy Forms and Cookiecutter Django  The django-crispy-forms package should have already been in- stalled earlier when we installed all of django-crash-starter’s local requirements. Therefore, we don’t need to install it again. django-crash-starter uses Crispy Forms to control the way forms are rendered in the users app. We’ll do something similar in the cheeses app.  47.4 Our Non-Crispy Form  This is the form that we’re about to change: Right now form elements are rendered using   tags. That’s why they look so poorly aligned. Once we modify it to use Crispy Forms, the fields will align nicely. That’s because by default, Crispy Forms renders form elements with Bootstrap-compatible HTML.  47.5 Use the Crispy Template Tag  In our text editor, let’s open templates cheeses cheese_form.html. Load the Crispy Forms template tags at the top of the template. Add this line right below {% extends "base.html" %}:  {% load crispy_forms_tags %}  Now the crispy tag is available for us to use in the template. Find this line:  223   Figure 51: Add Cheese Form  {{ form.as_p }}  And replace it with this line:  {{ formcrispy }}  Now we are using the crispy filter. Putting it all together, our code should now be:  224       {% extends "base.html" %} {% load crispy_forms_tags %}  {% block title %}Add Cheese{% endblock %}  {% block content %}  Add Cheese     {% csrf_token %} {{ formcrispy }}  Save     {% endblock %}  47.6 Reload the Add Cheese Form  Let’s go back to our browser and reload the Add Cheese form at http:  127.0.0.1:8000 cheeses add . It should now look like this: It looks much better. Now the form is rendered with Bootstrap controls instead of   tags. That’s just the start of the power of Crispy Forms. There’s so much more that we can do to make our forms render exactly how we want. Crispy Forms gives us fine-grained form rendering control.  47.7 Commit the Changes  Let’s save our changes:  225   Figure 52: Add Cheese Form, Rendered With Crispy Forms  git status git add -A git commit -m "Use django-crispy-forms for better Add Cheese form display" git push origin master  226       48 Understand View Mixins  and  LoginRequiredMixin  In the previous chapter we made it possible for any user on EveryCheese to create new cheeses. But what happens when people use the Add Cheese form to enter fake data or spam the site?  48.1 User-Generated Content and Account-  ability  Inevitably, some users will try to mess with the site and enter in garbage data:    People who are just trying out the site and don’t know  what to enter.    Spammers adding links for SEO.  To control the creation of bogus cheeses, some level of account- ability would help. We’ll start by requiring users to be logged in when they create cheeses.  48.2 Try Accessing the Add Cheese Form  Anonymously  Open a new private browser window:    If we’re using Chrome: New Incognito Window   If Firefox: New Private Window  In the incognito private browser window, let’s go to our Add Cheese form: http:  127.0.0.1:8000 cheeses add   227   Figure 53: Add Cheese Form, As Anonymous User  Here are two important observations:    In that window, we are not logged in.   Yet we can access the Add Cheese form. That’s bad.  48.3 Require Login  We’re going to make the Add Cheese form accessible only to users who are logged into the site.  228       Open cheeses views.py in our text editor. At the top, add this import:  from django.contrib.auth.mixins import LoginRequiredMixin  Then modify CheeseCreateView to use LoginRequiredMixin like this:  class CheeseCreateView LoginRequiredMixin, CreateView :  ...  Now CheeseCreateView cannot be accessed unless we are logged into EveryCheese.  48.3.1 Try Accessing the Add Cheese Form Incognito  In our private  incognito  browser window, let’s reload the Add Cheese form  http:  127.0.0.1:8000 cheeses add  . We should now see this: What happened?    Because we were an anonymous user in that window, we  were redirected to the login page.    Note the URL in the address bar: http:  127.0.0.1:8000   accounts login ?next= cheeses add   –  accounts login  is the standard login page. – The URL contains the parameter next= cheeses add .  That is the page that we will be redirected to after we log in.  229   Figure 54: Incognito Redirect to Sign In Page  48.4 Try Accessing It as Cheesehead  Switch to the browser window where we are logged in as cheese- head. Refresh the Add Cheese form page. We should be able to access the form. That’s because we are already logged in, so we can access that page normally.  48.5 View Mixins  Here we saw a common example of a view mixin. View mixins are used with class-based views. We use them by putting them to the left of the subclassed view name.  230       View mixins are frequently used to restrict access to a view. Mixins seem very fancy, but they can be quite simple. A simple view mixin looks like this:  class MyMixin object :  def some_method self :  return self.something  If we were to use MyMixin in our CheeseCreateView, it would give CheeseCreateView a method called some_method.  48.6 Commit the Changes  Save our changes:  git status git add -A git commit -m "Constrain Add Cheese form to logged-in users only" git push origin master  231   49 Add a Creator Field and Update  Our Cheese Records  To increase accountability, we’ll start tracking the creator of each cheese.  49.1 Add a Creator Field  Add the creator field to the Cheese model. Put this under the other field definitions but before the method declarations of __str__ and get_absolute_url:  creator = models.ForeignKey   settings.AUTH_USER_MODEL, null=True, on_delete=models.SET_NULL     This field is a Foreign Key to a User object. In this case since we are defining a field and just need a string representation of the User model name, it’s fine to import that string from settings rather than calling get_user_model  . We’ll also need to add this cheeses models.py module:  to the top of  import  the  from django.conf import settings  Remember to put it in the Django imports section, keeping that section organized alphabetically.  232   49.1.1 Explaining Foreign Keys  In relational databases, a foreign key is used to link two tables together. The first table has a field dedicated to tracking the key, which can select amongst the rows of the second table. Se- lections cannot for rows not in the second table. This protects the integrity of data. To use our own example, a cheese creator must be a user within the EveryCheese system. Our example also includes an on_delete action of models.SET_NULL, which means if the user selected as cre- ator is deleted, the cheese is not deleted. Instead, the cheese record has a null value assigned to the creator. Other options used to protect the integrity of data might be to delete the cheese or assign it to a default “EveryCheese Master” record. It really depends on the business requirements for a project and how the data needs to be protected. In summary, the idea that foreign keys are a critical part of the relational in relational databases is accurate and worth investi- gating:    Django Docs on Foreign Keys:  http:  bit.ly django-db-  models-ForeignKey    https:  en.wikipedia.org wiki Foreign_key  49.2 Make and Apply the Migration  At the command-line run migrate, which will apply the migration that we just created and edited:  python manage.py makemigrations cheeses python manage.py migrate  233   We don’t want the new creator to ever be empty. It’s a matter of data  and cheese  integrity. Once we run that, go into the Django shell with python manage.py shell_plus.  >>> cheesehead = User.objects.get username='cheesehead'  >>> for cheese in Cheese.objects.all  : ... ...  cheese.creator = cheesehead cheese.save    Now each Cheese record will have a creator field with the value set to the cheesehead User object. We can confirm this by checking cheese creators in either the Django admin or inside shell_plus. For example:  for cheese in Cheese.objects.all  : ...  print cheese, cheese.creator   49.3 Commit the Changes  Let’s save our changes:  git status git add -A git commit -m "Add creator field to Cheese model and custom migration" git push origin master  234   50 Track and Display the Cheese Cre-  ator  When a user submits a new cheese via the Add Cheese form, the CheeseCreateView will tie their User record to the new cheese that they created. That way if someone enters in bad data, we can go into the admin and warn or delete their account.  50.1 Set the Cheese Creator After Form Vali-  dation  The creator field shouldn’t be shown on the Add Cheese form page. That would allow users to set it to whatever they want, which would be bad. Instead, we want to automatically set the value of creator. A good place to do this is after the form data has been validated. We can override a CreateView’s form_valid   method to insert form data after validation occurs. Open cheeses views.py in our text editor. Add this form_valid   method to CheeseCreateView:  def form_valid self, form :  form.instance.creator = self.request.user return super  .form_valid form   Here, the value of creator is set to the User object associated with the current request. We can set creator programmatically after form validation be- cause there’s no need to validate the value of creator: it comes from our code, not from user input. The finished view class should now look like this:  235   class CheeseCreateView LoginRequiredMixin, CreateView :  model = Cheese fields = ['name', 'description', 'firmness',  'country_of_origin']  def form_valid self, form :  form.instance.creator = self.request.user return super  .form_valid form   50.2 Display the Creator on the Cheese Detail  Pages  On the Cheese Detail page, we’re going to display a bunch of info about the creator of the cheese:    Their username   Their name, if one exists in the database   Their bio, if one exists in the database  Let’s open templates cheeses cheese_detail.html in our text editor. At the bottom of the template, add a section containing info about who submitted the cheese:         Submitted by  {{ cheese.creator.username }}      {% if cheese.creator.name %}  236    {{ cheese.creator.name }}   {% endif %}  Powered by creator foreign key to the UserModel, what we’re pro- viding:    The creator’s username   A link to the creator’s bio   If they’ve filled it out, the creator’s name  Inside of Django when we ask for information about the cheese creator it queries the user table for us. This is really useful, taking away the minutia of writing small queries.  50.3 Try It Out  Start runserver if it’s not already running. Go to any Cheese Detail page. Look at the bottom for info about who created the cheese. While logged in as cheesehead, try adding a cheese:    Name: Kesong Putî   Description: A fresh, salty white cheese made from Philip-  pine water buffalo milk.    Firmness: Soft   Country of Origin: Philippines  It’s good to do this in order to ensure that our overridden Chees- eCreateView.form_valid   is saving the current user as the cheese’s creator. Save the cheese. We should be redirected to the Cheese Detail page, which should have our cheesehead user as the creator.  237   Figure 55: Cheese Detail With Creator  50.4 Commit the Changes  Save our changes:  git status git add -A git commit -m "Track and display the creator of each cheese" git push origin master  238       51 Update the Cheese Factory  Alright, we’ve made a number of code changes. We haven’t run the tests in awhile, and there are probably tests that we need to update or write.  51.1 Run the Tests  Let’s see what happens when we run the test suite:  coverage run -m pytest  The tests still pass. That doesn’t mean that we’re off the hook. We still have some changes to make.  51.2 Modify Cheese Factory  In VS Code, open cheeses tests factories.py. Study what we have so far in our CheeseFactory class. Notice that it doesn’t set the value of creator anywhere. To set creator, we’ll need a User object. The easiest way to get one for our CheeseFactory is to create a User with UserFactory. First, import UserFactory near the top of the cheeses tests factories.py module:  from everycheese.users.tests.factories import UserFactory  Then add this line to our CheeseFactory definition right under- neath the country_of_origin definition:  239   creator = factory.SubFactory UserFactory   Now when we use CheeseFactory to create a Cheese instance, the cheese’s creator will be a user created by UserFactory.  51.3 Run the Tests, Again  coverage run -m pytest  The tests should still pass.  51.4 Try CheeseFactory in the Shell  Okay, the tests passed. But how do we know that CheeseFactory is creating cheeses with creators properly? Well, we can see for ourselves in the shell. Start up Shell Plus:  python manage.py shell_plus  Instantiate a Cheese object using CheeseFactory, and see what the value of cheese.creator is set to:  In [1]: from everycheese.cheeses.tests.factories import CheeseFactory  In [2]: cheese = CheeseFactory    240   In [3]: cheese.creator Out[3]:    As we can see, a User object was created with a username of millsdustin. Of course, the name of the user in this book might be different from what we get in our shell.  51.5 Delete the Random Cheese  Clean up by deleting the random cheese that we created:  In [4]: cheese.delete   Out[4]:  1, {'cheeses.Cheese': 1}   51.6 Delete the Random User  Clean up the random user as well:  In [5]: u = User.objects.last    In [6]: u Out[6]:    In [7]: u.delete   Out[7]:  1, {'admin.LogEntry': 0, 'users.User_groups': 0, 'users.User_user_permissions': 0, 'users.User': 1}   241   We’re done experimenting and cleaning up. Exit the shell with Ctrl+D.  51.7 Commit the Changes  Save our changes:  git status git add -A git commit -m "Modify cheese factory to create a cheese creator user" git push origin master  242   52 Update the Cheese Model Tests  Open cheeses tests test_models.py in our text editor. We should have one test in there:  def test__str__  :  cheese = CheeseFactory   assert cheese.__str__   == cheese.name  Now look at cheeses models.py to determine if any new model tests need to be written:    __str__   has a test already.   get_absolute_url   still needs a test.  52.1 Test Get_absolute_url    Now we have a cheese ready to use in our next test. When we test get_absolute_url  , we want to call it and check that the result matches the expected absolute URL. Suppose we have a cheese named My Happy Cheese. Its absolute URL should be  cheeses my-happy-cheese , using cheese.slug in the URL. Add this test to the bottom of the cheeses test_models module:  def test_get_absolute_url  : cheese = CheeseFactory   url = cheese.get_absolute_url   assert url == f' cheeses {cheese.slug} '  243   Run the cheese model tests:  coverage run -m pytest  All the tests should pass.  52.2 Commit the Changes  Let’s save our changes:  git status git add -A git commit -m "Add test for get_absolute_url   method" git push origin master  244   53 Test All the Cheese Views  53.1 What to Test?  In a previous chapter, we added a creator field to the Cheese model which was a simple ForeignKey. This is just standard Django ORM usage. The Django core codebase already has tests for ForeignKey, so we don’t need to test that. There’s no other new model code. If we had added any model methods, we would have to write tests for them. We did define a new view: CheeseCreateView with a new URL pattern. It would be nice to test both of those, the view and the URL pattern. It’s also a good idea to have basic tests on our other views and URL patterns for completeness.  53.2 Start With Imports  In our text editor, create cheeses tests test_views.py. This is where we’ll be putting all our cheese view tests. Let’s import all the things we’ll need for the tests. Put this at the top of the module:  import pytest from pytest_django.asserts import    assertContains, assertRedirects     from django.urls import reverse from django.contrib.sessions.middleware \  import SessionMiddleware  245   from django.test import RequestFactory  from everycheese.users.models import User from ..models import Cheese from ..views import   CheeseCreateView, CheeseListView, CheeseDetailView    from .factories import CheeseFactory  pytestmark = pytest.mark.django_db  The first import is the pytest library. Then we import com- mon utilities from Django. Finally, we import User and Cheese models and view from our EveryCheese project. In this mix, we import the CheeseFactory so we can more easily write tests for cheese. Finally, we set pytestmark, which connects our tests to the database.  53.3 The First Cheese View Tests  We like to start our tests by stubbing out a simple test function for each view. These stubs are a great place to start when you’re not sure what view tests need to be written. All we’ll do at first is check that the views are returning valid 200 HTTP status codes34 for GET requests. 34https:  developer.mozilla.org en-US docs Web HTTP Status 200  246   53.3.1 Testing the Cheese List  For the list view test, pass in the name string for the list view. That’s cheeses:list. Add this test to test_views.py under the im- ports. The test has been commented heavily so we know what’s going on:  def test_good_cheese_list_view_expanded rf :  the cheese list view   Determine the URL url = reverse "cheeses:list"   rf is pytest shortcut to django.test.RequestFactory  We generate a request as if from a user accessing  request = rf.get url   Call as_view   to make a callable object  callable_obj is analogous to a function-based view callable_obj = CheeseListView.as_view    Pass in the request into the callable_obj to get an  response = callable_obj request   Test that the HTTP response has 'Cheese List' in the  assertContains response, 'Cheese List'   HTTP response served up by Django  HTML and has a 200 response code  Try it out!  coverage run -m pytest    assertContains also checks HTTP Status  A more accurate name case would be assertContainsAndCheckStatus.  the  for  assertContains  test If we read  247     the docs a 200 HTTP status code. ence the documentation on assertContains   docs.djangoproject.com en 3.0 topics testing tools .  for assertContains we see it also confirms refer- in https:  For more details,  Typically this test is written in much shorter format, but we expanded it as far as we could in order to understand exactly what’s going on. Here’s how this test is typically written:  def test_good_cheese_list_view rf :   Get the reauest request = rf.get reverse "cheeses:list"    Use the request to get the response response = CheeseListView.as_view   request   Test that the response is valid assertContains response, 'Cheese List'   Let’s try running tests again:  coverage run -m pytest  53.3.2 A Basic Cheese Detail Test  Similarly, we can test the CheeseDetailView by using Cheese- Factory to generate some test data. Let’s add this to our test_views.py module. Since individual cheeses have a URL based on their slug, our use of the reverse   function is expanded to use the cheese slug as an argument. We also pass in the cheese slug as part of the callable object. Here’s what it looks like:  248   def test_good_cheese_detail_view rf :   Order some cheese from the CheeseFactory cheese = CheeseFactory    Make a request for our new cheese url = reverse "cheeses:detail",  kwargs={'slug': cheese.slug}   request = rf.get url    Use the request to get the response callable_obj = CheeseDetailView.as_view   response = callable_obj request, slug=cheese.slug   Test that the response is valid assertContains response, cheese.name     Cheese doesn’t have slugs  It goes without saying that Cheese doesn’t have slugs. And when eating cheese, we advise against mixing it with slugs. There’s a near-infinite selection of other things to mix with cheese. Indeed we suggest you start with more palatable options to partner with cheese.  Okay, enough about slugs, let’s run the tests!  coverage run -m pytest  53.3.3 A Basic Cheese Create Test  The create view doesn’t need a keyword argument. But it’s a bit trickier because you can’t access it unless you’re logged in, due to the LoginRequiredMixin you used.  249       You need to first set up a user so that you can log in as    In the test, the admin_user class provides an already authen-  that user.  ticated user.  Add this test to test_views.py:  def test_good_cheese_create_view rf, admin_user :   Order some cheese from the CheeseFactory cheese = CheeseFactory    Make a request for our new cheese request = rf.get reverse "cheeses:add"    Add an authenticated user request.user = admin_user  Use the request to get the response response = CheeseCreateView.as_view   request   Test that the response is valid assert response.status_code == 200  Run the tests yet again:  coverage run -m pytest  At this point, we’ve stubbed out a test for each cheese view. That’s a good start. These tests are better than nothing. But we can do better.  53.4 Really Test the Cheese List View  What does a list view do? It lists its associated objects. A good thing to test is whether the list view response contains a couple of object’s names.  250   For that, we’ll need to add a few kinds of cheese. Then look inside the Cheese List response and check that the names of the cheeses can be found.  def test_cheese_list_contains_2_cheeses rf :  for a list of cheeses   Let's create a couple cheeses cheese1 = CheeseFactory   cheese2 = CheeseFactory    Create a request and then a response  request = rf.get reverse 'cheeses:list'   response = CheeseListView.as_view   request   Assert that the response contains both cheese names  assertContains response, cheese1.name  assertContains response, cheese2.name   in the template.  As always, run the tests:  coverage run -m pytest  53.5 Test the Cheese Detail View  A detail view shows detailed data for 1 object, in this case cheese. Let’s write a test that checks the response contents:  def test_detail_contains_cheese_data rf :  cheese = CheeseFactory    Make a request for our new cheese url = reverse "cheeses:detail",  251   kwargs={'slug': cheese.slug}   request = rf.get url   Use the request to get the response callable_obj = CheeseDetailView.as_view   response = callable_obj request, slug=cheese.slug   Let's test our Cheesy details! assertContains response, cheese.name  assertContains response, cheese.get_firmness_display    assertContains response, cheese.country_of_origin.name   Run the tests again:  coverage run -m pytest  53.6 Test the Cheese Create View  A create view should create an object correctly. Upon POST, CheeseCreateView should redirect to the detail page for the created cheese. The creator of that cheese should be the user who was logged in and submitted the cheese. We can test for this as follows:  def test_cheese_create_form_valid rf, admin_user :   Submit the cheese add form form_data = {  "name": "Paski Sir", "description": "A salty hard cheese", "firmness": Cheese.Firmness.HARD  } request = rf.post reverse "cheeses:add" , form_data   252   request.user = admin_user response = CheeseCreateView.as_view   request    Get the cheese based on the name cheese = Cheese.objects.get name="Paski Sir"    Test that the cheese matches our form assert cheese.description == "A salty hard cheese" assert cheese.firmness == Cheese.Firmness.HARD assert cheese.creator == admin_user  Run the tests:  coverage run -m pytest  53.7 Commit the Changes  Let’s save our changes:  git status git add -A git commit -m "Write tests for all cheese views" git push origin master  53.8 Conclusion  In this chapter we wrote a bunch of tests, some to increase test coverage, and others to ensure that code already covered had more accurate tests. In other words, we added depth to our tests.  253   Keep in mind that 100% test coverage is only as meaningful as the tests that cover the code. It is possible to write meaningless tests that increase test coverage of code but don’t account for checking the validity of the results of that code. For example, while we came into this chapter with the code for the cheese list and detail views list at 100% coverage, whether or not cheese data showed up in their templates was not yet checked. We addressed that in this chapter, adding depth to our tests. Keep in mind we’re not necessarily done. It may not be obvious yet, but there are ways we can improve the tests in this chapter. It’s not uncommon for experienced coders to come back to tests they wrote years, months, weeks, or even days earlier and find ways they could make them better. And that’s okay. it’s just the nature of being a software devel- oper writing tests.  254   54 Test All the Cheese URL Patterns  We like to test each of our URL patterns. Regular expressions can be error-prone. It’s nice to have tests in place just to verify that they behave as expected.  54.1 Add the Imported Cheese  Create the module cheeses tests test_urls.py. Import reverse and resolve from django.urls, which we’ll need to test URL patterns backwards and forwards:  import pytest  from django.urls import reverse, resolve  from .factories import CheeseFactory  pytestmark = pytest.mark.django_db  54.2 Write Our First Fixture  In this chapter we’re going to need an instantiated cheese a few times. Rather than write cheese = CheeseFactory   in each test function, we’re going to create a test fixture. It’s quite easy to do, just put this underneath the imports:  @pytest.fixture def cheese  :  return CheeseFactory    We’ll use this later in this chapter.  255   54.3 Test the Cheese List URL Pattern  When we test URL patterns, it’s good to test them backwards and forwards:    Reversing the view name should give us the absolute URL.   Resolving the absolute URL should give us the view name.  Applying these concepts to testing the cheese list URL pattern, add the following to test_urls.py:  def test_list_reverse  :  """cheeses:list should reverse to  cheeses .""" assert reverse 'cheeses:list'  == ' cheeses '  def test_list_resolve  :  """ cheeses  should resolve to cheeses:list.""" assert resolve ' cheeses ' .view_name == 'cheeses:list'  Run the tests again:  coverage run -m pytest  What we like about writing these tests is that it provides us more than just proof that we have good URLs, and protects us from supplying “404 page not found” errors to users. Specifically, it helps us understand how Django resolves URLs.  54.4 Test the Add Cheese URL Pattern  The tests for the add cheese URL pattern are very similar to those for the cheese list. That’s because for both URL patterns there are no slugs, primary keys, or other arguments to pass in.  256   Add these tests to test_urls.py:  def test_add_reverse  :  """cheeses:add should reverse to  cheeses add .""" assert reverse 'cheeses:add'  == ' cheeses add '  def test_add_resolve  :  """ cheeses add  should resolve to cheeses:add.""" assert resolve ' cheeses add ' .view_name == 'cheeses:add'  Run the cheese URL tests:  coverage run -m pytest  54.5 Test the Cheese Detail URL Pattern  Here’s where things get slightly fancier. The cheese detail URL pattern takes in a cheese slug. Remember how we created a cheese fixture earlier for testing purposes? Now’s the time to use it. We just include it a the argument in the test functions. Add these tests to cheeses tests test_urls.py:  def test_detail_reverse cheese :  """cheeses:detail should reverse to  cheeses cheeseslug .""" url = reverse 'cheeses:detail',  kwargs={'slug': cheese.slug}   assert url == f' cheeses {cheese.slug} '  def test_detail_resolve cheese :  """ cheeses cheeseslug  should resolve to cheeses:detail."""  257   url = f' cheeses {cheese.slug} ' assert resolve url .view_name == 'cheeses:detail'  Run the cheese URL tests:  coverage run -m pytest  Remember in the previous chapter when we used the rf and admin_user arguments in our test functions? Those were fixtures just like our new cheese fixture. In any case, we’ve tested all our cheese URL patterns. That wasn’t so bad. URL patterns are relatively simple to test.  54.6 Commit the Changes  Let’s save our changes:  git status git add -A git commit -m "Write tests for all cheese URL patterns" git push origin master  258   55 Adding a CheeseUpdateView and  Form Recycling  So far, EveryCheese has a way to create new cheeses. However, it lacks a way for end-users to update existing cheeses. If we’re a regular user entering a new cheese and we make a mistake, we have no way to fix it. In this chapter, we’re going to add an update view to the cheeses app.  55.1 Add the CheeseUpdateView  The first step is to go to cheeses views.py and import the generic UpdateView class. We can combine this import with the existing imports:  At the bottom of the file, define CheeseUpdateView:  from django.views.generic import    ListView, DetailView, CreateView, UpdateView     class CheeseUpdateView UpdateView :  model = Cheese fields = [ 'name', 'description', 'firmness',  259   'country_of_origin'  ] action = "Update"  Notice how the definition is very similar to that of CheeseCreate- View.  55.2 Wire in the URL Pattern  Add the following URL pattern to cheeses urls.py. We can put it before the detail and after the add views:  path    ,  route='  update ', view=views.CheeseUpdateView.as_view  , name='update'  The route here is equivalent to that of the CheeseDetailView plus update  at the end.  55.3 Try It in the Browser  Start runserver if it’s not already running. Go back to the browser. From the cheese list, click on any cheese to go to its cheese detail page. Then add update  to the end of the URL and load the page. That should bring up the Add Cheese form. The difference from before is that the form fields should already be populated with data:  260   Figure 56: Pre-populated Add Cheese Form  Try making a change to the description and country of origin. Save the changes. We should see our changes reflected in the cheese detail page. Great! Right? However, check the URL bar we’ll notice something weird. The slug has a “-2” appended to it. Even more noticeable is that if we go to http:  127.0.0.1:8000   261       cheeses  we can see that there are now 2 kinds of cheese with that name. What just happened?!?  55.4 What Happened?!?  By default, both CheeseCreateView and CheeseUpdateView share the same cheese_form.html template. The problem is that our current cheese_form.html always sends the user to the CheeseCreateView, even if we’re doing it from the CheeseUpdateView Let’s fix that, making the form template flexible enough to han- dle both CheeseCreateView and CheeseUpdateView views. Open tem- plates cheeses cheese_form.html in your text editor.  55.4.1 Using View Properties In Templates  Right now the h1 element of templates cheeses cheese_form.html and the form button are hardcoded as:   Add Cheese  ...  Save   This makes the form confusing because adding cheese isn’t the same as updating cheese. Let’s fix it by replace the current code in {% block content %} with the following more flexible approach:  {% block content %} {% with action=view.actiondefault:"Add" %}   {{ action }} Cheese   262      {% csrf_token %} {{ formcrispy }}  {{ action }}      {% endwith %} {% endblock title %}  Let’s break down what we just did:  1. We used the Django template tag {% with %} to set the view.action view method under the simpler name of action, and default it to “Add”. This only lasts for the duration of the request, and can only be used within one code block. 2. We used the action variable in both the h1 and submit form.  If we refresh the page, we’ll see that the Add is gone and replaced by Update. So where did the view.action variable come from? Let’s dig in and find out!  1. In the section above titled Add the CheeseUpdateView, the CheeseUpdateView included a property called action and was set with the value of "Update".  2. Inside a template rendered by a view, we can call at- tritibutes and properties of the view, referencing it under the easily remembered object name of view.  3. The action attribute of the view specifies what we are do- ing. Because we used clear language, it’s not just easier to debug, we can use it as a internationalizable value in our project.  263   55.4.2 Smart Titling  Right now the title element of templates cheeses cheese_form.html is hardcoded as:  {% block title %}Add Cheese{% endblock %}  Let’s make it a more flexible title by leveraging in the view.action property. In our template, change the title block to be:  {% block title %}{{ view.actiondefault:"Add" }} Cheese{% endblock title %}  We just removed the word Add with {{ view.action }}, which calls the action property on the view used in a request. Refresh the page and if we check the browser tab the title of the page has changed.    Why didn’t we wrap the whole page in with?  Unfortunately, Django’s {% with %} template tag doesn’t work across template blocks.  55.4.3 Form Posting to Itself  Right now the form method and action are defined as:     Using action="." as below is a commonly-used trick to reuse a form template for both create and update views. Replace the above with:  264        Now the form page posts to itself in both cases, eliminating the need to create 2 forms with hardcoded actions.  55.5 Link to the Update Form  It would be nice if every cheese detail page had an Update but- ton, with the button going to the update form for the cheese. Open templates cheeses cheese_detail.html in your text editor. Right below the page title, add a button link to the cheese detail form:  <a class="btn btn-primary"  href="{% url 'cheeses:update' cheese.slug %}" role="button">        Update     55.6 Try It in the Browser  Go to the Cheese Detail page for any cheese. Click Update to make changes to a cheese. Then see what hap- pens. Compare this with creating a cheese.  55.7 Make Login Required  Earlier we imported LoginRequiredMixin so that we could use it in CheeseCreateView. Add it to CheeseUpdateView as well:  265   Figure 57: Cheese Detail With Update Button  class CheeseUpdateView LoginRequiredMixin, UpdateView :  Order matters here with multiple inheritance. Make sure it’s put to the left of UpdateView. This will prevent anonymous users from modifying existing cheeses.  55.8 Commit the Changes  Finally, we save our work:  266       git status git add -A git commit -m "Add cheese update view, modify template" git push origin master  267   56 Test the Cheese Forms and Update  View  We’ve implemented a CheeseUpdateView, and we’ve made changes to the cheese_form.html template used by both CheeseCreateView and CheeseUpdateView. Now’s a good time to check on the tests and write more.  56.1 Refactoring our Cheese Fixture  Before we add more tests, let’s do some refactoring. The cheese fixture that we created in the last chapter was so useful, let’s add it to other Cheesy tests. To do this, open up cheeses tests factories.py and under the other imports at the top bring in the pytest library. Also, copy in the cheese fixture:  import pytest  @pytest.fixture def cheese  :  return CheeseFactory    Now, let’s open up cheeses tests test_views.py and bring our new cheese fixture. We’ll do it by importing the cheese fixture right after CheeseFactory import. That means we should have a line like this at the top of the module:  from .factories import CheeseFactory, cheese  268   Once that’s in place, in cheeses tests test_views.py find the test function named test_good_cheese_detail_view. Change the top three lines from this:  def test_good_cheese_detail_view rf :   Order some cheese from the CheeseFactory cheese = CheeseFactory    to this, where a cheese argument has been added to the function and the call to CheeseFactory has been removed:  def test_good_cheese_detail_view rf, cheese :  Order some cheese from the CheeseFactory  Now run the tests again:  coverage run -m pytest  All tests should pass. Not only that, but we’ve reduced line count and added clarity to the tests. Yeah! Now, with the exception of test_cheese_list_contains_2_cheeses, which needs two cheeses to function, go and change the other tests in cheeses tests test_views.py.  56.2 Test the Add Cheese Page Title  Since we added an if else block to the page title cheese_form.html, it’s good to test that both branches work. Add this test to cheeses tests test_views.py:  in  269   def test_cheese_create_correct_title rf, admin_user :  """Page title for CheeseCreateView should be Add Cheese.""" request = rf.get reverse 'cheeses:add'   request.user = admin_user response = CheeseCreateView.as_view   request  assertContains response, 'Add Cheese'   This test checks that the web page corresponding to CheeseCre- ateView contains the string Add Cheese.  56.3 Test That CheeseUpdateView Is a Good View  So we can test it, add CheeseUpdateView to the imports:  from ..views import   CheeseCreateView, CheeseListView, CheeseDetailView, CheeseUpdateView     Then, following the same pattern established in previous chapters, we start testing CheeseUpdateView. We define a test case in test_views.py, comment it extensively, and call it test_good_cheese_update_view  .  def test_good_cheese_update_view rf, admin_user, cheese :  url = reverse "cheeses:update",  kwargs={'slug': cheese.slug}    Make a request for our new cheese  270   request = rf.get url   Add an authenticated user request.user = admin_user  Use the request to get the response callable_obj = CheeseUpdateView.as_view   response = callable_obj request, slug=cheese.slug   Test that the response is valid assertContains response, "Update Cheese"   Again, test_good_cheese_update_view   is just a start. It gives us some peace of mind, especially as EveryCheese grows in new and unexpected directions.  56.4 Test That a Cheese Updates Correctly  Remember, the point of CheeseUpdateView is to give us a form page for modifying cheeses that already exist in the database. A good thing to test is whether we can send a POST request to CheeseUpdateView with data modifying an existing cheese. Add this test to test_views.py module:  def test_cheese_update rf, admin_user, cheese :  """POST request to CheeseUpdateView updates a cheese  and redirects.  """  Make a request for our new cheese form_data = {  'name': cheese.name, 'description': 'Something new', 'firmness': cheese.firmness  } url = reverse "cheeses:update",  271   kwargs={'slug': cheese.slug}  request = rf.post url, form_data  request.user = admin_user callable_obj = CheeseUpdateView.as_view   response = callable_obj request, slug=cheese.slug     Check that the cheese has been changed cheese.refresh_from_db   assert cheese.description == 'Something new'  Notice how we call refresh_from_db   to update the cheese instance with the latest values from the database. This is needed because the database was modified, the old cheese object is stale until refreshed.  56.5 Commit the Changes  It’s time to save our changes:  git status git add -A git commit -m "Test the cheese forms and update view" git push origin master  272   57 EveryCheese is the Foundation!  Congratulations! We’ve reached the end of the tutorial part of this book, but this isn’t the end for EveryCheese. After the summary below, this chapter includes Next Steps After This Book. The EveryCheese project is built off solid Django principles, the same ones that we’ve espoused in our Two Scoops of Django book series for over seven years. Like the hellodjango project, we recommend keeping EveryCheese as a reference project to see how to write tests, modify views, use choices fields, and other techniques used in production Django projects.  57.1 Summary  We started with a deployable project by using the django-crash- starter Cookiecutter template. We installed dependencies, cre- ated a database, and started up Django’s development server. Then we saved our progress using git. Next, we explored authentication and the User model. We ex- panded upon the User model by adding a bio field. Then we learned about tests and test coverage. Now we got into the cheesiness of things. We created a Cheeses app and a Cheese model. We generated the model migration and executed it, creating a table in our database. And we began writing our tests. From here we expanded on our cheese model and began adding views so users could start adding their favorite cheeses. Work- ing with views meant learning about controlling access to views, adding links, buttons, multi-use templates, and third-party pack- ages like django-countries and django-crispy-forms. Throughout all of this, we reinforced the idea of writing easily understood function-based tests powered by pytest. That came  273   with more knowledge about useful project ingredients like test factories and pytest fixtures. Speaking of project ingredients, for sample data we mentioned delicious cheeses from around the world.  57.2 Next Steps After This Book  This isn’t the end for EveryCheese! In the weeks and months to come, we’re going to be releasing Django Crash Course Extensions, all of which will use EveryCheese as the foundation. Rather than write a HUGE tutorial book off what we think our readers want, we’re writing a series of “micro-books” starting at US$2.99 based on the material we’ve taught based on previous customer requests. This allows readers to pick and choose what they want to learn. Here are some extensions we are considering:    Individual deployment optimization extensions for AWS,  Azure, GCP, and Heroku    VueJS   React*   Django REST Framework   GraphQL   Async, ASGI, and Channels   Celery   Payment gateways like Stripe, Paddle, and PayPal  If you’re interested in helping us write any of the extensions listed above or have suggestions for ones you would like to write, we pay authors a generous 50% royalties for books published by us. While we reserve the right to determine what we publish, we do promise to seriously consider every submission. Contact us at hi@roygreenfeld.com35. 35mailto:hi@roygreenfeld.com  274   57.3 Giving Us Feedback  If you have any feedback, the absolute best place to give it to us is on our oﬀicial issue tracker at https:  github.com roygreenfeld  django-crash-course issues.  275   Part III Aftermatter  58 Troubleshooting  This appendix is for helping readers resolve problems that may come up during the Django Crash Course.  58.1 Troubleshooting Conda Installations on  Pre-Catalina OSX  If conda list fails, then enter these two commands, replacing THEUSERNAME with our Mac username:  source  Users THEUSERNAME miniconda3 bin activate conda init  58.2 Troubleshooting Conda Installations on  Catalina or higher OSX  source  Users THEUSERNAME miniconda3 bin activate conda init zsh  Reference:  https:  docs.conda.io projects conda en latest user-guide install  macos.html  276   If that still doesn’t work, we recommend reading https:   towardsdatascience.com how-to-successfully-install-anaconda-on- a-mac-and-actually-get-it-to-work-53ce18025f97  58.3 Troubleshooting PostgreSQL: Role Does  Not Exist  We’ll probably run into this if we’re on GNU Linux, and if we haven’t given our local development user a role yet. If we get this error:  createdb: could not connect to database template1: FATAL: role "audreyr" does not exist`  Then it means we need to create a role for our local user. Start the psql prompt as the postgres user, and create a role for our- selves with the CREATEDB and LOGIN attributes. Change audreyr to our own username:  psql -U postgres postgres= CREATE ROLE audreyr WITH CREATEDB LOGIN; postgres= \q  Our username is what prints out when we type whoami at the command line. Try createdb everycheese again. With this role we shouldn’t need to create a Postgres user or password specific to everycheese, which means we won’t need to edit our settings to include any new database-specific username or password.  277   58.4 Troubleshooting PostgreSQL: Cannot  Create Database  If we get an error about not having permission to create a database, we can try enabling trust authentication for all in PostgreSQL. Edit our pg_hba.conf  e.g.  etc postgresql 9.5 main pg_hba.conf  to have this line:  local users  local all all trust  Make sure that there’s no other line that cancels this line out, such as local all all md5. Then restart PostgreSQL:  sudo service postgresql restart  Try createdb everycheese again.  58.5 Troubleshooting PsycoPG2  If we get the error pg_config executable not found, it most likely means that psycopg2 can’t find where we installed Postgres on our system. Try adding our Postgres path to our PATH variable.  58.6 Troubleshooting GCC Errors on the Mac  If you get this error that looks similar to this on the Mac:  error: command 'gcc' failed with exit status 69  278   That could mean XCode development tools haven’t been fully installed yet due to licensing. Apple insists Mac users agree to their license. To ensure we’ve met their requirements, type this on the command-line:  sudo xcodebuild -license  Go ahead and agree to the license, then run pip install -r re- quirements local.txt again.  58.7 Troubleshooting the MS Visual Studio  Build Tools Error  Windows users might get an error that says Need MS Visual Studio Build Tools 2014" error.. If that’s the case, installing VS Tools won’t help. Instead, run pip again with this install option:  pip install rcssmin --install-option="--without-c-extensions"  279   59 Changelog  All chapters are now in the book!  59.1 Beta Changelog 2020-03-10    Simplified add update page titles using view properties rather than the harder-to-test-in-templates HttpRequest ap- proach in chapter 55  59.2 Beta Changelog 2020-03-06    Made all chapters except the introduction have a number,  this is to make referencing code examples easier    Added Fabio as a tech reviewer   Warning box for password managers had the word “names”  corrected to “passwords”    Accepted PR that fixed django-crash-starter   Revised Postgres.app installation instructions in chapter 1   Rename README.rst to README.md in chapter 17   Replace the reference to cookiecutter-django to django-crash-  starter in chapter 17    Refer back to basic url routing in chapter 22   Explained app_name and path name in chapter 34   Add mention and links to Factory Boy in chapters 40 and    Use correct fontface for country_of_origin in chapter 44   Included missing app_name in chapter 46   Made INSTALLED_APPS a list rather than a tuple in chapter  41  48    Added troubleshooting chapter 58 and began moving trou-  bleshooting instructions there  280   59.3 Beta Changelog 2020-03-03    Give Christian and Enrique formal credit as tech reviewers   Grammar and spelling corrections, including some embar-  ressingly large ones    Test str   built-in function result in chapters 28 and 41   Fixed location of figure 54 in chapter 47   Removed unnecessary usage of Stracchino in chapter 51. Up for debate is if there ever an unnecessary usage of cheese    Corrected markdown error in chapter 53   Used even more flexible approach in chapter 54 to account  for form changes    Added typesetting to acknowledgements  59.4 Beta Changelog 2020-02-26    Minor grammar and spelling corrections   Replaced old summary with chapter 16 with 16.2 para-  graphs  chapter 22    Combine end text for chapter 16 with start text in chapter  17 to be new start text of chapter 17    Put verify your email image into correct place within    Explained source of cheese_list in chapter 35   Properly use cheese firmness in chapter 41   Use f-strings instead of format   in chapter 41   Correct git message in chapter 41   Added tipbox in chapter 52 explaining that assertContains  includes an HTTP status check  59.5 Beta Changelog 2020-02-22    Minor grammar and spelling corrections   Added the cover back to the PDF version  281     Fixed epub metadata so Audrey shows up as author   Made some explanations more concise per the classic Two  Scoops of Django style    Added explanation for as_view   method in Chapter 9  59.6 Beta Changelog 2020-02-21    Code examples are now at 70% scale, meaning code over-  laps should be a thing of the past    The PDF now uses Source Code Pro as the code font   Added section in introduction titled Why Learn  Django?    Linux instructions for installing Conda in the Ultimate  Django Setup, authored by Enrique Matías Sánchez    Added unidecode to django-crash-starter to deal with fu-  ture unicode issues like Κεφαλοτύρι    Added another troubleshooting link for Conda on Mac in  the Ultimate Setup Chapter.    Added troubleshooting instructions for GCC failures on  the Mac in chapter 17    Windows users now have troubleshooting instructions for  MS Visual Studio code failures in chapter 17    Put figures  images  into their right places in chapters 22    Chapter 24 test run example now lists the correct number    Troubleshooting non-ASCII characters added to chapter  and 23  of tests  45    Rewrote chapter 56, next steps  59.7 Beta Changelog 2020-02-19    Pronoun corrections across the book   Specific Django version in the introduction  282     Various grammar fixes   Removed vendor.js from django-crash-starter   Corrected Spanish in chapter 8   Now using django-crash-starter as a name consistently   Added missing exit from psql in chapter 17   Accepted PR that patched the totally borked django-crash-  starter    For repo creation in chapter 19, corrected text and image   Made HTML in chapter 35 match what exists in django-  crash-starter    Added missing closing backtick in chapter 35   Fixed broken test in chapter 41  59.8 Alpha Changelog 2020-02-14    Imported more art!   New tip and warning icons   More pronoun corrections   Removed mention of UnitTest from several chapters   Note in Ultimate Django Setup about using alternatives to    In Ultimate Django Setup added instruction for CLI tools  conda  for Mac    Finished fixing chapter 11 context['my_statement'] dialogue  to say ‘Nice to see you!’    Chapter 15 updates:  django-crash-starter Cookiecutter prompts updated to match current template, and fix escaping and margins    More clear description of allauth source code in chapter 21   Now calling Cheese firmness the correct way in chapter 27,    Wrote literal definition of Cheese Factory to chapter 39   Added chapters 51, 52, 53, 54, and 55! All chapters are in!  40, and 41  Hooray!  283   59.9 Alpha Changelog 2020-02-11    Described Django settings as constants   Converted chapter 26 to use Django 3-style enums   Pronoun corrections in numerous chapters   Image size optimizations to reduce filesize   Added calling code command from shell for Mac in Ultimate  Django Setup chapter    Added summary to chapter 6   Fixed chapter 11 context['my_statement'] result to say ‘Nice  to see you!’    Added chapter 50: Updating the cheese factory  59.10 Alpha Changelog 2020-02-07    ePub TOC now only lists chapter level items   Removed avatar_tags template tag reference   Fixed pytest segments   upgraded from legacy django.core.urlresolvers.reverse to  modern django.urls.reverse    Foreign keys now have on_delete arguments set   Minor grammar corrections   Better description faker material so it’s more obvious    Describe git commit messages to better reflect the content    Cleanup on chapters 37 to 49. Next up, getting more chap-  what’s going on  of their chapters  ters into the book!    Added how to give feedback to the next steps chapter  59.11 Alpha Changelog 2020-02-05    Fix for digits at the end of some PDF links  284     Make lowercase code segments like ! Usr Bin Env Python  and __Str__ caused by an overzealous titlecase script    Added strong password and good storage practices  reminder to Django superuser creation    Replaced link to image to the actual image   Corrected index links to projects   Removed broken link markup   Replaced old mentions of GitLab with GitHub   Use lists instead of tuples to avoid missing-comma tuple  confusion    Updated PyPI link to https:  pypi.org project    Better description for hard forks of open source projects   Added troubleshooting for Conda on Mac   Cleanup on chapter 35   Cleanup on chapter 36  59.12 Alpha Changelog 2020-02-04    Added acknowledgements and changelog sections   Fixed conda setup for hellodjango project   grammar and spelling fixes   URL path corrections   Removed : suﬀix from cookiecutter command  59.13 Alpha Changelog 2020-02-03    Release of the alpha!  285   60 Acknowledgements  This book was not written in a vacuum. We would like to express our thanks to everyone who had a part in putting it together. Contributors are listed in the order that their bug reports, tips, and other submissions were addressed.  60.1 Tech Reviewers  It is often said that a good technical book is impossible without great technical editing. The book would not be in the shape it is without the two following people:  60.1.1 Christian Hetmann  A lifelong learner, Christian Hetmann is a degreed German engi- neer working for a Swedish furniture retailer in transport logis- tics. He’s passionate about documenting and modeling of pro- cesses and concepts in logistics, automation and robotics. Chris- tian enjoys watching movies and doing computer things with his two sons.  60.1.2 Enrique Matías Sánchez  Enrique is an engineer who loves strong-flavored cheeses, soft- ware development, system administration and everything in be- tween. When he is not at his job as a Python programmer at the University of Zaragoza in Spain, he can be found hiking the mountains nearby or traveling the world. He shares a black cat with his lovely girlfriend, another cheese-lover. Enrique also provided our Linux installation instructions. Any innaccuracies or problems in that section are due to our inability to copy and paste his writing.  286   60.1.3 Fabio C. Barrionuevo da Luz  Fabio is a Brazilian engineer working for Roy Greenfeld. He likes to focus on producing the highest quality code that runs on all platforms. He enjoys open source and is a Cookiecutter and Cookiecutter Django core developer. Fabio is a creator and maintainer of http:  pythonclub.com.br . When not programming, Fabio enjoys video games, reading science fiction, and spending time with his wife. Fabio created the new book building system at Roy Greenfeld, for which we are very grateful.  60.2 Contributors to 3.x Beta  We could not have survived without our beta readers. Their attention to detail cannot be understated: Carla Breden, Enrique Matías Sánchez, Christian Hetmann, Derrick Kearney, Joe Talarovich, Justin Kanusek, Magnus Vaughan, Ivange Larry, Bob Earl, Og Maciel, Doug Gibbs, Mark Pors, Romack Natividad, Fábio C. Barrionuevo da Luz, Rohith PR, Toby Bettridge, Matt Winslow, Jonn Doe, Ben McNeill, Leigh Michael Forrest, Kevin J. Murray  60.3 Contributors to 3.x Alpha  Our alpha readers were incredibly patient and understanding. Working through the first version of any programming tutorial book can be quite a challenge! We are especially grateful to: Nnenanya Obinna Kingsley, Oluwole Majiyagbe, Paul Muston, Adam Johnson, David Nugent, Diederik de Vries, Chuma Umenze, Perry Mertz, Derrick Kearney, Justin Kanusek, Modasser Billah, Christian Hetmann, Og Maciel, and Joe Talarovich  287   If your name is not on these lists but should be, please send us an email so we can make corrections!  60.4 Typesetting  We originally wrote Django Crash Course using ReStruc- turedText and compiled using Sphinx. It was moved later to GFM markdown and hosted on a custom corporate training plat- form. For this book the material was converted to R-Markdown and an extended version of Bookdown36. 36https:  bookdown.org   288
