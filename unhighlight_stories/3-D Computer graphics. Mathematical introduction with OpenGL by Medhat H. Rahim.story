This page intentionally left blank   3-D Computer Graphics A Mathematical Introduction with OpenGL  This book is an introduction to 3-D computer graphics with particular emphasis on fundamentals and the mathematics underlying computer graphics. It includes descriptions of how to use the cross-platform OpenGL programming environment. It also includes source code for a ray tracing software package.  Accompanying software is available freely from the book’s Web site.   Topics include a thorough treatment of transformations and viewing, lighting and shading models, interpolation and averaging, B´ezier curves and B-splines, ray tracing and radiosity, and intersection testing with rays. Additional topics, covered in less depth, include texture mapping and color theory. The book also covers some aspects of animation, including quaternions, orientation, and inverse kinematics. Mathematical background on vectors and matrices is reviewed in an appendix.  This book is aimed at the advanced undergraduate level or introductory graduate level and can also be used for self-study. Prerequisites include basic knowledge of calculus and vectors. The OpenGL programming portions require knowledge of programming in C or C++. The more important features of OpenGL are covered in the book, but it is intended to be used in conjunction with another OpenGL programming book.  Samuel R. Buss is Professor of Mathematics and Computer Science at the Univer- sity of California, San Diego. With both academic and industrial expertise, Buss has more than 60 publications in the ﬁelds of computer science and mathematical logic. He is the editor of several journals and the author of a book on bounded arithmetic. Buss has years of experience in programming and game development and has acted as consultant for SAIC and Angel Studios.    3-D Computer Graphics  A Mathematical Introduction with OpenGL  SAMUEL R. BUSS University of California, San Diego        Cambridge, New York, Melbourne, Madrid, Cape Town, Singapore, São Paulo  Cambridge  University  Press The Edinburgh Building, Cambridge  , United Kingdom Published in the United States of America by Cambridge University Press, New York www.cambridge.org Information on this title: www.cambridge.org 9780521821032    Samuel R. Buss 2003  This book is in copyright. Subject to statutory exception and to the provision of relevant collective licensing agreements, no reproduction of any part may take place without the written permission of Cambridge University Press.  First published in print format   2003  -    ---- -    ---  eBook   NetLibrary   eBook   NetLibrary   -    ---- -    ---  hardback  hardback  Cambridge University Press has no responsibility for the persistence or accuracy of s for external or third-party internet websites referred to in this book, and does not guarantee that any content on such websites is, or will remain, accurate or appropriate.   To my family  Teresa, Stephanie, and Ian   Contents  Preface  I  II  Introduction I.1 Display Models I.2 Coordinates, Points, Lines, and Polygons I.3 Double Buffering for Animation  Transformations and Viewing II.1 Transformations in 2-Space II.2 Transformations in 3-Space II.3 Viewing Transformations and Perspective II.4 Mapping to Pixels  III Lighting, Illumination, and Shading  III.1 The Phong Lighting Model III.2 The Cook–Torrance Lighting Model  IV Averaging and Interpolation  IV.1 Linear Interpolation IV.2 Bilinear and Trilinear Interpolation IV.3 Convex Sets and Weighted Averages IV.4 Interpolation and Homogeneous Coordinates IV.5 Hyperbolic Interpolation IV.6 Spherical Linear Interpolation  V  Texture Mapping V.1 Texture Mapping an Image V.2 Bump Mapping V.3 Environment Mapping V.4 Texture Mapping in OpenGL  VI Color  VI.1 Color Perception VI.2 Representation of Color Values  page xi  1 1 4 15  17 18 34 46 58  67 68 87  99 99 107 117 119 121 122  126 126 135 137 139  146 146 149  vii   viii  VII B´ezier Curves  Contents  VII.1 B´ezier Curves of Degree Three VII.2 De Casteljau’s Method VII.3 Recursive Subdivision VII.4 Piecewise B´ezier Curves VII.5 Hermite Polynomials VII.6 B´ezier Curves of General Degree VII.7 De Casteljau’s Method Revisited VII.8 Recursive Subdivision Revisited VII.9 Degree Elevation VII.10 B´ezier Surface Patches VII.11 B´ezier Curves and Surfaces in OpenGL VII.12 Rational B´ezier Curves VII.13 Conic Sections with Rational B´ezier Curves VII.14 Surface of Revolution Example VII.15 Interpolating with B´ezier Curves VII.16 Interpolating with B´ezier Surfaces  VIII B-Splines  VIII.1 Uniform B-Splines of Degree Three VIII.2 Nonuniform B-Splines VIII.3 Examples of Nonuniform B-Splines VIII.4 Properties of Nonuniform B-Splines VIII.5 The de Boor Algorithm VIII.6 Blossoms VIII.7 Derivatives and Smoothness of B-Spline Curves VIII.8 Knot Insertion VIII.9 B´ezier and B-Spline Curves VIII.10 Degree Elevation VIII.11 Rational B-Splines and NURBS VIII.12 B-Splines and NURBS Surfaces in OpenGL VIII.13 Interpolating with B-Splines  IX Ray Tracing  IX.1 Basic Ray Tracing IX.2 Advanced Ray Tracing Techniques IX.3 Special Effects without Ray Tracing  X  Intersection Testing X.1 Fast Intersections with Rays X.2 Pruning Intersection Tests  XI Radiosity  XI.1 The Radiosity Equations XI.2 Calculation of Form Factors XI.3 Solving the Radiosity Equations  XII Animation and Kinematics  XII.1 Overview XII.2 Animation of Position  155 156 159 160 163 164 165 168 169 171 173 178 180 182 187 189 195  200 201 204 206 211 214 217 221 223 226 227 228 229 229  233 234 244 252  257 258 269  272 274 277 282  289 289 292   Contents  ix  XII.3 Representations of Orientations XII.4 Kinematics  A Mathematics Background  A.1 Preliminaries A.2 Vectors and Vector Products A.3 Matrices A.4 Multivariable Calculus  B  RayTrace Software Package B.1 Introduction to the Ray Tracing Package B.2 The High-Level Ray Tracing Routines B.3 The RayTrace API  Bibliography Index  Color art appears following page 256.  295 307  319 319 320 325 329  332 332 333 336  353 359    Preface  Computer graphics has grown phenomenally in recent decades, progressing from simple 2-D graphics to complex, high-quality, three-dimensional environments. In entertainment, com- puter graphics is used extensively in movies and computer games. Animated movies are in- creasingly being made entirely with computers. Even nonanimated movies depend heavily on computer graphics to develop special effects: witness, for instance, the success of the Star Wars movies beginning in the mid-1970s. The capabilities of computer graphics in personal computers and home game consoles have now improved to the extent that low-cost systems are able to display millions of polygons per second.  There are also signiﬁcant uses of computer graphics in nonentertainment applications. For example, virtual reality systems are often used in training. Computer graphics is an indis- pensable tool for scientiﬁc visualization and for computer-aided design  CAD . We need good methods for displaying large data sets comprehensibly and for showing the results of large-scale scientiﬁc simulations.  The art and science of computer graphics have been evolving since the advent of computers and started in earnest in the early 1960s. Since then, computer graphics has developed into a rich, deep, and coherent ﬁeld. The aim of this book is to present the mathematical foundations of computer graphics along with a practical introduction to programming using OpenGL. I believe that understanding the mathematical basis is important for any advanced use of computer graphics. For this reason, this book attempts to cover the underlying mathematics thoroughly. The principle guiding the selection of topics for this book has been to choose topics that are of practical signiﬁcance for computer graphics practitioners – in particular for software developers. My hope is that this book will serve as a comprehensive introduction to the standard tools used in this ﬁeld and especially to the mathematical theory behind these tools.  About This Book  The plan for this book has been shaped by my personal experiences as an academic mathe- matician and by my participation in various applied computer projects, including projects in computer games and virtual reality. This book was started while I was teaching a mathematics class at the University of California, San Diego  UCSD , on computer graphics and geometry. That course was structured as an introduction to programming 3-D graphics in OpenGL and to the mathematical foundations of computer graphics. While teaching that course, I became convinced of the need for a book that would bring together the mathematical theory underlying computer graphics in an introductory and uniﬁed setting.  xi   xii  Preface  The other motivation for writing this book has been my involvement in several virtual reality and computer game projects. Many of the topics included in this book are presented mainly because I have found them useful in computer game applications. Modern-day computer games and virtual reality applications are technically demanding software projects: these applications require software capable of displaying convincing three-dimensional environments. Generally, the software must keep track of the motion of multiple objects; maintain information about the lighting, colors, and textures of many objects; and display these objects on the screen at 30 or 60 frames per second. In addition, considerable artistic and creative skills are needed to make a worthwhile three-dimensional environment. Not surprisingly, this requires sophisticated software development by large teams of programmers, artists, and designers.  Perhaps it is a little more surprising that 3-D computer graphics requires extensive math- ematics. This is, however, the case. Furthermore, the mathematics tends to be elegant and interdisciplinary. The mathematics needed in computer graphics brings together construc- tions and methods from several areas, including geometry, calculus, linear algebra, numeri- cal analysis, abstract algebra, data structures, and algorithms. In fact, computer graphics is arguably the best example of a practical area in which so much mathematics combines so elegantly.  This book presents a blend of applied and theoretical topics. On the more applied side, I recommend the use of OpenGL, a readily available, free, cross-platform programming en- vironment for 3-D graphics. The C and C++ code for OpenGL programs that can freely be downloaded from the Internet has been included, and I discuss how OpenGL implements many of the mathematical concepts discussed in this book. A ray tracer software package is also described; this software can also be downloaded from the Internet. On the theoretical side, this book stresses the mathematical foundations of computer graphics, more so than any other text of which I am aware. I strongly believe that knowing the mathematical foundations of computer graphics is important for being able to use tools such as OpenGL or Direct3D, or, to a lesser extent, CAD programs properly.  The mathematical topics in this book are chosen because of their importance and relevance to graphics. However, I have not hesitated to introduce more abstract concepts when they are crucial to computer graphics – for instance, the projective geometry interpretation of homogeneous coordinates. A good knowledge of mathematics is invaluable if you want to use the techniques of computer graphics software properly and is even more important if you want to develop new or innovative uses of computer graphics.  How to Use This Book  This book is intended for use as a textbook, as a source for self-study, or as a reference. It is strongly recommended that you try running the programs supplied with the book and write some OpenGL programs of your own. Note that this book is intended to be read in conjunction with a book on learning to program in OpenGL. A good source for learning OpenGL is the comprehensive OpenGL Programming Guide  Woo et al., 1999 , which is sometimes called the “red book.” If you are learning OpenGL on your own for the ﬁrst time, the OpenGL Programming Guide may be a bit daunting. If so, the OpenGL SuperBible  Wright Jr., 1999  may provide an easier introduction to OpenGL with much less mathematics. The book OpenGL: A Primer  Angel, 2002  also gives a good introductory overview of OpenGL.  The outline of this book is as follows. The chapters are arranged more or less in the order the material might be covered in a course. However, it is not necessary to read the material in order. In particular, the later chapters can be read largely independently, with the exception that Chapter VIII depends on Chapter VII.   Preface  xiii  Chapter I. Introduction. Introduces the basic concepts of computer graphics; drawing points, lines, and polygons; modeling with polygons; animation; and getting started with OpenGL programming.  Chapter II. Transformations and Viewing. Discusses the rendering pipeline, linear and afﬁne transformations, matrices in two and three dimensions, translations and rotations, homoge- neous coordinates, transformations in OpenGL, viewing with orthographic and perspective transformations, projective geometry, pixelization, Gouraud and scan line interpolation, and the Bresenham algorithm.  Chapter III. Lighting, Illumination, and Shading. Addresses the Phong lighting model; ambient, diffuse, and specular lighting; lights and material properties in OpenGL; and the Cook–Torrance model.  Chapter IV. Averaging and Interpolation. Presents linear interpolation, barycentric coor- dinates, bilinear interpolation, convexity, hyperbolic interpolation, and spherical linear inter- polation. This is a more mathematical chapter with many tools that are used elsewhere in the book. You may wish to skip much of this chapter on the ﬁrst reading and come back to it as needed.  Chapter V. Texture Mapping. Discusses textures and texture coordinates, mipmapping, su- persampling and jittering, bump mapping, environment mapping, and texture maps in OpenGL. Chapter VI. Color. Addresses color perception, additive and subtractive colors, and RGB  and HSL representations of color.  Chapter VII. B´ezier Curves. Presents B´ezier curves of degree three and of general degree; De Casteljau methods; subdivision; piecewise B´ezier curves; Hermite polynomials; B´ezier surface patches; B´ezier curves in OpenGL; rational curves and conic sections; surfaces of rev- olution; degree elevation; interpolation with Catmull–Rom, Bessel–Overhauser, and tension- continuity-bias splines; and interpolation with B´ezier surfaces.  Chapter VIII. B-Splines. Describes uniform and nonuniform B-splines and their proper- ties, B-splines in OpenGL, the de Boor algorithm, blossoms, smoothness properties, rational B-splines  NURBS  and conic sections, knot insertion, relationship with B´ezier curves, and interpolation with spline curves. This chapter has a mixture of introductory topics and more specialized topics. We include all proofs but recommend that many of the proofs be skipped on the ﬁrst reading.  Chapter IX. Ray Tracing. Presents recursive ray tracing, reﬂection and transmission, dis-  tributed ray tracing, backwards ray tracing, and cheats to avoid ray tracing.  Chapter X. Intersection Testing. Describes testing rays for intersections with spheres, planes, triangles, polytopes, and other surfaces and addresses bounding volumes and hierarchical pruning.  Chapter XI. Radiosity. Presents patches, form factors, and the radiosity equation; the  hemicube method; and the Jacobi, Gauss–Seidel, and Southwell iterative methods.  Chapter XII. Animation and Kinematics. Discusses key framing, ease in and ease out, representations of orientation, quaternions, interpolating quaternions, and forward and inverse kinematics for articulated rigid multibodies.  Appendix A. Mathematics Background. Reviews topics from vectors, matrices, linear al-  gebra, and calculus.  software is freely downloadable.  Appendix B. RayTrace Software Package. Describes a ray tracing software package. The   xiv  Preface  Exercises are scattered throughout the book, especially in the more introductory chapters. These are often supplied with hints, and they should not be terribly difﬁcult. It is highly recommended that you do the exercises to master the material. A few sections in the book, as well as some of the theorems, proofs, and exercises, are labeled with an asterisk    . This indicates that the material is optional, less important, or both and can be safely skipped without affecting your understanding of the rest of the book. Theorems, lemmas, ﬁgures, and exercises are numbered separately for each chapter.   cid:1   Obtaining the Accompanying Software  All software examples discussed in this book are available for downloading from the Internet at  http:  math.ucsd.edu ∼sbuss MathCG .  The software is available as source ﬁles and as PC executables. In addition, complete Microsoft Visual C++ project ﬁles are available.  The software includes several small OpenGL programs and a relatively large ray tracing  software package.  The software may be used without any restriction except that its use in commercial products  or any kind of substantial project must be acknowledged.  Getting Started with OpenGL  OpenGL is a platform-independent API  application programming interface  for rendering 3-D graphics. A big advantage of using OpenGL is that it is a widely supported industry standard. Other 3-D environments, notably Direct3D, have similar capabilities; however, Direct3D is speciﬁc to the Microsoft Windows operating system.  The ofﬁcial OpenGL Web site is http:  www.opengl.org. This site contains a huge amount of material, but if you are just starting to learn OpenGL the most useful material is probably the tutorials and code samples available at  http:  www.opengl.org developers code tutorials.html.  The OpenGL programs supplied with this text use the OpenGL Utility Toolkit routines, called GLUT for short, which is widely used and provides a simple-to-use interface for con- trolling OpenGL windows and handling simple user input. You generally need to install the GLUT ﬁles separately from the rest of the OpenGL ﬁles.  If you are programming with Microsoft Visual C++, then the OpenGL header ﬁles and libraries are included with Visual C++. However, you will need to download the GLUT ﬁles yourself. OpenGL can also be used with other development environments such as Borland’s C++ compiler.  The ofﬁcial Web site for downloading the latest version of GLUT for the Windows operating  system is available from Nate Robin at  http:  www.xmission.com ∼nate glut.html.  To install the necessary GLUT ﬁles on a Windows machine, you should put the header ﬁle glut.h in the same directory as your other OpenGL header ﬁles such as glu.h. You should likewise put the glut32.dll ﬁles and glut32.lib ﬁle in the same directories as the corresponding ﬁles for OpenGL, glu32.dll, and glu32.lib.   Preface  xv  OpenGL and GLUT work under a variety of other operating systems as well. I have not tried out all these systems but list some of the prominent ones as an aid to the reader trying to run OpenGL in other environments.  However, changes occur rapidly in the software development world, and so these links may become outdated quickly.   For Macintosh computers, you can ﬁnd information about OpenGL and the GLUT libraries  at the Apple Computer site  http:  developer.apple.com opengl .  OpenGL and GLUT also work under the Cygwin system, which implements a Unix- like development environment under Windows. Information on Cygwin is available at http:  cygwin.com  or http:  sources.redhat.com cygwin .  OpenGL for Sun Solaris systems can be obtained from  http:  www.sun.com software graphics OpenGL .  There is an OpenGL-compatible system, Mesa3D, which is available from http:   mesa3d.sourceforge.net . This runs on several operating systems, including Linux, and supports a variety of graphics boards.  Other Resources for Computer Graphics  You may wish to supplement this book with other sources of information on computer graphics. One rather comprehensive textbook is the volume by Foley et al.  1990 . Another excellent recent book is M¨oller and Haines  1999 . The articles by Blinn  1996; 1998  and Glassner  1999  are also interesting.  Finally, an enormous amount of information about computer graphics theory and practice is available on the Internet. There you can ﬁnd examples of OpenGL programs and information about graphics hardware as well as theoretical and mathematical developments. Much of this can be found through your favorite search engine, but you may also use the ACM Transactions on Graphics Web site http:  www.acm.org tog  as a starting point.  For the Instructor  This book is intended for use with advanced junior- or senior-level undergraduate courses or introductory graduate-level courses. It is based in large part on my teaching of computer graph- ics courses at the upper division level and at the graduate level. In a two-quarter undergraduate course, I cover most of the material in the book more or less in the order presented here. Some of the more advanced topics would be skipped, however – most notably Cook–Torrance lighting and hyperbolic interpolation – and some of the material on B´ezier and B-spline curves and patches is best omitted from an undergraduate course. I also do not cover the more difﬁcult proofs in undergraduate courses.  It is certainly recommended that students studying this book get programming assignments using OpenGL. Although this book covers much OpenGL material in outline form, students will need to have an additional source for learning the details of programming in OpenGL. Programming prerequisites include some experience in C, C++, or Java.  As we write this, there is no standardized OpenGL API for Java; however, Java is close enough to C or C++ that students can readily make the transition required for mastering the simple programs included with this text.  The ﬁrst quarters of my own courses have included programming assignments ﬁrst on two-dimensional graphing, second on three-dimensional transformations based on the solar system exercise on page 40, third on polygonal modeling  students are asked to draw tori   xvi  Preface  of the type in Figure I.11 b  , fourth on adding materials and lighting to a scene, and ﬁnally an open-ended assignment in which students choose a project of their own. The second quarter of the course has included assignments on modeling objects with B´ezier patches  Blinn’s article  1987  on how to construct the Utah teapot is used to help with this , on writing a program that draws Catmull–Rom and Overhauser spline curves that interpolate points picked with the mouse, on using the computer-aided design program 3D Studio Max  this book does not cover any material about how to use CAD programs , on using the ray tracing software supplied with this book, on implementing some aspect of distributed ray tracing, and then ending with another ﬁnal project of their choosing. Past course materials can be found on the Web from my home page http:  math.ucsd.edu ∼sbuss .  Acknowledgments  Very little of the material in this book is original. The aspects that are original mostly concern organization and presentation: in several places, I have tried to present new, simpler proofs than those known before. Frequently, material is presented without attribution or credit, but in most instances this material is due to others. I have included references for items I learned by consulting the original literature and for topics for which it was easy to ascertain the original source; however, I have not tried to be comprehensive in assigning credit.  I learned computer graphics from several sources. First, I worked on a computer graphics project with several people at SAIC, including Tom Yonkman and my wife, Teresa Buss. Subsequently, I have worked for many years on computer games applications at Angel Studios, where I beneﬁted greatly, and learned an immense amount, from Steve Rotenberg, Brad Hunt, Dave Etherton, Santi Bacerra, Nathan Brown, Ted Carson, Jeff Roorda, Daniel Blumenthal, and others. I am particularly indebted to Steve Rotenberg, who has been my guru for advanced topics and current research in computer graphics.  I have taught computer graphics courses several times at UCSD, using at various times the textbooks by Watt and Watt  1992 , Watt  1993 , and Hill  2001 . This book was written from notes developed while teaching these classes.  I am greatly indebted to Frank Chang and Malachi Pust for a thorough proofreading of an early draft of this book. In addition, I thank Michael Bailey, Stephanie Buss  my daughter , Chris Calabro, Joseph Chow, Daniel Curtis, Tamsen Dunn, Rosalie Iemhoff, Cyrus Jam, Jin-Su Kim, Vivek Manpuria, Jason McAuliffe, Jong-Won Oh, Horng Bin Ou, Chris Pollett, John Rapp, Don Quach, Daryl Sterling, Aubin Whitley, and anonymous referees for corrections to preliminary drafts of this book and Tak Chu, Craig Donner, Jason Eng, Igor Kaplounenko, Alex Kulungowski, Allen Lam, Peter Olcott, Nevin Shenoy, Mara Silva, Abbie Whynot, and George Yue for corrections incorporated into the second printing. Further thanks are due to Cambridge University Press for copyediting and ﬁnal typesetting. As much as I would like to avoid it, the responsibility for all remaining errors is my own.  The ﬁgures in this book were prepared with several software systems. The majority of the ﬁgures were created using van Zandt’s pstricks macro package for LATEX. Some of the ﬁgures were created with a modiﬁed version of Geuzaine’s program GL2PS for converting OpenGL images into PostScript ﬁles. A few ﬁgures were created from screen dump bitmaps and converted to PostScript images with Adobe Photoshop.  Partial ﬁnancial support was provided by National Science Foundation grants DMS-  9803515 and DMS-0100589.   I  Introduction  This chapter discusses some of the basic concepts behind computer graphics with particular emphasis on how to get started with simple drawing in OpenGL. A major portion of the chapter explains the simplest methods of drawing in OpenGL and various rendering modes. If this is your ﬁrst encounter with OpenGL, it is highly suggested that you look at the included sample code and experiment with some of the OpenGL commands while reading this chapter.  The ﬁrst topic considered is the different models for graphics displays. Of particular im- portance for the topics covered later in the book is the idea that an arbitrary three-dimensional geometrical shape can be approximated by a set of polygons – more speciﬁcally as a set of triangles. Second, we discuss some of the basic methods for programming in OpenGL to dis- play simple two- and three-dimensional models made from points, lines, triangles, and other polygons. We also describe how to set colors and polygonal orientations, how to enable hidden surface removal, and how to make animation work with double buffering. The included sample OpenGL code illustrates all these capabilities. Later chapters will discuss how to use transfor- mations, how to set the viewpoint, how to add lighting and shading, how to add textures, and other topics.  I.1 Display Models  We start by describing three models for graphics display modes:  1  drawing points,  2  drawing lines, and  3  drawing triangles and other polygonal patches. These three modes correspond to different hardware architectures for graphics display. Drawing points corresponds roughly to the model of a graphics image as a rectangular array of pixels. Drawing lines corresponds to vector graphics displays. Drawing triangles and polygons corresponds to the methods used by modern graphics display hardware for displaying three-dimensional images.  I.1.1 Rectangular Arrays of Pixels  The most common low-level model is to treat a graphics image as a rectangular array of pixels in which, each pixel can be independently set to a different color and brightness. This is the display model used for cathode ray tubes  CRTs  and televisions, for instance. If the pixels are small enough, they cannot be seen individually by the human viewer, and the image, although composed of points, can appear as a single smooth image. This technique is used in art as well – notably in mosaics and, even more so, in pointillism, where pictures are composed of small  1   2  Introduction  Figure I.1. A pixel is formed from subregions or subpixels, each of which displays one of three colors. See Color Plate 1.  patches of solid color but appear to form a continuous image when viewed from a sufﬁcient distance.  Keep in mind, however, that the model of graphics images as a rectangular array of pixels is only a convenient abstraction and is not entirely accurate. For instance, on a CRT or television screen, each pixel actually consists of three separate points  or dots of phosphor : each dot corresponds to one of the three primary colors  red, blue, and green  and can be independently set to a brightness value. Thus, each pixel is actually formed from three colored dots. With a magnifying glass, you can see the colors in the pixel as separate colors  see Figure I.1 .  It is best to try this with a low-resolution device such as a television; depending on the physical design of the screen, you may see the separate colors in individual dots or in stripes.   A second aspect of rectangular array model inaccuracy is the occasional use of subpixel image addressing. For instance, laser printers and ink jet printers reduce aliasing problems, such as jagged edges on lines and symbols, by micropositioning toner or ink dots. More recently, some handheld computers  i.e., palmtops  are able to display text at a higher resolution than would otherwise be possible by treating each pixel as three independently addressable subpixels. In this way, the device is able to position text at the subpixel level and achieve a higher level of detail and better character formation.  In this book however, issues of subpixels will never be examined; instead, we will always model a pixel as a single rectangular point that can be set to a desired color and brightness. Sometimes the pixel basis of a computer graphics image will be important to us. In Section II.4, we discuss the problem of approximating a straight sloping line with pixels. Also, when using texture maps and ray tracing, one must take care to avoid the aliasing problems that can arise with sampling a continuous or high-resolution image into a set of pixels.  We will usually not consider pixels at all but instead will work at the higher level of polygonally based modeling. In principle, one could draw any picture by directly setting the brightness levels for each pixel in the image; however, in practice this would be difﬁcult and time consuming. Instead, in most high-level graphics programming applications, we do not have to think very much about the fact that the graphics image may be rendered using a rectangular array of pixels. One draws lines, or especially polygons, and the graphics hardware handles most of the work of translating the results into pixel brightness levels. A variety of sophisticated techniques exist for drawing polygons  or triangles  on a computer screen as an array of pixels, including methods for shading and smoothing and for applying texture maps. These will be covered later in the book.  I.1.2 Vector Graphics  In traditional vector graphics, one models the image as a set of lines. As such, one is not able to model solid objects, and instead draws two-dimensional shapes, graphs of functions,   I.1 Display Models  3  y  2  1  penup  ; moveto 2,2 ; pendown  ; moveto 2,1 ; penup  ; moveto 1,2 ; pendown  ; moveto 0,2 ; moveto 1,1 ; moveto 1,2 ;  x  1  2  Figure I.2. Examples of vector graphics commands.  or wireframe images of three-dimensional objects. The canonical example of vector graphics systems are pen plotters; this includes the “turtle geometry” systems. Pen plotters have a drawing pen that moves over a ﬂat sheet of paper. The commands available include  a  pen up, which lifts the pen up from the surface of the paper,  b  pen down, which lowers the point of the pen onto the paper, and  c  move-to x, y , which moves the pen in a straight line from its current position to the point with coordinates  cid:5 x, y cid:6 . When the pen is up, it moves without drawing; when the pen is down, it draws as it moves  see Figure I.2 . In addition, there may be commands for switching to a different color pen as well as convenience commands to make it easier to draw images.  Another example of vector graphics devices is vector graphics display terminals, which traditionally are monochrome monitors that can draw arbitrary lines. On these vector graphics display terminals, the screen is a large expanse of phosphor and does not have pixels. A traditional oscilloscope is also an example of a vector graphics display device.  Vector graphics displays and pixel-based displays use very different representations of images. In pixel-based systems, the screen image will be stored as a bitmap, namely, as a table containing all the pixel colors. A vector graphics system, on the other hand, will store the image as a list of commands – for instance as a list of pen up, pen down, and move commands. Such a list of commands is called a display list.  Nowadays, pixel-based graphics hardware is very prevalent, and thus even graphics sys- tems that are logically vector based are typically displayed on hardware that is pixel based. The disadvantage is that pixel-based hardware cannot directly draw arbitrary lines and must approximate lines with pixels. On the other hand, the advantage is that more sophisticated ﬁgures, such as ﬁlled regions, can be drawn.  Modern vector graphics systems incorporate more than just lines and include the ability to draw curves, text, polygons, and other shapes such as circles and ellipses. These systems also have the ability to ﬁll in or shade a region with a color or a pattern. They generally are restricted to drawing two-dimensional ﬁgures. Adobe’s PostScript language is a prominent example of a modern vector graphics system.  I.1.3 Polygonal Modeling  One step up, in both abstraction and sophistication, is the polygonal model of graphics images. It is very common for three-dimensional geometric shapes to be modeled ﬁrst as a set of polygons and then mapped to polygonal shapes on a two-dimensional display. The basic display hardware is generally pixel based, but most computers now have special-purpose graphics hardware for processing polygons or, at the very least, triangles. Graphics hardware for rendering triangles   4  Introduction  is also used in modern computer game systems; indeed, the usual measure of performance for graphics hardware is the number of triangles that can be rendered per second. At the time this book is being written, nominal peak performance rates of relatively cheap hardware are well above one million polygons per second!  Polygonal-based modeling is used in nearly every three-dimensional computer graphics systems. It is a central tool for the generation of interactive three-dimensional graphics and is used for photo-realistic rendering, including animation in movies.  The essential operation in a polygonal modeling system is drawing a single triangle. In addition, there are provisions for coloring and shading the triangle. Here, “shading” means varying the color across the triangle. Another important tool is the use of texture mapping, which can be used to paint images or other textures onto a polygon. It is very typical for color, shading, and texture maps to be supported by special-purpose hardware such as low-cost graphics boards on PCs.  The purpose of these techniques is to make polygonally modeled objects look more realistic. Refer to Figure III.1 on page 68. You will see six models of a teapot. Part  a  of the ﬁgure shows a wireframe teapot, as could be modeled on a vector graphics device. Part  b  shows the same shape but ﬁlled in with solid color; the result shows a silhouette with no three-dimensionality. Parts  c  through  f  show the teapot rendered with lighting effects:  c  and  e  show ﬂat-shaded  i.e., unshaded  polygons for which the polygonal nature of the teapot is clearly evident; parts  d  and  f  incorporate shading in which the polygons are shaded with color that varies across the polygons. The shading does a fairly good job of masking the polygonal nature of the teapot and greatly increases the realism of the image.  I.2 Coordinates, Points, Lines, and Polygons  The next sections discuss some of the basic conventions of coordinate systems and of drawing points, lines, and polygons. Our emphasis will be on the conventions and commands used by OpenGL. For now, only drawing vertices at ﬁxed positions in the xy-plane or in xyz-space is discussed. Chapter II will explain how to move vertices and geometric shapes around with rotations, translations, and other transformations.  I.2.1 Coordinate Systems  When graphing geometric shapes, one determines the position of the shape by specifying the positions of a set of vertices. For example, the position and geometry of a triangle are speciﬁed in terms of the positions of its three vertices. Graphics programming languages, including OpenGL, allow you to set up your own coordinate systems for specifying positions of points; in OpenGL this is done by specifying a function from your coordinate system into the screen coordinates. This allows points to be positioned at locations in either 2-space  R2  or 3-space  R3  and to have OpenGL automatically map the points into the proper location in the graphics image.  In the two-dimensional x y-plane, also called R2, a position is set by specifying its x- and y-coordinates. The usual convention  see Figure I.3  is that the x-axis is horizontal and pointing to the right and the y-axis is vertical and pointing upwards. In three-dimensional space R3, positions are speciﬁed by triples  cid:5 a, b, c cid:6  giving the x-, y-, and z-coordinates of the point. However, the convention for how the three coordinate axes are positioned is different for computer graphics than is usual in mathematics. In computer graphics, the x-axis points to the right, the y-axis points upwards, and the z-axis points toward the viewer. This is different from our customary expectations. For example, in calculus, the x-,   I.2 Coordinates, Points, Lines, and Polygons  5  y  b   cid:1 a,  cid:2 b  a  x  Figure I.3. The x y-plane, R2, and the point  cid:5 a, b cid:6 .  y-, and z-axes usually point forward, rightwards, and upwards  respectively . The computer graphics convention was adopted presumably because it keeps the x- and y-axes in the same position as for the x y-plane, but it has the disadvantage of taking some getting used to. Figure I.4 shows the orientation of the coordinate axes.  It is important to note that the coordinates axes used in computer graphics do form a right- handed coordinate system. This means that if you position your right hand with your thumb and index ﬁnger extended to make an L shape and place your hand so that your right thumb points along the positive x-axis and your index ﬁnger points along the positive y-axis, then your palm will be facing toward the positive z-axis. In particular, this means that the right-hand rule applies to cross products of vectors in R3.  I.2.2 Geometric Shapes in OpenGL  We next discuss methods for drawing points, lines, and polygons in OpenGL. We only give some of the common versions of the commands available in OpenGL. You should consult the OpenGL programming manual  Woo et al., 1999  for more complete information.  Drawing Points in OpenGL OpenGL has several commands that deﬁne the position of a point. Two of the common ways to use these commands are1  glVertex3f float x, float y, float z ;  or  float v[3] = { x, y, z }; glVertex3fv  &v[0]  ;  The ﬁrst form of the command, glVertex3f, speciﬁes the point directly in terms of its x-, y-, and z-coordinates. The second form, glVertex3fv, takes a pointer to an array containing the coordinates. The “v” on the end of the function name stands for “vector.” There are many other forms of the glVertex* command that can be used instead.2 For instance, the “f,”  1 We describe OpenGL commands with simpliﬁed prototypes  and often do not give the ofﬁcially correct prototype . In this case, the speciﬁers “float” describe the types of the arguments to glVertex3f   but should be omitted in your C or C++ code.  2 There is no function named glVertex*: we use this notation to represent collectively the many  variations of the glVertex commands.   6  Introduction  y  b  c  z  a, cid:1    cid:2 cb,  a  x  Figure I.4. The coordinate axes in R3 and the point  cid:5 a, b, c cid:6 . The z-axis is pointing toward the viewer.  which stands for “ﬂoat,” can be replaced by “s” for “short integer,” by “i” for “integer,” or by “d” for “double.”3  For two-dimensional applications, OpenGL also allows you to specify points in terms of  just x- and y-coordinates by using the commands  glVertex2f float x, float y ;  or  float v[2] = { x, y }; glVertex2fv  &v[0]  ;  glVertex2f is equivalent to glVertex3f but with z = 0.  All calls to glVertex* must be bracketed by calls to the OpenGL commands glBegin and glEnd. For example, to draw the three points shown in Figure I.5, you would use the commands  glBegin GL_POINTS ; glVertex2f  1.0, 1.0  ; glVertex2f  2.0, 1.0  ; glVertex2f  2.0, 2.0  ; glEnd  ;  The calls to the functions glBegin and glEnd are used to signal the start and end of drawing. A sample OpenGL program, SimpleDraw, supplied with this text, contains the preceding code for drawing three points. If OpenGL is new to you, it is recommended that you examine the source code and try compiling and running the program. You will probably ﬁnd that the points are drawn as very small, single-pixel points – perhaps so small as to be almost invisible. On most OpenGL systems, you can make points display as large, round dots by calling the following functions:     Points are n pixels in diameter  glPointSize n ; glEnable GL_POINT_SMOOTH ; glHint GL_POINT_SMOOTH_HINT, GL_NICEST ; glEnable GL_BLEND ; glBlendFunc GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA ;  3 To be completely accurate, we should remark that, to help portability and future compatibility, OpenGL uses the types GLfloat, GLshort, GLint, and GLdouble, which are generally deﬁned to be the same as float, short, int, and double. It would certainly be better programming practice to use OpenGL’s data types; however, the extra effort is not really worthwhile for casual programming.   I.2 Coordinates, Points, Lines, and Polygons  7  y  2  1  x  1  2  Figure I.5. Three points drawn in two dimensions.   In the ﬁrst line, a number such as 6 for n may give good results.  The SimpleDraw program already includes the preceding function calls, but they have been commented out. If you are lucky, executing these lines in the program before the drawing code will cause the program to draw nice round dots for points. However, the effect of these commands varies with different implementations of OpenGL, and thus you may see square dots instead of round dots or even no change at all.  The SimpleDraw program is set up so that the displayed graphics image is shown from the viewpoint of a viewer looking down the z-axis. In this situation, glVertex2f is a convenient method for two-dimensional graphing.  Drawing Lines in OpenGL To draw a line in OpenGL, specify its endpoints. The glBegin and glEnd paradigm is still used. To draw individual lines, pass the parameter GL_LINES to glBegin. For example, to draw two lines, you could use the commands  glBegin  GL_LINES  ; glVertex3f  x1, y1, z1  ; glVertex3f  x2, y2, z2  ; glVertex3f  x3, y3, z3  ; glVertex3f  x4, y4, z4  ; glEnd  ;  Letting vi be the vertex  cid:5 xi , yi , zi cid:6 , the commands above draw a line from v1 to v2 and an- other from v3 to v4. More generally, you may specify an even number, 2n, of points, and the GL_LINES option will draw n lines connecting v2i−1 to v2i for i = 1, . . . , n. You may also use GL_LINE_STRIP instead of GL_LINES: if you specify n vertices, a con- tinuous chain of lines is drawn, namely, the lines connecting vi and vi+1 for i = 1, . . . , n − 1. The parameter GL_LINE_LOOP can also be used; it draws the line strip plus the line connecting vn to v1. Figure I.6 shows the effects of these three line-drawing modes.  The SimpleDraw program includes code to draw the images in Figure I.6. When the program is run, you may ﬁnd that the lines look much too thin and appear jagged because they  v3  v2  v5  v4  v1  v3  v2  v5  v4  v1  v3  v2  v5  v4  v1  v6  GL LINES  v6  v6  GL LINE STRIP  GL LINE LOOP  Figure I.6. The three line-drawing modes as controlled by the parameter to glBegin.   8  Introduction  Figure I.7. Figures for Exercises I.2, I.3, and I.4.  were drawn only one pixel wide. By default, OpenGL draws thin lines, one pixel wide, and does not do any “antialiasing” to smooth out the lines. You can try making wider and smoother lines by using the following commands:     Lines are n pixels wide  glLineWidth  n  ; glEnable GL_LINE_SMOOTH ; glHint GL_LINE_SMOOTH_HINT, GL_NICEST ; glEnable GL_BLEND ; glBlendFunc GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA ;     Antialias lines   In the ﬁrst line, a value such as 3 for n may give good results.  How well, and whether, the line-width speciﬁcation and the antialiasing work will depend on your implementation of OpenGL.  Exercise I.1 The OpenGL program SimpleDraw includes code to draw the images shown in Figures I.5 and I.6, and a colorized version of Figure I.12. Run this program, and examine its source code. Learn how to compile the program and then try enabling the code for making bigger points and wider, smoother lines.  This code is already present but is commented out.  Does it work for you?  Exercise I.2 Write an OpenGL program to generate the two images of Figure I.7 as line drawings. You will probably want to modify the source code of SimpleDraw for this.  Drawing Polygons in OpenGL OpenGL includes commands for drawing triangles, quadrilaterals, and convex polygons. Ordi- narily, these are drawn as solid, ﬁlled-in shapes. That is, OpenGL does not just draw the edges of triangles, quadrilaterals, and polygons but instead draws their interiors.  To draw a single triangle with vertices vi =  cid:5 xi , yi , zi cid:6 , you can use the commands  glBegin  GL_TRIANGLES  ; glVertex3f  x1, y1, z1  ; glVertex3f  x2, y2, z2  ; glVertex3f  x3, y3, z3  ; glEnd  ;  You may specify multiple triangles by a single invocation of the glBegin GL_TRIANGLES  function by making 3n calls to glVertex* to draw n triangles.  Frequently, one wants to combine multiple triangles to form a continuous surface. For this, it is convenient to specify multiple triangles at once, without having to specify the same vertices repeatedly for different triangles. A “triangle strip” is drawn by invoking glBegin   I.2 Coordinates, Points, Lines, and Polygons  9  v5  v4  v6  v3  v2  v1 GL TRIANGLES  v6  v4  v2  v5  v3  v1  GL TRIANGLE STRIP  v5  v6  v1  v4  v3  v2 GL TRIANGLE FAN  Figure I.8. The three triangle-drawing modes. These are shown with the default front face upwards. In regard to this, note the difference in the placement of the vertices in each ﬁgure, especially of v5 and v6 in the ﬁrst two ﬁgures.  with GL_TRIANGLE_STRIP and specifying n vertices. This has the effect of joining up the triangles as shown in Figure I.8.  Another way to join up multiple triangles is to let them share the common vertex v1. This is also shown in Figure I.8 and is invoked by calling glBegin with GL_TRIANGLE_FAN and giving vertices v1, . . . , vn.  OpenGL allows you to draw convex quadrilaterals, that is, convex four-sided polygons. OpenGL does not check whether the quadrilaterals are convex or even planar but instead simply breaks the quadrilateral into two triangles to draw the quadrilateral as a ﬁlled-in polygon.  Like triangles, quadrilaterals are drawn by giving glBegin and glEnd commands and between them specifying the vertices of the quadrilateral. The following commands can be used to draw one or more quadrilaterals:  glBegin  GL_QUADS  ; glVertex3f  x1, y1, z1  ;  ···  glVertex3f  xn, yn, zn  ; glEnd  ;  Here n must be a multiple of 4, and OpenGL draws the n 4 quadrilaterals with vertices v4i−3, v4i−2, v4i−1, and v4i , for 1 ≤ i ≤ n 4. You may also use the glBegin parameter GL_QUAD_STRIP to connect the polygons in a strip. In this case, n must be even, and OpenGL draws the n 2 − 1 quadrilaterals with vertices v2i−3, v2i−2, v2i−1, and v2i , for 2 ≤ i ≤ n 2. These are illustrated in Figure I.9.  v8  v7  v7  v8  v5  v4  v6  v3  v1  v2  GL QUADS  v5  v3  v6  v4  v1  v2  GL QUAD STRIP  Figure I.9. The two quadrilateral-drawing modes. It is important to note that the order of the vertices is different in the two modes!   10  v1  v2  v6  v5  v4  v3  Introduction  Figure I.10. A polygon with six vertices. The OpenGL standards do not specify how the polygon will be triangulated.  The vertices for GL_QUADS and for GL_QUAD_STRIP are speciﬁed in different orders. For GL_QUADS, vertices are given in counterclockwise order. For GL_QUAD_STRIP, they are given in pairs in left-to-right order suggesting the action of mounting a ladder.  OpenGL also allows you to draw polygons with an arbitrary number of sides. You should note that OpenGL assumes the polygon is planar, convex, and simple.  A polygon is simple if its edges do not cross each other.  Although OpenGL makes these assumptions, it does not check them in any way. In particular, it is quite acceptable to use nonplanar polygons  just as it is quite acceptable to use nonplanar quadrilaterals  as long as the polygon does not deviate too far from being simple, convex, and planar. What OpenGL does is to triangulate the polygon and render the resulting triangles.  To draw a polygon, you call glBegin with the parameter GL_POLYGON and then give the  n vertices of the polygon. An example is shown in Figure I.10.  Polygons can be combined to generate complex surfaces. For example, Figure I.11 shows two different ways of drawing a torus as a set of polygons. The ﬁrst torus is generated by using quad strips that wrap around the torus; 16 such strips are combined to make the entire torus. The second torus is generated by using a single long quadrilateral strip that wraps around the torus like a ribbon.  Exercise I.3 Draw the ﬁve-pointed star of Figure I.7 as a solid, ﬁlled-in region. Use a single triangle fan with the initial point of the triangle fan at the center of the star.  Save your program to modify for Exercise I.4.   Colors OpenGL allows you to set the color of vertices, and thereby the color of lines and polygons, with the glColor* commands. The most common syntax for this command is  glColor3f  float r, float g, float b  ;  The numbers r, g, b specify respectively the brightness of the red, green, and blue components of the color. If these three values all equal 0, then the color is black. If they all equal 1, then the color is white. Other colors can be generated by mixing red, green, and blue. For instance, here are some ways to specify some common colors:  glColor3f  1, 0, 0  ; glColor3f  0, 1, 0  ; glColor3f  0, 0, 1  ; glColor3f  1, 1, 0  ; glColor3f  1, 0, 1  ; glColor3f  0, 1, 1  ;     Red    Green    Blue    Yellow    Magenta    Cyan   I.2 Coordinates, Points, Lines, and Polygons  11   a  Torus as multiple quad strips.   b  Torus as a single quad strip.  Figure I.11. Two different methods of generating wireframe tori. The second torus is created with the supplied OpenGL program WrapTorus. In the second torus, the quadrilaterals are not quite planar.  The brightness levels may also be set to fractional values between 0 and 1  and in some cases values outside the range [0, 1] can be used to advantage, although they do not correspond to actual displayable colors . These red, green, and blue color settings are used also by many painting and drawing programs and even many word processors on PCs. Many of these pro- grams have color palettes that let you choose colors in terms of red, green, and blue values. OpenGL uses the same RGB system for representing color.  The glColor* command may be given inside the scope of glBegin and glEnd com- mands. Once a color is set by glColor*, that color will be assigned to all subsequent vertices until another color is speciﬁed. If all the vertices of a line or polygon have the same color, then the entire line or polygon is drawn with this color. On the other hand, it is possible for different vertices of line or polygon to have different colors. In this case, the interior of the line or polygon is drawn by blending colors; points in the interior of the line or polygon will be assigned a color by averaging colors of the vertices in such a way that the colors of nearby vertices will have more weight than the colors of distant vertices. This process is called shading and blends colors smoothly across a polygon or along a line.  You can turn off shading of lines and polygons by using the command  glShadeModel  GL_FLAT  ;  and turn it back on with  glShadeModel  GL_SMOOTH  ;   12  Introduction  In the ﬂat shading mode, an entire region gets the color of one of its vertices. The color of a line, triangle, or quadrilateral is determined by the color of the last speciﬁed vertex. The color of a general polygon, however, is set by the color of its ﬁrst vertex.  The background color of the graphics window defaults to black but can be changed with the glClearColor command. One usually starts drawing an image by ﬁrst calling the glClear command with the GL_COLOR_BUFFER_BIT set in its parameter; this initializes the color to black or whatever color has been set by the glClearColor command.  Later in the book we will see that shading is an important tool for creating realistic images, particularly when combined with lighting models that compute colors from material properties and light properties, rather than using colors that are explicitly set by the programmer.  Exercise I.4 Modify the program you wrote for Exercise I.3, which drew a ﬁve-pointed star as a single triangle fan. Draw the star in the same way, but now make the triangles alternate between two colors.  Hidden Surfaces When we draw points in three dimensions, objects that are closer to the viewpoint may oc- clude, or hide, objects that are farther from the viewer. OpenGL uses a depth buffer that holds a distance or depth value for each pixel. The depth buffer lets OpenGL do hidden surface com- putations by the simple expedient of drawing into a pixel only if the new distance will be less than the old distance. The typical use of the depth buffer is as follows: When an object, such as a triangle, is rendered, OpenGL determines which pixels need to be drawn and computes a measure of the distance from the viewer to each pixel image. That distance is compared with the distance associated with the former contents of the pixel. The lesser of these two distances de- termines which pixel value is saved, because the closer object is presumed to occlude the farther object.  To better appreciate the elegance and simplicity of the depth buffer approach to hidden surfaces, we consider some alternative hidden surface methods. One such method, called the painter’s algorithm, sorts the polygons from most distant to closest and renders them in back- to-front order, letting subsequent polygons overwrite earlier ones. The painter’s algorithm is easy but not completely reliable; in fact, it is not always possible to sort polygons consistently according to their distance from the viewer  cf. Figure I.12 . In addition, the painter’s algorithm cannot handle interpenetrating polygons. Another hidden surface method is to work out all the information geometrically about how the polygons occlude each other and to render only the visible portions of each polygon. This, however, is quite difﬁcult to design and implement robustly. The depth buffer method, in contrast, is very simple and requires only an extra depth, or distance, value to be stored per pixel. Furthermore, this method allows polygons to be rendered independently and in any order.  The depth buffer is not activated by default. To enable the use of the depth buffer, you must have a rendering context with a depth buffer. If you are using the OpenGL Utility Toolkit  as in the code supplied with this book , this is done by initializing your graphics window with a command such as  glutInitDisplayMode GLUT_DEPTH  GLUT_RGB  ;  which initializes the graphics display to use a window with RGB buffers for color and with a depth buffer. You must also turn on depth testing with the command  glEnable  GL_DEPTH_TEST  ;   I.2 Coordinates, Points, Lines, and Polygons  13  Figure I.12. Three triangles. The triangles are turned obliquely to the viewer so that the top portion of each triangle is in front of the base portion of another.  It is also important to clear the depth buffer each time you render an image. This is typically done with a command such as  glClear  GL_COLOR_BUFFER_BIT  GL_DEPTH_BUFFER_BIT  ;  which both clears the color  i.e., initializes the entire image to the default color  and clears the depth values.  The SimpleDraw program illustrates the use of depth buffering for hidden surfaces. It shows three triangles, each of which partially hides another, as in Figure I.12. This example shows why ordering polygons from back to front is not a reliable means of performing hidden surface computation.  Polygon Face Orientations OpenGL keeps track of whether polygons are facing toward or away from the viewer, that is, OpenGL assigns each polygon a front face and a back face. In some situations, it is desirable for only the front faces of polygons to be viewable, whereas at other times you may want both the front and back faces to be visible. If we set the back faces to be invisible, then any polygon whose back face would ordinarily be seen is not drawn at all and, in effect, becomes transparent.  By default, both faces are visible.   OpenGL determines which face of a polygon is the front face by the default convention that vertices on a polygon are speciﬁed in counterclockwise order  with some exceptions for triangle strips and quadrilateral strips . The polygons in Figures I.8, I.9, and I.10 are all shown with their front faces visible.  You can change the convention for which face is the front face by using the glFrontFace  command. This command has the format  glFrontFace   GL_CW GL_CCW   ;   cid:2   where “CW” and “CCW” stand for clockwise and counterclockwise; GL_CCW is the default. Using GL_CW causes the conventions for front and back faces to be reversed on subsequent polygons.  To make front or back faces invisible, or to do both, you must use the commands  glCullFace   GL_FRONT GL_BACK  GL_FRONT_AND_BACK  glEnable  GL_CULL_FACE  ;   ;   cid:1      14  Introduction   a  Torus as multiple quad strips.   b  Torus as a single quad strip.  Figure I.13. Two wireframe tori with back faces culled. Compare with Figure I.11.  You must explicitly turn on the face culling with the call to glEnable. Face culling can be turned off with the corresponding glDisable command. If both front and back faces are culled, then other objects such as points and lines are still drawn.  The two wireframe tori of Figure I.11 are shown again in Figure I.13 with back faces culled. Note that hidden surfaces are not being removed in either ﬁgure; only back faces have been culled.  Toggling Wireframe Mode By default, OpenGL draws polygons as solid and ﬁlled in. It is possible to change this by using the glPolygonMode function, which determines whether to draw solid polygons, wireframe polygons, or just the vertices of polygons.  Here, “polygon” means also triangles and quadri- laterals.  This makes it easy for a program to switch between the wireframe and nonwireframe mode. The syntax for the glPolygonMode command is    glPolygonMode   GL_FRONT GL_BACK  GL_FRONT_AND_BACK  ,   GL_FILL  GL_LINE GL_POINT   ;  The ﬁrst parameter to glPolygonMode speciﬁes whether the mode applies to front or back faces or to both. The second parameter sets whether polygons are drawn ﬁlled in, as lines, or as just vertices.  Exercise I.5 Write an OpenGL program that renders a cube with six faces of different colors. Form the cube from six quadrilaterals, making sure that the front faces are facing   I.3 Double Buffering for Animation  15  outwards. If you already know how to perform rotations, let your program include the ability to spin the cube around.  Refer to Chapter II and see the WrapTorus program for code that does this.   If you rendered the cube using triangles instead, how many triangles would be needed?  Exercise I.6 Repeat Exercise I.5 but render the cube using two quad strips, each containing three quadrilaterals.  Exercise I.7 Repeat Exercise I.5 but render the cube using two triangle fans.  I.3 Double Buffering for Animation  The term “animation” refers to drawing moving objects or scenes. The movement is only a visual illusion, however; in practice, animation is achieved by drawing a succession of still scenes, called frames, each showing a static snapshot at an instant in time. The illusion of motion is obtained by rapidly displaying successive frames. This technique is used for movies, television, and computer displays. Movies typically have a frame rate of 24 frames per second. The frame rates in computer graphics can vary with the power of the computer and the complexity of the graphics rendering, but typically one attempts to get close to 30 frames per second and more ideally 60 frames per second. These frame rates are quite adequate to give smooth motion on a screen. For head-mounted displays, where the view changes with the position of the viewer’s head, much higher frame rates are needed to obtain good effects.  Double buffering can be used to generate successive frames cleanly. While one image is displayed on the screen, the next frame is being created in another part of the memory. When the next frame is ready to be displayed, the new frame replaces the old frame on the screen instantaneously  or rather, the next time the screen is redrawn, the new image is used . A region of memory where an image is being created or stored is called a buffer. The image being displayed is stored in the front buffer, and the back buffer holds the next frame as it is being created. When the buffers are swapped, the new image replaces the old one on the screen. Note that swapping buffers does not generally require copying from one buffer to the other; instead, one can just update pointers to switch the identities of the front and back buffers.  A simple example of animation using double buffering in OpenGL is shown in the program SimpleAnim that accompanies this book. To use double buffering, you should include the following items in your OpenGL program: First, you need to have a graphics context that supports double buffering. This is obtained by initializing your graphics window by a function call such as  glutInitDisplayMode GLUT_DOUBLE  GLUT_RGB  GLUT_DEPTH  ;  In SimpleAnim, the function updateScene is used to draw a single frame. It works by drawing into the back buffer and at the very end gives the following commands to complete the drawing and swap the front and back buffers:  glFlush  ; glutSwapBuffers  ;  It is also necessary to make sure that updateScene is called repeatedly to draw the next frame. There are two ways to do this. The ﬁrst way is to have the updateScene routine call glutPostRedisplay  . This will tell the operating system that the current window needs rerendering, and this will in turn cause the operating system to call the routine speci- ﬁed by glutDisplayFunc. The second method, which is used in SimpleAnim, is to use glutIdleFunc to request the operating system to call updateScene whenever the CPU is   16  Introduction  idle. If the computer system is not heavily loaded, this will cause the operating system to call updateScene repeatedly.  You should see the GLUT documentation for more information about how to set up call- backs, not only for redisplay functions and idle functions but also for capturing keystrokes, mouse button events, mouse movements, and so on. The OpenGL programs supplied with this book provide examples of capturing keystrokes; in addition, ConnectDots shows how to capture mouse clicks.   II  Transformations and Viewing  This chapter discusses the mathematics of linear, afﬁne, and perspective transformations and their uses in OpenGL. The basic purpose of these transformations is to provide methods of changing the shape and position of objects, but the use of these transformations is pervasive throughout computer graphics. In fact, afﬁne transformations are arguably the most fundamen- tal mathematical tool for computer graphics.  An obvious use of transformations is to help simplify the task of geometric modeling. For example, suppose an artist is designing a computerized geometric model of a Ferris wheel. A Ferris wheel has considerable symmetry and includes many repeated elements such as multiple cars and struts. The artist could design a single model of the car and then place multiple instances of the car around the Ferris wheel attached at the proper points. Similarly, the artist could build the main structure of the Ferris wheel by designing one radial “slice” of the wheel and using multiple rotated copies of this slice to form the entire structure. Afﬁne transformations are used to describe how the parts are placed and oriented.  A second important use of transformations is to describe animation. Continuing with the Ferris wheel example, if the Ferris wheel is animated, then the positions and orientations of its individual geometric components are constantly changing. Thus, for animation, it is necessary to compute time-varying afﬁne transformations to simulate the motion of the Ferris wheel.  A third, more hidden, use of transformations in computer graphics is for rendering. After a 3-D geometric model has been created, it is necessary to render it on a two-dimensional surface called the viewport. Some common examples of viewports are a window on a video screen, a frame of a movie, and a hard-copy image. There are special transformations, called perspective transformations, that are used to map points from a 3-D model to points on a 2-D viewport.  To properly appreciate the uses of transformations, it is important to understand the ren- dering pipeline, that is, the steps by which a 3-D scene is modeled and rendered. A high-level description of the rendering pipeline used by OpenGL is shown in Figure II.1. The stages of the pipeline illustrate the conceptual steps involved in going from a polygonal model to an on-screen image. The stages of the pipeline are as follows:  Modeling. In this stage, a 3-D model of the scene to be displayed is created. This stage is generally the main portion of an OpenGL program. The program draws images by spec- ifying their positions in 3-space. At its most fundamental level, the modeling in 3-space consists of describing vertices, lines, and polygons  usually triangles and quadrilaterals  by giving the x-, y-, z-coordinates of the vertices. OpenGL provides a ﬂexible set of tools for positioning vertices, including methods for rotating, scaling, and reshaping objects.  17   18  Transformations and Viewing  Modeling  View  Selection  Perspective  Division  Displaying  Figure II.1. The four stages of the rendering pipeline in OpenGL.  These tools are called “afﬁne transformations” and are discussed in detail in the next sections. OpenGL uses a 4 × 4 matrix called the “model view matrix” to describe afﬁne transformations.  View Selection. This stage is typically used to control the view of the 3-D model. In this stage, a camera or viewpoint position and direction are set. In addition, the range and the ﬁeld of view are determined. The mathematical tools used here include “orthographic projections” and “perspective transformations.” OpenGL uses another 4 × 4 matrix called the “projection matrix” to specify these transformations.  Perspective Division. The previous two stages use a method of representing points in 3- space by means of homogeneous coordinates. Homogeneous coordinates use vectors with four components to represent points in 3-space.  The perspective division stage merely converts from homogeneous coordinates back into the usual three x-, y-, z-coordinates. The x- and y-coordinates determine the position of a vertex in the ﬁnal graphics image. The z-coordinates measure the distance to the object, although they can represent a “pseudo-distance,” or “fake” distance, rather than a true distance.  Homogeneous coordinates are described later in this chapter. As we will see, perspec-  tive division consists merely of dividing through by a w value.  Displaying. In this stage, the scene is rendered onto the computer screen or other display medium such as a printed page or a ﬁlm. A window on a computer screen consists of a rectangular array of pixels. Each pixel can be independently set to an individual color and brightness. For most 3-D graphics applications, it is desirable to not render parts of the scene that are not visible owing to obstructions of view. OpenGL and most other graphics display systems perform this hidden surface removal with the aid of depth  or distance  information stored with each pixel. During this fourth stage, pixels are given color and depth information, and interpolation methods are used to ﬁll in the interior of polygons. This fourth stage is the only stage dependent on the physical characteristics of the output device. The ﬁrst three stages usually work in a device-independent fashion.  The discussion in this chapter emphasizes the mathematical aspects of the transformations used by computer graphics but also sketches their use in OpenGL. The geometric tools used in computer graphics are mathematically very elegant. Even more important, the techniques discussed in this chapter have the advantage of being fairly easy for an artist or programmer to use and lend themselves to efﬁcient software and hardware implementation. In fact, modern- day PCs typically include specialized graphics chips that carry out many of the transformations and interpolations discussed in this chapter.  II.1 Transformations in 2-Space  We start by discussing linear and afﬁne transformations on a fairly abstract level and then see examples of how to use transformations in OpenGL. We begin by considering afﬁne transformations in 2-space since they are much simpler than transformations in 3-space. Most of the important properties of afﬁne transformations already apply in 2-space.   II.1 Transformations in 2-Space  19 The x y-plane, denoted R2 = R × R, is the usual Cartesian plane consisting of points  cid:5 x, y cid:6 . To avoid writing too many coordinates, we often use the vector notation x for a point in R2, with the usual convention being that x =  cid:5 x1, x2 cid:6 , where x1, x2 ∈ R. This notation is convenient but potentially confusing because we will use the same notation for vectors as for points.1 We write 0 for the origin, or zero vector, and thus 0 =  cid:5 0, 0 cid:6 . We write x + y and x − y for the componentwise sum and difference of x and y. A real number α ∈ R is called a scalar, and the product of a scalar and a vector is deﬁned by αx =  cid:5 αx1, αx2 cid:6 .2  II.1.1 Basic Deﬁnitions A transformation on R2 is any mapping A : R2  cid:13 → R2. That is, each point x ∈ R2 is mapped to a unique point, A x , also in R2.  Deﬁnition Let A be a transformation. A is a linear transformation provided the following two conditions hold: 1. For all α ∈ R and all x ∈ R2, A αx  = α A x . 2. For all x, y ∈ R2, A x + y  = A x  + A y . Note that A 0  = 0 for any linear transformation A. This follows from condition 1 with α = 0.  Examples: Here are ﬁve examples of linear transformations: 1. A1 :  cid:5 x, y cid:6   cid:13 →  cid:5 −y, x cid:6 . 2. A2 :  cid:5 x, y cid:6   cid:13 →  cid:5 x, 2y cid:6 . 3. A3 :  cid:5 x, y cid:6   cid:13 →  cid:5 x + y, y cid:6 . 4. A4 :  cid:5 x, y cid:6   cid:13 →  cid:5 x,−y cid:6 . 5. A5 :  cid:5 x, y cid:6   cid:13 →  cid:5 −x,−y cid:6 .  Exercise II.1 Verify that the preceding ﬁve transformations are linear. Draw pictures of how they transform the F shown in Figure II.2.  We deﬁned transformations as acting on a single point at a time, but of course, a transfor- mation also acts on arbitrary geometric objects since the geometric object can be viewed as a collection of points and, when the transformation is used to map all the points to new locations, this changes the form and position of the geometric object. For example, Exercise II.1 asked you to calculate how transformations acted on the F shape.  2  1 Points and vectors in 2-space both consist of a pair of real numbers. The difference is that a point speciﬁes a particular location, whereas a vector speciﬁes a particular displacement, or change in location. That is, a vector is the difference of two points. Rather than adopting a confusing and nonstandard notation that clearly distinguishes between points and vectors, we will instead fol- low the more common, but ambiguous, convention of using the same notation for points as for vectors. In view of the distinction between points and vectors, it can be useful to form the sums and differences of two vectors, or of a point and a vector, or the difference of two points, but it is not generally useful to form the sum of two points. The sum or difference of two vectors is a vector. The sum or difference of a point and a vector is a point. The difference of two points is a vector. Likewise, a vector may be multiplied by a scalar, but it is less frequently appropriate to multiply a scalar and point. However, we gloss over these issues and deﬁne the sums and products on all combinations of points and vectors. In any event, we frequently blur the distinction between points and vectors.   Transformations and Viewing  20   cid:1 0, 1 cid:2   cid:1 0, 0 cid:2    cid:1 0,−1 cid:2   y   cid:1 1, 1 cid:2   x   cid:1 1, 0 cid:2   Figure II.2. An F shape.  One simple, but important, kind of transformation is a “translation,” which changes the position of objects by a ﬁxed amount but does not change the orientation or shape of geometric objects. Deﬁnition A transformation A is a translation provided that there is a ﬁxed u ∈ R2 such that A x  = x + u for all x ∈ R2.  The notation Tu is used to denote this translation, thus Tu x  = x + u. The composition of two transformations A and B is the transformation computed by ﬁrst applying B and then applying A. This transformation is denoted A ◦ B, or just AB, and satisﬁes   A ◦ B  x  = A B x  .  The identity transformation maps every point to itself. The inverse of a transformation A is −1 ◦ A are both the identity transformation. the transformation A Not every transformation has an inverse, but when A is one-to-one and onto, the inverse transformation A  −1 such that A ◦ A  −1 always exists.  −1 and A  Note that the inverse of Tu is T−u.  Deﬁnition A transformation A is afﬁne provided it can be written as the composition of a translation and a linear transformation. That is, provided it can be written in the form A = Tu B for some u ∈ R2 and some linear transformation B. In other words, a transformation A is afﬁne if it equals  A x  = B x  + u,  with B a linear transformation and u a point. Because it is permitted that u = 0, every linear transformation is afﬁne. However, not every afﬁne transformation is linear. In particular, if u  cid:16 = 0, then transformation II.1 is not linear since it does not map 0 to 0.  Proposition II.1 Let A be an afﬁne transformation. The translation vector u and the linear transformation B are uniquely determined by A. Proof First, we see how to determine u from A. We claim that in fact u = A 0 . This is proved by the following equalities:  A 0  = Tu B 0   = Tu 0  = 0 + u = u.  Then B = T  u A = T−u A, and so B is also uniquely determined. −1  II.1   cid:1   II.1.2 Matrix Representation of Linear Transformations  The preceding mathematical deﬁnition of linear transformations is stated rather abstractly. However, there is a very concrete way to represent a linear transformation A – namely, as a 2 × 2 matrix.   II.1 Transformations in 2-Space  21 Deﬁne i =  cid:5 1, 0 cid:6  and j =  cid:5 0, 1 cid:6 . The two vectors i and j are the unit vectors aligned with the x-axis and y-axis, respectively. Any vector x =  cid:5 x1, x2 cid:6  can be uniquely expressed as a linear combination of i and j, namely, as x = x1i + x2j. Let A be a linear transformation. Let u =  cid:5 u1, u2 cid:6  = A i  and v =  cid:5 v1, v2 cid:6  = A j . Then, by linearity, for any x ∈ R2,  A x  = A x1i + x2j  = x1 A i  + x2 A j  = x1u + x2v  Let M be the matrix   cid:10   =  cid:5 u1x1 + v1x2, u2x1 + v2x2 cid:6 .  cid:11   cid:12    cid:12  cid:11   . Then,   cid:9   cid:11    cid:12   u1 u2  v1 v2   cid:11   M  x1 x2  =  u1 v1 u2 v2  x1 x2  =   cid:12   ,  u1x1 + v1x2 u2x1 + v2x2  and so the matrix M computes the same thing as the transformation A. We call M the matrix representation of A.  We have just shown that every linear transformation A is represented by some matrix. Conversely, it is easy to check that every matrix represents a linear transformation. Thus, it is reasonable to think henceforth of linear transformations on R2 as being the same as 2 × 2 matrices. One notational complication is that a linear transformation A operates on points x =  cid:5 x1, x2 cid:6 , whereas a matrix M acts on column vectors. It would be convenient, however, to use both of the notations A x  and Mx. To make both notations be correct, we adopt the following rather special conventions about the meaning of angle brackets and the representation of points as column vectors:  Notation The point or vector  cid:5 x1, x2 cid:6  is identical to the column vector . So “point,” “vector,” and “column vector” all mean the same thing. A column vector is the same as a single column matrix. A row vector is a vector of the form  x1, x2 , that is, a matrix with a single row.  x1 x2   cid:9    cid:10   A superscript T denotes the matrix transpose operator. In particular, the transpose of a row vector is a column vector and vice versa. Thus, xT equals the row vector  x1, x2 . It is a simple, but important, fact that the columns of a matrix M are the images of i and j under M. That is to say, the ﬁrst column of M is equal to Mi and the second column of M is equal to Mj. This gives an intuitive method of constructing a matrix for a linear transformation, as shown in the next example.  . Consider the action of M on the F shown in Figure II.3. To ﬁnd the −1j. It is not  −1, it is enough to determine M  −1i and M   cid:10   Example: Let M = cid:9   cid:11  1−1 2   cid:12    cid:11   =  −1  1 0  M  1 1  0 2   cid:12   matrix representation of its inverse M hard to see that  Hint: Both facts follow from M −1 is equal to  Therefore, M   cid:9    cid:9   and  M   cid:10    cid:10  = cid:9   cid:10   0 1  0 1 2  1−1 2  0 1 2  .  −1   cid:11    cid:12   cid:9   0 1  =   cid:11   cid:10  = cid:9    cid:12   cid:10   .  0 1 2  .  and M  1 0  1 1   22  Transformations and Viewing   cid:1 1, 3 cid:2    cid:1 1, 1 cid:2   x  y   cid:1 0, 2 cid:2    cid:1 0, 0 cid:2    cid:1 0,−2 cid:2   y   cid:1 1, 1 cid:2   x   cid:1 1, 0 cid:2    cid:1 0, 1 cid:2   cid:1 0, 0 cid:2    cid:1 0,−1 cid:2   ⇒   cid:11   Figure II.3. An F shape transformed by a linear transformation.  The example shows a rather intuitive way to ﬁnd the inverse of a matrix, but it depends on being able to ﬁnd preimages of i and j. One can also compute the inverse of a 2 × 2 matrix by the well-known formula   cid:12 −1 =   cid:11   a b c d   cid:12   ,  1  det M   d −b −c a  where det M   = ad − bc is the determinant of M.  Exercise II.2 Figure II.4 shows an afﬁne transformation acting on an F.  a  Is this a linear transformation? Why or why not?  b  Express this afﬁne transformation in the form x  cid:13 → Mx + u by explicitly giving M and u.  A rotation is a transformation that rotates the points in R2 by a ﬁxed angle around the origin. Figure II.5 shows the effect of a rotation of θ degrees in the counterclockwise  CCW  direction. As shown in Figure II.5, the images of i and j under a rotation of θ degrees are  cid:5 cos θ, sin θ cid:6  and  cid:5 −sin θ, cos θ cid:6 . Therefore, a counterclockwise rotation through an angle θ is represented by the matrix Rθ =   cid:11  cos θ −sin θ cos θ sin θ   cid:12   II.2  .  Exercise II.3 Prove the angle sum formulas for sin and cos:  sin θ + ϕ  = sin θ cos ϕ + cos θ sin ϕ cos θ + ϕ  = cos θ cos ϕ − sin θ sin ϕ,  by considering what the rotation Rθ does to the point x =  cid:5 cos ϕ, sin ϕ cid:6 .  y   cid:1 1, 1 cid:2   x   cid:1 1, 0 cid:2    cid:1 0, 1 cid:2   cid:1 0, 0 cid:2    cid:1 0, 1 cid:2  −  ⇒  y   cid:1 0, 1 cid:2    cid:1 0, 0 cid:2    cid:1 1, 1 cid:2   cid:1 1, 0 cid:2    cid:1 1,−1 cid:2   x  Figure II.4. An afﬁne transformation acting on an F.   II.1 Transformations in 2-Space  23   cid:1   −  sin , cos θ cid:2   θ   cid:1 0, 1 cid:2    cid:1 cos , sin θ  θ   cid:2   0  θ  θ  θ  0, 0  1, 0  Figure II.5. Effect of a rotation through angle θ. The origin 0 is held ﬁxed by the rotation.  Conventions on Row and Column Vectors and Transposes. The conventions adopted in this book are that points in space are represented by column vectors, and linear transfor- mations with matrix representation M are computed as Mx. Thus, our matrices multiply on the left. Unfortunately, this convention is not universally followed, and it is also com- mon in computer graphics applications to use row vectors for points and vectors and to use matrix representations that act on the right. That is, many workers in computer graphics use a row vector to represent a point: instead of using x, they use the row vec- tor xT. Then, instead of multiplying on the left with M, they multiply on the right with its transpose M T. Because xT M T equals  Mx T, this has the same meaning. Similarly, when multiplying matrices to compose transformations, one has to reverse the order of the multiplications when working with transposed matrices because  M N  T = N T M T. OpenGL follows the same conventions as we do: points and vectors are column vec- tors, and transformation matrices multiply on the left. However, OpenGL does have some vestiges of the transposed conventions; namely, when specifying matrices with glLoad- Matrix and glMultMatrix the entries in the matrix are given in column order.  II.1.3 Rigid Transformations and Rotations  A rigid transformation is a transformation that only repositions objects, leaving their shape and size unchanged. If the rigid transformation also preserves the notions of “clockwise” versus “counterclockwise,” then it is orientation-preserving.  Deﬁnition A transformation is called rigid if and only if it preserves both  1. Distances between points, and 2. Angles between lines.  The transformation is said to be orientation-preserving if it preserves the direction of an- gles, that is, if a counterclockwise direction of movement stays counterclockwise after being transformed by A.  Rigid, orientation-preserving transformations are widely used. One application of these transformations is in animation: the position and orientation of a moving rigid body can be described by a time-varying transformation A t . This transformation A t  will be rigid and orientation-preserving provided the body does not deform or change size or shape.  The two most common examples of rigid, orientation-preserving transformations are ro- tations and translations. Another example of a rigid, orientation-preserving transformation is a “generalized rotation” that performs a rotation around an arbitrary center point. We prove below that every rigid, orientation-preserving transformation over R2 is either a translation or a generalized rotation.   24  b, a−  y  0, 0  a, b  x  Transformations and Viewing  Figure II.6. A rigid, orientation-preserving, linear transformation acting on the unit vectors i and j.  For linear transformations, an equivalent deﬁnition of rigid transformation is that a linear transformation A is rigid if and only if it preserves dot products. That is to say, if and only if, for all x, y ∈ R2, x · y = A x  · A y . To see that this preserves distances, recall that x2 = x · x is the square of the magnitude of x or the square of x’s distance from the origin.3 Thus, x2 = x · x = A x  · A x  = A x 2. From the deﬁnition of the dot product as x · y = x · y cos θ, where θ is the angle between x and y, the transformation A must also preserve angles between lines.  Exercise II.4 Which of the ﬁve linear transformations in Exercise II.1 on page 19 are rigid? Which ones are both rigid and orientation-preserving?  Exercise II.5 Let M =  u, v , that is, M = cid:9   . Show that the linear transformation represented by the matrix M is rigid if and only if u = v = 1, and u · v = 0. Prove that if M represents a rigid transformation, then det M  = ±1.   cid:10   u1 u2  v1 v2  A matrix M of the type in the previous exercise is called an orthonormal matrix.  −1.  Exercise II.6 Prove that the linear transformation represented by the matrix M is rigid if and only if M T = M Exercise II.7 Show that the linear transformation represented by the matrix M is orientation-preserving if and only if det M  > 0. [Hint: Let M =  u, v . Let u  cid:3  be u  cid:3  · v > 0.] ◦ rotated counterclockwise 90  . Then M is orientation-preserving if and only if u  Theorem II.2 Every rigid, orientation-preserving, linear transformation is a rotation.  The converse to Theorem II.2 holds too: every rotation is obviously a rigid, orientation- preserving, linear transformation. Proof Let A be a rigid, orientation-preserving, linear transformation. Let  cid:5 a, b cid:6  = A i . By rigidity, A i  · A i  = a2 + b2 = 1. Also, A j  must be the vector obtained by rotating A i  ; thus, A j  =  cid:5 −b, a cid:6 , as shown in Figure II.6. counterclockwise 90 . Because a2 + b2 = 1, there must be an angle θ such that cos θ = a and sin θ = b, namely, either θ = cos −1 a.  cid:1  From equation II.2, we see that A is a rotation through the angle θ.  Therefore, the matrix M representing A is equal to  −1 a or θ = − cos  −b a   cid:10    cid:9   a b  ◦  Some programming languages, including C and C++, have a two-parameter version of the  arctangent function that lets you compute the rotation angle as  θ = atan2 b, a .  tion.  Theorem II.2 and the deﬁnition of afﬁne transformations give the following characteriza-  3 Appendix A contains a review of elementary facts from linear algebra, including a discussion of dot  products and cross products.   II.1 Transformations in 2-Space  25  y  0, 3  θ  0, 1  0, 0   cid:1  ,−1  1, 1  1, 0  x  Figure II.7. A generalized rotation Ru  θ . The center of rotation is u =  cid:5 0, 3 cid:6 . The angle is θ = 45 ◦  .  Corollary II.3 Every rigid, orientation-preserving, afﬁne transformation can be  uniquely  expressed as the composition of a translation and a rotation.  Deﬁnition A generalized rotation is a transformation that holds a center point u ﬁxed and rotates all other points around u through a ﬁxed angle θ. This transformation is denoted Ru θ . An example of a generalized rotation is given in Figure II.7. Clearly, a generalized rotation  is rigid and orientation-preserving.  One way to perform a generalized rotation is ﬁrst to apply a translation to move the point u to the origin, then rotate around the origin, and then translate the origin back to u. Thus, the generalized rotation Ru θ = Tu Rθ T−u. Ru  θ can be expressed as  II.3  You should convince yourself that formula II.3 is correct.  Theorem II.4 Every rigid, orientation-preserving, afﬁne transformation is either a translation or a generalized rotation.  Obviously, the converse of this theorem holds too. Proof Let A be a rigid, orientation-preserving, afﬁne transformation. Let u = A 0 . If u = 0, A is actually a linear transformation, and Theorem II.2 implies that A is a rotation. So suppose u  cid:16 = 0. It will sufﬁce to prove that either A is a translation or there is some point v ∈ R2 that is a ﬁxed point of A, that is, such that A v  = v. This is sufﬁcient since, if there is a ﬁxed point v, then the reasoning of the proof of Theorem II.2 shows that A is a generalized rotation around v. Let L be the line that contains the two points 0 and u. We consider two cases. First, suppose that A maps L to itself. By rigidity, and by choice of u, A u  is distance u from u, and so we must have either A u  = u + u or A u  = 0. If A u  = u + u, then A must be the translation Tu. This follows because, again by the rigidity of A, every point x ∈ L must map to x + u and, by the rigidity and orientation-preserving properties, the same holds for every point not on L. On the other hand, if A u  = 0, then rigidity implies that v = 1 2 u is a ﬁxed point of A, and thus A is a generalized rotation around v.  Second, suppose that the line L is mapped to a different line L  with L, as shown in Figure II.8. Since L L 2 be the line perpendicular to L at the point 0, and let L point u. Note that L 2 and L   cid:3   cid:16 = L, θ is nonzero and is not a multiple of 180 ◦  make an angle of θ . Let  cid:3  2 be the line perpendicular to L at the  cid:3  2 are parallel. Now let L 3 be the line obtained by rotating L 2 around  . Let L   cid:3    cid:3    26  Transformations and Viewing  v   cid:1  L 3   cid:1  L 2  θ 2  A u    cid:1  L  θ  u = A 0   L2  L3  θ 2  L  0  Figure II.8. Finding the center of rotation. The point v is ﬁxed by the rotation.   cid:3   cid:3  the origin through a clockwise angle of θ 2, and let L 3 be the line obtained by rotating L 2 around the point u through a counterclockwise angle of θ 2. Because A is rigid and orientation-  cid:3  preserving and the angle between L and L 3 equals the angle between L 3, the line L 3  cid:3  3 are not parallel and intersect in a point v. By is mapped to L the symmetry of the constructions, v is equidistant from 0 and u. Therefore, again by rigidity, A v  = v. It follows that A is the generalized rotation Rv θ , which performs a rotation through  cid:1  an angle θ around the center v.   cid:3  3 by A. The two lines L 3 and L  and L   cid:3   II.1.4 Homogeneous Coordinates Homogeneous coordinates provide a method of using a triple of numbers  cid:5 x, y, w cid:6  to represent a point in R2. Deﬁnition If x, y, w ∈ R and w  cid:16 = 0, then  cid:5 x, y, w cid:6  is a homogeneous coordinate represen- tation of the point  cid:5 x w, y w cid:6  ∈ R2.   cid:3 , y  Note that any given point in R2 has many representations in homogeneous coordinates. For example, the point  cid:5 2, 1 cid:6  can be represented by any of the following sets of homogeneous coordinates:  cid:5 2, 1, 1 cid:6 ,  cid:5 4, 2, 2 cid:6 ,  cid:5 6, 3, 3 cid:6 ,  cid:5 −2,−1,−1 cid:6 , and so on. More generally, the triples  cid:5 x, y, w cid:6  and  cid:5 x  cid:3 , w cid:3  cid:6  represent the same point in homogeneous coordinates if and only if there is a nonzero scalar α such that x So far, we have only speciﬁed the meaning of the homogeneous coordinates  cid:5 x, y, w cid:6  when w  cid:16 = 0 because the deﬁnition of the meaning of  cid:5 x, y, w cid:6  required dividing by w. However, we will see in Section II.1.8 that, when w = 0,  cid:5 x, y, w cid:6  is the homogeneous coordinate represen- tation of a “point at inﬁnity.”  Alternatively, graphics software such as OpenGL will sometimes use homogeneous coordinates with w = 0 as a representation of a direction.  However, it is always required that at least one of the components x, y, w be nonzero.   cid:3  = αy, and w cid:3  = αw.   cid:3  = αx, y  The use of homogeneous coordinates may at ﬁrst seem somewhat strange or poorly moti- vated; however, it is an important mathematical tool for the representation of points in R2 in computer graphics. There are several reasons for this. First, as discussed next, using homoge- neous coordinates allows an afﬁne transformation to be represented by a single matrix. The second reason will become apparent in Section II.3, where perspective transformations and interpolation are discussed. A third important reason will arise in Chapters VII and VIII, where homogeneous coordinates will allow B´ezier curves and B-spline curves to represent circles and other conic sections.    cid:12    cid:11    cid:12   x1 x2  +  e f   cid:11   =  ax1 + bx2 + e cx1 + dx2 + f   cid:12   .  II.1 Transformations in 2-Space  27  II.1.5 Matrix Representation of Afﬁne Transformations  Recall that any afﬁne transformation A can be expressed as a linear transformation B followed by a translation Tu, that is, A = Tu ◦ B. Let M be a 2 × 2 matrix representing B, and suppose   cid:12   cid:11   cid:12  cid:11   e f  .  and   cid:12   u =  cid:11   Then the mapping A can be deﬁned by  x1 x2   cid:13 → M  = Now deﬁne N to be the 3 × 3 matrix  x1 x2  +  e f  a b c d   cid:11   a b c d   cid:12   cid:11  a b e  =  c d f 0 0 1   cid:11    cid:12   . a b e  c d f 0 0 1  M =  cid:11   cid:12   N =  x1  x2 1  N  N  Using the homogeneous representation  cid:5 x1, x2, 1 cid:6  of  cid:5 x1, x2 cid:6 , we see that  x1   =  x2 1   ax1 + bx2 + e  cx1 + dx2 + f   .  1  The effect of N ’s acting on  cid:5 x, y, 1 cid:6  is identical to the effect of the afﬁne transformation A acting on  cid:5 x, y cid:6 . The only difference is that the third coordinate of “1” is being carried around. More generally, for any other homogeneous representation of the same point,  cid:5 αx1, αx2, α cid:6  with α  cid:16 = 0, the effect of multiplying by N is   =  αx1  αx2 α   α ax1 + bx2 + e   α cx1 + dx2 + f     ,  α  which is another representation of the point A x  in homogeneous coordinates.  Thus, the 3 × 3 matrix N provides a representation of the afﬁne map A because, when one works with homogeneous coordinates, multiplying by the matrix N provides exactly the same results as applying the transformation A. Further, N acts consistently on different homogeneous representations of the same point. The method used to obtain N from A is completely general, and therefore any afﬁne transformation can be represented as a 3 × 3 matrix that acts on homogeneous coordinates. So far, we have used only matrices that have the bottom row  0 0 1 ; these matrices are sufﬁcient for representing any afﬁne transformation. In fact, an afﬁne transformation may henceforth be viewed as being identical to a 3 × 3 matrix that has bottom row  0 0 1 .  When we discuss perspective transformations, which are more general than afﬁne transfor-  mations, it will be necessary to have other values in the bottom row of the matrix.  Exercise II.8 Figure II.9 shows an afﬁne transformation acting on an F.  a  Is this a linear transformation? Why or why not?  b  Give a 3 × 3 matrix that represents the afﬁne transformation.  [Hint: In this case, the easiest way to ﬁnd the matrix is to split the transformation into a linear part and a translation. Then consider what the linear part does to the vectors i and j.]  For the next exercise, it is not necessary to invert a 3 × 3 matrix. Instead, note that if a  transformation is deﬁned by y = Ax + u, then its inverse is x = A  −1y − A  −1u.   Transformations and Viewing  28  0, 1  0, 0  0,−1  y  1, 1  x  1, 0  ⇒  y  0, 2  0, 1  1 2 , 1  x  1,−1  Figure II.9. An afﬁne transformation acting on an F.  Exercise II.9 Give the 3 × 3 matrix that represents the inverse of the transformation in Exercise II.8. Exercise II.10 Give an example of how two different 3 × 3 homogeneous matrices can represent the same afﬁne transformation.  II.1.6 Two-Dimensional Transformations in OpenGL  We take a short break in this subsection from the mathematical theory of afﬁne transformations and discuss how OpenGL speciﬁes transformations. OpenGL maintains several matrices that control where objects are drawn, where the camera or viewpoint is positioned, and where the graphics image is displayed on the screen. For the moment we consider only a matrix called the ModelView matrix, which is used principally to position objects in 3-space. In this subsection, we are trying to convey only the idea, not the details, of how OpenGL handles transformations, and thus we will work in 2-space. OpenGL really uses 3-space, however, and so not everything we discuss is exactly correct for OpenGL.  We denote the ModelView matrix by M for the rest of this subsection. The purpose of M is to hold a homogeneous matrix representing an afﬁne transformation. We therefore think of M as being a 3 × 3 matrix acting on homogeneous representations of points in 2-space.  However, in actuality, M is a 4 × 4 matrix operating on points in 3-space.  The OpenGL programmer speciﬁes points in 2-space by calling a routine glVertex2f x,y . As described in Chapter I, this point, or “vertex,” may be drawn as an isolated point or may be the endpoint of a line or a vertex of a polygon. For example, the following routine would specify three points to be drawn:  drawThreePoints   {  glBegin GL_POINTS ; glVertex2f 0.0, 1.0 ; glVertex2f 1.0, -1.0 ; glVertex2f -1.0, -1.0 ; glEnd  ;  }  The calls to glBegin and glEnd are used to bracket calls to glVertex2f. The param- eter GL_POINTS speciﬁes that individual points are to be drawn, not lines or polygons. Figure II.10 a  shows the indicated points.  However, OpenGL applies the transformation M before the points are drawn. Thus, the points will be drawn at the positions shown in Figure II.10 a  if M is the identity matrix. On   II.1 Transformations in 2-Space  29  y   cid:1 0, 1 cid:2   y   cid:1 0, 4 cid:2    cid:1 0, 2 cid:2    cid:1 2, 3 cid:2   x  x  Figure II.10. Drawing points  a  without transformation by the model view matrix and  b  with trans- formation by the model view matrix. The matrix is as given in the text and represents a rotation of −90 ◦ degrees followed by a translation of  cid:5 1, 3 cid:6 .   cid:1  1,−−  1 cid:2    cid:1 1,−1 cid:2    a    b   the other hand, for example, if M is the matrix   0  1 1 −1 0 3 0 1 0   ,  II.4  then the points will be drawn as shown in Figure II.10 b . Fortunately for OpenGL programmers, we do not often have to work directly with the component values of matrices; instead, OpenGL lets the programmer specify the model view matrix with a set of calls that implement rotations and translations. Thus, to use the matrix II.4, one can code as follows  function calls that start with “pgl” are not valid OpenGL4 :  glMatrixMode GL_MODELVIEW ; glLoadIdentity  ; pglTranslatef 1.0,3.0 ; pglRotatef -90.0 ; drawThreePoints  ;     Select model view matrix    M = Identity    M = M · T cid:5 1,3 cid:6 .5    M = M · R−90◦.5    Draw the three points  When drawThreePoints is called, the model view matrix M is equal to T cid:5 1,3 cid:6  ◦ R−90◦. This transformation is applied to the vertices speciﬁed in drawThreePoints, and thus the vertices are placed as shown in Figure II.10 b . It is important to note the order in which the two transformations are applied, since this is potentially confusing. The calls to the routines pglTranslatef and pglRotatef perform multiplications on the right; thus, when the vertices are transformed by M, the effect is that they are transformed ﬁrst by the rotation and  4 The preﬁx pgl stands for “pseudo-GL.” The two pgl functions would have to be coded as glTrans- latef 1.0,3.0,0.0  and glRotatef -90.0,0.0,0.0,1.0  to be valid OpenGL function calls. These perform a translation and a rotation in 3-space  see Section II.2.2 . R−90◦ can be viewed as 3 × 3 matrices.  5 We are continuing to identify afﬁne transformations with homogeneous matrices, and so T cid:5 1,3 cid:6  and   30  y  Transformations and Viewing  r  r   cid:11   θ  x  Figure II.11. The results of drawing the triangle with two different model view matrices. The dotted lines are not drawn by the OpenGL program and are present only to indicate the placement.  then by the translation. That is to say, the transformations are applied to the drawn vertices in the reverse order of the OpenGL function calls. The reason for this convention is that it makes it easier to transform vertices hierarchically.  Next, consider a slightly more complicated example of an OpenGL-style program that draws two copies of the triangle, as illustrated in Figure II.11. In the ﬁgure, there are three parameters, an angle θ, and lengths  cid:11  and r, which control the positions of the two triangles. The code to place the two triangles is as follows:  glMatrixMode GL_MODELVIEW ; glLoadIdentity  ; pglRotatef θ ; pglTranslatef  cid:11 ,0 ; glPushMatrix  ; pglTranslatef 0, r+1 ; drawThreePoints  ; glPopMatrix  ; pglRotatef 180.0 ; pglTranslatef 0, r+1 ; drawThreePoints  ;     Select model view matrix    M = Identity    M = M · Rθ    M = M · T cid:5  cid:11 ,0 cid:6     Save M on a stack    M = M · T cid:5 0,r+1 cid:6     Draw the three points    Restore M from the stack    M = M · R180◦    M = M · T cid:5 0,r+1 cid:6     Draw the three points  The new function calls glPushMatrix and glPopMatrix to save and restore the current matrix M with a stack. Calls to these routines can be nested to save multiple copies of the ModelView matrix in a stack. This example shows how the OpenGL matrix manipulation routines can be used to handle hierarchical models.  If you have never worked with OpenGL transformations before, then the order in which rotations and translations are applied in the preceding program fragment can be confusing. Note that the ﬁrst time drawThreePoints is called, the model view matrix is equal to  M = Rθ ◦ T cid:5  cid:11 ,0 cid:6  ◦ T cid:5 0,r+1 cid:6 .   II.1 Transformations in 2-Space  31  y   cid:1 1, 1 cid:2   x   cid:1 1, 0 cid:2    cid:1 0, 1 cid:2   cid:1 0, 0 cid:2    cid:1 0,−1 cid:2   y   cid:1 1, 1 cid:2    cid:1 2, 1 cid:2   ⇒   cid:1 1, 0 cid:2   x   cid:1 3, 0 cid:2   Figure II.12. The afﬁne transformation for Exercise II.11.  The second time drawThreePoints is called  M = Rθ ◦ T cid:5  cid:11 ,0 cid:6  ◦ R180◦ ◦ T cid:5 0,r+1 cid:6 .  You should convince yourself that this is correct and that this way of ordering transformations makes sense.  Exercise II.11 Consider the transformation shown in Figure II.12. Suppose that a function drawF   has been written to draw the F at the origin as shown in the left-hand side of Figure II.12. a. Give a sequence of pseudo-OpenGL commands that will draw the F as shown on the b. Give the 3 × 3 homogeneous matrix that represents the afﬁne transformation shown in  right-hand side of Figure II.12.  the ﬁgure.  II.1.7 Another Outlook on Composing Transformations  So far we have discussed the actions of transformations  rotations and translations  as acting on the objects being drawn and viewed them as being applied in reverse order from the order given in the OpenGL code. However, it is also possible to view transformations as acting not on objects but instead on coordinate systems. In this alternative viewpoint, one thinks of the transformations acting on local coordinate systems  and within the local coordinate system , and now the transformations are applied in the same order as given in the OpenGL code.  To explain this alternate view of transformations better, consider the triangle drawn in Figure II.10 b . That triangle is drawn by drawThreePoints when the model view matrix is M = T cid:5 1,3 cid:6  · R−90◦. The model view matrix was set by the two commands  pglTranslatef 1.0,3.0 ; pglRotatef -90.0 ;     M = M · T cid:5 1,3 cid:6     M = M · R−90◦ ,  ◦  and our intuition was that these transformations act on the triangle by ﬁrst rotating it clockwise around the origin and then translating it by the vector  cid:5 1, 3 cid:6 . 90 The alternate way of thinking about these transformations is to view them as acting on a local coordinate system. First, the x y-coordinate system is translated by the vector  cid:5 1, 3 cid:6  to create a new coordinate system with axes x . Then the rotation acts on the coordinate system again to deﬁne another new local coordinate system with axes x by rotating the axes −90 ◦ -coordinate system. These new local coordinate systems are shown in Figure II.13. Finally, when drawThreePoints is invoked, it draws the triangle in the local coordinate axes x  with the center of rotation at the origin of the x  cid:3  cid:3   and y  and y  and y  y   cid:3  cid:3    cid:3  cid:3    cid:3  cid:3   .   cid:3    cid:3    cid:3    cid:3    32  Transformations and Viewing  y   cid:1   y  y   cid:1  x  x   cid:1  cid:1   y   cid:1  cid:1  x  x   a    b   cid:3   cid:3   Figure II.13.  a  The local coordinate system x ◦ coordinates further transformed by a clockwise rotation of 90 axes x  and y  y   cid:3  cid:3    cid:3  cid:3   obtained by translating the x y-axes by  cid:5 1, 3 cid:6 .  b  The , yielding the local coordinate system with  cid:3  cid:3  .  and y   cid:3  cid:3   . In  b , the triangle’s vertices are drawn according to the local coordinate axes x  When transformations are viewed as acting on local coordinate systems, the meanings of the transformations are to be interpreted within the framework of the local coordinate system. For instance, the rotation R−90◦ has its center of rotation at the origin of the current local coordinate system, not at the origin of the initial x y-axes. Similarly, a translation must be carried out relative to the current local coordinate system.  Exercise II.12 Review the transformations used to draw the two triangles shown in Fig- ure II.11. Understand how this works from the viewpoint that transformations act on local coordinate systems. Draw a ﬁgure showing all the intermediate local coordinate systems that are implicitly deﬁned by the pseudocode that draws the two triangles.  II.1.8 Two-Dimensional Projective Geometry   cid:1   Projective geometry provides an elegant mathematical interpretation of the homogeneous co- ordinates for points in the x y-plane. In this interpretation, the triples  cid:5 x, y, w cid:6  do not represent points just in the usual ﬂat Euclidean plane but in a larger geometric space known as the projective plane. The projective plane is an example of a projective geometry. A projective geometry is a system of points and lines that satisﬁes the following two axioms:6  P1. Any two distinct points lie on exactly one line. P2. Any two distinct lines contain exactly one common point  i.e., the lines intersect in exactly  one point .  Of course, the usual Euclidean plane, R2, does not satisfy the second axiom since parallel lines do not intersect in R2. However, by adding appropriate “points at inﬁnity” and a “line at inﬁnity,” the Euclidean plane R2 can be enlarged so as to become a projective geometry. In addition, homogeneous coordinates are a suitable way of representing the points in the projective plane.  6 This is not a complete list of the axioms for projective geometry. For instance, it is required that every  line have at least three points, and so on.   II.1 Transformations in 2-Space  33  The intuitive idea of projective plane construction is as follows: for each family of parallel lines in R2, we create a new point, called a point at inﬁnity. This new point is added to each of these parallel lines. In addition, we add one new line: the line at inﬁnity, which contains exactly all the new points at inﬁnity. It is not hard to verify that the axioms P1 and P2 hold.  Consider a line L in Euclidean space R2: it can be speciﬁed by a point u on L and by a  nonzero vector v in the direction of L. In this case, L consists of the set of points  {u + αv : α ∈ R} = { cid:5 u1 + αv1, u2 + αv2 cid:6  : α ∈ R}.  For each value of α, the corresponding point on the line L has homogeneous coordinates  cid:5 u1 α + v1, u2 α + v2, 1 α cid:6 . As α → ∞, this triple approaches the limit  cid:5 v1, v2, 0 cid:6 . This limit is a point at inﬁnity and is added to the line L when we extend the Euclidean plane to the projective plane. If one takes the limit as α → −∞, then the triple  cid:5 −v1,−v2, 0 cid:6  is approached in the limit. This is viewed as being the same point as  cid:5 v1, v2, 0 cid:6  since multiplication by the nonzero scalar −1 does not change the meaning of homogeneous coordinates. Thus, the same point at inﬁnity on the line is found at both ends of the line. Note that the point at inﬁnity,  cid:5 v1, v2, 0 cid:6 , on the line L does not depend on u. If the point u is replaced by some point not on L, then a different line is obtained; this line will be parallel to L in the Euclidean plane, and any line parallel to L can be obtained by appropriately choosing u. Thus, any line parallel to L has the same point inﬁnity as the line L. More formally, the projective plane is deﬁned as follows. Two triples,  cid:5 x, y, w cid:6  and  cid:5 x , and w = αw cid:3   cid:3 , w cid:3  cid:6 , are equivalent if there is a nonzero α ∈ R such that x = αx  cid:3 , y . We write  cid:5 x, y, w cid:6 P to denote the equivalence class containing the triples that are equivalent to  cid:5 x, y, w cid:6 . The projective points are the equivalence classes  cid:5 x, y, w cid:6 P such that at least one of x, y, w is nonzero. A projective point is called a point at inﬁnity if w = 0.  , y = αy   cid:3    cid:3   A projective line is either a usual line in R2 plus a point at inﬁnity, or the line at inﬁnity. Formally, for any triple a, b, c of real numbers, with at least one of a, b, c nonzero, there is a projective line L deﬁned by  L = { cid:5 x, y, w cid:6 P : ax + by + cw = 0, x, y, w not all zero}.  II.5 If at least one of a, b is nonzero, then by considering only the w = 1 case, the line L is the line containing the Euclidean points  cid:5 x, y cid:6  such that ax + by + c = 0. In addition, the line L contains the point at inﬁnity  cid:5 −b, a, 0 cid:6 P. Note that  cid:5 −b, a cid:6  is a Euclidean vector parallel to the line L. The projective line deﬁned with a = b = 0 and c  cid:16 = 0 is the line at inﬁnity; it contains those points  cid:5 x, y, 0 cid:6 P such that x and y are not both zero.   cid:1   Exercise II.13 Another geometric model for the two-dimensional projective plane is provided by the 2-sphere with antipodal points identiﬁed. The 2-sphere is the sphere in R3 that is centered at the origin and has radius 1. Points on the 2-sphere are represented by normalized triples  cid:5 x, y, w cid:6 , which have x 2 + y2 + w2 = 1. In addition, the antipodal points  cid:5 x, y, w cid:6  and  cid:5 −x,−y,−w cid:6  are treated as equivalent. Prove that lines in projective space correspond to great circles on the sphere, where a great circle is deﬁned as the intersection of the sphere with a plane containing the origin. For example, the line at inﬁnity corresponds to the intersection of the 2-sphere with the x y-plane. [Hint: Equation II.5 can be viewed as deﬁning L in terms of a dot product with  cid:5 a, b, c cid:6 .]  Yet another way of mathematically understanding the two-dimensional projective space is to view it as the space of linear subspaces of three-dimensional Euclidean space. To un- derstand this, let x =  cid:5 x1, x2, x3 cid:6  be a homogeneous representation of a point in the pro- jective plane. This point is equivalent to the points αx for all nonzero α ∈ R; these points   34  Transformations and Viewing  plus the origin form a line through the origin in R3. A line through the origin is of course a one-dimensional subspace, and we identify this one-dimensional subspace of R3 with the point x. Now consider a line L in the projective plane. If L is not the line at inﬁnity, then it corresponds to a line in R2. One way to specify the line L is to choose u =  cid:5 u1, u2 cid:6  on L and a vector v =  cid:5 v1, v2 cid:6  in the direction of L. The line L then is the set of points {u + αv : α ∈ R}. It is easy to verify that, after adding the point at inﬁnity, the line L contains exactly the following set of homogeneous points:  {β cid:5 u1, u2, 1 cid:6  + γ cid:5 v1, v2, 0 cid:6  : β, γ ∈ R s.t. β  cid:16 = 0 or γ  cid:16 = 0} .  This set of triples is, of course, a plane in R3 with a hole at the origin. Thus, we can identify this two-dimensional subspace of R3  that is, the plane  with the line in the projective plane. If, on the other hand, L is the line at inﬁnity, then it corresponds in the same way to the two-dimensional subspace { cid:5 x1, x2, 0 cid:6  : x1, x2 ∈ R}.  These considerations give rise to another way of understanding the two-dimensional pro- jective plane. The “points” of the projective plane are one-dimensional subspaces of R3. The “lines” of the projective plane are two-dimensional subspaces of R3. A “point” lies on a “line” if and only if the corresponding one-dimensional subspace is a subset of the two-dimensional subspace.  The historical development of projective geometry arose from the development of the theory of perspective by Brunelleschi in the early ﬁfteenth century. The basic tenet of the theory of perspective for drawings and paintings is that families of parallel lines point toward a common “vanishing point,” which is essentially a point at inﬁnity. The modern mathematical development of projective geometry based on homogeneous coordinates came much later of course through the work of Feuerbach and M¨obius in 1827 and Klein in 1871. Homogeneous coordinates have long been recognized as useful for many computer graphics applications; see, for example, the early textbook  Newman and Sproull, 1979 . An accessible mathematical introduction to abstract projective geometry is the textbook  Coxeter, 1974 .  II.2 Transformations in 3-Space  We turn next to transformations in 3-space. This turns out to be very similar in many respects to transformations in 2-space. There are, however, some new features – most notably, rotations are more complicated in 3-space than in 2-space. First, we discuss how to extend the concepts of linear and afﬁne transformations, matrix representations for transformations, and homoge- neous coordinates to 3-space. We then explain the basic modeling commands in OpenGL for manipulating matrices. After that, we give a mathematical derivation of the rotation matrices needed in 3-space and give a proof of Euler’s theorem.  II.2.1 Moving from 2-Space to 3-Space In 3-space, points, or vectors, are triples  cid:5 x1, x2, x3 cid:6  of real numbers. We denote 3-space by R3 and use the notation x for a point with it being understood that x =  cid:5 x1, x2, x3 cid:6 . The origin, or zero vector, now is 0 =  cid:5 0, 0, 0 cid:6 . As before, we will identify  cid:5 x1, x2, x3 cid:6  with the column vector with the same entries. By convention, we always use a “right-handed” coordinate system, as shown in Figure I.4 on page 6. This means that if you position your right hand so that your thumb points along the x-axis and your index ﬁnger is extended straight and points along the y-axis, your palm will be facing in the positive z-axis direction. It also means that vector cross   u1  u2 u3   .  v1 w1 v2 w2 v3 w3  M =  II.2 Transformations in 3-Space  35  products are deﬁned with the right-hand rule. As discussed in Section I.2.1, it is common in computer graphics applications to visualize the x-axis as pointing to the right, the y-axis as pointing upwards, and the z-axis as pointing toward you. Homogeneous coordinates for points in R3 are vectors of four numbers. The homogeneous coordinates  cid:5 x, y, z, w cid:6  represents the point  cid:5 x w, y w, z w cid:6  in R3. The two-dimensional projective geometry described in Section II.1.8 can be straightforwardly extended to a three- dimensional geometry by adding a “plane at inﬁnity”: each line has a single point at inﬁnity, and each plane has a line of points at inﬁnity  see Section II.2.5 for more on projective geometry .  A transformation on R3 is any mapping from R3 to R3. The deﬁnition of a linear transfor- mation on R3 is identical to the deﬁnition used for R2 except that now the vectors x and y range over R3. Similarly, the deﬁnitions of translation and of afﬁne transformation are word-for-word identical to the deﬁnitions given for R2 except that now the translation vector u is in R3. In particular, an afﬁne transformation is still deﬁned as the composition of a translation and a linear transformation. Every linear transformation A in R3 can be represented by a 3 × 3 matrix M as follows. Let i =  cid:5 1, 0, 0 cid:6 , j =  cid:5 0, 1, 0 cid:6 , and k =  cid:5 0, 0, 1 cid:6 , and let u = A i , v = A j , and w = A k . Set M equal to the matrix  u, v, w , that is, the matrix whose columns are u, v, and w, and thus  II.6  Then Mx = A x  for all x ∈ R3, that is to say, M represents A. In this way, any linear trans- formation of R3 can be viewed as being a 3 × 3 matrix.  Compare this with the analogous construction for R2 explained at the beginning of Section II.1.2.   2 + x3  2 + x2 x1  x · x = √  A rigid transformation is one that preserves the size and shape of an object and changes only its position and orientation. Formally, a transformation A is deﬁned to be rigid provided vector x is equal to x = √ it preserves distances between points and angles between lines. Recall that the length of a 2. An equivalent deﬁnition of rigidity is that a transformation A is rigid if it preserves dot products, that is to say, if A x  · A y  = x · y for all x, y ∈ R3. It is not hard to prove that M =  u, v, w  represents a rigid transformation if and only if u = v = w = 1 and u · v = v · w = u · w = 0. From this, it is straightforward −1 = M T  c.f. Exercises II.5 to show that M represents a rigid transformation if and only if M and II.6 on page 24 . We deﬁne an orientation-preserving transformation to be one that preserves “right- handedness.” Formally, we say that A is orientation-preserving provided that  A u  × A v   · A u × v  > 0 for all noncollinear u, v ∈ R3. By recalling the right-hand rule used to determine the direction of a cross product, you should be able to convince yourself that this deﬁnition makes sense.  Exercise II.14 Let M =  u, v, w  be a 3 × 3 matrix. Prove that det M  is equal to  u × v  · w. Conclude that M represents an orientation-preserving transformation if and only if det M  > 0. Also, prove that if u and v are unit vectors that are orthogonal to each other, then setting w = u × v makes M =  u, v, w  a rigid, orientation-preserving transformation.  Any afﬁne transformation is the composition of a linear transformation and a translation. Since a linear transformation can be represented by a 3 × 3 matrix, any afﬁne transformation can be represented by a 3 × 3 matrix and a vector in R3 representing a translation amount.   36  Transformations and Viewing  That is, any afﬁne transformation can be written as   .    cid:13 →   cid:13 →  y z  x x  y z 1  d e f g h i  u  + x a b c  a b c u  . x  y z  v w  d e f v g h i w 0 0 0 1  y z 1  We can rewrite this using a single 4 × 4 homogeneous matrix that acts on homogeneous coordinates as follows:  This 4 × 4 matrix contains the linear transformation in its upper left 3 × 3 submatrix and the translation in the upper three entries of the last column. Thus, afﬁne transformations can be identiﬁed with 4 × 4 matrices with bottom row  0 0 0 1 . When we study transformations for perspective, we will see some nontrivial uses of the bottom row of a 4 × 4 homogeneous matrix, but for now we are only interested in matrices whose fourth row is  0, 0, 0, 1 .  As mentioned at the beginning of this section, rotations in 3-space are considerably more complicated than in 2-space. The reason for this is that a rotation can be performed about any axis whatsoever. This includes not just rotations around the x-, y- and z-axes but also rotations around an axis pointing in an arbitrary direction. A rotation that ﬁxes the origin can be speciﬁed by giving a rotation axis u and a rotation angle θ, where the axis u can be any nonzero vector. We think of the base of the vector being placed at the origin, and the axis of rotation is the line through the origin parallel to the vector u. The rotation angle θ speciﬁes the magnitude of the rotation. The direction of the rotation is determined by the right-hand rule; namely, if one mentally grasps the vector u with one’s right hand so that the thumb, when extended, is pointing in the direction of the vector u, then one’s ﬁngers will curl around u pointing in the direction of the rotation. In other words, if one views the vector u headon, that is, down the axis of rotation in the opposite direction that u is pointing, then the rotation direction is counterclockwise  for positive values of θ . A rotation of this type is denoted Rθ,u. By convention, the axis of rotation always passes through the origin, and thus the rotation ﬁxes the origin. Figure II.14 on page 37 illustrates the action of Rθ,u on a point v. Clearly, Rθ,u is a linear transformation and is rigid and orientation-preserving.  Section II.2.4 below shows that every rigid, orientation-preserving, linear transformation in 3-space is a rotation. As a corollary, every rigid, orientation-preserving, afﬁne transformation can be  uniquely  expressed as the composition of a translation and a rotation about a line through the origin.  It is of course possible to have rotations about axes that do not pass through the origin.  These are discussed further in Section II.2.4.  II.2.2 Transformation Matrices in OpenGL  OpenGL has several function calls that enable you to conveniently manipulate the model view matrix, which transforms the positions of points speciﬁed with glVertex*. We have already seen much of the functionality of these routines in Section II.1.6, which explains the use of OpenGL matrix transformations in the two-dimensional setting. Actually, OpenGL really operates in three dimensions, although it supports a few two-dimensional functions, such as glVertex2f, which merely set the z-component to zero.  In three dimensions, the following commands are particularly useful for working with the  model view matrix M.   II.2 Transformations in 3-Space  37  v1  θ  Rθ,u v   v  u  0  v3  v2  Figure II.14. The vector v being rotated around u. The vector v1 is v’s projection onto u. The vector v2 is ◦ the component of v orthogonal to u. The vector v3 is v2 rotated 90 around u. The dashed line segments in the ﬁgure all meet at right angles.  First, the command  glMatrixMode GL_MODELVIEW ;  selects the model view matrix as the currently active matrix. Other matrices that can be selected with this command include the projection matrix. The projection matrix and the model view matrix work together to position objects, and Section II.3.5 explains the interaction between these two matrices.  The following four commands provide simple ways to effect modeling transformations. All four commands affect the currently active matrix, which we assume is the matrix M for the sake of discussion.  glLoadIdentity  . Sets M equal to the 4 × 4 identity matrix. glTranslatef  float u1, float u2, float u3  . This command sets M equal to M ◦ Tu, where u =  cid:5 u1, u2, u3 cid:6  and Tu is the transformation that performs a translation by u. The 4 × 4 matrix representation for Tu in homogeneous coordinates is  1 0 0  u1 0 1 0 u2 0 0 1 u3 0 0 0 1   .    1 − c u2  + c  1 − c u1u2 + su3  1 − c u1u3 − su2  1  0  glRotatef float θ, float u1, float u2, float u3 . This sets M equal to M ◦ Rθ,u, where u =  cid:5 u1, u2, u3 cid:6  and, as discussed above, Rθ,u is the transformation that performs a rotation around the axis through the origin in the direction of the vector u. The rotation angle is θ  measured in degrees , and the direction of the rotation is determined by the right-hand rule. The vector u must not equal 0. For the record, if u is a unit vector, then the 4 × 4 matrix representation of Rθ,u in homogeneous coordinates is   1 − c u1u2 − su3  1 − c u2 + c  1 − c u2u3 + su1  2  0   1 − c u1u3 + su2  1 − c u2u3 − su1 + c  1 − c u2 0  3   ,  0 0 0 1  II.7   38  Transformations and Viewing where c = cos θ and s = sin θ. OpenGL does not require that u be passed in as a unit vector: OpenGL will automatically compute the normalization of u in order to compute the rotation matrix. The formula II.7 for Rθ,u will be derived below in Section II.2.3. glScalef float α1, float α2, float α3 . This command scales the x-, y-, z-coordinates of points independently. That is to say, it sets M = M ◦ S, where S is the matrix  α1  0 0  0 0 α2 0 0  0 0 0 α3 0 1 0  0   .  The matrix S will map  cid:5 x1, x2, x3, 1 cid:6  to  cid:5 α1x1, α2x2, α3x3, 1 cid:6 , so it allows scaling inde- pendently in each of the x-, y-, and z-directions.  OpenGL does not have any special function calls for reﬂections or shearing transformations. A reﬂection transformation is a transformation that transforms points to their “mirror image” across some plane, as illustrated in Figure II.16 on page 43. Reﬂections across the coordinate planes can easily be done with glScalef. For example,  glScalef -1.0, 1.0, 1.0 ;  performs a reﬂection across the yz-plane by negating the x-coordinate of a point. A shearing transformation is a more complicated kind of transformation; some two-dimensional examples include the transformation A3 of Exercise II.1 and the transformation shown in Figure II.3. In principle, one can use glScalef in combination with rotations and translations to perform arbitrary reﬂections and shearing transformations. In practice, this is usually more trouble than it is worth. Instead, you can just explicitly give the components of a 4 × 4 matrix that perform any desired afﬁne transformation. For example, the formulas from Exercises II.18 and II.19 below can be used to get the entries of a 4 × 4 matrix that carries out a reﬂection. OpenGL includes the following two commands that allow you to use any homogeneous 4 × 4 matrix you wish. Both of these commands take 16 ﬂoating point numbers as inputs and create a 4 × 4 homogeneous matrix with these components. The elements of the matrix are given in column order!  entries the 16 numbers pointed to by matEntries.  glLoadMatrixf  float* matEntries  . This initializes M to be the matrix with glMultMatrixf  float* matEntries  . This sets M equal to M · M  cid:3  is the matrix with entries equal to the 16 values pointed to by matEntries.  , where M   cid:3   The variable matEntries can have its type deﬁned by any one of the following lines:  float* matEntries;  float matEntries[16];  float matEntries[4][4];  In the third case, if one lets i and j range from 0 to 3, the entry in row i and column j is the value matEntries[j][i]. The indices i and j are reversed from what might normally be expected because the entries are speciﬁed in column order.  Solar System Examples in OpenGL. The Solar program contains some examples of using OpenGL’s modeling transformations. This program creates a simple solar system with a central sun, a planet revolving around the sun every 365 days, and a moon revolving   II.2 Transformations in 3-Space  39  around the planet 12 times per year. In addition, the planet rotates on its axis once per day, that is, once per 24 hours. The program uses a combination of rotations and translations. In addition, it uses glPushMatrix and glPopMatrix to save and restore the model view matrix so as to isolate the transformations used to rotate the planet on its axis from the transformations used to position the moon as it revolves around the planet.  The central part of the Solar program code is as follows:     Choose and clear Modelview matrix glMatrixMode GL_MODELVIEW ; glLoadIdentity  ;    Move 8 units away to be able to view from the origin. glTranslatef 0.0, 0.0, -8.0 ;    Tilt system 15 degrees downward in order to view    glRotatef 15.0, 1.0,0.0,0.0 ;  from above the xy-plane.     Draw the sun -- as a yellow, wireframe sphere glColor3f  1.0, 1.0, 0.0  ; glutWireSphere  0.8, 15, 15  ;     Radius = 0.8 units.     Draw the Earth    First position it around the sun    Use DayOfYear to determine its position glRotatef  360.0*DayOfYear 365.0, 0.0, 1.0, 0.0  ; glTranslatef  4.0, 0.0, 0.0  ;    Second, rotate the earth on its axis.    Use HourOfDay to determine its rotation. glPushMatrix  ; glRotatef  360.0*HourOfDay 24.0, 0.0, 1.0, 0.0  ;    Third, draw as a blue, wireframe sphere. glColor3f  0.2, 0.2, 1.0  ; glutWireSphere  0.4, 10, 10 ; glPopMatrix  ;     Save matrix state     Restore matrix state     Draw the moon.    Use DayOfYear to control its rotation around the earth glRotatef  360.0*12.0*DayOfYear 365.0, 0.0, 1.0, 0.0  ; glTranslatef  0.7, 0.0, 0.0  ; glColor3f  0.3, 0.7, 0.3  ; glutWireSphere  0.1, 5, 5  ;  The complete code for Solar.c can be found with the software accompanying this book.  The code fragment draws wireframe spheres with commands  glutWireSphere  radius, slices, stacks  ;  The value of radius is the radius of the sphere. The integer values slices and stacks control the number of “wedges” and horizontal “stacks” used for the polygonal model of the sphere. The sphere is modeled with the “up” direction along the z-axis, and thus “horizontal” means parallel to the x y-plane.   40  color.  Transformations and Viewing  The glColor3f red, green, blue  commands are used to set the current drawing  The solar program code starts by specifying the ModelView matrix, M, as the current matrix and initializes it to the identity. The program then right multiplies M with a translation of −8 units in the z-direction and thereafter performs a rotation of 15 around the x-axis. This has the effect of centering the solar system at  cid:5 0, 0,−8 cid:6  with a small tilt, and so it is viewed from slightly above. The viewpoint, or camera position, is placed at the origin, looking down the negative z-axis.  ◦  The sun is drawn with glutWireSphere. This routine draws the wireframe sphere, is- suing glVertex* commands for a sphere centered at the origin. Of course, the sphere is actually drawn centered at  cid:5 0, 0,−8 cid:6  because the position is transformed by the contents of the M matrix.  To draw the Earth and its moon, another glRotatef and glTranslatef are performed. These translate the Earth system away from the sun and revolve it around the sun. The angle of rotation depends on the day of the year and is speciﬁed in degrees. A further glRotatef rotates the Earth on its axis. This rotation is bracketed by commands pushing M onto the ModelView matrix stack and then restoring it with a pop. This prevents the rotation of the Earth on its axis from affecting the position of the moon. Finally, a glRotatef and glTranslatef control the position of the moon around the Earth.  To understand the effect of the rotations and translations on an intuitive level, you should think of their being applied in the reverse order of how they appear in the program. Thus, the moon can be thought of as being translated by  cid:5 0.7, 0, 0 cid:6 , then rotated through an angle based on the day of the year  with exactly 12 months in a year , then translated by  cid:5 4, 0, 0 cid:6 , then rotated by an angle that depends on the day of the year again  one revolution around the around the x-axis, and ﬁnally translated by  cid:5 0, 0,−8 cid:6 . ◦ sun every 365 days , then rotated 15 That is, to see the order in which the transformations are logically applied, you have to read backward through the program, being sure to take into account the effect of matrix pushes and pops.  Exercise II.15 Review the Solar program and understand how it works. Try making some of the following extensions to create a more complicated solar system.  a. Add one or more planets. b. Add more moons. Make a geostationary moon, which always stays above the same point on the planet. Make a moon with a retrograde orbit.  A retrograde orbit means the moon revolves opposite to the usual direction, that is, in the clockwise direction instead of counterclockwise.   c. Give the moon a satellite of its own. d. Give the planet and its moon s  a tilt. The tilt should be in a ﬁxed direction. This is similar to the tilt of the Earth, which causes the seasons. The tilt of the Earth is always in the direction of the North Star, Polaris. Thus, during part of a year, the Northern Hemisphere tilts toward the sun, and during the rest of the year, the Northern Hemisphere tilts away from the sun.  e. Change the length of the year so that the planet revolves around the sun once every 365.25 days. Be sure not to introduce any discontinuities in the orientation of the planet at the end of a year.  f. Make the moon rotate around the planet every 29 days. Make sure there is no disconti-  nuity in the moon’s position at the end of a year.   II.2 Transformations in 3-Space  v3   cos θ v2 +  sin θ v3  41  θ  v2  0 Figure II.15. The vector v2 being rotated around u. This is the same situation as shown in Figure II.14 but viewed looking directly down the vector u.  II.2.3 Derivation of the Rotation Matrix  This section contains the mathematical derivation of Formula II.7 for the matrix representing a rotation, Rθ,u, through an angle θ around axis u. Recall that this formula was  1 − c u1u3 + su2 0  1 − c u2u3 − su1 0  1 − c u2 0 0 1  + c  1 − c u1u2 + su3  1 − c u1u3 − su2   1 − c u1u2 − su3  1 − c u2 + c  1 − c u2u3 + su1    1 − c u2   ,  Rθ,u =  + c  II.7  0  0  3  1  2  where c = cos θ and s = sin θ. The vector u must be a unit vector. There is no loss of generality in assuming that u is a unit vector since if not, it may be normalized by dividing by u. To derive the matrix for Rθ,u, let v be an arbitrary point and consider what w = Rθ,uv is equal to. For this, we split v into two components, v1 and v2 so that v = v1 + v2 with v1 parallel to u and v2 orthogonal to u. The vector v1 is the projection of v onto the line of u and is equal to v1 =  u · v u since the dot product u · v is equal to u · v cos ϕ  where ϕ is the angle between u and v, and since u = 1.  Refer to Figure II.14 on page 37.  We rewrite this as  v1 =  u · v u = u u · v  = u uTv  =  uuT v.  The equation above uses the fact that a dot product u · v can be rewritten as a matrix product uTv  recall that our vectors are all column vectors  and that matrix multiplication is associative. The product uuT is the symmetric 3 × 3 matrix    u1 u2 u3  =   u2  u1  u2 u3  u1u2 u1u3 1 u2 u2u3 u1u2 2 u2 u1u3 u2u3 3   .  = uuT =  Proju  Since v = v1 + v2, we therefore have  v1 = Projuv  and  v2 =  I − Proju v,  where I is the 3 × 3 identity matrix.  We know that Rθ,uv1 = v1 because v1 is a scalar multiple of u and is not affected by a  rotation around u. To compute Rθ,uv2, we further deﬁne v3 to be the vector  v3 = u × v2 = u × v.  The second equality holds since v and v2 differ by a multiple of u. The vector v3 is orthogonal to both u and v2. Furthermore, because u is a unit vector orthogonal to v2, v3 has the same magnitude as v2. That is to say, v3 is equal to the rotation of v2 around the axis u through   Transformations and Viewing  . Figure II.15 shows a view of v2 and v3 oriented straight down the u axis of an angle of 90 rotation. From the ﬁgure, it is obvious that rotating v2 through an angle of θ around u results in the vector  II.8  42  ◦   cos θ v2 +  sin θ v3. Therefore, Rθ,uv is equal to  Rθ,uv = Rθ,uv1 + Rθ,uv2  = v1 +  cos θ v2 +  sin θ v3 = Projuv +  cos θ  I − Proju v +  sin θ  u × v .  To ﬁnish deriving the matrix for Rθ,u, we deﬁne the matrix   0 −u3 u2  0 −u1 0  u3 −u2 u1    Mu× =  and see, by a simple calculation, that  Mu× v = u × v holds for all v. From this, it is immediate that  Rθ,uv = [Proju  +  cos θ  I − Proju  +  sin θ Mu×]v +  cos θ I +  sin θ Mu× ]v.  = [ 1 − cos θ Proju  The quantity inside the square brackets is a 3 × 3 matrix, and so this completes the derivation of the matrix representation of Rθ,u. An easy calculation shows that this corresponds to the representation given earlier  in homogeneous form  by Equation II.7.  Exercise II.16 Carry out the calculation to show that the formula for Rθ,u above is equivalent to the formula in Equation II.7.   cid:1   Let u, v and w be orthogonal unit vectors with w = u × v. Prove that  Exercise II.17 Rθ,u is represented by the following 3 × 3 matrix:  uuT +  cos θ  vvT + wwT  +  sin θ  wvT − vwT .  It is also possible to convert a rotation matrix back into a unit rotation vector u and a rotation angle θ. For this, refer back to Equation II.7. Suppose we are given such a 4 × 4 rotation matrix M =  mi, j  i, j so that the entry in row i and column j is mi, j . The sum of the ﬁrst three entries on the diagonal of M  that is, the trace of the 3 × 3 submatrix representing the rotation  is equal to  m1,1 + m2,2 + m3,3 =  1 − c  + 3c = 1 + 2c  since u2 1  + u2  2  + u2  3  = 1. Thus, cos θ =  m1,1 + m2,2 + m3,3 − 1  2, or  where α = m1,1 + m2,2 + m3,3 − 1. Letting s = sin θ, we can determine u’s components from  II.9  θ = arccos α 2 , u1 = m3,2 − m2,3 u2 = m1,3 − m3,1 u3 = m2,1 − m1,2  2s  2s  2s  .   II.2 Transformations in 3-Space  43  y  u  P  x  Figure II.16. Reﬂection across the plane P. The vector u is the unit vector perpendicular to the plane. A reﬂection maps a point to its mirror image across the plane. The point x is mapped to the point y directly across the plane and vice versa. Each F is mapped to the mirror image F.  The preceding method of computing θ and u from M will have problems with stability if θ is very close to 0 since, in that case, sin θ ≈ 0, and thus the determination of the values of ui requires dividing by values near zero. The problem is that dividing by a near-zero value tends to introduce unstable or inaccurate results, because small roundoff errors can have a large effect on the results of the division.  Of course, if θ, and thus sin θ, are exactly equal to zero, the rotation angle is zero and any vector u will work. Absent roundoff errors, this situation occurs only if M is the identity matrix.  To mitigate the problems associated with dividing by a near-zero value, one should instead  compute β =   cid:19   m3,2 − m2,3 2 +  m1,3 − m3,1 2 +  m2,1 − m1,2 2.  Note that β will equal 2s = 2 sin θ because dividing by 2s in Equations II.9 was what was needed to normalize the vector u. If β is zero, then the rotation angle θ is zero and, in this case, u may be an arbitrary unit vector. If β is nonzero, then  u1 =  m3,2 − m2,3  β u2 =  m1,3 − m3,1  β u3 =  m2,1 − m1,2  β.  θ = atan2  β, α .  This way of computing u makes it more likely that a  nearly  unit vector will be obtained for u when the rotation angle θ is near zero. From α and β, the angle θ can be computed as  This is a more robust way to compute θ than using the arccos function.  For an alternate, and often better, method of representing rotations in terms of 4-vectors,  see the parts of Section XII.3 on quaternions  pages 298–307 .   cid:1   Exercise II.18 A plane P containing the origin can be speciﬁed by giving a unit vector u that is orthogonal to the plane. That is, let P = {x ∈ R3 : u · x = 0}. A reﬂection across P is the linear transformation that maps each point x to its “mirror image” directly across P, as illustrated in Figure II.16. Prove that, for a plane containing the origin, this reﬂection is represented by the 3 × 3 matrix I − 2uuT. Write out this matrix in component form too. [Hint: If v = v1 + v2, as in the derivation of the rotation matrix, the reﬂection maps v to v2 − v1.]   44   cid:1   Transformations and Viewing Now let P be the plane {x ∈ R3 : u · x = a} for some unit vector u and Exercise II.19 scalar a, where P does not necessarily contain the origin. Derive the 4 × 4 matrix that represents the transformation reﬂecting points across P. [Hint: This is an afﬁne transfor- mation. It is the composition of the linear map from Exercise II.18 and a translation.]  II.2.4 Euler’s Theorem  A fundamental fact about rigid orientation-preserving linear transformations is that they are always equivalent to a rotation around an axis passing through the origin.  Theorem II.5 If A is a rigid, orientation-preserving linear transformation of R3, then A is the same as some rotation Rθ,v.  Proof The idea of the proof is similar to the proof of Theorem II.4, which showed that every rigid, orientation-preserving afﬁne transformation is either a generalized rotation or a trans- lation. However, now we consider the action of A on points on the unit sphere instead of on points in the plane.   cid:3    cid:3   be the image of L under A and let C  around the unit sphere. Let L . Suppose that L = L  cid:3   Since A is rigid, unit vectors are mapped to unit vectors. So, A maps the unit sphere onto itself. In fact, it will sufﬁce to show that A maps some point v on the unit sphere to itself, for if v is a ﬁxed point, then A ﬁxes the line through the origin containing v. The rigidity and orientation-preserving properties then imply that A is a rotation around this line because the action of A on v and on a vector perpendicular to v determines all the values of A. Assume that A is not the identity map. First, note that A cannot map every point u on the unit sphere to its antipodal point −u; otherwise, A would not be orientation-preserving. Therefore, there is some unit vector u0 on the sphere such that A u0   cid:16 = −u0. Fix such a point, and let u = A u0 . If u = u0, we are done; so suppose u  cid:16 = u0. Let C be the great circle containing both u0 and u and let L be the shorter portion of C connecting u0 to u, that is, L is spanning ◦ be the great less than 180 circle containing L , that is, that A maps this line to itself. In this case, rigidity implies that A maps u to u0. Then, rigidity further implies that the point v midway between u0 and u is a ﬁxed point of A, and so A is a rotation around v. make an angle of θ with the great circle C, as shown in Figure II.17. Since L  cid:16 = L  cid:3  2, be the great circle perpendicular to L at u0, respectively at u. Let C3 be C2 rotated an angle of −θ 2 around  cid:3   cid:3  the vector u0, and let C 3 intersect at a 3 be C point v equidistant from u0 and u. Furthermore, by rigidity considerations and the deﬁnition  cid:3  3 and v is a ﬁxed point of A. Thus, A is a rotation around the vector v.  cid:1  of θ, A maps C3 to C θ,u that performs a rotation through angle θ around the line L, where L is the line that contains the point v and is parallel to u. However, unlike the situation for 2-space  see Theorem II.4 , it is not the case that every rigid, orientation-preserving afﬁne transformation in 3-space is equivalent to either a translation or a generalized rotation of this type. Instead, we need a more general notion of “glide rotation” that incorporates a screwlike motion. For example, consider a transformation that both rotates around the y-axis and translates along the y-axis.   cid:3  2 rotated an angle of θ 2 around u. Then C3 and C  One can deﬁne a generalized rotation in 3-space to be a transformation Rv  Otherwise, suppose L  cid:16 = L  , we have −180  . Let C2, respectively C  ◦ < θ < 180  . Let L  ◦   cid:3    cid:3    cid:3    cid:3   A glide rotation is a mapping that can be expressed as a translation along an axis u composed  with a rotation Rv  θ,u around the line that contains v and is parallel to u.   cid:1   Exercise II.20 Prove that every rigid, orientation-preserving afﬁne transformation is a glide rotation. [Hint: First consider A’s action on planes and deﬁne a linear transfor- mation B as follows: let r be a unit vector perpendicular to a plane P and deﬁne B r    II.2 Transformations in 3-Space  45  C3   cid:1  C 3  C2  θ 2  u0  C  v  L   cid:1  C2  θ 2   cid:1  L  θ  u   cid:1   C  Figure II.17. Finding the axis of rotation. We have u = A u0  and v = A v . Compare this with Figure II.8.  to be the unit vector perpendicular to the plane A P . The transformation B is a rigid, orientation-preserving map on the unit sphere. Furthermore, B r  = A r  − A 0 , and so B is a linear transformation. By Euler’s theorem, B is a rotation. Let w be a unit vector ﬁxed by B and Q be the plane through the origin perpendicular to w, and thus A Q  is parallel to Q. Let C be a transformation on Q deﬁned by letting C x  be the value of A x  projected onto Q. Then C is a two-dimensional, generalized rotation around a point v in the plane Q.  Why?  From this, deduce that A has the desired form.]  II.2.5 Three-Dimensional Projective Geometry   cid:1   Three-dimensional projective geometry can be developed analogously to the two-dimensional geometry discussed in Section II.1.8, and three-dimensional projective space can be viewed either as the usual three-dimensional Euclidean space augmented with points at inﬁnity or as the space of linear subspaces of the four-dimensional R4. We ﬁrst consider how to represent three-dimensional projective space as R3 plus points at inﬁnity. The new points at inﬁnity are obtained as follows: let F be a family of parallel lines  i.e., let F be the set of lines parallel to a given line L, where L is a line in R3 . We have a new point at inﬁnity, uF , and this point is added to every line in F. The three-dimensional projective space consists of R3 plus these new points at inﬁnity. Each plane P in R3 gets a new line of points at inﬁnity in the projective space, namely, the points at inﬁnity that belong to the   46  Transformations and Viewing  lines in the plane P. The set of lines of the projective space are  a  the lines of R3  including their new point at inﬁnity , and  b  the lines at inﬁnity that lie in a single plane. Finally, the set of all points at inﬁnity forms the plane at inﬁnity.  You should check that, in three-dimensional projective space, any two distinct planes inter-  sect in a unique line.  Three-dimensional projective space can also be represented by linear subspaces of the four- dimensional space R4. This corresponds to the representation of points in R3 by homogeneous coordinates. A point in the projective space is equal to a one-dimensional subspace of R4, namely, a set of points of the form {αu : α ∈ R} for u a ﬁxed nonzero point of R4. The 4-tuple u is just a homogeneous representation of a point; if its fourth component  w-component  is zero, then the point is a point at inﬁnity. The lines in projective space are just the two-dimensional subspaces of R4. A line is a line at inﬁnity if and only if all its 4-tuples have zero as fourth component. The planes in projective space are precisely the three-dimensional subspaces of R4.  Exercise II.21 Work out the correspondence between the two ways of representing three- dimensional projective space.  OpenGL and other similar systems use 4-tuples as homogeneous coordinates for points in 3- space extensively. In OpenGL, the function call glVertex4f a,b,c,d  is used to specify a point  cid:5 a, b, c, d cid:6  in homogeneous coordinates. Of course, it is more common for a programmer to specify a point with only three  nonhomogeneous  coordinates, but then, whenever a point in 3-space is speciﬁed by a call to glVertex3f a,b,c , OpenGL translates this to the point  cid:5 a, b, c, 1 cid:6 .  However, OpenGL does not usually deal explicitly with points at inﬁnity  although there are some exceptions, namely, deﬁning B´ezier and B-spline curves . Instead, points at inﬁnity are typically used for indicating directions. As we will see later, when a light source is given a position, OpenGL interprets a point at inﬁnity as specifying a direction. Strictly speaking, this is not a mathematically correct use of homogeneous coordinates, since taking the negative of the coordinates does not yield the same result but instead indicates the opposite direction for the light.  II.3 Viewing Transformations and Perspective  So far, we have used afﬁne transformations as a method for placing geometric models of objects in 3-space. This is represented by the ﬁrst stage of the rendering pipeline shown in Figure II.1 on page 18. In this ﬁrst stage, points are placed in 3-space controlled by the model view matrix. We now turn our attention to the second stage of the pipeline. This stage deals with how the geometric model in 3-space is viewed; namely, it places the camera or eye with a given position, view direction, and ﬁeld of view. The placement of the camera or eye position determines what parts of the 3-D model will be visible in the ﬁnal graphics image. Of course, there is no actual camera; it is only virtual. Instead, transformations are used to map the geometric model in 3-space into the x y-plane of the ﬁnal image. Transformations used for this purpose are called viewing transformations. Viewing transformations include not only the afﬁne transformations discussed earlier but also a new class of “perspective transformations.”  To understand the purposes and uses of viewing transformations properly, it is necessary to consider the end result of the rendering pipeline  Figure II.1 . The ﬁnal output of the rendering pipeline is usually a rectangular array of pixels. Each pixel has an x y-position in the graphics image. In addition, each pixel has a color or grayscale value. Finally, it is common for each pixel to store a “depth value” or “distance value” that measures the distance to the object visible in that pixel.   II.3 Viewing Transformations and Perspective  47  Storing the depth is important because it is used by the hidden surface algorithm. When a scene is rendered, there may be multiple objects that lie behind a given pixel. As the objects are drawn onto the screen, the depth value, or distance, to the relevant part of the object is stored into each pixel location. By comparing depths, one can determine whether an object is in front of another object and thereby that the more distant object, being hidden behind the closer object, is not visible.  The use of the depth values is discussed more in Section II.4, but for now it is enough for us to keep in mind that it is important to keep track of the distance of objects from the camera position.  Stages 2 and 3 of the rendering pipeline are best considered together. These two stages are largely independent of the resolution of the screen or other output device. During the second stage, vertices are mapped by a 4 × 4 afﬁne matrix into new homogeneous coordinates  cid:5 x, y, z, w cid:6 . The third stage, perspective division, further transforms these points by converting them back to points in R3 by the usual map  cid:5 x, y, z, w cid:6   cid:13 →  cid:5 x w, y w, z w cid:6 .  The end result of the second and third stages is that they map the viewable objects into the 2 × 2 × 2 cube centered at the origin, which contains the points with−1 ≤ x ≤ 1,−1 ≤ y ≤ 1, and−1 ≤ z ≤ 1. This cube will be mapped by simple rectangular scaling into the ﬁnal graphics image during stage 4 of the rendering pipeline. The points with x = 1  respectively, x = −1  are to be at the right  respectively, left  side of the screen or ﬁnal image, and points with y = 1  respectively, y = −1  are at the top  respectively, bottom  of the screen. Points with z = 1 are closest to the viewer, and points with z = −1 are farthest from the viewer.7  There are two basic kinds of viewing transformations: orthographic projections and per- spective transformations. An orthographic projection is analagous to placing the viewer at an inﬁnite distance  with a suitable telescope . Thus, orthographic projections map the geometric model by projecting at right angles onto a plane perpendicular to the view direction. Perspec- tive transformations put the viewer at a ﬁnite position, and perspective makes closer objects appear larger than distant objects of the same size. The difference between orthographic and perspective transformations is illustrated in Figure II.18.  To simplify the deﬁnitions of orthographic and perspective transformations, it is convenient to deﬁne them only for a viewer who is placed at the origin and is looking in the direction of the negative z-axis. If the viewpoint is to be placed elsewhere or directed elsewhere, ordinary afﬁne transformations can be used to adjust the view accordingly.  II.3.1 Orthographic Viewing Transformations  Orthographic viewing transformations carry out a parallel projection of a 3-D model onto a plane. Unlike the perspective transformations described later, orthographic viewing projections do not cause closer objects to appear larger and distant objects to appear smaller. For this reason, orthographic viewing projections are generally preferred for applications such as architecture or engineering applications, including computer-aided design and manufacturing  CAD CAM  since the parallel projection is better at preserving relative sizes and angles.  7 OpenGL uses the reverse convention on z with z = −1 for the closest objects and z = 1 for the farthest objects. Of course, this is merely a simple change of sign of the z component, but OpenGL’s convention seems less intuitive because the transformation into the 2 × 2 × 2 cube is no longer orientation-preserving. Since the OpenGL conventions are hidden from the programmer in most situations anyway, we will instead adopt the more intuitive convention.   48  Transformations and Viewing  Figure II.18. The cube on the left is rendered with an orthographic projection, and the one on the right with a perspective transformation. With the orthographic projection, the rendered size of a face of the cube is independent of its distance from the viewer; compare, for example, the front and back faces. Under a perspective transformation, the closer a face is, the larger it is rendered.  For convenience, orthographic projections are deﬁned in terms of an observer who is at the origin and is looking down the z-axis in the negative z-direction. The view direction is perpendicular to the x y-plane, and if two points differ in only their z-coordinate, then the one with higher z-coordinate is closer to the viewer.  An orthographic projection is generally speciﬁed by giving six axis-aligned “clipping planes,” which form a rectangular prism. The geometry that lies inside the rectangular prism is scaled to have dimensions 2 × 2 × 2 and translated to be centered at the origin. The rectan- gular prism is speciﬁed by six values  cid:11 , r, b, t, n, and f . These variable names are mnemonics for “left,” “right,” “bottom,” “top,” “near,” and “far,” respectively. The rectangular prism then consists of the points  cid:5 x, y, z cid:6  such that   cid:11  ≤ x ≤ r, b ≤ y ≤ t, and n ≤ −z ≤ f.  The −z has a negative sign because of the convention that the viewer is looking down the z-axis facing in the negative z-direction. This means that the distance of a point  cid:5 x, y, z cid:6  from the viewer is equal to −z. The usual convention is for n and f to be positive values; however, this is not actually required. The plane z = −n is called the near clipping plane, and the plane z = − f is called the far clipping plane. Objects closer than the near clipping plane or farther than the far clipping plane will be culled and not be rendered. The orthographic projection must map points from the rectangular prism into the 2 × 2 × 2 cube centered at the origin. This consists of  1  scaling along the coordinate axes and  2  translating so that the cube is centered at the origin. It is not hard to verify that this is accomplished by the following 4 × 4 homogeneous matrix:    2 r −  cid:11  0  0  0   .  −r +  cid:11  r −  cid:11  − t + b t − b f + n f − n 1  2 t − b 0  0  0  0  0  2 f − n 0  II.10   II.3 Viewing Transformations and Perspective  49  Viewscreen plane z = −d  Vertex  cid:1 x, y, z cid:2    cid:1  d · x z, d · y z,− − d cid:2   −  x  0  z  Figure II.19. Perspective projection onto a viewscreen at distance d. The viewer is at the origin looking in the direction of the negative z-axis. The point  cid:5 x, y, z cid:6  is perspectively projected onto the plane z = −d, which is at distance d in front of the viewer at the origin.  II.3.2 Perspective Transformations  Perspective transformations are used to create the view when the camera or eye position is placed at a ﬁnite distance from the scene. The use of perspective means that an object will appear larger as it moves closer to the viewer. Perspective is useful for giving the viewer the sense of being “in” a scene because a perspective view shows the scene from a particular viewpoint. Perspective is heavily used in entertainment applications, where it is desired to give an immersive experience; it is particularly useful in dynamic situations in which the combination of motion and correct perspective gives a strong sense of the three-dimensionality of the scene. Perspective is also used in applications as diverse as architectural modeling and crime recreation to show the view from a particular viewpoint.  As was mentioned in Section II.1.8, perspective was originally discovered for applications in drawing and painting. An important principle in the classic theory of perspective is the notion of a “vanishing point” shared by a family of parallel lines. An artist who is incorporating perspective in a drawing will choose appropriate vanishing points to aid the composition of the drawing. In computer graphics applications, we are able to avoid all considerations of vanishing points and similar factors. Instead, we place objects in 3-space, choose a viewpoint  camera position , and mathematically calculate the correct perspective transformation to create the scene as viewed from the viewpoint. For simplicity, we consider only a viewer placed at the origin looking down the negative z-axis. We mentally choose as a “viewscreen” the plane z = −d, which is parallel to the x y-plane at distance d from the viewpoint at the origin. Intuitively, the viewscreen serves as a display screen onto which viewable objects are projected. Let a vertex in the scene have position  cid:5 x, y, z cid:6 . We form the line from the vertex position to the origin and calculate the point  cid:5 x  cid:3  cid:6  where the line intersects the viewscreen  see Figure II.19 . Of course, we have  cid:3  = −d. Referring to Figure II.19 and arguing on the basis of similar triangles, we have z   cid:3 , y  cid:3 , z  cid:3  = d · x−z   cid:3    cid:3   x  The values x at the origin.  and   cid:3  = d · y−z  y  .  , y  give the position of the vertex as seen on the viewscreen from the viewpoint  So far, projective transformations have been very straightforward, but now it is necessary to incorporate also the “depth” of the vertex, that is, its distance from the viewer. The obvious ﬁrst  II.11   50  Transformations and Viewing  Plane z = −d   cid:1  A = A  B   cid:1   B  0  z   cid:1   C = C  x  Figure II.20. The undesirable transformation of a line to a curve. The mapping used is  cid:5 x, y, z cid:6   cid:13 →  cid:5 −d · x z,−d · y z, z cid:6 . The points A and C are ﬁxed by the transformation, and B is mapped to B . The dotted curve is the image of the line segment AC.  The small unlabeled circles show the images of A and B under the mapping of Figure II.19.  attempt would be to use the value −z for the depth. Another, albeit less appealing, possibility x 2 + y2 + z2 as the depth. Both of these ideas, however, would be to record the true distance fail to work well. The reason is that, if perspective mappings are deﬁned with a depth speciﬁed in either of these ways, then lines in the three-dimensional scene can be mapped to curves in the viewscreen space. That is, a line of points with coordinates x, y, z, will map to a curve that is not a line in the viewscreen space.   cid:20    cid:3   An example of how a line can map to a curve is shown in Figure II.20. For this ﬁgure, we  use the transformation  x  cid:13 → d · x−z  y  cid:13 → d · y−z  z  cid:13 → z  II.12  so that the z-coordinate directly serves a measure of depth.  Since the viewpoint is looking down the negative z-axis, greater values of z correspond to closer points.  In Figure II.20, , and we see points A, B, and C that are mapped by Transformation II.12 to points A and C = C  cid:3  . C  cid:3  However, the point B is mapped to the point B to C . Thus, the image of the line segment is not straight.  . Obviously, A and C are ﬁxed points of the transformation, and thus A = A  , which is not on the line segment from A  , B  cid:3    cid:3    cid:3    cid:3    cid:3    cid:3   One might question at this point why it is undesirable for lines to map to curves. The answer to this question lies in the way the fourth stage of the graphics-rendering pipeline works. In the fourth stage, the endpoints of a line segment are used to place a line in the screen space. This line in screen space typically has not only a position on the screen but also depth  distance  values stored in a depth buffer.8 When the fourth stage processes a line segment, say as shown as points  cid:5 x A, yA, z A cid:6  and  cid:5 xC , yC , zC cid:6 . in Figure II.20, it is given only the endpoints A It then uses linear interpolation to determine the rest of the points on the line segment. This then gives an incorrect depth to intermediate points such as B . With incorrect depth values, the hidden surface algorithm can fail in dramatically unacceptable ways since the depth buffer values are used to determine which points are in front of other points.  and C   cid:3    cid:3    cid:3   Thus, we need another way to handle depth information. In fact, it is enough to ﬁnd a deﬁnition of a “fake” distance or a “pseudo-distance” function that has the following two  8 Other information, such as color values, is also stored along with depth, but this does not concern the  present discussion.   II.3 Viewing Transformations and Perspective  51  properties:  1. The pseudo-distance preserves relative distances, and 2. It causes lines to map to lines.  As it turns out, a good choice for this pseudo-distance is any function of the form  pseudo-dist z  = A + B z,  where A and B are constants such that B < 0. Since B < 0, property 1 certainly holds because pseudo-dist z1  < pseudo-dist z2  holds whenever z1 < z2. It is a common convention to choose the values for A and B so that points on the near and far clipping planes have pseudo-distances equal to +1 and −1, respectively. The near and far clipping planes have z = −n and z = − f , and so we need the following:  pseudo-dist −n  = A − B n = 1 pseudo-dist − f   = A − B  f = −1.  Solving these two equations for A and B yields  A = −  f + n  f − n  and  B = −2 f n f − n  .  II.13  II.15  Before discussing property 2, it is helpful to see how this deﬁnition of the pseudo-distance function ﬁts into the framework of homogeneous representation of points. With the use of the pseudo-dist function, the perspective transformation becomes the mapping   cid:5 x, y, z cid:6   cid:13 →  cid:5 −d · x z,−d · y z, A + B z cid:6 . We can rewrite this in homogeneous coordinates as  cid:5 x, y, z, 1 cid:6   cid:13 →  cid:5 d · x, d · y,−A · z − B,−z cid:6   II.14 since multiplying through by  −z  does not change the point represented by the homogeneous coordinates. More generally, because the homogeneous representation cid:5 x, y, z, w cid:6  is equivalent to  cid:5 x w, y w, z w, 1 cid:6 , the mapping II.14 acting on this point is   cid:5 x w, y w, z w, 1 cid:6   cid:13 →  cid:5 d · x w, d · y w, − A ·  z w  − B, − z w cid:6 ,  and, after multiplying both sides by w, this becomes   cid:5 x, y, z, w cid:6   cid:13 →  cid:5 d · x, d · y, −  A · z + B · w , − z cid:6 .  Thus, we have established that the perspective transformation incorporating the pseudo-dist function is represented by the following 4 × 4 homogeneous matrix:   d  0 0 0   .  0 0 0 0 0 d 0 −A −B 0 −1 0  That the perspective transformation based on pseudo-distance can be expressed as a 4 × 4 matrix has two unexpected beneﬁts. First, homogeneous matrices provide a uniform framework for representing both afﬁne and perspective transformations. Second, in Section II.3.3, we prove the following theorem: Theorem II.6 The perspective transformation represented by the 4 × 4 matrix II.15 maps lines to lines.   Transformations and Viewing  52  e c n a t s i d - o d u e s P  1  −1  n  f  Distance  −z    Figure II.21. Pseudo-distance varies nonlinearly with distance. Larger pseudo-distance values correspond to closer points.  In choosing a perspective transformation, it is important to select values for n and f , the near and far clipping plane distances, so that all the desired objects are included in the ﬁeld of view. At the same time, it is also important not to choose the near clipping plane to be too near, or the far clipping plane to be too distant. The reason is that the depth buffer values need to have enough resolution so as to allow different  pseudo distance values to be distinguished. To understand how the use of pseudo-distance affects how much resolution is needed to distinguish between different distances, consider the graph of pseudo-distance versus distance in Figure II.21. Qualitatively, it is clear from the graph that pseudo-distance varies faster for small distance values than for large distance values  since the graph of the pseudo-distance function is sloping more steeply at smaller distances than at larger distances . Therefore, the pseudo-distance function is better at distinguishing differences in distance at small distances than at large distances. In most applications this is good, for, as a general rule, small objects tend to be close to the viewpoint, whereas more distant objects tend to either be larger or, if not larger, then errors in depth comparisons for distant objects make less noticeable errors in the graphics image.  It is common for stage 4 of the rendering pipeline to convert the pseudo-distance into a value in the range 0 to 1, with 0 used for points at the near clipping plane and with 1 representing points at the far clipping plane. This number, in the range 0 to 1, is then represented in ﬁxed point, binary notation, that is, as an integer with 0 representing the value at the near clipping plane and the maximum integer value representing the value at the far clipping plane. In modern graphics hardware systems, it is common to use a 32-bit integer to store the depth information, and this gives sufﬁcient depth resolution to allow the hidden surface calculations to work well in most situations. That is, it will work well provided the near and far clipping distances are chosen wisely. Older systems used 16-bit depth buffers, and this tended occasionally to cause resolution problems. By comparison, the usual single-precision ﬂoating point numbers have 24 bits of resolution.  II.3.3 Mapping Lines to Lines   cid:1   As was discussed in the previous section, the fact that perspective transformations map lines in 3-space to lines in screen space is important for interpolation of depth values in the screen space. Indeed, more than this is true: any transformation represented by a 4 × 4 homogeneous matrix maps lines in 3-space to lines in 3-space. Since the perspective maps are represented by 4 × 4 matrices, as shown by Equation II.15, the same is true a fortiori of perspective transformations. Theorem II.7 Let M be a 4 × 4 homogeneous matrix acting on homogeneous coordinates for points in R3. If L is a line in R3, then the image of L under the transformation represented by M, if deﬁned, is either a line or a point in R3.  This immediately gives the following corollary.   II.3 Viewing Transformations and Perspective  53  Corollary II.8 Perspective transformations map lines to lines.  For proving Theorem II.7, the most convenient way to represent the three-dimensional projective space is as the set of linear subspaces of the Euclidean space R4, as was described in Section II.2.5. The “points” of the three-dimensional projective space are the one-dimensional subspaces of R4. The “lines” of the three-dimensional projective space are the two-dimensional subspaces of R4. The “planes” of the three-dimensional projective geometry are the three- dimensional subspaces of R4. The proof of Theorem II.7 is now immediate. Since M is represented by a 4 × 4 matrix, it acts linearly on R4. Therefore, M must map a two-dimensional subspace representing a line onto a subspace of dimension at most two: that is, onto either a two-dimensional subspace representing a line, or a one-dimensional subspace representing a point, or a zero-dimensional subspace. In the last case, the value of M on points on the line is undeﬁned because the point  cid:5 0, 0, 0, 0 cid:6  is not a valid set of homogeneous coordinates for a point in R3.  II.3.4 Another Use for Projection: Shadows  In the next chapter, we study local lighting and illumination models, which, because they track only local features, cannot handle phenomena such as shadows or indirect illumination. There are global methods for calculating lighting that do handle shadows and indirect illumination  see chapters IX and XI , but these methods are often computationally very difﬁcult and cannot be used with ordinary OpenGL commands in any event. There are also some multipass rendering techniques for rendering shadows that can be used in OpenGL  see Section IX.3 . An alternative way to cast shadows that works well for casting shadows onto ﬂat, planar surfaces is to render the shadow of an object explicitly. This can be done in OpenGL by setting the current color to black  or whatever shadow color is desired  and then drawing the shadow as a ﬂat object on the plane. Determining the shape of a shadow of a complex object can be complicated since it depends on the orientation of the object and the position of the light source and object relative to the plane. Instead of attempting to calculate the shape of the shadow explicitly, you can ﬁrst set the model view matrix to hold a projection transformation and then render the object in 3-space, letting the model view matrix map the rendered object down onto the plane.  This method has several advantages, chief among them being that it requires very little coding effort. One can merely render the object twice: once in its proper location in 3-space, and once with the model view matrix set to project it down ﬂat onto the plane. This technique handles arbitrarily complex shapes properly, including objects that contain holes. To determine what the model view matrix should be for shadow projections, suppose that the light is positioned at  cid:5 0, y0, 0 cid:6 , that is, at height y0 up the y-axis, and that the plane of projection is the xz-plane, where y = 0. It is not difﬁcult to see by using similar triangles that the projection transformation needed to cast shadows should be  see Figure II.22    cid:5 x, y, z cid:6   cid:13 →  x  1 − y y0  , 0,  z  1 − y y0   cid:22   .   cid:21    .  1  0 0 0 0 0 0 − 1  y0  0 0 0 0 1 0 0 1  This transformation is represented by the following homogeneous matrix:   Transformations and Viewing  light  54  y0  y  object  shadow   cid:1  x  x  0 Figure II.22. A light is positioned at  cid:5 0, y0, 0 cid:6 . An object is positioned at  cid:5 x, y, z cid:6 . The shadow of the point is projected to the point  cid:5 x   cid:3  = x  1 − y y0  and z   cid:3  = z  1 − y y0 .   cid:3  cid:6 , where x   cid:3 , 0, z  Exercise II.22 Prove the correctness of the formula above for the shadow transformation and the homogeneous matrix representation.  One potential pitfall with drawing shadows on a ﬂat plane is that, if the shadow is drawn exactly coincident with the plane, z-ﬁghting may cause the plane and shadow to show through each other. The phenomenon of z-ﬁghting occurs when two objects are drawn at the same depth from the viewer: owing to roundoff errors, it can happen that some pixel positions have the ﬁrst object closer than the other and other pixels have the second closer than the ﬁrst. The effect is a pattern of pixels in which one object shows through the other. One way to combat z-ﬁghting is to lift the shadow up from the plane slightly, but this can cause problems from some viewpoints where the gap between the plane and the shadow can become apparent. To solve this problem, you can use the OpenGL polygon offset feature. The polygon offset mode perturbs the depth values  pseudo-distance values  of points before performing depth testing against the pixel buffer. This allows the depth values to be perturbed for depth comparison purposes without affecting the position of the object on the screen.  To use polygon offset to draw a shadow on a plane, you would ﬁrst enable the polygon offset mode with a positive offset value, draw the plane, and disable the polygon offset mode. Finally, you would render the shadow without any polygon offset.  The OpenGL commands for enabling the polygon offset mode are  glPolygonOffset  1.0, 1.0  ;   GL_POLYGON_OFFSET_FILL  GL_POLYGON_OFFSET_LINE GL_POLYGON_OFFSET_POINT    ;  glEnable   Similar options for glDisable will disable polygon offset. The amount of offset is controlled by the glPolygonOffset   command; setting both parameters to 1.0 is a good choice in most cases. You can also select negative values such as -1.0 to use offset to pull objects closer to the view. For details on what these parameters mean, see the OpenGL programming manual  Woo et al., 1999 .  II.3.5 The OpenGL Perspective Transformations  OpenGL provides special functions for setting up viewing transformations as either ortho- graphic projections or perspective transformations. The direction and location of the camera can be controlled with the same afﬁne transformations used for modeling transformations, and, in addition, there is a function, gluLookAt, that provides a convenient method to set the camera location and view direction.   II.3 Viewing Transformations and Perspective  55  The basic OpenGL command for creating an orthographic projection is  glOrtho   float  cid:11 , float r, float b, float t, float n, float f  ;  As discussed in Section II.3.1, the intent of the glOrtho command is to set up the camera or eye position so that it is oriented to look down the negative z-axis at the rectangular prism of points with  cid:11  ≤ x ≤ r and b ≤ y ≤ t and n ≤ −z ≤ f . Any part of the scene that lies outside this prism is clipped and not displayed. In particular, objects that are closer than the near clipping plane, deﬁned by  −z  = n, are not visible and do not even obstruct the view of more distant objects. In addition, objects farther than the far clipping plane, deﬁned by  −z  = f , are likewise not visible. Of course, objects, or parts of objects, outside the left, right, bottom, and top planes are not visible.  Internally, the effect of the glOrtho command is to multiply the current matrix, which is  usually the projection matrix P, by the matrix    2 r −  cid:11  0  0  0  S =   .  −r +  cid:11  r −  cid:11  − t + b t − b − f + n f − n 1  0  0  2 t − b 0  0  0 −2 f − n 0  This is the same as the matrix shown in Equation II.10 on page 48, except the signs of the third row are reversed. This is because OpenGL’s convention for the meaning of points in the 2 × 2 × 2 cube is that z = −1 for the closest objects and z = 1 for the farthest objects, and thus the z values need to be negated. As usual, the multiplication is on the right; that is, it has the effect of performing the assignment P = P · S, where P is the current matrix  presumably the projection matrix .  A special case of orthographic projections in OpenGL is provided by the following function:  gluOrtho2D  float  cid:11 , float r, float b, float t  ;  The function gluOrtho2D is exactly like glOrtho, but with n = −1 and f = 1. That is, gluOrtho2D views points that have z-value between−1 and 1. Usually, gluOrtho2D is used when drawing two-dimensional ﬁgures that lie in the x y-plane, with z = 0. It is a convenience function, along with glVertex2*, intended for drawing two-dimensional objects.  OpenGL has two commands that implement perspective transformations, glFrustum and gluPerspective. Both these commands make the usual assumption that the viewpoint is at the origin and the view direction is toward the negative z-axis. The most basic command is the glFrustum command, which has the following syntax:  glFrustum   float  cid:11 , float r, float b, float t, float n, float f  ;  A frustum is a six-sided geometric shape formed from a rectangular pyramid by removing a top portion. In this case, the frustum consists of the points  cid:5 x, y, z cid:6  satisfying the conditions II.16 and II.17.  Refer to Figure II.23 .  a. The points lie between the near and far clipping planes:  n ≤ −z ≤ f.  II.16   View Frustum  Transformations and Viewing  56  z = −f   cid:1 r, t,−n cid:2   z  n   cid:11 , b, n  0  Figure II.23. The frustum viewed with glFrustum  cid:11 , r, b, t, n, f  . The near clipping plane is z = −n. The far clipping plane is z = − f . The frustum is the set of points satisfying Relations II.16 and II.17.  b. The perspective mapping, which performs a perspective projection onto the near clipping  cid:3  ≤ t. On the basis of   cid:3  ≤ r and b ≤ y   cid:3  cid:6  with  cid:11  ≤ x  The effect of the glFrustum command is to form the matrix  plane, maps  cid:5 x, y, z cid:6  to a point  cid:5 x Equation II.11, this is the same as  cid:11  ≤ n · x−z   cid:3 , y  cid:3 , z b ≤ n · y−z  ≤ r  and  ≤ t.    S =  2n r −  cid:11  0  0  0  2n t − b 0  0  0  r +  cid:11  r −  cid:11  t + b t − b −  f + n  f − n −1  0  0 −2 f n f − n 0    II.17  II.18  and then multiply the current matrix  usually the projection matrix  on the right by S. This matrix S is chosen so that the frustum is mapped onto the 2 × 2 × 2 cube centered at the origin. The formula for the matrix S is obtained in nearly the same way as the derivation of Equation II.15 for the perspective transformation in Section II.3.2. There are three differences between Equations II.18 and II.15. First, the OpenGL matrix causes the ﬁnal x and y values to lie in the range −1 to 1 by performing appropriate scaling and translation: the scaling is caused by the ﬁrst two diagonal entries, and the translation is effected by the top two values in the third column. The second difference is that the values in the third row are negated because OpenGL negates the z values from our own convention. The third difference is that Equation II.15 was derived under the assumption that the view frustum was centered on the z-axis. For glFrustum, this happens if  cid:11  = −r and b = −t. But, glFrustum also allows more general-view frustums that are not centered on the z-axis.  Exercise II.23  Derive Formula II.18 for the glFrustum matrix.   cid:1   OpenGL provides a function gluPerspective that can be used as an alternative to glFrustum. The function gluPerspective limits you to perspective transformations for   II.3 Viewing Transformations and Perspective  57  which the z-axis is in the center of the ﬁeld of view, but this is usually what is wanted anyway. The function gluPerspective works by making a single call to glFrustum. The usage of gluPerspective is  gluPerspective  float θ, float aspectRatio, float n, float f  ;  where θ is an angle  measured in degrees  specifying the vertical ﬁeld of view. That is to say, θ is the solid angle between the top bounding plane and the bottom bounding plane of the frustum in Figure II.23. The aspect ratio of an image is the ratio of its width to its height, and so the parameter aspectRatio speciﬁes the ratio of the width of the frustum to the height of the frustum. It follows that a call to gluPerspective is equivalent to calling glFrustum with  t = n · tan θ 2  b = −n · tan θ 2  r =  aspectRatio  · t  cid:11  =  aspectRatio  · b  As an example of the use of gluPerspective, consider the following code fragment from the Solar.c program:     Called when the window is resized    Sets up the projection view matrix  somewhat poorly, however  void ResizeWindow int w, int h  {  glViewport  0, 0, w, h  ;     Viewport uses whole window  float aspectRatio; h =  h == 0  ? 1 : h; aspectRatio =  float w  float h;     Avoid divide by zero     Set up the projection view matrix glMatrixMode  GL_PROJECTION  ; glLoadIdentity  ; gluPerspective  60.0, aspectRatio, 1.0, 30.0  ;  }  The routine ResizeWindow is called whenever the program window is resized9 and is given the new width and height of the window in pixels. This routine ﬁrst speciﬁes that the viewport is to be the entire window, giving its lower left-hand corner as the pixel with coordinates 0, 0 and its upper right-hand corner as the pixel with coordinates w − 1, h − 1.10 The viewport is the area of the window in which the OpenGL graphics are displayed. The routine then makes the projection matrix the active matrix, restores it to the identity, and calls gluPerspective. ◦ This call picks a vertical ﬁeld-of-view angle of 60 and makes the aspect ratio of the viewed scene equal to the aspect ratio of the viewport.  It is illuminating to consider potential problems with the way gluPerspective is used is probably higher than optimal. By  ◦ in the sample code. First, a vertical ﬁeld of view of 60  9 This is set up by the earlier call to glutReshapeFunc in the main program of Solar.c. 10 Pixel positions are numbered by values from 0 to h − 1 from the bottom row of pixels to the top row  and are numbered from 0 to w − 1 from the left column of pixels to the right column.   58  Transformations and Viewing  making the ﬁeld of view too large, the effects of perspective are exaggerated, causing the image to appear as if it were viewed through a wide-angle or “ﬁsh-eye” lens. On the other hand, if the ﬁeld of view is too small, then the image does not have enough perspective and looks too close to an orthographic projection. Ideally, the ﬁeld of view should be chosen to be equal to the angle that the ﬁnal screen image takes up in the ﬁeld of view of the person looking at the image. Of course, to set the ﬁeld of view precisely in this way, one would need to know the dimensions of the viewport  in inches, say  and the distance of the person from the screen. In practice, one can usually only guess at these values.  The second problem with the preceding sample code is that the ﬁeld of view angle is controlled by only the up–down, y-axis, direction. To see why this is a problem, try running the Solar program and resizing the window ﬁrst to be wide and short and then to be narrow and tall. In the second case, only a small part of the solar system will be visible.  Exercise II.24 Rewrite the ResizeWindow function in Solar.c so that the entire solar system is visible no matter what the aspect ratio of the window is.  OpenGL provides another function gluLookAt to make it easy to position a viewpoint at an arbitrary location in 3-space looking in an arbitrary direction with an arbitrary orientation. This function is called with nine parameters:  gluLookAt eye_x, eye_y, eye_z, center_x, center_y, center_z,  up_x, up_y, up_z ;  The three “eye” values specify a location in 3-space for the viewpoint. The three “center” values must specify a different location so that the view direction is toward the center location. The three “up” values specify an upward direction for the y-axis of the viewer. It is not necessary for the “up” vector to be orthogonal to the vector from the eye to the center, but it must not be parallel to it. The gluLookAt command should be used when the current matrix is the model view matrix, not the projection matrix. This is because the viewer should always be placed at the origin in order for OpenGL’s lighting to work properly.  Exercise II.25 Rewrite the Solar function on page 39 to use gluLookAt instead of the ﬁrst translation and rotation.  II.4 Mapping to Pixels  The fourth stage of the rendering pipeline  see Figure II.1 on page 18  takes polygons with vertices in 3-space and draws them into a rectangular array of pixels. This array of pixels is called the viewport. By convention, these polygons are speciﬁed in terms of their vertices; the three earlier stages of the pipeline have positioned these vertices in the 2 × 2 × 2 cube centered at the origin. The x- and y-coordinates of a vertex determine its position in the viewport. The z-coordinate speciﬁes a relative depth or distance value – possibly a pseudo-distance value. In addition, each vertex will usually have other values associated with it – most notably color values. The color values are commonly scalars r, g, b, α for the intensities of red, green, and blue light and the alpha channel value, respectively. Alternatively, the color may be a single scalar for gray-scale intensity in a black and white image. Other values may also be associated with pixels, for instance, u, v-values indexing into a texture map. If the viewport has width w and height h, we index a pixel by a pair  cid:5 i, j cid:6  with i, j integer values, 0 ≤ i < w and 0 ≤ j < h. Suppose a vertex v has position  cid:5 x, y, z cid:6  in the 2 × 2 × 2 cube. It is convenient to remap the x, y values into the rectangle [0, w  × [0, h  so that the   II.4 Mapping to Pixels  59  values of x, y correspond directly to pixel indices. Thus, we let  x   cid:3  = x + 1  cid:3  cid:24  i =  cid:23   2  x  w  and  and  h.  y   cid:3  = y + 1 j =  cid:23   cid:3  cid:24   2  y  ,  Then the vertex v is mapped to the pixel  cid:5 i, j cid:6 , where11   cid:3  = w yields i = w − 1 and y   cid:3  = h yields j = h − 1. Thus, the pixel   cid:3   2  2   cid:6 .  , j + 1  At the same time as the x  with the exceptions that x  cid:5 i, j cid:6  corresponds to vertices with  cid:5 x and y   cid:3  cid:6  in the unit square centered at  cid:5 i + 1  cid:3 , y  cid:3  values are quantized to pixel indices, the other values associated with the pixel are likewise quantized to integer values. The z-value is typically saved as a 16- or 32-bit integer with 0 indicating the closest visible objects and larger values more distant objects. Color values such as r, g, b are typically stored as either 8-bit integers  for “millions of colors” mode with 16,777,216 colors  or as 5-bit integers  for “thousands of colors” mode, with 32,768 colors . Texture coordinates are usually mapped to integer coordinates indexing a pixel in the texture. Now suppose that a line segment has as endpoints the two vertices v1 and v2 and that these endpoints have been mapped to the pixels  cid:5 i1, j1 cid:6  and  cid:5 i2, j2 cid:6 . Once the endpoints have been determined, it is still necessary to draw the pixels that connect the two endpoints in a straight line. The problem is that the pixels are arranged rectangularly thus, for lines that are not exactly horizontal or vertical, there is some ambiguity about which pixels belong to the line segment. There are several possibilities here for how to decide which pixels are drawn as part of the line segment. The usual solution is the following. First, when drawing the pixels that represent a line segment, we work only with the val- ues  cid:5 i1, j1 cid:6  and  cid:5 i2, j2 cid:6 : the ﬂoating point numbers from which they were derived have been forgotten.12 Then let  cid:15 i = i2 − i1   cid:15 j = j2 − j1.  Of course, we may assume that i1 ≤ i2; otherwise, the vertices could be interchanged. We can also assume, without loss of any generality, that j1 ≤ j2, since the case j1 > j2 is symmetric. We then distinguish the cases of whether the slope of the line segment is ≤ 1 or ≥ 1, that is, whether  cid:15 j  cid:15 i ≤ 1 or  cid:15 i   cid:15 j ≤ 1. As illustrated in Figure II.24, in the ﬁrst case, the line segment can be drawn so that there is exactly one pixel  cid:5 i, j cid:6  drawn for each i between i1 and i2. In the second case, there is exactly one pixel  cid:5 i, j cid:6  drawn for each j between j1 and j2. Henceforth, it is assumed that the slope of the line is ≤ 1, that is,  cid:15 j ≤  cid:15 i and that, in particular, i1  cid:16 = i2. This does not cause any loss of generality since the case of slope > 1 can be handled by interchanging the roles of the variables i and j. Our goal is to ﬁnd values j i  so that the line segment can be drawn using the pixels  cid:5 i, j i  cid:6 , for i = i1, i1 + 1, . . . , i2. This is done by using linear interpolation to deﬁne an “ideal” value y i  for j i  and then rounding to the nearest integer. Namely, suppose i1 ≤ i ≤ i2. Let α = i−i1 . Calculating the y-coordinate i2−i1  and  11 The notation  cid:25 a cid:26  denotes the least integer less than or equal to a. 12 There is some loss of information in rounding to the nearest pixel and forgetting the ﬂoating point numbers. Some implementations of line drawing algorithms use subpixel levels of precision; that is, rather than rounding to the nearest pixel, they use a ﬁxed number of bits of extra precision to address subpixel locations. This extra precision does not change the essential nature of the Bresenham algorithm for line drawing, which is described in the next section. In particular, the Bresenham algorithms can still work with integers.   60  D  C  A  that is,  Transformations and Viewing  B  Figure II.24. The line segment AB has slope  cid:15 j  cid:15 i ≤ 1. The line segment C D has slope ≥ 1. The former segment is drawn with one pixel per column; the latter segment is drawn with one pixel per row.  2 and y i2  = j2 + 1  2 . We then  of the line to be drawn on the viewport, we have that  y i  − y i1  = α ·   y i2  − y i1  ,  y i  = j1 + 1 2  + α  j2 − j1  = j1 + 1 2  + α cid:15 j  because our best estimates for y i1  and y i2  are y i1  = j1 + 1  cid:26  obtain j i  by rounding down, namely, =   cid:26    cid:25    cid:25   .  + α cid:15 j  j i  =   cid:15 j  j1 + 1 2  + i − i1 i2 − i1  j1 + 1 2  II.19  II.20  Another, and more suggestive, way to write the formula for j i  is to use the notation [x] to denote x rounded to the nearest integer. Then [x] =  cid:25 x + 1  cid:26 , and so Equation II.19 is equivalent to  2  j i  = [ 1 − α  j1 + αj2] .  As we will see in Chapter IV, this is the usual formula for linear interpolation.  The additive 1 2 in the earlier formulas is thus seen to be just an artifact of the rounding process.   The other scalar values, such as the depth value z; the color values r, g, b; and the texture coordinates can be linearly interpolated in the same way. For the color values, this is what is called Gouraud interpolation.13 For example, the interpolated values for the depth  pseudo- distance  z would be computed so that  z i  = [ 1 − α z1 + αz2] ,  where z1 and z2 are the integer values at the ﬁrst and last vertex obtained by appropriately scaling the z values and rounding down to the nearest integer. The value z i  is the calculated interpolating integer value at the pixel  cid:5 i, y i  cid:6 .  13 Gouraud interpolation is named after H. Gouraud, who proposed linear interpolation in 1971 as a method of blending colors across polygons in  Gouraud, 1971 . His motivation was to apply smoothly varying colors to renderings of surface patches similar to the patches discussed in Section VII.10.   II.4 Mapping to Pixels  61  v1  i5, j cid:2   cid:1   v3   cid:1   i4, j cid:2   v2   cid:1 i, j cid:2   Figure II.25. The scan line interpolation method ﬁrst interpolates along the edges of the triangle and then interpolates along the horizontal rows of pixels in the interior of the triangle. The interpolation directions are shown with arrows. If you look closely, you will note that the rightmost pixel  cid:5 i5, j cid:6  on the horizontal scan line is not exactly on the line segment forming the right edge of the triangle – this is necessary because its position must be rounded to the nearest pixel.  The next section will present the Bresenham algorithm, which gives an efﬁcient, purely  integer-based method for computing the interpolating values y i , z i , and so forth.  Before studying the Bresenham algorithm, we consider how interpolation is used to inter- polate values across a triangle of pixels in the viewport. Let a triangle have vertices v1, v2, and v3. After projecting and rounding to integer values, the vertices map to points  cid:5 im , jm cid:6 , for m = 1, 2, 3. By the linear interpolation formulas above, the three sides of the triangle can be drawn as pixels, and the other values such as depth and color are also interpolated to the pixels along the sides of the triangle. The remaining pixels in the interior of the triangle are ﬁlled in by interpolation along the horizontal rows of pixels. Thus, for instance, in Figure II.25, the scalar values at pixel  cid:5 i, j cid:6  are interpolated from the values at the pixels  cid:5 i4, j cid:6  and  cid:5 i5, j cid:6 . This method is called scan line interpolation.  The process of interpolating along a scan line is mathematically identical to the linear interpolation discussed above. Thus, it can also be carried out with the efﬁcient Bresenham algorithm. In fact, the most natural implementation would involve nested loops that implement nested Bresenham algorithms.  Finally, there is a generalization of scan line interpolation that applies to general polygons rather than just to triangles. The general scan line interpolation interpolates values along all the edges of the polygon. Then, each horizontal scan line of pixels in the interior of the polygon begins and ends on an edge or vertex of course. The values on the horizontal scan line are ﬁlled in by interpolating from the values at the ends. With careful coding, general scan line interpolation can be implemented efﬁciently to carry out the interpolation along edges and across scan lines simultaneously. However, scan line interpolation suffers from the serious drawback that the results of the interpolation can change greatly as the polygon is rotated, and so it is generally not recommended for scenes that contain rotating polygons. Figure II.26 shows an example of how scan line interpolation can inconsistently render polygons as they rotate. ◦ There, a polygon is drawn twice – ﬁrst upright and then rotated 90 . Two of the vertices of the polygon are labeled W and are assigned the color white. The other two vertices are labeled B   Transformations and Viewing  62  W  W  B  B  W  W  B  B  Figure II.26. Opposite vertices have the same black or white color. Scan line interpolation causes the appearance of the polygon to change radically when it is rotated. The two polygons are identical except for their orientation.  and are colored black. The scan line interpolation imposes a top-to-bottom interpolation that drastically changes the appearance of the rotated polygon.  Another problem with scan line interpolation is shown in Figure II.27. Here a nonconvex polygon has two black vertices and three white vertices. The nonconvexity causes a discontin- uous shading of the polygon.  Scan line interpolation on triangles does not suffer from the problems just discussed. Indeed, for triangles, scan line interpolation is equivalent to linear interpolation – at least up to roundoff errors introduced by quantization.  II.4.1 Bresenham Algorithm  The Bresenham algorithm provides a fast iterative method for interpolating on integer values. It is traditionally presented as an algorithm for drawing pixels in a rectangular array to form a line. However, it applies equally well to performing linear interpolation of values in the depth buffer, linear interpolation for Gouraud shading, and so forth.  Before presenting the actual Bresenham algorithm, we present pseudocode for an algorithm based on real numbers. Then we see how to rewrite the algorithm to use integers instead. The algorithm will calculate the integer values j i  for i = i1, i1 + 1, . . . , i2 so that j i1  = j1 and j i2  = j2. We are assuming without loss of generality that i1 < i2 and j1 ≤ j2 and that  cid:15 j = j2 − j1 and  cid:15 i = i2 − i1 with  cid:15 j  cid:15 i ≤ 1. The ﬁrst algorithm to compute the j i  values is  in pseudo-C++ :  float dJ = j2-j1; float dI = i2-i1; float m = dJ dI; writePixel i1, j1 ; float y = j1; int i, j; for   i=i1+1; i<=i2; i++   {     Slope  y = y+m; j = round y ; writePixel  i, j  ;  }     Round to nearest integer  In the preceding code, the function writePixel i,j  is called to indicate that j i  = j. The function round y  is not a real C++ function but is intended to return y rounded to the nearest integer. The variables i1 and i2 are equal to i1 and i2.  The algorithm given above is very simple, but its implementation suffers from its using ﬂoating point and converting a ﬂoating point number to an integer number in each iteration   II.4 Mapping to Pixels  B  B  W  63  W Figure II.27. Vertices are colored black or white as labeled. Scan line interpolation causes the nonconvex polygon to be shaded discontinuously.  W  of the loop. A more efﬁcient algorithm, known as Bresenham’s algorithm, can be designed to operate with only integers. The basic insight for Bresenham’s algorithm is that the value of y in the algorithm is always a multiple of 1  i2 − i1  = 1  cid:15 i. We rewrite the algorithm, using variables j and ry that have the property that j +  ry  cid:15 i  is equal to the value y of the previous pseudocode. Furthermore, j is equal to [y] = round y , and thus − cid:15 x 2 < ry ≤  cid:15 x 2, where  cid:15 x =  cid:15 i. With these correspondences, it is straightforward to verify that the next algorithm is equivalent to the previous algorithm.     Integer division rounds down  int deltaX = i2-i1; int thresh = deltaX 2; int ry = 0; int deltaY = j2 - j1; writePixel  i1, j1  ; int i; int j = j1; for   i=i1+1; i<=i2; i++   {  ry = ry + deltaY; if   ry > thresh   {  j = j + 1; ry = ry - deltaX;  } writePixel  i, j  ;  }  The preceding algorithm, the Bresenham algorithm, uses only integer operations and straightforward operations such as addition, subtraction, and comparison. In addition, the algorithm is simple enough that it can readily be implemented efﬁciently in special-purpose hardware.  We also need a version of the Bresenham algorithm that works for interpolating other values such as depth buffer values, color values, and so on. When interpolating depth buffer values, for instance, it may well be the case that  cid:15 z = z2 − z1 is greater than  cid:15 x; however, there is, without loss of generality, only one z value per i value.  Since we are assuming that the line’s slope is at most 1, there is only one pixel per i value.  To adapt the Bresenham algorithm to the case in which  cid:15 z >  cid:15 x, we let q =  cid:25  cid:15 z  cid:15 x cid:26  and r =  cid:15 z − q cid:15 x. Then, the values z i  increase by approximately q + r  cid:15 x each time i is incremented. The resulting algorithm is as follows:  int deltaX = i2-i1; int thresh = deltaX 2; int rz = 0; int q =  z2-z1  deltaX;     Integer division rounds down   64  Transformations and Viewing  int r=  z2-z1 -q*deltaX; writePixelZ  i1, z1  ; int i; int z = z1; for   i=i1+1; i<=i2; i++   {  z = z + q; rz = rz + r; if   rz > thresh   {  z = z + 1; rz = rz - deltaX;  } writePixelZ  i, z  ;  }  The function writePixelZ i,z  indicates that z is the interpolated value at the pixel  cid:5 i, j i  cid:6 . This algorithm applies to the case in which  cid:15 z < 0 too, provided that the computa- tion of q as  z2-z1  deltaX always rounds down to the nearest integer.  However, the usual C C++ rounding does not work this way!   II.4.2 The Perils of Floating Point Roundoff  The preceding algorithm for line drawing has the property of attempting to draw lines that are “inﬁnitely thin.” Because of this, several unavoidable pitfalls can arise. The ﬁrst and most common problem is that of aliasing. The term aliasing refers to a large variety of problems or effects that can occur when analog data is converted into digital data or vice versa. When drawing a line, we are converting ﬂoating point numbers representing positions into integers that signify pixel positions. The ﬂoating point numbers usually have much more precision than the integer values, and the conversion to integer values can cause problems.  For drawing lines on a screen, a major part of the problem is that the pixels on the screen are arranged rectangularly, whereas a line can be diagonal at an arbitrary angle. Therefore, a line at a diagonal is drawn as a “step function” consisting of straight segments that are horizontal  or vertical  with a 1-pixel jump between the segments. This can give the line drawn on the screen a jagged or sawtooth look, that is to say, the line has “jaggies.” In addition, if the line is animated, the positions of the jaggies on the line move with the line. This can cause undesirable effects when the jaggies become annoyingly visible or where a moving line ﬁgure becomes “shimmery” from the changes in the digitization of the lines.  Several antialiasing methods can reduce the undesirable jaggies on lines, but we do not discuss these here  see Sections IX.2.1 and IX.3 . Instead, we discuss another problem that can arise in rendering lines if the programmer is not careful to avoid inconsistent roundoff errors. An example is shown in Figure II.28. In the ﬁgure, the program has attempted to draw two polygons, ABC D and B AE F, that share the common edge AB. However, owing to roundoff are placed 1 pixel above errors, the second polygon was drawn as B and to the left of A and B, respectively. Because of this, the whole line segment A cid:3  B cid:3  is placed 1 pixel up and 1 pixel to the left of the segment AB. The result is that the edges of the polygons do not exactly coincide, and there are pixels between the two polygons that are left undrawn. Each time the line segments “jog” up 1 pixel, an undrawn pixel is left behind. These undrawn pixels can create unsightly pixel-sized holes in the surface being formed from the two polygons. In actuality, the problems of matching up edges between two abutting polygons is even more sensitive to roundoff error than is indicated in the previous paragraph. When two polygons share  E F, where A  and B  A   cid:3    cid:3    cid:3    cid:3    II.4 Mapping to Pixels  65  F   cid:1   B  B  C  E   cid:1   A  A  D   cid:3    cid:3   A  Figure II.28. The polygons ABC D and B E F are supposed to share an edge, but arbitrarily small roundoff errors can cause a small displacement of the edge. This can lead to pixel-sized holes appearing between the two polygons. In the ﬁgure, the pixelized polygons are shown with different crosshatching: the three white pixels between the polygons are errors introduced by roundoff errors and will cause unwanted visual artifacts. This same effect can occur even in cases in which only one of the vertices is affected by roundoff errors.  an edge, the graphics display system should render them so that each pixel on the boundary edge belongs to exactly one of the two polygons. That is to say, the image needs to be drawn without leaving any gaps between the polgons and without having the polygons overlap in any pixel. There are several reasons it is important not to have the polygons overlap and share a pixel. First, it is desirable for the image to be drawn the same regardless of the order in which the two polygons are processed. Second, for some applications, such as blending or shadow volumes, polygons will leave visible seams where they overlap. Graphics hardware will automatically draw abutting polygons with no gaps and no overlaps; the edges are traced out by the Bresenham algorithm, but only the pixels whose centers are inside the polygon are drawn.  Some special handling is needed to handle the situation in which a pixel center lies exactly on a polygon edge.  This does mean, unfortunately, that almost any roundoff error that moves a vertex to a different pixel position can cause rendering errors.   cid:3    cid:3   and B  This kind of misplacement from roundoff errors can happen no matter how small the roundoff error is. The only way to avoid this kind of roundoff error is to compute the positions in exactly the same way that A and B were computed. By “exactly the same way,” A we do not mean by a mathematically equivalent way; rather, we mean by the same sequence of calculations.14 Figure II.29 shows another situation in which discretization errors can cause pixel-sized holes, even if there are no roundoff errors. In the ﬁgure, three triangles are being drawn:  cid:27 uyx,  cid:27 uzy, and  cid:27 vxz. The point y lies on the boundary of the third triangle. Of course, if the color assigned to the vertex y is not the appropriate weighted average of the colors assigned to x and z, then there will be a discontinuity in color across the line xz. But there can be problems even  14  In rare cases, even using exactly the same sequence of calculations may not be good enough if the CPU or ﬂoating point coprocessor has ﬂexibility in when it performs rounding of intermediate results, which is the default setting on many PCs.   Transformations and Viewing  66  x  u  v  y  z  Figure II.29. Three triangles as placed by glVertex*. Even if no roundoff errors occur, the pixel-level discretization inherent in the Bresenham algorithm can leave pixel-sized gaps along the line xz.  if all vertices are assigned the same color. When the Bresenham algorithm draws the lines xy, yz, and xz, it starts by mapping the endpoints to the nearest pixel centers. This can sufﬁciently perturb the positions of the three points so that there are pixel-sized gaps left undrawn between the line xz and the two lines xy and yz.  This kind of discretization error can easily arise when approximating a curved surface with ﬂat polygons  see the discussion on “cracking” in Section VII.10.2 . It can also occur when two ﬂat polygons that abut each other are subdivided into subpolygons, for example, in radiosity algorithms. If you look closely, you may be able to see examples of this problem in Figures XI.1–XI.3 on pages 273–274.  This depends on how precisely the ﬁgures were rendered in the printing process!  To avoid this problem, you should subdivide the triangle  cid:27 vxz and draw the two triangles  cid:27 vxy and  cid:27 vyz instead.   III  Lighting, Illumination, and Shading  Lighting and shading are important tools for making graphics images appear more realistic and more understandable. Lighting and shading can provide crucial visual cues about the curvature and orientation of surfaces and are important in making three-dimensionality apparent in a graphics image. Indeed, good lighting and shading are probably more important than correct perspective in making a scene understandable.  Lighting and illumination models in computer graphics are based on a modular approach wherein the artist or programmer speciﬁes the positions and properties of light sources, and, independently, speciﬁes the surface properties of materials. The properties of the lights and the materials interact to create the illumination, color, and shading seen from a given viewpoint.  For an example of the importance of lighting and shading for rendering three-dimensional images, refer to Figure III.1. Figure III.1 b  shows a teapot rendered with a solid color with no shading. This ﬂat, featureless teapot is just a silhouette with no three-dimensionality. Figure III.1 c  shows the same teapot but now rendered with the Phong lighting model. This teapot now looks three-dimensional, but the individual polygons are clearly visible. Figure III.1 d  further improves the teapot by using Gouraud interpolation to create a smooth, rounded appearance. Finally, Figures III.1 e  and  f  show the teapot with specular lighting added; the brightly reﬂecting spot shown in  e  and  f  is called a specular highlight.  “Shading” refers to the practice of letting colors and brightness vary smoothly across a surface. The two most popular kinds of shading are Gouraud interpolation  Gouraud, 1971  and Phong interpolation  Phong, 1975 . Either of these shading methods can be used to give a smooth appearance to surfaces; even surfaces modeled as ﬂat facets can appear smooth, as shown in Figure III.1 d  and  f .  This chapter discusses two local models of illumination and shading. The ﬁrst model is the popular Phong lighting model. This model gives good shading and illumination; in addition, it lends itself to efﬁcient implementation in either software or hardware. The Phong lighting model is almost universally used in real-time graphics systems – particularly for PCs and workstations. The Phong lighting model was introduced by Phong in the same paper  Phong, 1975  that also introduced Phong shading.  The second local lighting model is the Cook–Torrance lighting model. This is computa- tionally more difﬁcult to implement but gives better ﬂexibility and the ability to model a wider variety of surfaces.  These lighting and shading models are at least partly based on the physics of how light reﬂects off surfaces. However, the actual physics of reﬂection is quite complicated, and it is  67   68  Lighting, Illumination, and Shading   a    c    e    b    d    f    Figure III.1. Six teapots with various shading and lighting options.  a  Wireframe teapot.  b  Teapot drawn with solid color but no lighting or shading  c  Teapot with ﬂat shading with only ambient and diffuse lighting.  d  Teapot drawn with Gouraud interpolation with only ambient and diffuse reﬂection.  e  Teapot drawn with ﬂat shading with ambient, diffuse, and specular lighting.  f  Teapot with Gouraud shading with ambient, diffuse, and specular lighting. See Color Plate 4.  more accurate to say that the Phong and Cook–Torrance models are physically inspired rather than physically correct.  The Phong and Cook–Torrance models are both “local” models of lighting: they consider only the effects of a light source shining directly onto a surface and then being reﬂected directly to the viewpoint. Local lighting models do not consider secondary reﬂections, where light may reﬂect from several surfaces before reaching the viewpoint. Nor do the local lighting models, at least in their simplest forms, properly handle shadows cast by lights. We will discuss nonlocal, or “global,” lighting models later: Chapter IX discusses ray tracing, and Chapter XI discusses radiosity.  III.1 The Phong Lighting Model  The Phong lighting model is the simplest, and by far the most popular, lighting and shading model for three-dimensional computer graphics. Its popularity is due, ﬁrstly, to its being ﬂexible enough to achieve a wide range of visual effects, and, secondly, to the ease with which it can   III.1 The Phong Lighting Model  Light source  69  Figure III.2. Diffusely reﬂected light is reﬂected equally brightly in all directions. The double line is a beam of incoming light. The dotted arrows indicate outgoing light.  be efﬁciently implemented in software and especially hardware. It is the lighting model of choice for essentially all graphics hardware for personal computers, game consoles, and other realtime applications.  The Phong lighting model is, at its heart, a model of how light reﬂects off of surfaces. In the Phong lighting model, all light sources are modeled as point light sources. Also, light is modeled as consisting of the three discrete color components  red, green, and blue . That is to say, it is assumed that all light consists of a pure red component, a pure green component, and a pure blue component. By the superposition principle, we can calculate light reﬂection intensities independently for each light source and for each of the three color components.  The Phong model allows for two kinds of reﬂection:  Diffuse Reﬂection. Diffusely reﬂected light is light which is reﬂected evenly in all direc- tions away from the surface. This is the predominant mode of reﬂection for nonshiny surfaces. Figure III.2 shows the graphical idea of diffuse reﬂection.  Specular Reﬂection. Specularly reﬂected light is light which is reﬂected in a mirror-like fashion, as from a shiny surface. As shown in Figure III.3, specularly reﬂected light leaves a surface with its angle of reﬂection approximately equal to its angle of incidence. This is the main part of the reﬂected light from a polished or glossy surface. Specular reﬂections are the cause of “specular highlights,” that is, bright spots on curved surfaces where intense specular reﬂection occurs.  In addition to dividing reﬂections into two categories, the Phong lighting model treats light  or illumination as being of three distinct kinds:  Specular Light. Specular light is light from a point light source that will be reﬂected  Diffuse Light. Diffuse light is light from a point light source that will be reﬂected diffusely.  specularly.  Light source  Figure III.3. Specularly reﬂected light is reﬂected primarily in the direction with the angle of incidence equal to the angle of reﬂection. The double line is a beam of incoming light. The dotted arrows indicate outgoing light; the longer the arrow, the more intense the reﬂection in that direction.   70  Light source  Lighting, Illumination, and Shading  Eye  Viewpoint   n   cid:7   v  Figure III.4. The fundamental vectors of the Phong lighting model. The surface normal is the unit vector n. The point light source is in the direction of the unit vector  cid:7 . The viewpoint  eye  is in the direction of the unit vector v. The vectors  cid:7 , n, and v are not necessarily coplanar.  Ambient Light. Ambient light is light that arrives equally from all directions rather than from a point light source. Ambient light is intended to model light that has spread around the environment through multiple reﬂections.  As mentioned earlier, light is modeled as coming in a small number of distinct wavelengths, that is, in a small number of colors. In keeping with the fact that monitors have red, green, and blue pixels, light is usually modeled as consisting of a blend of red, green, and blue. Each of the color components is treated independently with its own specular, diffuse, and ambient properties.  Finally, the Phong lighting model gives material properties to each surface; the material properties control how lights illuminate the surface. Except for the specular exponent, these properties can be set independently for each of the three colors.  Specular Reﬂection Properties. A specular reﬂectivity coefﬁcient, ρs, controls the amount of specular reﬂection. A specular exponent, f , controls the shininess of the surface by controlling the narrowness of the spread of specularly reﬂected light.  Diffuse Reﬂection Properties. A diffuse reﬂectivity coefﬁcient, ρd, controls the relative  intensity of diffusely reﬂected light.  Ambient Reﬂection Properties. An ambient reﬂectivity coefﬁcient, ρa, controls the  amount of ambient light reﬂected from the surface.  Emissive Properties. The emissivity of a surface controls how much light the surface emits in the absence of any incident light. Light emitted from a surface does not act as a light source that illuminates other surfaces; instead, it only affects the color seen by the observer.  The basic setup for reﬂection in the Phong reﬂection model is shown in Figure III.4. As shown in the ﬁgure, a particular point on a surface is being illuminated by a point light source and viewed from some viewpoint. The surface’s orientation is speciﬁed by a unit vector n pointing perpendicularly up from the surface. The light’s direction is speciﬁed by a unit vector  cid:7  that points from the point on the surface towards the light. The viewpoint direction is similarly speciﬁed by a unit vector v pointing from the surface towards the viewpoint. These three vectors, plus the properties of the light source and of the surface material, are used by the Phong model to determine the amount of light reaching the eye.  We assume that light from the point light source is shining with intensity I in. The Phong lighting model provides methods to calculate the intensity of the light reﬂected from the surface that arrives at the eye. It is not particularly important to worry about how light intensity is measured except that it is useful to think of it as measuring the energy ﬂux per unit area, where the area is measured perpendicularly to the direction of the light.   III.1 The Phong Lighting Model  71  I in d   cid:7   n  θ  χ  v  Id  Figure III.5. The setup for diffuse reﬂection in the Phong model. The angle of incidence is θ, and I in Id are the incoming and outgoing light intensities in the indicated directions.  d and  The next two sections discuss how the Phong model calculates the reﬂection due to diffuse re- ﬂection and to specular reﬂection. For the time being, we will restrict attention to light at a single wavelength  i.e., of a single, pure color  and coming from a single light source. Section III.1.4 explains how the effects of multiple lights and of different colors are additively combined.  III.1.1 Diffuse Reﬂection  Diffuse reﬂection means that light is being reﬂected equally in all directions, as illustrated in Figure III.2. The fundamental Phong vectors are shown again in Figure III.5 but now with the angle between  cid:7  and n shown equal to θ: this is the angle of incidence of the light arriving from the point source. The amount of light that is diffusely reﬂected is modeled as  Id = ρd I in  d cos θ = ρd I in  d   cid:7  · n ,  III.1  where the second equality holds because the vectors are unit vectors. Here, I in d is the intensity of the incoming diffuse light, and Id is the intensity of the diffusely reﬂected light in the direction of the viewpoint. The value ρd is a constant, which is called the diffuse reﬂectivity coefﬁcient of the surface. This value represents a physical property of the surface material.  A surface that diffusely reﬂects light according to Equation III.1 is called Lambertian, and most nonshiny surfaces are fairly close to Lambertian. The deﬁning characteristic of a Lambertian surface is that, if a large ﬂat region of the surface is uniformly lit, the surface should have the same apparent  or perceived  brightness and color from all viewing directions. The presence of the cos θ term in Equation III.1 requires some explanation. Recall that the incoming light intensity I in d is intended to measure energy ﬂux per unit area with unit area measured perpendicularly to the direction of the light. Since the light is incident onto the surface at an angle of θ away from the normal vector n, a “perpendicularly measured unit area’s” worth of energy ﬂux is spread over a larger area of the surface, namely, an area that is larger by a factor of 1  cos θ . See Figure III.6 for an illustration of how the area increases by  Area A  n  θ  Area A cos θ  Figure III.6. The perpendicular cross-sectional area of a beam of light is A. The area of the surface tilted at an angle θ is larger by a factor of 1  cos θ.   72  Lighting, Illumination, and Shading  I in s   cid:7   n  r  θ  θ ϕ  Is  v  Figure III.7. The setup for specular reﬂection in the Phong model. The angle of incidence is θ. The vector r points in the direction of perfect mirror-like reﬂection, and I in s and Is are the incoming and outgoing specular light intensities respectively, in the indicated directions.  a factor of 1  cos θ. Because of this, the energy ﬂux arriving per unit area of the surface is only  cos θ I in d .  At this point, it would be reasonable to ask why there is not another cosine factor involving the angle of reﬂection. Of course, this is not what we generally perceive: that is, when one looks at a surface from a sharp angle we do not see the brightness of the surface drop off dramatically with the cosine of the angle of reﬂection. Otherwise, surfaces viewed from a sharply sidewise angle would appear almost black. Conversely, diffusely reﬂecting surfaces do not appear much brighter when viewed from straight on.1  However, more careful consideration of why there is no factor involving the angle of re- ﬂection reveals that Figure III.2 is a little misleading. It is not the case that the probability of a single photon’s being reﬂected in a given direction is independent of the reﬂection direction. Instead, letting χ be the angle between the surface normal n and the outgoing light direction v, we ﬁnd the probability that a photon reﬂects out in the direction v is proportional to cos χ. The viewer looking at the surface from this view angle of χ from the normal vector sees light coming from a surface area of  1  cos χ  times the apparent ﬁeld of view area.  This is similar to the justiﬁcation of the cos θ factor.  The two factors of cos χ and 1  cos χ cancel out, and we are left with the Phong diffuse reﬂection formula III.1.  III.1.2 Specular Reﬂection  Specular reﬂection occurs when light reﬂects, primarily mirror-like, in the direction where the angle of incidence equals the angle of reﬂection. Specular reﬂection is used to model shiny surfaces. A perfect mirror would reﬂect all of its light in exactly that direction, but most shiny surfaces do not reﬂect nearly as well as a mirror, and so the specularly reﬂected light spreads out a little, as is shown in Figure III.3.  In any event, the Phong lighting model is not capable of modeling mirror-like reﬂections other than specular reﬂections from point light sources.  Given the unit vector  cid:7  in the direction of the light source and the unit surface normal n, the direction of a perfect mirror-like reﬂection is given by the vector r shown in Figure III.7. The vector r is a unit vector coplanar with  cid:7  and n. The angle of perfect reﬂection is the angle between r and n, and this is equal to the angle of incidence θ, which is the angle between  cid:7  and n.  It is best to compute r using the following formula:  r = 2  cid:7  · n n −  cid:7 .  To derive this formula, note that   cid:7  · n n is the projection of  cid:7  onto n and that  cid:7  −   cid:7  · n n is equal to   cid:7  · n n − r.  1 We are describing Lambertian surfaces. However, not all surfaces are Lambertian  e.g., the moon as  illuminated by the sun and viewed from the Earth .   III.1 The Phong Lighting Model  73  I in s   cid:7   h  ψ  r  n  θ  ϕ  Is  v  Figure III.8. The setup for calculating the specular reﬂection using the halfway vector h, the unit vector halfway between  cid:7  and v.  In Figure III.7, the angle between the view vector and the perfect reﬂection direction vector is ϕ. The guiding principle for determining specular reﬂection is that, the closer the angle ϕ is to zero, the more intense is the specular reﬂection in the direction of the viewpoint. The Phong lighting model uses the factor   cos ϕ  f  to model the dropoff in light intensity in a reﬂection direction that differs by an angle of ϕ from the direction r of perfect reﬂection. There is no particular physical justiﬁcation for the use of the factor  cos ϕ  f ; rather, it is used because the cosine can easily be computed by a dot product and the exponent f can be adjusted experimentally on an ad hoc basis to achieve the desired spread of specular light. The exponent f is ≥ 0, and values in the range 50 to 80 are typical for shiny surfaces; the larger the exponent, the narrower the beam of specularly reﬂected light. Higher exponent values make the specular highlights smaller and the surface appear shinier; however, exponents that are too high can lead to specular highlights being missed.  With the factor III.2, the Phong formula for the intensity Is of specularly reﬂected light is  Is = ρs I in  s  cos ϕ  f = ρs I in  s  v · r  f ,  where ρs is a constant called the specular reﬂectivity coefﬁcient and I in is the intensity of s the specular light from the light source. The value of ρs depends on the surface and on the wavelength of the light. For the time being, we are working under the assumption that all the light is a single pure color.  Often a computational shortcut, based on the “halfway” vector, is used to simplify the calculation of Is. The halfway vector h is deﬁned to be the unit vector halfway between the light source direction and the view direction, namely,  h =  cid:7  + v  cid:7  + v .  Let ψ be the angle between h and the surface normal n. Referring to Figure III.8, one can easily see that if  cid:7 , n, and v are  approximately  coplanar, then ψ is  approximately  equal to ϕ 2. Therefore, it is generally acceptable to use ψ instead of ϕ in the calculation of Is since the exponent f can be changed slightly to compensate for the factor of two change in the value of the angle. With the halfway vector, the Phong equation for the intensity of specular reﬂection becomes  Is = ρs I in  s  cos ψ  f = ρs I in  s  h · n  f .  Although III.4 is not exactly equal to III.3, it gives qualitatively similar results.  For polygonally modeled objects, the calculation of the diffuse and specular components of Phong lighting is usually done at least once for each vertex in the geometric model. For points  III.2  III.3  III.4   74  Lighting, Illumination, and Shading  in the interior of polygons, Gouraud shading is used to determine the lighting and colors by averaging values from the vertices  see Section III.1.5 below . To apply the formula III.1 and the formulas III.3 or III.4 at each vertex, it is necessary to calculate the unit vectors  cid:7  and v at each vertex. To calculate these two vectors, one subtracts the surface position from the positions of the light and the viewpoint and then normalizes the resulting differences. This is computationally expensive, since, for each of  cid:7  and v, this computation requires calculation of a square root and a division. One way to avoid this calculation is to make the simplifying approximation that the two vectors  cid:7  and v are constants and are the same for all vertices. In essence, this has the effect of placing the lights and the viewpoint at points at inﬁnity so that the view direction v and the light direction  cid:7  are independent of the position of the surface being illuminated. When the light direction vector  cid:7  is held constant, we call the light a directional light. Nondirectional lights are called positional lights since the light’s position determines the direction of illumination of any given point. If the view direction is computed using the position of the viewpoint, then we say there is a local viewer. Otherwise, the view direction v is held ﬁxed, and we call it a nonlocal viewer. Note that a nonlocal viewer can be used in conjunction with a perspective viewing transformation.  If we have a directional light and a nonlocal viewer, so that both  cid:7  and v are held constant, then the vector h also remains constant. This makes the use of the halfway vector and Formula III.4 even more advantageous: the only vector that needs to be calculated on a per-vertex basis is the surface normal n.  III.1.3 Ambient Reﬂection and Emissivity  Ambient light is light that comes from all directions rather than from the direction of a light source. It is modeled as being reﬂected equally in all directions, and thus the ambient component of the surface lighting and shading is independent of the direction of view. We let I in a represent the total intensity of the incoming ambient light. In the Phong model, the surface has an associated ambient reﬂectivity coefﬁcient ρa that speciﬁes the fraction of the ambient light reﬂected. The formula for the intensity of the outgoing ambient light is  Ia = ρa I in  a  .  III.5  Finally, a surface can also be given an emissive intensity constant Ie. This is equal to the  intensity of the light emitted by the surface in addition to the reﬂected light.  III.1.4 Putting It Together: Multiple Lights and Colors  So far, the discussion of the Phong model has been restricted to a single wavelength  or pure color  of light with illumination from a single light source. According to the superposition principle, the various types of reﬂection and emission can be combined by simple addition. Furthermore, the effect of multiple lights is likewise determined by adding the illumination from the lights considered individually. Finally, different wavelengths may be considered in- dependently with no interaction between the intensity of one wavelength and that of another. First, for a single wavelength and a single light source, the total outgoing light intensity I  is equal to  I = Ia + Id + Is + Ie = ρa I in  + ρd I in  d   cid:7  · n  + ρs I in  s  r · v  f + Ie.  a  III.6  The halfway vector formula for specular reﬂection may be used instead with h · n replacing r · v in the equation.    III.1 The Phong Lighting Model  75  Second, to adapt this formula to multiple wavelengths, we write I λ, I λ,in  , I λ e for the intensities of the light at wavelength λ. In addition, the material properties are also dependent on the wavelength λ and can now be written as ρλ a , and so forth. It is usual, however, to make the specular exponent independent of the wavelength. Equation III.6 can be specialized to a single wavelength, yielding d I λ,in   r · v  f + I λ    cid:7  · n  + ρλ  I λ = ρλ  + ρλ  a I λ,in  s I λ,in  , I λ,in  III.7  d  .  a  a  e  s  s  , I λ,in  d  It is traditional to use the three wavelengths of red, green, and blue light since these are the three colors displayed by computer monitors; however, more wavelengths can be used for greater realism. To write a single equation incorporating all three wavelengths at once, we use boldface variables to denote a 3-tuple: we let ρa denote the triple  cid:5 ρred  cid:6 ; let I equal  cid:5 I red, I green, I blue cid:6 , and so forth. We also momentarily use ∗ for component-wise multipli- cation on 3-tuples. Then Equation III.7 can be written as s  r · v  f + Ie.  d   cid:7  · n  + ρs ∗ Iin  I = ρa ∗ Iin  + ρd ∗ Iin  , ρgreen  , ρblue  III.8  a  a  a  a  Third, we consider the effect of multiple point light sources. We assume there are k light sources. When illuminating a given point on a surface, light number i has light direction vector  cid:7 i . The ith light also has an intensity value Iin,i that represents the intensity of the light reaching that point on the surface. This intensity may be moderated by the distance of the surface from the light and by various other effects such as spotlight effects. In addition, if n ·  cid:7 i ≤ 0, then the light is not shining from above the surface, and in this case we take Iin,i to be zero. We then merely add the terms of Equation III.8 over all light sources to get the overall illumination  ri is the unit vector in the direction of perfect reﬂection for light i :  + ρd ∗ k cid:27   i=1    cid:7 i · n  + ρs ∗ k cid:27   i=1  Iin,i d  I = ρa ∗ Iin  a   ri · v  f + Ie.  Iin,i s  a represents the incoming ambient light. It is common to specify a global value, , for global ambient light and to have each light source contribute some additional  The 3-tuple Iin Iin,global a ambient light, Iin,i = Iin,global  a  Iin a  a  , to the scene. Then,  + k cid:27   i=1  Iin,i a  .  III.9  III.10  This completes the theoretical description of the Phong lighting model. The next section takes up the two most common methods of interpolating, or shading, colors and brightness from the vertices of a triangle into the interior points of the triangle. Section III.1.8 explains in outline form how OpenGL commands are used to specify the material and light properties needed for the Phong lighting calculations.  Exercise III.1 Why is it customary to use the same specular exponent for all wavelengths? What would a specular highlight look like if different wavelengths had different specular exponents?  III.1.5 Gouraud and Phong Shading  The term “shading” refers to the use of interpolation to create a smoothly varying pattern of color and brightness on the surfaces of objects. Without shading, each polygon in a geometric model would be rendered as a solid, constant color; the resulting image would be noticeably   76  Lighting, Illumination, and Shading   a    b   Figure III.9. Two cubes with  a  normals at vertices perpendicular to each face, and  b  normals outward from the center of the cube. Note that  a  is rendered with Gouraud shading, not ﬂat shading. See Color Plate 5.  polygonal. One way to avoid this problem is to use extremely small polygons, say with each polygon so small that it spans only one pixel, but often this is prohibitively expensive in terms of computational time. Instead, good shading effects can be obtained even for moderately large polygons by computing the lighting and colors at only the vertices of the polygons and using interpolation, or averaging, to set the lighting and colors of pixels in the interior of the polygons. There are several ways that interpolation is used to create shading effects. As usual, suppose a surface is modeled as a set of planar, polygonal patches and we render one patch at a time. Consider the problem of determining the color at a single vertex of one of the patches. Once the light source, viewpoint, and material properties are ﬁxed, it remains only to specify the normal vector n at the vertex. If the surface is intended to be a smooth surface, then the normal vector at the vertex should, of course, be set to be the normal to the underlying surface. On the other hand, some surfaces are faceted and consist of ﬂat polygonal patches – for example, the cube shown in part  a  of Figure III.9. For these surfaces, the normal vector for the vertex should be the same as the normal vector for the polygon being rendered. Since vertices typically belong to more than one polygon, this means that a vertex might be rendered with different normal vectors for different polygons.  Parts  d  and  f  of Figure III.1 show examples of Gouraud shading. Figure III.9 shows a more extreme example of how Gouraud shading can hide, or partially hide, the edges of polygons. Both parts of Figure III.9 show a reddish solid cube lit by only ambient and diffuse light, and both ﬁgures use Gouraud shading. The ﬁrst cube was rendered by drawing each polygon independently with the normals at all four vertices of each polygon normal to the plane of the polygon. The second cube was drawn with the normal to each vertex pointing √ outward from the center point of the cube; that is, the normals at a vertex are an average of the normals of the three adjacent faces and thus are equal to  cid:5 ±1  3 cid:6 . The faces of the cube are clearly visible as ﬂat surfaces in the ﬁrst ﬁgure but are somewhat disguised in the second picture.  √ 3,±1   √ 3,±1   The question of how to determine the surface normal at a vertex of a polygonal model will be discussed further in Section III.1.6. For the moment, we instead consider the methods for interpolating the results of the Phong lighting model to shade interior points of a polygon. We assume the polygon is a triangle. This is a reasonable assumption, as rendering systems gener- ally triangulate polygons. This assumption has the convenient effect that triangles are always planar, and so we do not need to worry about the pathological situation of nonplanar polygons.   III.1 The Phong Lighting Model  77  Two kinds of shading are used with the Phong model, and both usually use the scan line interpolation described in Section II.4. Scan line interpolation is also equivalent to linear interpolation, which is discussed in Section IV.1. The ﬁrst kind of shading is Gouraud shading. In Gouraud shading, a color value is deter- mined for each vertex, the color value being a triple  cid:5 r, g, b cid:6  with red, green, and blue light intensities. After the three vertices of a triangle are rendered at pixel positions in the viewport, the interior pixels of the triangle in the viewport are shaded by simple linear interpolation. Recall that this means that if two vertices x0, x1 have color values  cid:5 ri , gi , bi cid:6  for i = 0, 1, and if another pixel is positioned on the line segment between the points at a fraction α of the way from x0 to x1, then the interpolated color is  1 − α  cid:5 r0, g0, b0 cid:6  + α cid:5 r1, g1, b1 cid:6 .  Gouraud interpolation works reasonably well; however, for large polygons, it can miss specular highlights or at least miss the brightest part of the specular highlight if this falls in the middle of a polygon. Another example of how Gouraud shading can fail is that a spotlight shining on a wall can be completely overlooked by Gouraud interpolation: if the wall is modeled as a large polygon, then the four vertices of the polygon may not be illuminated by the spotlight at all. More subtly, Gouraud interpolation suffers from the fact that the brightness of a specular highlight depends strongly on how the highlight is centered on a vertex; this is particularly apparent when objects or lights are being animated. Nonetheless, Gouraud shading works well in many cases and can be implemented efﬁciently in hardware. For this reason, it is very popular and widely used.  The second kind of shading is Phong shading. In this technique, the surface normals are interpolated throughout the interior of the triangle, and the full Phong lighting is recalculated at each pixel in the triangle on the viewport. The interpolation is not as simple as the usual linear interpolation described in Section II.4 because the interpolated surface normals must be unit vectors to be used in the Phong lighting calculations.  The most common way to calculate interpolated surface normals is as follows: Suppose x0, x1 are pixels where the surface normals are n0 and n1, respectively. At a pixel a fraction α of the distance along the line from x0 to x1, the interpolated normal is  nα =  1 − α n0 + αn1  1 − α n0 + αn1 .  III.11  This is computationally more work than Gouraud shading – especially because of the renor- malization. However, the biggest disadvantage of Phong shading is that all the information about the colors and directions of lights needs to be kept until the ﬁnal rendering stage so that lighting can be calculated at every pixel in the ﬁnal image. On the other hand, the big advantage of Phong shading is that small specular highlights and spotlights are not missed when they occur in the interior of a triangle or polygon. In addition, the brightness of a specular highlight is not nearly so sensitive to whether the specular highlight is centered over a vertex or in the interior of a polygon.  A potential problem with both Gouraud and Phong shading is that they perform the inter- polation in the coordinates of the screen or viewport. However, in perspective views, a large polygon that is angled from the viewpoint will have its more distant parts appear more com- pressed in the graphics image than its closer parts. Thus, the interpolation in screen coordinates does not properly reﬂect the size of the polygon. This can sometimes contribute to subopti- mal shading with unwanted visual effects. The method of hyperbolic interpolation, which is discussed in Section IV.5, can be used to avoid these problems.   78  Lighting, Illumination, and Shading  Yet another problem with Phong shading is that normals should not be interpolated linearly across the polygonal approximation to a surface because they tend to change less rapidly in areas where the normals are pointing towards the viewer and more rapidly in areas where the normals are pointing more sideways. One way to partly incorporate this observation in the Phong shading calculation is to use the following method to calculate normals. Let the normals be ni =  cid:5 nx,i , n y,i , nz,i cid:6 , i = 0, 1. Then replace the calculation of Equation III.11 by  nx,α =  1 − α nx,0 + αnx,1 n y,α =  1 − α n y,0 + αn y,1 nz,α = y,α .  x,α − n2  1 − n2   cid:19   The equations above calculate the x- and y-components of nα by linear interpolation and choose the z-component so as to make nα a unit vector.   cid:1   Exercise III.2 Prove that these alternate equations for normal vector interpolation provide the correct unit normal vectors in the case of a spherical surface viewed ortho- graphically.  III.1.6 Computing Surface Normals  As we have seen, it is important to set the values of surface normals correctly to obtain good lighting and shading effects. In many cases, one can determine surface normals by understanding the surface clearly and using symmetry properties. For example, the surface normals for objects like spheres, cylinders, tori, and so forth, are easy to determine. However, for more complicated surfaces, it is necessary to use more general methods. We next consider three different methods for calculating surface normals on general surfaces.  First, suppose a surface has been modeled as a mesh of ﬂat polygons with vertices that lie on the surface. Consider a particular vertex v, and let P1, . . . , Pk be the polygons that have that vertex as a corner. The unit surface normal ni for each individual polygon Pi is easy to compute by taking two adjacent  and noncollinear  edges from the polygon, forming their cross product, and normalizing. Then we can estimate the unit normal n at the vertex as the average of the unit normals of the adjacent polygons, namely as   cid:28   cid:29  cid:29  cid:29  cid:29  cid:28    cid:29  cid:29  cid:29  cid:29  .  i ni i ni  n =  Note that it was necessary to renormalize since the Phong lighting model works with unit vectors.  Computing the normal vector by averaging the normals of adjacent polygons has the advan- tage that it can be done directly from the polygonal model of a surface without using any direct knowledge of the surface. It also works even when there is no mathematical surface underlying the polygonal data, say in situations in which the polygonal data has been generated by hand or by measurement of some object. Of course, this method does not generally give the exactly correct surface normal, but if the polygons are small enough compared with the rate of change of the surface curvature, this approach will give normals that are close to the correct surface normals.  The second method of computing surface normals can be used with surfaces that are deﬁned parametrically. We say that a surface is deﬁned parametrically if there is a function f x, y  of two variables with a domain A ⊆ R2 such that the surface is the set of points {f x, y  :  cid:5 x, y cid:6  ∈ A}.   III.1 The Phong Lighting Model  79  Figure III.10. A polygonal mesh deﬁned by a parametric function. The horizontal and vertical curves are lines of constant y values and constant x values, respectively.  We write f in boldface because it is a function that takes values in R3, that is, it is a vector-valued function,  f x, y  =  cid:5  f1 x, y , f2 x, y , f3 x, y  cid:6 .  The partial derivatives  fx := ∂f ∂x  and  fy := ∂f ∂y  are deﬁned component-wise as usual and are likewise vectors in R3. The partial derivatives are the rates of change of f with respect to changes in one of the variables while the other is held ﬁxed. In Figures III.10 and III.11, this is illustrated with the partial derivative tangent to the surface cross sections where the other variable is constant. Except in degenerate cases, the cross product of the two partial derivatives gives a vector perpendicular to the surface. Theorem III.1 Suppose f has partial derivatives at  cid:5 x, y cid:6 . If the cross-product vector fx  x, y  × fy x, y  is nonzero, then it is perpendicular to the surface at f x, y .  parametrically deﬁned by f.  To prove the theorem, note that fx and fy are noncollinear and are both tangent to the surface Usually, the vector fx × fy must be normalized, and care must be taken to choose the correct outward direction. Therefore, the unit vector normal to a parametrically deﬁned surface is given  fy  fx  Figure III.11. A close-up view of a polygonal mesh. The partial derivatives are tangent to the horizontal and vertical cross-section curves.   80  by the formula  Lighting, Illumination, and Shading  ± fx  x, y  × fy x, y  fx  x, y  × fy x, y   III.12 whenever the vector fx  x, y  × fy x, y  is nonzero. The sign is chosen to make the vector point outward.  Exercise III.3 Let T be a torus  doughnut shape  with major radius R and minor radius r. This torus is a tube going around the y-axis. The center of the tube stays distance R from the y-axis and lies in the xz-plane. The radius of the tube is r.  a  Show that the torus T is parametrically deﬁned by f θ, ϕ , for 0 ≤ θ ≤ 360 ◦  0 ≤ ϕ ≤ 360 ◦ f θ, ϕ  =  cid:5  R + r cos ϕ  sin θ, r sin ϕ,  R + r cos ϕ  cos θ cid:6 . III.13 [Hint: θ controls the angle measured around the y-axis, starting with θ = 0 at the positive z-axis. The angle ϕ speciﬁes the amount of turn around the centerline of the torus.] Draw a picture of the torus and of a point on it for a representative value of θ and ϕ.  , where  and   b  Use your picture and the symmetry of the torus to show that the unit normal vector to  the torus at the point f θ, ϕ  is equal to  cid:5 sin θ cos ϕ, sin ϕ, cos θ cos ϕ cid:6 .  III.14  Exercise III.4 Let T be the torus from the previous exercise. Use Theorem III.1 to compute a vector normal to the torus at the point f θ, ϕ . Compare your answer with equation III.14. Is it the same? If not, why not?  The third method for computing surface normals applies to surfaces deﬁned as level sets of functions. Such a surface can be deﬁned as the set of points satisfying some equation and is sometimes called an implicitly deﬁned surface  see Appendix A.4 . Without loss of generality, there is a function f  x, y, z , and the surface is the set of points { cid:5 x, y, z cid:6  : f  x, y, z  = 0}. Recall that the gradient of f , ∇ f , is deﬁned by   cid:21    cid:22   ∇ f  x, y, z  =  ∂ f ∂x  ,  ∂ f ∂y  ,  ∂ f ∂z  .  From multivariable calculus, it follows that the gradient of f surface. Theorem III.2 Let S be the level set deﬁned as above as the set of zeroes of f . Let  cid:5 x, y, z cid:6  be a point on the surface S. If the vector ∇ f  x, y, z  is nonzero, then it is perpendicular to the surface at  cid:5 x, y, z cid:6 .  is perpendicular to the level  Exercise III.5 Show that the torus T considered in the previous two exercises can be deﬁned as the set of zeros of the function  f  x, y, z  =    x 2 + z2 − R 2 + y2 − r 2.   cid:20   Use Theorem III.2 to derive a formula for a vector perpendicular to the surface at a point  cid:5 x, y, z cid:6 . Your answer should be independent of r. Does this make sense?   III.1 The Phong Lighting Model  81  y  y  n1  ⇒  n2  x  x  Figure III.12. An example of how a nonuniform scaling transformation affects a normal. The transfor- mation maps  cid:5 x, y cid:6  to  cid:5  1 2 x, y cid:6 . The line with unit normal n1 =  cid:5  1√  cid:6  is transformed to a line with unit normal n2 =  cid:5  2√  cid:6 . , 1√ 5  , 1√ 2  2  5  III.1.7 Afﬁne Transformations and Normal Vectors  When using afﬁne transformations to transform the positions of geometrically modeled objects, it is important to also transform the normal vectors appropriately. After all, things could get very mixed up if the vertices and polygons are rotated but the normals are not! For now, assume we have an afﬁne transformation Ax = Bx + u0, where B is a linear transformation. Since translating a surface does not affect its normal vectors, we can ignore the translation u0 and just work with the linear mapping B.  If B is a rigid transformation  possibly not orientation-preserving , then it is clear that, after a surface is mapped by B, its normals are also mapped by B. That is to say, if a vertex v on the surface S has the normal n, then on the transformed surface B S , the transformed vertex B v  has surface normal B n .  However, the situation is more complicated for nonrigid transformations. To understand this on an intuitive level, consider an example in the x y-plane. In Figure III.12 a , a line segment is shown with slope−1: the vector n1 =  cid:5 1, 1 cid:6  is perpendicular to this line. If B performs a scaling by a factor of 1 2 in the x-axis dimension, then the line is transformed to a line with slope −2. , 1 cid:6 , which is not perpendicular to the transformed But, the normal vector is mapped by B to  cid:5  1 line. Instead, the correct perpendicular direction is n2 =  cid:5 2, 1 cid:6 ; thus, it looks almost like the inverse of B needs to be applied to the normal vector. This is not quite correct though; as we will see next, it is the transpose of the inverse that needs to be applied to the normals.  2  We state the next theorem in terms of a vector normal to a plane, but the same results hold for a normal to a surface since we can just use the plane tangent to the surface at a given point. We may assume without much loss of applicability that the transformation B is invertible, for otherwise the image of B would be contained in a plane P and any normal to the plane P would be perpendicular to the surface.  Theorem III.3 Let B be a linear transformation represented by the invertible matrix M. Let N −1 T. Let P be a plane and n be orthogonal to P. Then N n is orthogonal equal  M T  to the image B P  of the plane P under the map B.  −1 =  M  For the proof, it is helpful to recall that for any vectors x and y, the dot product x · y is equal  to xTy  see Appendix A . Proof Suppose that x is a vector lying in the plane P, and so n · x = 0. To prove the theorem, it will sufﬁce to show that  N n  ·  Mx  = 0. But this follows immediately from −1  Mx   −1 Tn T Mx  =  nT M  −1 Tn  ·  Mx  =   M −1 Mx  = nTx = n · x = 0,   N n  ·  Mx  =   M = nT M and the theorem is proved.   cid:1    82  Lighting, Illumination, and Shading  Recall that the adjoint of a matrix M is the transpose of the matrix formed from the cofactors of M  see Appendix A . In addition, the inverse of a matrix M is equal to the adjoint of M divided by the determinant of M. Therefore, it is immediate that Theorem III.3 also holds for the transpose of the adjoint of M in place of the transpose of the inverse of M. To summarize, a normal vector transforms under an afﬁne transformation x  cid:13 → Mx + u0  according to the formula  n  cid:13 → N n,  where N is the transpose of either the inverse or the adjoint of M. Note that N n may not be a unit vector.  Exercise III.6 The linear transformation of R2 depicted in Figure III.12 is given by the matrix   cid:11    cid:12   M =  1 2 0 0 1  .  Compute the transposes of the adjoint of M and the inverse of M. Prove that, for any line L in R2, these matrices correctly map a vector normal to the line L to a vector normal to the image M L  of the line.  So far, we have only discussed how normal vectors are converted by afﬁne transformations. However, the 4 × 4 homogeneous matrices allowed in OpenGL are more general than just afﬁne transformations, and for these a different construction is needed. Given a 4 × 4 matrix M, let N be the transpose of either the inverse or the adjoint of M. Let n be orthogonal to a plane P. As discussed in Section II.2.5, the plane P in 3-space corresponds to a three- dimensional linear subspace P H of R4 in homogeneous coordinates. Let u be a point on the plane P, and x =  cid:5 x1, x2, x3 cid:6  and y =  cid:5 y1, y2, y3 cid:6  be two noncollinear vectors parallel to P in 3-space. Form the vectors xH =  cid:5 x1, x2, x3, 0 cid:6  and yH =  cid:5 y1, y2, y3, 0 cid:6 . These two vectors, plus uH =  cid:5 u1, u2, u3, 1 cid:6 , span P H. Let n =  cid:5 n1, n2, n3 cid:6  be orthogonal to P, and let nH =  cid:5 n1, n2, n3,−u · n cid:6 . Since nH is or- thogonal to xH, yH, and uH, it is perpendicular to the space P H spanned by these three vectors. Therefore, by exactly the same proof as that of Theorem III.3, we have that N nH is orthog- onal to M P H . Let N nH =  cid:5 n  cid:6  is a vector in 3-space  cid:3   cid:3  , n , n  cid:6  is perpendicular to orthogonal to the 3-space vectors parallel to M P . Therefore,  cid:5 n  cid:3   cid:3   cid:3  3 2 , n , n 3 2 1 the plane M P  in 3-space.   cid:6 . Then clearly,  cid:5 n  , n  , n  , n   cid:3  2   cid:3  1   cid:3  3   cid:3  4   cid:3  1  III.1.8 Light and Material Properties in OpenGL  OpenGL implements the full Phong lighting model with Gouraud interpolation. It supports all the material properties, including the ambient, diffuse, and specular reﬂectivity coefﬁcients and emissivity. Light sources may be given independent ambient, diffuse, and specular intensities, and special effects for lights include spotlighting and distance attenuation.  This section is an outline of how lighting and surface material properties are speciﬁed and controlled in OpenGL. This is only an overview and you should refer to an OpenGL manual such as  Schreiner, 1999; Woo et al., 1999  for more information on the command syntax and operation. In particular, we do not include information on all the variations of the command syntax and only include the more common versions of the commands  usually the ones based on ﬂoating point inputs when appropriate .  Initializing the Lighting Model. By default, OpenGL does not compute Phong lighting effects. Instead, it just uses the color as given by a glColor3f   command to set the   III.1 The Phong Lighting Model  83  vertex color. To enable Phong lighting calculation, use the command  glEnable GL_LIGHTING ;  OpenGL includes eight point light sources; they must be explicitly enabled, or “turned on,” by calling  glEnable GL_LIGHTi ;    'i' should be 0,1,2,3,4,5,6, or 7  The light names are GL_LIGHT0, GL_LIGHT1, and so forth, and any OpenGL imple- mentation should support at least eight lights. Lights can be disabled, or turned off, with the glDisable GL_LIGHTi  command.  By default, OpenGL renders polygons with Gouraud shading. However, Gouraud  shading can be turned off with the command  glShadeModel GL_FLAT ;  In this case, the usual convention is that the color of the last vertex of a polygon is used to color the entire polygon  but see page 12 . The command  glShadeModel  GL_SMOOTH  ;  can be used to turn Gouraud shading back on. Usually, it is best to keep Gouraud shading turned on, but when rendering a faceted object it can be convenient to turn it off.  OpenGL gives you the option of rendering only one side or both sides of polygons. Recall that polygons are given a front face and a back face – usually according to the right-hand rule  see Section I.2.2 for more information . When applying lighting to the back face of a polygon, OpenGL reverses the normal vector direction at each vertex to get the surface normal vector for the back face. Frequently, however, the back faces are not visible or properly lit, and by default OpenGL does not shade the back faces according to the Phong lighting model. To tell OpenGL to use the Phong lighting model for the back faces too, use the command  glLightModeli GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE ;   This can be turned off by using GL_FALSE instead of GL_TRUE.  If the back faces are never visible, you may also want to cull them. For this, see glCullFace in Section I.2.2. OpenGL can use the halfway vector computational shortcut mentioned at the end of Section III.1.2, which sets the light direction vectors  cid:7  and the view direction vector v to be constant vectors independent of vertex positions. To turn this off and allow the view vector v to be recalculated for each vertex position, use the command  glLightModeli GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE ;  To force OpenGL to use constant light direction vectors  cid:7 , make the lights directional rather than positional, using the commands discussed later in this section.  OpenGL’s implementation of Phong lighting assumes that the view position, or camera, is positioned at the origin and, when the local viewer option is not used, that the view direction be oriented down the negative z-axis so that v =  cid:5 0, 0, 1 cid:6 . For this reason, the routines gluPerspective, glFrustum, and glOrtho should be invoked when the projection matrix is the current matrix, but gluLookAt should be invoked when the model view matrix is active.  Vertex Normals and Colors. Recall how glBegin   and glEnd   are used to bracket the speciﬁcation of the geometric objects of points, lines, and polygons. OpenGL requires that all glVertex* commands be inside a glBegin, glEnd pair. In addition to the   84  Lighting, Illumination, and Shading  glVertex* commands giving the positions of vertices, you may also include commands that specify the surface normal and the surface material properties of a vertex. This can be done by commands of the following type:      cid:5 x, y, z cid:6  is the normal    Multiple glMaterial commands OK    Vertex position  glNormal3f  x,y,z  ; glMaterial*  ···  ; glVertex*  ···  ; The glMaterial*   commands are used to specify the reﬂectivity coefﬁcients and the shininess exponent. The syntax of these commands is described later. The effect of a glNormal3f   or a glMaterial*   command is applied to all subsequent glVertex*   commands until it is overridden by another glNormal3f   or glMa- terial*  .  The normal vector speciﬁed with glNormal3f should be a unit vector unless you have instructed OpenGL to normalize unit vectors automatically as described on page 87. , is set by calling the OpenGL  Light Properties. The global ambient light intensity, Iin,global  a  routines as follows:  float color[4] = { r, g, b, a }; glLightModelfv GL_LIGHT_MODEL_AMBIENT, &color[0] ;  Note how the color is passed in as a pointer to a ﬂoat, that is, as the C C++ type float*– in the OpenGL naming scheme, this is indicated by the sufﬁx “fv” on the function name. The “v” stands for “vector.”  The ambient color includes the levels of ambient light intensity for red, green, and blue and also a value for the “alpha” component of light. The alpha component is typically used for blending and transparency effects. We will not discuss it further here but remark only that it is handled just like the other color components until the ﬁnal stage  stage 4  of the rendering pipeline. See Chapter V for more discussion on the uses of the alpha color channel. When specifying colors of lights and materials, OpenGL often requires you to set an alpha value; ordinarily, it is best just to set the alpha color equal to 1.  The positions, or alternatively the directions, of the point light sources are set with the  OpenGL command  float pos[4] = { x, y, z, w }; glLightfv  GL_LIGHTi,GL_POSITION, &pos[0] ;  The position has to be speciﬁed in homogeneous coordinates. If w  cid:16 = 0, then this indicates a positional light placed at the position  cid:5 x w, y w, z w cid:6 . If w = 0, then the light is directional: the directional light is thought of as being placed at inﬁnity in the  cid:5 x, y, z cid:6  direction  not all of x, y, z, w should be zero . The light direction vector  cid:7  is thus equal to the constant vector  cid:5 x, y, z cid:6   recall that the vector  cid:7  points from the surface towards the light opposite to the direction the light is traveling . Note that, unlike the usual situation for homogeneous vectors, the vectors  cid:5 x, y, z, 0 cid:6  and  cid:5 −x,−y,−z, 0 cid:6  do not have the same meaning. Instead they indicate directional lights shining from opposite directions. The default value for lights is that they are directional, shining down the z-axis, that is, the default direction vector is  cid:5 0, 0, 1, 0 cid:6 .  The positions and directions of lights are modiﬁed by the current contents of the model view matrix. Therefore, lights can be placed conveniently using the local coordinates of a model. It is important to keep in mind that the projection matrix does not affect the lights’ positions and directions and that lights will work correctly only if the viewpoint is placed at the origin looking down the negative z-axis.   III.1 The Phong Lighting Model  85  The colors, or, more properly speaking, the light intensity values, of lights are set by  the following OpenGL command:  float color[4] = { r, g, b, a };   GL_AMBIENT  GL_DIFFUSE GL_SPECULAR  , &color[0]  ;  glLightfv GL_LIGHTi,  where the second parameter may be any of the three indicated possibilities. This command sets the values of the light’s Iin intensity vector.2 The ambient light intensity defaults to  cid:5 0, 0, 0, 1 cid:6 . The diffuse and specular light intensities default to  cid:5 1, 1, 1, 1 cid:6  for light 0  GL_LIGHT0  and to  cid:5 0, 0, 0, 0 cid:6  for all other lights.  d , or Iin s  a , Iin  One might wonder why lights include an ambient color value when it would be com- putationally equivalent just to include the lights’ ambient intensities in the global ambient light. The reasons are threefold. First, lights may be turned off and on, and this makes it convenient to adjust the ambient lighting automatically. Second, a light’s ambient light intensity is adjusted by the distance attenuation and spotlight effects discussed later in this section. Finally, the purpose of ambient light is to model light after multiple bounces off of surfaces, and this logically goes with the light itself.  Material Properties. OpenGL’s glMaterial*   commands are used to set the surface material properties. The ambient, diffuse, and specular reﬂectivity coefﬁcients and the emissive intensity can be set by the following commands:  float color[4] = {r, g, b, a };  ,    GL_FRONT GL_BACK  GL_FRONT_AND_BACK  &color[0]  ;  ,  GL_AMBIENT GL_DIFFUSE  GL_SPECULAR GL_EMISSION  glMaterialfv   GL_AMBIENT_AND_DIFFUSE  These set the indicated reﬂectivity coefﬁcient or emissive intensity for either the front surface of polygons, the back surface of polygons, or both surfaces of polygons. The default values are  cid:5 0.2, 0.2, 0.2, 1 cid:6  for ambient reﬂectivity,  cid:5 0.8, 0.8, 0.8, 1 cid:6  for diffuse reﬂectivity, and  cid:5 0, 0, 0, 1 cid:6  for specular reﬂectivity and emissivity.  The specular exponent, or shininess coefﬁcient, is set by a command   , GL_SHININESS,float f  ;  glMaterialf   GL_FRONT GL_BACK  GL_FRONT_AND_BACK  The default value for the specular exponent is 0, and the maximum value is 128.  You can still use glColor*   commands with Phong lighting, but they are less  ﬂexible than the glMaterial*   commands. First you have to call      glEnable GL_COLOR_MATERIAL ;  2 However, before being used to calculate the illumination levels, as in Equation III.9, these light  intensity values may be reduced by a distance attenuation factor or spotlight factor.   86  Lighting, Illumination, and Shading  so that glColor* will affect material properties. Then you can code as follows:  glNormal3f  x, y, z  ; glColor3f  r, g, b  ; glVertex*  ···  ;      cid:5 x, y, z cid:6  is the normal    Change reflectivity parameter s     Vertex position  By default, the preceding glColor*   command changes the ambient and diffuse color of the material; however, this default can be changed with the glColorMaterial   command.  Special Effects: Attenuation and Spotlighting. OpenGL supports both distance attenua- tion and spotlighting as a means of achieving some special effects with lighting. Distance attenuation refers to making the light less intense, that is, less bright, as the distance increases from the light. The formula for the distance attenuation factor is  1  kc + k cid:11 d + kqd2  ,  where d is the distance from the light, and the constant scalars kc, k cid:11  and kq are the constant attenuation factor, the linear attenuation factor, and the quadratic attenuation factor, respectively. All three of the light intensity values, Iin s , are multiplied by the distance attenuation factor before being used in the Phong lighting calculations. The distance attenuation factors are set by the following OpenGL commands:  d , and Iin  a , Iin   GL_CONSTANT_ATTENUATION  GL_LINEAR_ATTENUATION  GL_QUADRATIC_ATTENUATION   , float k  ;  glLightf  GL_LIGHTi,  A spotlight effect can be used to make a positional light act as a narrow beam of light. A spotlight effect is speciﬁed by giving  a  the direction of the spotlight;  b  the cutoff angle, which is the angle of the cone of light from the light source; and  c  a spotlight exponent, which controls how fast the light intensity decreases away from the center of the spotlight. The spotlight direction is set by the commands  float dir[3] = { x, y, z }; glLightfv  GL_LIGHTi, GL_SPOT_DIRECTION, &dir[0]  ;  The spotlight direction is modiﬁed by the model view matrix in exactly the same way that vertex normals are.  The spotlight cutoff angle controls the spread of the spotlight. A cutoff angle of θ speciﬁes that the light intensity drops abruptly to zero for any direction more than θ degrees away from the spotlight direction. The spotlight cutoff angle is set by the command  glLightf GL_LIGHTi, GL_SPOT_CUTOFF, float θ  ;  where, as usual for OpenGL, the angle is measured in degrees.  The spotlight exponent is used to reduce the intensity of the spotlight away from the center direction. The intensity of the light along a direction at an angle ϕ from the center of the spotlight  where ϕ is less than the spotlight cutoff angle  is reduced by a factor of  cos ϕ c, where the constant c is the spotlight exponent. The command to set a spotlight exponent is  glLightf GL_LIGHTi, GL_SPOT_EXPONENT, float c  ;   III.2 The Cook–Torrance Lighting Model  87  Normalizing Normal Vectors. By default, OpenGL treats normal vectors by assuming that they are already unit vectors and transforming them by the current model view matrix. As discussed in Section III.1.7, this is ﬁne as long as the model view matrix holds a rigid transformation. However, this is not acceptable if the model view matrix holds a more general transformation, including a scaling transformation or a shear.  To make OpenGL transform normals by the procedure described in Section III.1.7,  you must give the command  glEnable  GL_NORMALIZE  ;  This command should be given if you either use nonunit vectors with glNormal3f   or nonrigid transformations.  The latest version of OpenGL  version 1.2  has a new normalization option  glEnable  GL_RESCALE_NORMAL  ;  that rescales normal vectors under the assumption that the normal given with glNor- mal3f   is a unit vector and that the model view matrix consists of a rigid transformation composed with a uniform scaling, where the same scaling factor is used in all directions. This is considerably faster than the full GL_NORMALIZE option, which needs to compute the transpose of the inverse and then normalize the vector.  III.2 The Cook–Torrance Lighting Model   cid:1   The Cook–Torrance lighting model is an alternative to Phong lighting that can better capture reﬂectance properties of a wider range of surface materials. The Cook–Torrance lighting model was introduced by  Cook and Torrance, 1982  based partly on a lighting model developed by  Blinn, 1973 . The Cook–Torrance lighting model incorporates the physical properties of reﬂection more fully than the Phong lighting model by using a microfacet model for rough surfaces and by incorporating the Fresnel equations in the calculation of reﬂection intensities. It thus can better handle rough surfaces and changes in reﬂection due to grazing view angles. In particular, the Cook–Torrance lighting model can be used to render metallic surfaces better than can be done with the Phong lighting model.  Several other local lighting models exist besides the Phong and the Cook–Torrance model.  He et al., 1991  have described a model that extends the Cook–Torrance model to include more physical aspects of light reﬂection. Another popular model by  Schlick, 1994  incorpo- rates many features of the physically based models but is more efﬁcient computationally.  III.2.1 Bidirectional Reﬂectivity  The central part of any local lighting model is to compute how light reﬂects off of a surface. To state this in a general form, we assume that a beam of light is shining on a point of the surface from the direction pointed to by a unit vector  cid:7  and that we wish to compute the intensity of the light that is reﬂected in the direction of a unit vector v. Thus, the light reﬂectance calculation can be reduced to computing a single bidirectional reﬂectivity function, BRIDF. The initials “BRIDF” actually stand for “bidirectional reﬂected intensity distribution function.” The parameters to the BRIDF function are  a  the incoming direction  cid:7 ;  b  the outgoing direction v,  c  the color or wavelength λ of the incoming light, and  d  the properties of the reﬂecting surface, including its normal and orientation. We write the BRIDF function   88  Lighting, Illumination, and Shading  ,in λ  I   cid:11   n  ,out  I λ  v  Figure III.13. The BRIDF function relates the outgoing light intensity and the incoming light intensity according to BRIDF  cid:7 , v, λ  = I λ,out I λ,in.  as just  BRIDF  cid:7 , v, λ ,  to signify a function of the light and view directions, and of the wavelength, suppressing in the notation the dependence on the surface properties. The value BRIDF  cid:7 , v, λ  is intended to be the ratio of the intensity of the outgoing light in the direction v to the intensity of the incoming light from the direction pointed to by  cid:7 .3 As shown in Figure III.13, the bidirectional reﬂectivity function is deﬁned by BRIDF  cid:7 , v, λ  = I λ,out I λ,in  .  An important characteristic of the BRIDF function is that the incoming and outgoing directions are completely arbitrary, and in particular, the outgoing direction v does not have to be in the direction of perfect reﬂection. By expressing the BRIDF function in this general form, one can deﬁne BRIDF functions for anisotropic surfaces, where the reﬂectance function is not circularly symmetric around the perpendicular. An example of an anisotropic surface would be a brushed metal surface that has parallel grooves: light will reﬂect from such a surface differently depending on the orientation of the incoming direction relative to the orientation of the grooves. Other examples of anisotropic surfaces include some types of cloth, where the weave pattern may create directional dependencies in reﬂection. Still other examples include hair, feathers, and fur. We will not consider anisotropic surfaces in this book, but the interested reader can consult  Kajiya, 1985  for an early treatment of anisotropic surfaces in computer graphics.  The bidirectional reﬂectivity function can be computed in several ways. First, if one is trying to simulate the appearance of a physical, real-world surface, the most direct way would be to perform experiments measuring the reﬂectivity function. This would require shining light from various directions and of various wavelengths onto a sample of the material and measuring the levels of reﬂected light in various directions.  Devices that perform these measurements are called goniometers.  Interpolation could then be used to ﬁll in the values of the BRIDF function between the measured directions. In principle, this would give an accurate calculation of the  3 We are following  Trowbridge and Reitz, 1975  in using the BRIDF function, but many authors prefer to use a closely related function, BRDF  cid:7 , v, λ  instead. The BRDF function is called the “bidirectional reﬂectivity distribution function.” These two functions are related by  BRIDF  cid:7 , v, λ  = BRDF  cid:7 , v, λ  ·  n ·  cid:7  .  Here, n is the unit surface normal, and so n ·  cid:7  is the cosine of the angle between the surface normal and the incidence vector. Thus, the only difference between the two functions is that the BRIDF takes into account the reduction in intensity  per unit surface area  due to the angle of incidence, whereas the BRDF does not.   III.2 The Cook–Torrance Lighting Model  89  I1  I2  Figure III.14. A microfacet surface consists of small ﬂat pieces. The horizontal line shows the average level of a ﬂat surface, and the microfacets show the microscopic shape of the surface. Dotted lines show the direction of light rays. The incoming light can either be reﬂected in the direction of perfect mirror-like reﬂection  I1  or can enter the surface  I2 . In the second case, the light is modeled as eventually exiting the material as diffusely reﬂected light.  bidirectional reﬂectivity function. In practice, the physical measurements are time consuming and inconvenient at best. And of course, physical measurements cannot be performed for materials that do not physically exist. There are published studies of reﬂectivity functions: these are typically performed at various wavelengths but usually only from perpendicular illumination and viewing directions.  A second way to calculate bidirectional reﬂectivity functions is to create a mathematical model of the reﬂectivity of the surface. We have already seen one example of this, namely, the Phong lighting model, which gives a simple and easy way to compute bidirectional reﬂectivity function. The Cook–Torrance model, which we discuss in detail in Section III.2.2, is another similar model but takes more aspects of the physics of reﬂection into account and thereby captures more features of reﬂectance.  The bidirectional reﬂectivity function is only an idealized model of reﬂection. To make physical sense of the way we have deﬁned bidirectional reﬂectivity, one has to let the sur- face be an inﬁnite ﬂat surface and the distances to the light source and the viewer tend to inﬁnity. Several more sophisticated local lighting models have been developed since the Cook–Torrance model. These models take into account more detailed aspects of the physics of reﬂectivity, such as subsurface scattering, polarization, and diffraction. To handle polariza- tion, the BRIDF function needs to be redeﬁned so as to incorporate polarization parameters  cf.  Wolff and Kurlander, 1990  .  III.2.2 Overview of Cook–Torrance   cid:1   The Cook–Torrance model and the earlier Blinn model are based on a microfacet model for surface reﬂection. According to this model, a surface consists of small ﬂat pieces called facets. A one-dimensional cross section of a microfacet surface is shown in Figure III.14. The assumption is then made that light hitting a microfacet can either be immediately reﬂected or can enter into the surface. The light that is immediately reﬂected is presumed to reﬂect off the microfacet in the direction of perfect reﬂection, that is, in the direction of reﬂection from a mirror parallel to the microfacet. Light that is refracted and enters into the surface through the microfacet is assumed to penetrate deeper into the material and to reﬂect around inside the surface several times before exiting the surface. This portion of the light that is refracted and undergoes multiple reﬂections inside the material will exit the surface in an unpredictable direction. Thus, this part of the light is treated as being diffusely reﬂected.  Just like the Phong model, the Cook–Torrance model treats reﬂection as being composed of separate ambient, diffuse, and specular components. The ambient and diffuse components are essentially the same in the Cook–Torrance model as in the Phong lighting model. Thus, in   90  Lighting, Illumination, and Shading  the Cook–Torrance model, reﬂected light at a given wavelength can be expressed by  I = Ia + Id + Is = ρa I in + ρd I in  a  d   cid:7  · n  + Is.  Is =  n ·  cid:7    n · v   s F G D · I in  ,  s  This is the same as in the Phong model  see Equation III.6  except that now the specularly reﬂected light will be calculated differently.  The calculation for specular light has the form  where n is the unit vector normal to the surface, s is a scalar constant, and F, G, and D are scalar-valued functions that will be explained below. The constant s is used to scale the brightness of the specular reﬂection. Including the multiplicative factor n ·  cid:7  has the effect of converting the incoming light intensity into the incoming light energy ﬂux per unit surface area; that is to say, the value  n ·  cid:7  I in measures the amount of light energy hitting a unit area of the surface. Similarly,  n · v Is measures the amount of light energy leaving a unit area of the surface, and for this reason we need to include the division by n · v. Thus, the quantity s · F · G · D is the ratio of the energy hitting a unit area of the surface from the direction of  cid:7  to the energy leaving the unit area in the direction of v. The function D = D  cid:7 , v  measures the distribution of the microfacets, namely, it equals the fraction of microfacets that are oriented correctly for specular reﬂection from the direction of  cid:7  to the direction v. Possible functions for D are discussed in Section III.2.3. The G = G  cid:7 , v  function measures the diminution of reﬂected light due to shadowing and masking, where the roughness of the surface creates shadowing that prevents reﬂection. This geometric term will be discussed in Section III.2.4. The function F = F  cid:7 , v, λ  is the Fresnel coefﬁcient, which shows what percentage of the incidence light is reﬂected. The Fresnel term is discussed in Section III.2.5.  The Fresnel coefﬁcient is particularly important because it can be used to create the effect that light reﬂects more specularly at grazing angles than at angles near vertical. This kind of effect is easy to observe; for instance, a piece of white paper that usually reﬂects only diffusely will reﬂect specularly when viewed from a very oblique angle. An interesting additional effect is that the Fresnel term can cause the angle of greatest reﬂection to be different than the direction of perfect mirror-like reﬂection. The Fresnel term F, unlike the D and G functions, is dependent on the wavelength λ. This causes the color of specular reﬂections to vary with the angles of incidence and reﬂection.  In our description of the Cook–Torrance model, we have not followed exactly the con- ventions of  Blinn, 1973  and  Cook and Torrance, 1982 . They did not distinguish between diffuse and specular incoming light but instead assumed that there is only one kind of incoming light. They then used a bidirectional reﬂectivity function of the form  BRIDF = d · ρd n ·  cid:7   + s ·  n ·  cid:7    n · v   F G D,  where d and s are scalars, with d + s = 1, that control the fraction of diffuse versus specular reﬂection. We have changed this aspect of their model since it makes the model a little more general and also for the practical reason that it allows Cook–Torrance lighting to coexist with Phong lighting in the ray-tracing software described in Appendix B.   III.2 The Cook–Torrance Lighting Model  91   cid:1   III.2.3 The Microfacet Distribution Term The microfacet model assumes that light incident from the direction of  cid:7  is specularly reﬂected independently by each individual microfacet. Hence, the amount of light reﬂected in the direc- tion v is deemed to be proportional to the fraction of microfacets that are correctly oriented to cause mirror-like reﬂection in that direction. To determine the direction of these microfacets, recall that the halfway vector was deﬁned by  h = v +  cid:7  v +  cid:7    see Figure III.8 on page 73 . For a microfacet to be oriented properly for perfect reﬂection, the normal pointing outward from the microfacet must be equal to h. We let ψ equal the angle between h and the overall surface normal n, that is, ψ = cos −1 h · n . Then, we use the function D = D ψ  to equal the fraction of microfacets that are correctly oriented for perfect reﬂection. There are several functions that have been suggested for D. One possibility is the Gaussian distribution function  where c and m are positive constants. Another possibility is the Beckmann distribution  D ψ  = ce  −ψ 2 m2 ,  D ψ  =  1  − tan2 ψ  m2 ,  e  π m2 cos4 ψ  where again m is a constant. The Beckmann distribution is based on a mathematical model for a rough one-dimensional surface where the height of the surface is a normally distributed √ function and the autocorrelation of the surface makes the root mean value of the slope equal to m  2. This sounds complicated, but what it means is that the constant m should be chosen to be approximately equal to the average slope of  microfacets of  the surface.4 Bigger values of m correspond to rougher, more bumpy surfaces.  III.2.4 The Geometric Surface Occlusion Term   cid:1   The geometric term G in the Cook–Torrance model computes the fraction of the illuminated portion of the surface that is visible to the viewer, or, to be more precise, the geometric term computes the fraction of the light specularly reﬂected by the microfacets that is able to reach the viewer. Because the surface is rough and bumpy, it is probable that some of the illuminated area of the surface is not visible to the viewer, and this can reduce the amount of visible specularly reﬂected light.  To derive a formula for the geometric term, we make two simplifying assumptions. The ﬁrst assumption is that the vectors  cid:7 , n, and v are coplanar. We call this plane the plane of reﬂection. At the end of this section, we discuss how to remove this coplanarity assumption. The second, and more important, assumption is that the microfacets on the surface are arranged as symmetric ‘V’-shaped grooves. These grooves are treated as being at right angles to the plane of reﬂection. In effect, this means we are adopting a one-dimensional model for the surface. We further assume that the tops of the grooves are all at the same height, that is, that the surface is obtained from a perfectly ﬂat surface by etching the grooves into the surface. A view of the grooves is shown in Figure III.15.  4 See  Beckmann and Spizzichino, 1963  for more details, including the details of the mathematical  models.   92  Lighting, Illumination, and Shading  Figure III.15. For the derivation of the geometric term G, the microfacets are modeled as symmetric, ‘V’-shaped grooves with the tops of the grooves all at the same height. The horizontal line shows the overall plane of the surface.  The assumption about the microfacets being ‘V’-shaped may seem rather drastic and un- justiﬁed, but the reason for the assumption is that it simpliﬁes the calculation of the geometric factor G. In addition, it is hoped that the simpliﬁed model will qualitatively match the behavior of more complicated surfaces fairly well.  Some different kinds of specularly reﬂected light occlusion are illustrated in Figure III.16. Since the tops of the grooves are all at the same height, each groove may be considered independently. In Figure III.16, light is shown coming in from the direction pointed to by  cid:7  and is reﬂected specularly in the direction of v. This means that the side of the groove must have the normal vector equal to the halfway vector h. In part  a  of the ﬁgure, the light falls fully onto the groove, and the entire groove is visible to the viewer. In part  b , the reﬂecting side of the groove is partly occluded by the other side, and thus some of the reﬂected light hits the opposite side of the groove and does not reach the viewer. In this case, we say that masking has occurred. In part  c , the reﬂecting side of the groove is partly shadowed by the other side of the groove so that the reﬂecting side of the groove is not fully illuminated: we call this shadowing. Finally, in part  d , both shadowing and masking are occurring.  v   cid:7    cid:7   h cid:1    cid:7   v  v  h cid:1   h  h   a  No shadowing or masking.   b  Only masking.  v   cid:7   h cid:1   h  h cid:1   h   c  Only shadowing.   d  Both shadowing and masking.  Figure III.16. Shadowing and masking inside a single groove. The ‘V’ shape represents a groove; the unit vector h is normal to the facet where specular reﬂection occurs. Light from the direction of  cid:7  is specularly reﬂected in the direction v.   III.2 The Cook–Torrance Lighting Model  93  v   cid:7   Figure III.17. Shadowing without masking does not reduce the intensity of the reﬂected light.  The usual formulation of the Cook–Torrance model calculates the percentage of light that is not shadowed and the percentage of the light that is not masked and uses the minimum of these for the G term. However, this usual formulation is incorrect because shadowing by itself should not cause any reduction in the intensity of reﬂected light. This is shown in Figure III.17, where the incoming light is partially shadowed, but, nonetheless, all of the incoming light is reﬂected to the viewer. Figure III.17 shows all the grooves having the same slope so as to make the situation clearer, but the same effect holds even if different grooves have different slopes  since the D term is used for the fraction of microfacets at a given slope, the G term does not need to take into account grooves that do not lead to perfect reﬂection .  Therefore, we present a version of the geometric term G that is different from the term used by  Blinn, 1973  and  Cook and Torrance, 1982  in that it uses a more correct treatment of shadowing. First, we need a geometric lemma due to  Blinn, 1973 . This lemma will serve as the basis for calculating the fraction of the groove that is masked or shadowed. As stated with v, the lemma computes the fraction that is not masked  if there is any masking , but replacing v with  cid:7  gives the formula for the fraction of the groove that is not shadowed  if there is any shadowing . Lemma III.4 Consider the situation in Figure III.18. Let AB be the distance from A to B, and so forth. Then,  AC = 2 n · h  n · v  BC  h · v   .  To prove the lemma, and for subsequent algorithms, it will be useful to deﬁne the vector h to be the unit vector that is normal to the opposite side of the groove. By the symmetry of the  III.15   cid:3   C  B  β  v  h  A  D  α  h cid:1   n  Figure III.18. The situation for Lemma III.4. The edges AC and AD form a symmetric groove, and AC and AD are of equal length. The vector n points upward, and the vector v is in the direction from B to D. The vectors h and h are normal to the sides of the groove. All four vectors are unit vectors. The ratio of BC to AC measures the fraction of the groove that is not masked.   cid:3    94  Lighting, Illumination, and Shading  groove, the vector h  is easily seen to equal   cid:3    cid:3  = 2 n · h n − h. h We now prove the lemma.  III.16   cid:1   Proof From the symmetry of the groove and the law of sines, we have  AB AC = AB  AD = sin α  .  Clearly, we have sin α = cos  π using Equation III.16, we get BC AC = 1 − AB  2  and the lemma follows immediately.  AC = 1 + v ·  2 n · h n − h   v · h  ,  sin β − α  = −v · h   cid:3   . Similarly, we have sin β = v · h. From this,  With the aid of the lemma, we can now give a formula for the geometric term that describes the reduction in reﬂection due to masking. First, we note that masking occurs if, and only if, v · h  cid:3  < 0. To see this, note that v · h  cid:3  is facing towards the viewer. When masking occurs, the fraction of the side of the groove that is not masked is given by Equation III.15 of the lemma.  cid:3  < 0. By Lemma III.4,  For similar reasons, shadowing occurs if and only if we have  cid:7  · h   cid:3  is positive only if the vector h  with v replaced by  cid:7 , the fraction of the side of the groove that is not shadowed is equal to  2 n · h  n ·  cid:7     h ·  cid:7    .  G = 2 n · h  n · v   .   h · v   cid:12    cid:11    cid:11     G =   h · v   1 2 n · h  n · v  n · v n ·  cid:7   We can now describe how to compute the geometric factor G. In the case in which there is neither masking nor shadowing, we set G equal to 1. When there is masking, but no shadowing, we set G equal to the fraction of the reﬂected light that is not masked, that is,  In the case in which both masking and shadowing occur, as illustrated in Figure III.16 d , we set G to equal the fraction of the reﬂected light that is not masked. This means that we set G equal to the ratio  note that h · v = h ·  cid:7  by the deﬁnition of h    cid:12   2 n · h  n · v    h · v   ÷  2 n · h  n ·  cid:7     h ·  cid:7    = n · v n ·  cid:7   if this value is less than 1. This is the case illustrated in part  d  of Figure III.16 d , and we are setting G equal to the ratio of the nonmasked amount to the nonshadowed amount. However, if the fraction is ≥ 1, then none of the nonshadowed part is masked, and so we just set G = 1.  To summarize, the geometric term G is deﬁned by  if v · h if v · h if v · h   cid:3  ≥ 0 or n · v ≥ n ·  cid:7   cid:3  < 0 and  cid:7  · h  cid:3  ≥ 0  cid:3  < 0,  cid:7  · h   cid:3  < 0, and n · v < n ·  cid:7 .   III.2 The Cook–Torrance Lighting Model  95  The formula for the geometric term was derived from a one-dimensional model of ‘V’- shaped grooves. Although this assumption that the facets are arranged in grooves is unrealistic, it still works fairly well as long the vectors  cid:7 , v, and n are coplanar. However, the formula breaks down when these vectors are not coplanar because the derivation of the formula for G made assumptions about how h, h , and n interact that are no longer valid in the noncoplanar case. The coplanar case is actually quite common; for instance, these vectors are always coplanar in  nondistributed  ray tracing, as we will see in Chapter IX, since basic ray tracing follows rays in the direction of perfect mirror-like reﬂection.   cid:3   In the noncoplanar case, we suggest that the vector n be replaced by projecting  actually, rotating  it down to the plane containing  cid:7  and v. That is to say, instead of n, we use a unit vector m that is parallel to the projection of n onto the plane containing  cid:7  and v. The vector h is still computed as usual, but now h is computed using m instead of n. It is not hard to see that the projection of n onto the plane is equal to   cid:3   n0 =  n ·  cid:7   cid:7  +  n · v v −  v ·  cid:7   v · n  cid:7  −  v ·  cid:7    cid:7  · n v  III.17 Then, m = n0 n0. In the extreme case, where v and  cid:7  are both perpendicular to n, this gives a divide by zero, but this case can be handled by instead setting n0 = v +  cid:7 .  1 −  v ·  cid:7  2  Putting this together gives the following algorithm for the case in which v,  cid:7 , and n are not  .  coplanar:  ComputeG  n,  cid:7 , v   {  If    cid:7  + v == 0   {    if v ·  cid:7  == −1  Set G = 1; Return   G  ;   cid:16 = 0   {  Set m = n0 n0;  } Set h =   cid:7  + v    cid:7  + v ; Set n0 =  n ·  cid:7   cid:7  +  n · v v −  v ·  cid:7   v · n  cid:7  −  v ·  cid:7    cid:7  · n v; If   n0 } Else { } Set h  = 2 m · h m − h;  Set m = h;   cid:3     Set G =  1 2 m · h  m · v  m · v m ·  cid:7  Return   G  ;   h · v   }  if v · h if v · h   cid:3  ≥ 0 or m · v ≥ m ·  cid:7   cid:3  < 0 and  cid:7  · h  cid:3  ≥ 0  otherwise.  Although it is not part of the Cook–Torrance model, it is possible to use the geometric term to affect the diffuse part of the reﬂection too.  Oren and Nayar, 1994; 1995  use the same ‘V’-shaped groove model of surface roughness to compute masking and shadowing effects for diffuse lighting; this allows them to render non-Lambertian surfaces.   96  Lighting, Illumination, and Shading  Exercise III.7  Derive the formula III.17 for n0.   cid:1   III.2.5 The Fresnel Term   cid:1   F  cid:7 , v, λ  = F ϕ, η ,  The Fresnel equations describe what fraction of incident light is specularly reﬂected from a ﬂat surface. For a particular wavelength λ, this can be deﬁned in terms of a function F  where ϕ = cos −1  cid:7  · h  is the angle of incidence, and η is the index of refraction of the surface. Here, ϕ is the angle of incidence of the incoming light with respect to the surface of the microfacets, not with respect to the overall plane of the whole surface. The index of refraction is the ratio of the speed of light above the surface to the speed of light inside the surface material and is discussed in more detail in Section IX.1.2 in connection with Snell’s law. For materials that are not electrically conducting, Fresnel’s law states that the fraction of light intensity that is specularly reﬂected is equal to   cid:31   F = 1 2  sin2 ϕ − θ  sin2 ϕ + θ   + tan2 ϕ − θ  tan2 ϕ + θ      ,  where ϕ is the angle of incidence and θ is the angle of refraction.  We are not concerned with the portion of the light that is refracted, but the angle of refraction still appears in the Fresnel equation.  This form of the Fresnel equation applies to unpolarized light and is obtained by averaging the two forms of the Fresnel equations that apply to light polarized in two different orientations. The angles of incidence and refraction are related by Snell’s law, which states that  = η.  sin ϕ sin θ  c = cos ϕ  Let   cid:20  η2 + c2 − 1 .  g =  and  III.19 The most common situation is that η > 1, and in this case η2 + c2 − 1 > 0; thus, g is well deﬁned.5 A little work shows that g = η cos θ, and then using the trigonometric angle sum and difference formulas it is not hard to see that  sin ϕ − θ  sin ϕ + θ   =  g − c   g + c   and  cos ϕ − θ  cos ϕ + θ   .  =  c g − c  + 1   c g + c  − 1   cid:11  1 + [c g + c  − 1]2 [c g − c  + 1]2   g − c 2  g + c 2   cid:12   .  F = 1 2  This lets us express the Fresnel equation III.18 in the following, easier to compute form:  III.18  III.20  III.21  III.22  5 However, the η < 1 case can arise in ray tracing when transmission rays are used, as described in Chapter IX. In that case, the condition η2 + c2 − 1 ≤ 0 corresponds to the case of total internal reﬂection. For total internal reﬂection, you should just set F equal to 1.   III.2 The Cook–Torrance Lighting Model  97  Gold: Iridium: Iron: Nickel: Copper: Platinum: Silver:  Red Green Blue 0.93 0.38 0.26 0.26 0.43 0.44 0.36 0.50 0.93 0.46 0.57 0.63 0.97 0.96  0.88 0.28 0.435 0.47 0.80 0.62 0.97  Figure III.19. Experimentally measured reﬂectances for perpendicularly incident light. Values are based on  Touloukian and Witt, 1970 .  The preceding form of the Fresnel equation makes several simplifying assumptions. First, the incoming light is presumed to be unpolarized. Second, conducting materials such as metals need to use an index of refraction that has an imaginary component called the extinction coefﬁcient. For simplicity, the Cook–Torrance model just sets the extinction coefﬁcient to zero. If the index of refraction η is known, then Equations III.19 and III.22 provide a good way to compute the reﬂectance F. On the other hand, the Fresnel equation is sometimes used in the context of ray tracing, and in that setting a slightly more efﬁcient method can be used. For this, refer to Section IX.1.2. That section has a vector v giving the direction from which the light arrives and describes a method for computing the transmission direction t. Then, we can calculate c = cos ϕ = v · n and g = η cos θ = −ηt · n, instead of using Equation III.19. Prove that the reﬂectance F can also be computed by the formula η cos θ − cos ϕ η cos θ + cos ϕ  Exercise III.8 F = 1 2  η cos ϕ − cos θ η cos ϕ + cos θ   cid:12 2 +  ! cid:11    cid:12 2   cid:11   "  III.23   cid:1   .  [Hint: Use Equation III.20 and use trignometry identities to show  tan ϕ − θ  tan ϕ + θ   = η cos ϕ − cos θ η cos ϕ + cos θ  .]  III.24  This still leaves the question of how to ﬁnd the value of η, and Cook and Torrance suggest the following procedure for determining an index of refraction for metals. They ﬁrst note that for perpendicularly incident light, ϕ = θ = 0; thus, c = 1, g = η, and   cid:11    cid:12 2  .  F =  η − 1 η + 1 η = 1 + √F 1 − √F .  Solving for η in terms of F gives  III.25 Reﬂectance values F for perpendicularly incident light have been measured for many mate- rials  see  Touloukian and Witt, 1970; 1972; Touloukian, Witt, and Hernicz, 1972  . Given a reﬂectance value for perpendicularly incident light, Equation III.25 can be used to get an approximate value for the index of refraction. This value for η can then be used to calculate the Fresnel term for light incident at other angles. Figure III.19 shows reﬂectance values F for a few metals. These values are estimated from the graphs in  Touloukian and Witt, 1970    98  Lighting, Illumination, and Shading  Figure III.20. Metallic tori with the specular component computed using the Cook–Torrance model. The materials are, from top to bottom, gold, silver, and platinum. The roughness is m = 0.4 for all three materials. The tori are each illuminated by ﬁve positional white lights. See Color Plate 16.  at red, green, and blue color values that correspond roughly to the red, green, and blue colors used by standard monitors.  Figures III.20 and V.8 show some examples of roughened metals rendered with the Cook– Torrance model. As can be seen from the ﬁgures, the Cook–Torrance model can do a fairly good job of rendering a metallic appearance, although the colors are not very accurate  and in any event, the colors in these ﬁgures have not been properly calibrated . The Cook–Torrance model works less well on shiny metals with low roughness.   IV  Averaging and Interpolation  This chapter takes up the subject of interpolation. For the purposes of the present chapter, the term “interpolation” means the process of ﬁnding intermediate values of a function by aver- aging its values at extreme points. Interpolation was already studied in Section II.4, where it was used for Gouraud and Phong interpolation to average colors or normals to create smooth lighting and shading effects. In Chapter V, interpolation is used to apply texture maps. More sophisticated kinds of interpolation will be important in the study of B´ezier curves and B-splines in Chapters VII and VIII. Interpolation is also very important for animation, where both positions and orientations of objects may need to be interpolated.  The ﬁrst three sections below address the simplest forms of interpolation; namely, linear interpolation on lines and triangles. This includes studying weighted averages, afﬁne combi- nations, extrapolation, and barycentric coordinates. Then we turn to the topics of bilinear and trilinear interpolation with an emphasis on bilinear interpolation, including an algorithm for inverting bilinear interpolation. The next section has a short, abstract discussion on convex sets, convex hulls, and the deﬁnition of convex hulls in terms of weighted averages. After that, we take up the topic of weighted averages performed on points represented in homogeneous coordinates. It is shown that the effect of the homogeneous coordinate is similar to an extra weighting coefﬁcient, and as a corollary, we derive the formulas for hyperbolic interpolation that are important for accurate interpolation in screen-space coordinates. The chapter con- cludes with a discussion of spherical linear interpolation  “slerping” , which will be used later for quaternion interpolation.  The reader may wish to skip many of the topics in this chapter on ﬁrst reading and return  to them as needed for topics taken up in later chapters.  IV.1 Linear Interpolation  IV.1.1 Interpolation between Two Points  Suppose that x1 and x2 are two distinct points, and consider the line segment joining them. We wish to parameterize the line segment between the two points by using a function x α  that maps the scalar α to a point on the line segment x1x2. We further want x 0  = x1 and x 1  = x2 and want x α  to interpolate linearly between x1 and x2 for values of α between 0 and 1.  Therefore, the function is deﬁned by  x α  =  1 − α x1 + αx2.  IV.1  99   100  α = −1  x1 α=0 α= 1  3  x2 α = 1 α = 1 1  2  Averaging and Interpolation  Figure IV.1. Interpolated and extrapolated points for various values of α. For α < 0, x α  is to the left of x1. For α > 1, x α  is to the right of x2. For 0 < α < 1, x α  is between x1 and x2.  Equivalently, we can also write x α  = x1 + α x2 − x1 ,  IV.2 where, of course, x2 − x1 is the vector from x1 to x2. Equation IV.1 is a more elegant way to express linear interpolation, but the equivalent formulation IV.2 makes it clearer how linear interpolation works.  We can also obtain points by extrapolation, by letting α be outside the interval [0, 1]. Equation IV.2 makes it clear how extrapolation works. When α > 1, the point x α  lies past x2 on the line containing x1 and x2. And, when α < 0, the point x α  lies before x1 on the line. All this is illustrated in Figure IV.1. Now we consider how to invert the process of linear interpolation. Suppose that the points x1, x2, and u are given and we wish to ﬁnd α such that u = x α . Of course, this is possible only if u is on the line containing x1 and x2. Assuming that u is on this line, we solve for α as follows: From Equation IV.2, we have that  u − x1 = α x2 − x1 .  α =  u − x1  ·  x2 − x1   .   x2 − x1 2  Taking the dot product of both sides of the equation with the vector x2 − x1 and solving for α, we obtain1  This formula for α is reasonably robust and will not have a divide-by-zero problem unless x1 = x2, in which case the problem was ill-posed. It is easy to see that if u is not on the line containing x1 and x2, then the effect of formula IV.3 is equivalent to ﬁrst projecting u onto the line and then solving for α.  Exercise IV.1 Let x1 =  cid:5 −1, 0 cid:6  and x2 =  cid:5 2, 1 cid:6 . Let α control the linear interpolation  and extrapolation  from x1 to x2. What points are obtained with α equal to −2, −1, 0, 1 10 ,  cid:6 ? The point  cid:5 8, 3 cid:6 ? Graph your 2 , 1, 1 1 3 , 1 1 answers.  2 , and 2? What value of α gives the point  cid:5 1, 2  3  Now we extend the notion of linear interpolation to linearly interpolating a function on the line segment x1x2. Let f  u  be a function, and suppose that the values of f  x1  and f  x2  are known. To linearly interpolate the values of f  u , we express u as u =  1 − α x1 + αx2. Then linear interpolation for f yields  f  u  =  1 − α  f  x1  + α f  x2 .  This method works equally well when the function f is vector-valued instead of scalar-valued. For instance, in Gouraud interpolation, this method was used to interpolate color values. However, it does not work quite so well for Phong interpolation, where normals are interpolated, since the interpolated vectors have to be renormalized.  IV.3  IV.4  1 We write v2 for v · v = v2. So  x2 − x1 2 means the same as x2 − x12.   IV.1 Linear Interpolation  101  Equation IV.4 can also be used when α is less than zero or greater than one to extrapolate  values of f .  The process of interpolating a function’s values according to Formula IV.4 is often referred to as “lerping.” “Lerp” is short for “Linear intERPolation.” Occasionally, when we want to stress the use of interpolation, we use the notation  lerp x, y, α  =  1 − α x + αy.  Thus, Formula IV.4 could be written as f  u  = lerp  f  x1 , f  x2 , α .  IV.1.2 Weighted Averages and Afﬁne Combinations  The next two deﬁnitions generalize interpolation to interpolating between more than two points.  Deﬁnition Let x1, x2, . . . , xk be points. Let a1, a2, . . . , ak be real numbers; then  is called a linear combination of x1, . . . xk.  a1x1 + a2x2 + ··· + akxk  cid:28   cid:28  i=1 ai = 1, the expression IV.5 is called an afﬁne i=1 ai = 1 and, in addition, each ai ≥ 0, then expression IV.5 is called a weighted  If the coefﬁcients sum to 1, that is, if  combination of x1, . . . , xk.  IV.5  If  k  k  average of x1, . . . , xk.  Theorem IV.1 Afﬁne combinations are preserved under afﬁne transformations. That is, if  f x1, . . . , xk  = a1x1 + a2x2 + ··· + akxk  is an afﬁne combination, and if A is an afﬁne transformation, then  f A x1 , A x2 , . . . , A xk   = A f x1, x2, . . . , xk  .  Theorem IV.1 will turn out to be very important for B´ezier curves and B-splines  as deﬁned in Chapters VII and VIII . B´ezier curves and B-spline curves will be deﬁned as afﬁne combi- nations of points called “control points,” and Theorem IV.1 tells us that arbitrary rotations and translations of the control points just rotate and translate the spline curves in exactly the same way.  Proof Recall from Chapter II that the afﬁne transformation A can be written as  A x  = B x  + A 0 ,  where B is a linear transformation. Then,  A a1x1 + a2x2 + ··· + akxk  = B a1x1 + a2x2 + ··· + akxk  + A 0  = a1 B x1  + a2 B x2  + ··· + ak B xk  + A 0   = a1 B x1  + a2 B x2  + ··· + ak B xk  + k cid:27   ai A 0   i=1  = a1 B x1  + a1 A 0  + a2 B x2  + a2 A 0  + ··· + ak B xk  + ak A 0  = a1 A x1  + a2 A x2  + ··· + ak A xk .   102  Averaging and Interpolation  The second equality above uses the linearity of B, and the third equality uses the fact that the  cid:1  combination is afﬁne.  cid:1   By deﬁnition, a function f x  is preserved under afﬁne combinations if  Exercise IV.2 and only if, for all α and all x1 and x2,  f  1 − α x1 + αx2  =  1 − α f x1  + αf x2 .   cid:1   Show that any function preserved under afﬁne combinations is an afﬁne transformation. [Hint: Show that f x  − f 0  is a linear transformation.] Show that any vector-valued function f x1, x2  preserved under afﬁne Exercise IV.3 transformations is an afﬁne combination. [Hint: Any such function is fully determined by the value of f 0, i .] Remark: This result holds also for functions f with more than two inputs as long as the number of inputs is at most one more than the dimension of the underlying space.  Theorem IV.1 states that afﬁne transformations preserve afﬁne combinations. On the other hand, perspective transformations do not in general preserve afﬁne combinations. Indeed, if we try to apply afﬁne combinations to points expressed in homogeneous coordinates, the problem arises that it makes a difference which homogeneous coordinates are chosen to represent the points. For example, consider the points v0 =  cid:5 0, 0, 0, 1 cid:6  and the point v1 =  cid:5 1, 0, 0, 1 cid:6 . The ﬁrst homogeneous vector represents the origin, and the second represents the vector i. The  cid:3  second vector is also equivalent to v 1  =  cid:5 2, 0, 0, 2 cid:6 . If we form the linear combinations  and  1  2 v0 + 1  2 v1 =  cid:5  1  2  , 0, 0, 1 cid:6   1  2 v0 + 1  cid:3  2 v 1  =  cid:5 1, 0, 0, 3   cid:6 ,  2  IV.6  IV.7  the resulting two homogeneous vectors represent different points in 3-space even though they are weighted averages of representations of the same points! Thus, afﬁne combinations of points in homogeneous coordinates have a different meaning than you might expect. We return to this subject in Section IV.4, where it will be seen that the w-component of a homogeneous vector serves as an additional weighting term. We will see later that afﬁne transformations of homogeneous representations of points can be a powerful and ﬂexible tool for rational B´ezier curves and B-splines because it allows them to deﬁne circles and other conic sections.  IV.1.3 Interpolation on Three Points: Barycentric Coordinates  Section IV.1.1 discussed linear interpolation  and extrapolation  on a line segment between points. In this section, the notion of interpolation is generalized to allow linear interpolation on a triangle.  Let x, y, and z be three noncollinear points, and thus they are the vertices of a triangle T .  Recall that a point u is a weighted average of these three points if it is equal to  u = αx + βy + γ z,  IV.8 where α + β + γ = 1 and α, β, and γ are all nonnegative. As shown below  Theorems IV.2 and IV.3 , a weighted average u of the three vertices x, y, z will always be in or on the triangle T . Furthermore, for each u in the triangle, there are unique values for α, β, and γ such that Equation IV.8 holds. The values α, β, and γ are called the barycentric coordinates of u.   IV.1 Linear Interpolation  103  y  u  w  z  x Figure IV.2. The point u in the interior of the triangle is on the line segment from w to z. The point w is a weighted average of x and y. The point u is a weighted average of w and z.  Theorem IV.2 Let x, y, z be noncollinear points and let T be the triangle formed by these three points.   a  Let u be a point on T or in the interior of T . Then u can be expressed as a weighted average of the three vertices x, y, z as in Equation IV.8 with α, β, γ ≥ 0 and α + β + γ = 1.  b  Let u be any point in the plane containing T . Then u can be expressed as an afﬁne combination of the three vertices, as in Equation IV.8 but with only the condition α + β + γ = 1.  Proof  a  If u is on an edge of T , it is a weighted average of the two vertices on that edge. Suppose u is in the interior of T . Form the line containing u and z. This line intersects the opposite edge, xy, of T at a point w, as shown in Figure IV.2. Since w is on the line segment between x and y, it can be written as a weighted average  where a + b = 1 and a, b ≥ 0. Also, because u is on the line segment between w and z, it can be written as a weighted average  w = ax + by,  u = cw + dz,  where c + d = 1 and c, d ≥ 0. Therefore, u is equal to  u =  ac x +  bc y + dz,  and this is easily seen to be a weighted average because ac + bc + d = 1 and all three coefﬁ- cients are nonnegative. This proves  a . Part  b  could be proved by a method similar to the proof of  a , but instead we give a proof based on linear independence. First, note that the vectors y − x and z − x are linearly independent since they form two sides of a triangle and thus are noncollinear. Let P be the plane containing the triangle T : the plane P consists of the points u such that  u = x + β y − x  + γ  z − x ,  IV.9 where β, γ ∈ R. If we let α =  1 − β − γ  , then u is equal to the afﬁne combination αx + βy + γ z.  cid:1  Exercise IV.4 Let x =  cid:5 0, 0 cid:6 , y =  cid:5 2, 3 cid:6 , and z =  cid:5 3, 1 cid:6  in R2. Determine the points represented by the following sets of barycentric coordinates. a. α = 0, β = 1, γ = 0. 3 , γ = 0. b. α = 2  3 , β = 1   Averaging and Interpolation  104  x  y  A  C  u  B  z  Figure IV.3. The barycentric coordinates α, β, and γ for the point u are proportional to the areas A, B and C.  3 , β = 1 5 , β = 1 3 , β = 2  c. α = 1 d. α = 4 e. α = 4 Graph your answers along with the triangle formed by x, y, and z.  3 , γ = 1 3 . 10 , γ = 1 10 . 3 , γ = −1.  The proof of part  b  of Theorem IV.2 constructed β and γ so that Equation IV.9 holds. In fact, because y − x and z − x are linearly independent, the values of β and γ are uniquely determined by u. This implies that the barycentric coordinates of u are unique, and so we have proved the following theorem.  Theorem IV.3 Let x, y, z, and T be as in Theorem IV.2. Let u be a point in the plane containing T . Then there are unique values for α, β, and γ such that α + β + γ = 1 and Equation IV.8 holds.  One major application of barycentric coordinates and linear interpolation on three points is to extend the domain of a function f by linear interpolation. Suppose, as usual, that x, y, and z are the vertices of a triangle T and that f is a function for which we know the values of f  x , f  y , and f  z . To extend f to be deﬁned everywhere in the triangle by linear interpolation, we let  f  u  = α f  x  + β f  y  + γ f  z ,  where α, β, γ are the barycentric coordinates of u. Mathematically, this is the same computation as used in Gouraud shading based on scan line interpolation  at least, it gives the same results to within roundoff errors, which are due mostly to pixelization . The same formula can be used to linearly extrapolate f to be deﬁned for all points u in the plane containing the triangle.  Area Interpretation of Barycentric Coordinates There is a nice characterization of barycentric coordinates in terms of areas of triangles. Figure IV.3 shows a triangle with vertices x, y, and z. The point u divides the triangle into three subtriangles. The areas of these three smaller triangles are A, B, and C, and so the area of the entire triangle is equal to A + B + C. As the next theorem states, the barycentric coordinates of u are proportional to the three areas A, B, and C.  Theorem IV.4 Suppose the situation shown in Figure IV.3 holds. Then the barycentric coor- dinates of u are equal to  α =  A  A + B + C  β =  B  A + B + C  γ =  C  A + B + C  .   IV.1 Linear Interpolation  105  y  D1  u  w  D2   a   x  z  x  y  A  w  E2  E1 u  B   b   z  Figure IV.4. The areas used in the proof of Theorem IV.4.  Proof The proof is based on the construction used in the proof of part  a  of Theorem IV.2. In particular, recall the way the scalars a, b, c, and d were used to deﬁne the barycentric coordinates of u. You should also refer to Figure IV.4, which shows additional areas D1, D2, E1, and E2. As shown in part  a  of Figure IV.4, the line zw divides the triangle into two subtriangles with areas D1 and D2. Let D be the total area of the triangle, and so D = D1 + D2. By using the usual “one-half base times height” formula for the area of a triangle with the base along the line xy, we have that  D1 = a D  and  D2 = bD.   Recall a and b are deﬁned so that w = ax + by.   Part  b  of the ﬁgure shows the triangle with area D1 further divided into two subtriangles with areas E1 and A and the triangle with area D2 divided into two subtriangles with areas E2 and B. By exactly the same reasoning used for Equations IV.10, we have  recall that u = cw + dz   IV.10  IV.11  E1 = d D1, E2 = d D2,  A = cD1, B = cD2.  Combining Equations IV.10 and IV.11 and using C = E1 + E2 and a + b = 1, we obtain  A = acD,  B = bcD,  and C = d D.  This proves Theorem IV.4 since D = A + B + C and α = ac, β = bc, and γ = d.   cid:1   Calculating Barycentric Coordinates Now we take up the problem of how to ﬁnd the barycentric coordinates of a given point u. First consider the simpler case of 2-space, where all points lie in the x y-plane.  The harder 3-space case will be considered afterwards.  The points x =  cid:5 x1, x2 cid:6 , y =  cid:5 y1, y2 cid:6 , z =  cid:5 z1, z2 cid:6 , and u =  cid:5 u1, u2 cid:6  are presumed to be known points. We are seeking coefﬁcients α, β, and γ that express u as an afﬁne combination of the other three points. Recall  see Appendix A.2.1  that, in two dimensions, the  signed  area of a parallelogram with sides equal to the vectors s1 and s2 has area equal to the cross product s1 × s2. Therefore, the area of the triangle shown in Figure IV.3 is equal to  D = 1  2  z − x  ×  y − x .   106  y  Averaging and Interpolation  e1  u  n  f  e2  z  x Figure IV.5. Calculating barycentric coordinates in R3.  Likewise, the area B is equal to  B = 1  2  z − x  ×  u − x .  Thus, by Theorem IV.4,  β =  z − x  ×  u − x   z − x  ×  y − x   .  Similarly,  γ =  u − x  ×  y − x   z − x  ×  y − x   .  IV.12  IV.13  The barycentric coordinate α can be computed in the same way, but it is simpler just to let α = 1 − β − γ .  Equations IV.12 and IV.13 can also be adapted for barycentric coordinates in 3-space ex- cept that you must use the magnitudes of the cross products instead of just the cross prod- ucts. However, there is a simpler and faster method presented below by Equations IV.14 through IV.16.  To derive the better method, refer to Figure IV.5. The two sides of the triangle are given by  the vectors  e1 = y − x  and  e2 = z − x.  In addition, the vector from x to u is f = u − x. The vector n is the unit vector perpendicular to the side e2 pointing into the triangle. The vector n is computed by letting m be the component of e1 perpendicular to e2,  m = e1 −  e1 · e2 e2 e2  ,  2  and setting n = m m.  The division by e2  Letting e2 be the base of the triangle, we ﬁnd that the height of the triangle is equal to n · e1.  2 is needed since e2 may not be a unit vector.   Thus, the area of the triangle is equal to  D = 1  B = 1  .  2  n · e1 e2 =  m · e1 e2 2m 2  n · f e2 =  m · f e2 2m  .  Similarly, the area of the subtriangle B is equal to   IV.2 Bilinear and Trilinear Interpolation  107  u1 = y  u2  u3  z  x  u4  Figure IV.6. The points from Exercise IV.5.  Therefore, β is equal to  β = B D  = m · f m · e1  =  e2  2 e1 −  e1 · e2 e2  · f e2 1e2 2  −  e1 · e2 2  .  IV.14  IV.15  IV.16  A similar formula holds for γ but with the roles of e1 and e2 reversed. We can further preprocess the triangle by letting  2e1 −  e1 · e2 e2 uβ = e2 −  e1 · e2 2 e2 1 e2 2  and  1e2 −  e1 · e2 e1 uγ = e2 −  e1 · e2 2 e2 1 e2 2  .  Thus, the barycentric coordinates can be calculated by  β = uβ · f  and  γ = uγ · f,  and of course α = 1 − β − γ .  Note that the vectors m and n were used to derive the formulas for β and γ , but there is no need to actually compute them: instead, the vectors uβ and uγ contain all the information necessary to compute the barycentric coordinates of the point u from f = u − x. This allows barycentric coordinates to be computed very efﬁciently. A further advantage is that Equations IV.15 and IV.16 work in any dimension, not just in R3. When the point u does not lie in the plane containing the triangle, then the effect of using Equations IV.15 and IV.16 is the same as pro- jecting u onto the plane containing the triangle before computing the barycentric coordinates. Exercise IV.5 Let x =  cid:5 0, 0 cid:6 , y =  cid:5 2, 3 cid:6 , and z =  cid:5 3, 1 cid:6 . Determine the barycentric coor- dinates of the following points  refer to Figure IV.6 . a. u1 =  cid:5 2, 3 cid:6 . b. u2 =  cid:5 1 1 , 2 cid:6 . c. u3 =  cid:5  3  cid:6 . 3 , 3 d. u4 =  cid:5 1, 0 cid:6 . 2  cid:1   Generalize the notion of linear interpolation to allow interpolation be-  2  Exercise IV.6 tween four noncoplanar points that lie in R3.  IV.2 Bilinear and Trilinear Interpolation  IV.2.1 Bilinear Interpolation  The last section discussed linear interpolation between three points. However, often we would prefer to interpolate between four points that lie in a plane or on a two-dimensional surface rather than between only three points. For example, a surface may be tiled by a mesh of four-sided   Averaging and Interpolation  108  w  z  α  a2  u  a1  β  b1  β  b2  α  y  x Figure IV.7. The point u = u α, β  is formed by bilinear interpolation with the scalar coordinates α and β. The points a1 and a2 are obtained by interpolating with α, and b1 and b2 are obtained by interpolating with β.  polygons that are nonrectangular  or even nonplanar , but we may wish to parameterize the polygonal patches with values α and β both ranging between 0 and 1. This frequently arises when using texture maps. Another common use is in computer games such as in driving simulation games when the player follows a curved race track consisting of a series of approx- imately rectangular patches. The game programmer can use coordinates α, β ∈ [0, 1] to track the position within a given patch.  To interpolate four points, we use a method called bilinear interpolation. Suppose four points form a four-sided geometric patch, as pictured in Figure IV.7. Bilinear interpolation will be used to deﬁne a smooth surface; the four straight-line boundaries of the surface will be the four sides of the patch. We wish to index points on the surface with two scalar values, α and β, both ranging from 0 to 1; essentially, we are seeking a smooth mapping that has as its domain the unit square [0, 1]2 = [0, 1] × [0, 1] and that maps the corners and the edges of the unit square to the vertices and the boundary edges of the patch. The value of α corresponds to the x-coordinate and that of β to the y-coordinate of a point u on the surface patch.  The deﬁnition of the bilinear interpolation function is as follows:  u =  1 − β  · [ 1 − α x + αy] + β · [ 1 − α w + αz] =  1 − α  · [ 1 − β x + βw] + α · [ 1 − β y + βz] =  1 − α  1 − β x + α 1 − β y + αβz +  1 − α βw.  For 0 ≤ α ≤ 1 and 0 ≤ β ≤ 1, this deﬁnes u as a weighted average of the vertices x, y, z, and w. We sometimes write u as u α, β  to indicate its dependence on α and β.  We deﬁned bilinear interpolation with three equivalent equations in IV.17 to stress that bilinear interpolation can be viewed as linear interpolation with respect to α followed by linear interpolation with respect to β or, vice versa, as interpolation ﬁrst with β and then with α. Thus, the ﬁrst two lines of Equation IV.17 can be rewritten as  u = lerp  lerp x, y, α , lerp w, z, α , β  = lerp  lerp x, w, β , lerp y, z, β , α .  Bilinear interpolation may be used to interpolate the values of a function f . If the values of f are ﬁxed at the four vertices, then bilinear interpolation is used to set the value of f at the point u obtained by Equation IV.17 to  f  u  =  1 − α  1 − β  f  x  + α 1 − β  f  y  + αβ f  z  +  1 − α β f  w .  IV.17  IV.18   IV.2 Bilinear and Trilinear Interpolation  109  w =  cid:1 0, 2 cid:2   z =  cid:1 5, 3 cid:2   x =  cid:1 0, 0 cid:2  Figure IV.8. Figure for Exercise IV.7.  y =  cid:1 4, 0 cid:2   Exercise IV.7 Let x =  cid:5 0, 0 cid:6 , y =  cid:5 4, 0 cid:6 , z =  cid:5 5, 3 cid:6 , and w =  cid:5 0, 2 cid:6 , as in Figure IV.8. For each of the following values of α and β, what point is obtained by bilinear interpolation? Graph your answers. a. α = 1 and β = 0. 3 and β = 1. b. α = 1 c. α = 1 2 and β = 1 4 . d. α = 2 3 and β = 1 3 .  Equation IV.17 deﬁning bilinear interpolation makes sense for an arbitrary set of vertices x, y, z, w. If the four vertices are coplanar and lie in a plane P, the bilinearly interpolated points u α, β  clearly lie in the same plane because they are weighted averages of the four vertices. If, on the other hand, the four vertices are not coplanar and are positioned arbitrarily in R3, then the points u = u α, β  obtained by bilinear interpolation with α, β ∈ [0, 1] form a four-sided “patch,” that is, a four-sided surface. The sides of the patch will be straight line segments, but the interior of the patch may be curved.  Exercise IV.8 Suppose a surface patch in R3 is deﬁned by bilinearly interpolating from four vertices. Derive the following formulas for the partial derivatives of u:  IV.19  =  1 − β  y − x  + β z − w   =  1 − α  w − x  + α z − y .  ∂u ∂α  ∂u ∂β  In addition, give the formula for the normal vector to the patch at a point u = u α, β .  Usually, bilinear interpolation uses vertices that are not coplanar but are not too far away from a planar, convex quadrilateral. A mathematical way to describe this is to say that a plane P exists such that, when the four vertices are orthogonally projected onto the plane, the result is a convex, planar quadrilateral. We call this condition the “projected convexity condition”:  Projected Convexity Condition: The projected convexity condition holds provided there exists a plane P such that the projection of the points x, y, z, w onto the plane P are the vertices of a convex quadrilateral with the four vertices being in counterclockwise or clockwise order.  To check that the projected convexity condition holds for a given plane, choose a unit vector n normal to the plane and assume, without loss of generality, that the plane contains the origin. Then project the four points onto the plane, yielding four points xP, yP, zP, and wP by using the following formula  see Appendix A.2.2 :  xP = x −  n · x n.   Averaging and Interpolation  110  v4  x  w  v3  v1  z  v2  y  v1 = y − x v2 = z − y v3 = w − z v4 = x − w.  Figure IV.9. The vectors vi are the directed edges around the quadrilateral.  Then check that the interior angles of the resulting quadrilateral are less than 180 .  We discuss convexity more in Section IV.3, but for now we can take this test as being the deﬁnition of a convex quadrilateral.   A mathematically equivalent method of checking whether the projected convexity condition  holds for a plane with unit normal n is as follows. First deﬁne the four edge vectors by  ◦  These give the edges in circular order around the quadrilateral, as shown Figure IV.9. The ◦ condition that the interior angles of the projected quadrilateral are less than 180 is equivalent to the condition that the four values  v3 × v4  · n  v4 × v1  · n   v1 × v2  · n  v2 × v3  · n  IV.20  are either all positive or all negative. To verify this, suppose we view the plane down the normal vector n. If the four values from IV.20 are all positive, then the projected vertices are in counterclockwise order. When the four values are all negative, the projected vertices are in clockwise order.  Exercise IV.9 Prove that the values  vi × v j   · n are equal to  cid:11 i ·  cid:11  j sin θ where  cid:11 i is the magnitude of the projection of vi onto the plane P and where θ is the angle between the projections of vi and v j .  The projected convexity condition turns out to be very useful, for instance, in the proof of Corollary IV.7 and for solving Exercise IV.10. Thus, it is a pleasant surprise that the projected convexity condition nearly always holds; indeed, it holds for any set of four noncoplanar vertices.  Theorem IV.5 Suppose that x, y, z, and w are not coplanar. Then the projected convexity condition is satisﬁed.  Proof We call the two line segments xz and yw the diagonals. With reference to Figure IV.10, let a be the midpoint of the diagonal xz so that a = 1 the other diagonal. The points a and b must be distinct, for otherwise the two diagonals would intersect and the four vertices would all lie in the plane containing the diagonals, contradicting the hypothesis of the theorem.  2  x + z . Likewise, let b be the midpoint of  Form the unit vector n in the direction from a to b, that is,  n = b − a b − a .   IV.2 Bilinear and Trilinear Interpolation  111  w  y  z  b  n  a  x  Figure IV.10. The line segments xz and yw have midpoints a and b. The vector n is the unit vector in the direction from a to b.  Let P be the plane containing the origin and perpendicular to n, and consider the orthogonal projection of the four vertices onto P. The midpoints a and b project onto the same point of P because of the way n was chosen. Also, the projections of the two diagonals cannot be collinear, for otherwise all four vertices would lie in the plane that contains the projections of the diagonals and is perpendicular to P. That is, the projections of the diagonals are two line segments that cross each other  intersect in their interiors , as shown in Figure IV.11. In particular, neither diagonal projects onto a single point. The projections of the four vertices are the four endpoints of the projections of the diagonals. Clearly they form a convex quadrilateral  cid:1  with the vertices being in clockwise or counterclockwise order.  For convex, planar quadrilaterals, we have the following theorem.  Theorem IV.6 Let x, y, z, w be the vertices of a planar, convex quadrilateral in counterclock- wise  or clockwise  order. Then the bilinear interpolation mapping   cid:5 α, β cid:6   cid:13 → u α, β   is a one-to-one map from [0, 1] × [0, 1] onto the quadrilateral. Proof We give a quick informal proof. If the value of β is ﬁxed, then the second line in Equation IV.17 or IV.18 shows that the function u α, β  is just equal to the result of using α to interpolate linearly along the line segment L β joining the two points   1 − β x + βw and  1 − β y + βz.  These two points lie on opposite edges of the quadrilateral and thus are distinct. Furthermore, for β  cid:16 = β cid:3  , the two line segments L β and L β cid:3  do not intersect, as may be seen by inspection of Figure IV.12. This uses the fact that the interior angles of the quadrilateral measure less . Therefore, if β  cid:16 = β cid:3  ◦  , since L β and L β cid:3  are disjoint. On than 180 the other hand, if β = β cid:3    because they are distinct points on the the line L β.  , then again u α, β   cid:16 = u α cid:3 , β cid:3   , then u α, β   cid:16 = u α cid:3 , β cid:3   , but α  cid:16 = α cid:3   To verify that the map is onto, note that the line segments L β sweep across the quadrilateral  cid:1   as β varies from 0 to 1. Therefore, any u in the quadrilateral lies on some L β.  Figure IV.13 shows an example of how Theorem IV.6 fails for planar quadrilaterals that are not convex. The ﬁgure shows a sample line L β that is not entirely inside the quadrilateral;  wP  xP  zP  yP  Figure IV.11. The projections of the two diagonals onto the plane P are noncollinear and intersect at their midpoints at the common projection of a and b. The four projected vertices form a convex quadrilateral.   112  w  z  Lβ cid:1   Lβ  Averaging and Interpolation  x Figure IV.12. Since the polygon is convex, distinct values β and β cid:3  segments.  y  give nonintersecting “horizontal” line  thus, the range of the bilinear interpolation map is not contained inside the quadrilateral. Furthermore, the bilinear interpolation map is not one-to-one; for instance, the point where the segments L β and zw intersect has two sets of bilinear coordinates.  However, the next corollary states that Theorem IV.6 does apply to any set of four noncopla-  nar points.  Corollary IV.7 Suppose x, y, z, and w are not coplanar. Then the function u α, β  is a one-to-one map on the domain [0, 1] × [0, 1].  Proof By Theorem IV.5, the projected convexity condition holds for some plane P. With- out loss of generality, the plane P is the x y-plane. The bilinear interpolation function u α, β  operates independently on the x-, y-, and z-components of the vertices. Therefore, by Theorem IV.6, the projection of the values of u α, β  onto the x y-plane is a one-to-one function from [0, 1]2 into the x y-plane. It follows immediately that the function u α, β  is  cid:1  one-to-one.  Exercise IV.10 projected convexity condition holds. Prove that  Let the vertices x, y, z, w be four points in R3 and suppose that the   cid:1   ∂u ∂α  × ∂u ∂β  is nonzero for all α, β ∈ [0, 1]. Conclude that this deﬁnes a nonzero vector normal to the surface. [Hint: Refer back to Exercise IV.8 on page 109. Prove that the cross product is equal to  α 1 − β v1 × v2 + αβv2 × v3 +  1 − α βv3 × v4 +  1 − α  1 − β v4 × v1,  and use the fact that  vi × v j   · n, for j =  i mod 4  + 1, all have the same sign, for n normal to the plane from the projected convexity condition.]  w  x  Lβ  z  y  Figure IV.13. An example of the failure of Theorem IV.6 for nonconvex, planar quadrilaterals.   IV.2 Bilinear and Trilinear Interpolation  113  w  u  s1 β   x  z  y  s2 β   Figure IV.14. The three points s1 β , u, and s2 β  will be collinear for the correct value of β. The value of β shown in the ﬁgure is smaller than the correct β coordinate of u.  IV.2.2 Inverting Bilinear Interpolation  We now discuss how to invert bilinear interpolation. For this, we are given the four vertices x, y, z, and w, which are assumed to form a convex quadrilateral in a plane.2 Without loss of generality, the points lie in R2, and so x =  cid:5 x1, x2 cid:6 , and so on. In addition, we are given a point u =  cid:5 u1, u2 cid:6  in the interior of the quadrilateral formed by these four points. The problem is to ﬁnd the values of α, β ∈ [0, 1] so that u satisﬁes the deﬁning equation IV.17 for bilinear interpolation. Our algorithm for inverting bilinear interpolation will be based on vectors. Let s1 = w − x and s2 = z − y. Then let s1 β  = x + βs1  s2 β  = y + βs2,  as shown in Figure IV.14. To solve for the value of β, it is enough to ﬁnd β such that 0 ≤ β ≤ 1 and such that the three points s1 β , u, and s2 β  are collinear.  and  Referring to Appendix A.2.1, we recall that two vectors in R2 are collinear if, and only if,  their cross product is equal to zero.3 Thus, for the three points to be collinear, we must have  0 =  s1 β  − u  ×  s2 β  − u  =  βs1 −  u − x   ×  βs2 −  u − y   =  s1 × s2 β2 + [s2 ×  u − x  − s1 ×  u − y ]β +  u − x  ×  u − y .  IV.21  This quadratic equation can readily be solved for the desired value of β. In general, there will be two roots of the quadratic equation. To ﬁnd these, let A, B, and C be the coefﬁcients of β2, β, and 1 in Equation IV.21, namely,  A = s1 × s2 =  w − x  ×  z − y  B =  z − y  ×  u − x  −  w − x  ×  u − y  C =  u − x  ×  u − y . β = −B ± √  .  B2 − 4AC 2A  The two roots of IV.21 are  2 At the end of this section, we discuss how to modify the algorithm to work in three dimensions. 3 Recall that the cross product for 2-vectors is deﬁned to be the scalar value   cid:5 v1, v2 cid:6  ×  cid:5 w1, w2 cid:6  = v1w2 − v2w1.  IV.22   114  Averaging and Interpolation  w  s1 β  −   u  x  y  z  s2 β  −   w  s1 β  −   x   a   s1 β+  s2 β+   s1 β+  s2 β+   z  s2 β  −   y  u   b   Figure IV.15. The two possibilities for the sign of s1 × s2. In  a , s1 × s2   0. In each case, there are two values for β where the points s1 β , s2 β , and u are collinear. The values β+ and β− are the solutions to Equation IV.22 obtained with the indicated choice of plus or minus sign. For  a  and  b , β = β−  is between 0 and 1 and is the desired root.  There remains the question of which of the two roots is the right value for β. Of course, one way to decide this is to use the root between 0 and 1. But we can improve on this and avoid having to test the roots to see if they are between 0 and 1.4 In fact, we will see that the right root is always the root  β = −B − √  B2 − 4AC 2A  .  IV.23 To prove this, consider the two cases s1 × s2   0 separately.  The case s1 × s2 = 0 will be discussed later.  First, assume that s1 × s2 < 0. This situation is shown in Figure IV.15 a , where the two vectors s1 and s2 are diverging, or pointing away, from each other since the angle from s1 to s2 must be negative if the cross product is negative. As shown in Figure IV.15 a , there are two values, β− , where s1 β , u, and s2 β  are collinear. The undesired root of Equation IV.21 occurs with a negative value of β, namely β = β+ , as shown in the ﬁgure. So in the case where s1 × s2 < 0, the larger root of IV.22 is the correct one. And since the denominator A = s1 × s2 of IV.22 is negative, the larger root is obtained by taking the negative sign in the numerator. Now assume that s1 × s2 > 0. This case is shown in Figure IV.15 b . In this case, the undesired root of Equation IV.21 is greater than 1; therefore, the desired root is the smaller of the two roots. Since the denominator is positive in this case, we again need to choose the negative sign in the numerator of IV.22.  and β+  This almost completes the mathematical description of how to compute the value of β. However, there is one further modiﬁcation to be made to make the computation more stable. It is well known  c.f.  Higman, 1996   that the usual formulation of the quadratic formula can be computationally unstable. This can happen to the formula IV.23 if value of B is negative and if B2 is much larger than 4AC, since the numerator will be computed as the difference of  4 The problem with testing for being between 0 and 1 is that roundoff error may cause the desired root to be slightly less than 0 or slightly greater than 1. In addition, if one is concerned about minor differences in computation time, then comparison between real numbers can actually be slightly slower than other operations on real numbers.   115  IV.24  IV.2 Bilinear and Trilinear Interpolation  two large numbers that mostly cancel out to yield a value close to 0. In this case, a more stable computation can be performed by using the formula  β =  −B + √  2C B2 − 4AC nominator of IV.23 by  −B + √  more stable when B is negative.  .  This formula is equivalent to IV.23, as can be seen by multiplying both the numerator and de- B2 − 4AC , and it has the advantage of being computationally  Once the value of β has been obtained, it is straightforward to ﬁnd the value of α, since u is  now the weighted average of s1 β  and s2 β . This can be done by just setting  α =  u − s1 β   ·  s2 β  − s1 β     s2 β  − s1 β  2  because this is the ratio of the distance from s1 β  to u to the distance from s1 β  to s2 β .  See also Equation IV.3 on page 100.   We now can present the algorithm for inverting bilinear interpolation. The input to the algorithm is ﬁve points in R2. For reliable results, the points x, y, z, w should be the vertices of a convex quadrilateral, and u should be on or inside the quadrilateral.     x, y, x, w, u lie in the plane R2 BilinearInvert  u, x, y, z, w   {  Set A =  w − x  ×  z − y ; Set B =  z − y  ×  u − x  −  w − x  ×  u − y ; Set C =  u − x  ×  u − y ; If   B > 0   {  −B − √  B2 − 4AC 2A  ;  Set β =  } Else {  ;  2C B2 − 4AC  Set β =  −B + √ } Set s1,β =  1 − β x + βw; Set s2,β =  1 − β y + βz;  s2,β − s1,β 2 Set α =   u − s1,β  ·  s2,β − s1,β   ;  Return α and β as the bilinear interpolation inverse.  }  We have omitted so far discussing the case where A = s1 × s2 = 0: this happens whenever s1 and s2 are collinear so that the left and right sides of the quadrilateral are parallel. When A equals 0, the quadratic equation IV.21 becomes the linear equation Bβ + C = 0 with only one root, namely, β = −C B. Thus, it would be ﬁne to modify the preceding algorithm to test whether A = 0 and, if so, compute β = −C B. However, the algorithm above will actually work correctly as written even when A = 0. To see this, note that, if A = 0, the left and right sides are parallel, so  w − x  ×  u − y  ≥ 0 and  z − y  ×  u − x  ≤ 0 since u is in the polygon. Furthermore, for a proper polygon these cross products are not both zero. Therefore, B < 0 and the algorithm above computes β according to the second case, which is mathematically equivalent to computing −C B and avoids the risk of a divide by zero.   Averaging and Interpolation  z =  cid:1 5, 3 cid:2   116  w =  cid:1 0, 2 cid:2   u =  cid:1  3  6 cid:2  2 , 7  x =  cid:1 0, 0 cid:2  Figure IV.16. Figure for Exercise IV.11.  y =  cid:1 4, 0 cid:2   Exercise IV.11 Let x =  cid:5 0, 0 cid:6 , y =  cid:5 4, 0 cid:6 , z =  cid:5 5, 3 cid:6 , w =  cid:5 0, 2 cid:6 , and u =  cid:5  3 Figure IV.16. What are the bilinear coordinates, α and β, of u?  2   cid:6 , as in  , 7 6  Now we generalize the bilinear inversion algorithm to work in three dimensions instead of two. The key idea is that we just need to choose two orthogonal axes and project the problem onto those two axes, reducing the problem back to the two-dimensional case. For this, we start by choosing a unit vector n such that the projected convexity condition holds for a plane perpendic- ular to n. To choose n, you should not use the vector from the proof of Theorem IV.5, as this may give a poorly conditioned problem and lead to unstable computations. Indeed, this would give disastrous results if the points x, y, z, and w were coplanar and would give unstable results if they were close to coplanar. Instead, in most applications, a better choice for n would be the vector   z − x  ×  w − y   z − x  ×  w − y  .  n =  z − x  ×  w − y .  Actually, it will turn out that there is no need to make n a unit vector, and so it is computationally easier just to set n to be the vector  IV.25  This choice for n is likely to work well in most applications. In particular, if this choice for n does not give a plane satisfying the projected convexity condition, then the patches are probably poorly chosen and are certainly not very patchlike.  In some cases there are easier ways to choose n. A common application of patches is to deﬁne a terrain or, more generally, a surface that does not vary too much from horizontal. In this case, the “up”-direction vector, say j, can be used for the vector n.  Once we have chosen the vector n, we can convert the problem into a two-dimensional one by projecting onto a plane P orthogonal to n. Fortunately, it is unnecessary to actually choose coordinate axes for P and project the ﬁve points u, x, y, z, and w onto P. Instead, we only need the three scalar values A, B, and C, and to compute these, it is mathematically equivalent to use the formulas in the BilinearInvert routine but then take the dot product with n.  To summarize, the bilinear inversion algorithm for points in R3 is the same as the Bilin- earInvert program as given on page 115, except that now u, x, y, z, and w are vectors in R3, and the ﬁrst three lines of the program are replaced by the following four lines:  Set n =  z − x  ×  w − y ; Set A = n ·   w − x  ×  z − y  ; Set B = n ·   z − y  ×  u − x  −  w − x  ×  u − y  ; Set C = n ·   u − x  ×  u − y  ;  The rest of BilinearInvert is unchanged. Other choices for n are possible too: the important point is that the projected convexity condition should hold robustly.   IV.3 Convex Sets and Weighted Averages  117  IV.2.3 Trilinear Interpolation   cid:27   i, j,k  u α, β, γ   =   Trilinear interpolation is a generalization of bilinear interpolation to three dimensions. For trilinear interpolation, we are given eight points xi, j,k, where i, j, k ∈ {0, 1}. Our goal is to deﬁne a smooth map u α, β, γ   from the unit cube [0, 1]3 into 3-space so that u i, j, k  = xi, j,k for all i, j, k ∈ {0, 1}. The intent is that the eight points xi, j,k are roughly in the positions of the vertices of a rectangular prism and that the map u α, β, γ   should be a smooth interpolation function.  For trilinear interpolation, we deﬁne  wi  α w j  β wk γ  xi, j,k ,  where the summation runs over all i, j, k ∈ {0, 1}, and where the values wn δ , for n ∈ {0, 1}, are deﬁned by wn δ  =  1 − δ  if n = 0 if n = 1.  δ  Trilinear interpolation can also be used to interpolate the values of a function. Suppose a function f has its values speciﬁed at the vertices so that f  xi, j,k  is ﬁxed for all eight vertices. Then, we extend f to the unit cube [0, 1]3 through trilinear interpolation by letting  f  u α, β, γ    =  wi  α w j  β wk γ   f  xi, j,k .   cid:27   i, j,k  To the best of our knowledge, there is no good way to invert trilinear interpolation in closed form. However, it is possible to use an iterative method based on Newton’s method to invert trilinear interpolation quickly.  IV.3 Convex Sets and Weighted Averages  The notion of a convex quadrilateral has already been discussed in the sections above. This section introduces the deﬁnition of convexity for general sets of points and proves that a set is convex if and only if it is closed under the operation of taking weighted averages.  The intuitive notion of a convex set is that it is a fully “ﬁlled in” region with no “holes” or missing interior points and that there are no places where the boundary bends inward and back outward. Figure IV.17 shows examples of convex and nonconvex sets in the plane. Nonconvex sets have the property that it is possible to ﬁnd a line segment that has endpoints in the set but is not entirely contained in the set.  Deﬁnition Let A be a set of points  in Rd for some dimension d . The set A is convex if and only if the following condition holds: for any two points x and y in A, the line segment joining x and y is a subset of A.  Some simple examples of convex sets include:  a  any line segment,  b  any line or ray,  c  any plane or half-plane,  d  any half-space,  e  any linear subspace of Rd,  f  the entire space Rd,  g  any ball  i.e., a circle or sphere plus its interior ,  h  the interior of a triangle or parallelogram, and so on. It is easy to check that the intersection of two convex sets must be convex. In fact, the intersection of an arbitrary collection of convex sets is convex.  You should supply a proof of this!  However, the union of two convex sets is not always convex.  Deﬁnition Let A be a set of points in Rd. The convex hull of A is the smallest convex set containing A.   118  Averaging and Interpolation  Figure IV.17. The shaded regions represent sets. The two sets on the left are convex, and the two sets on the right are not convex. The dotted lines show line segments with endpoints in the set that are not entirely contained in the set.  $S of these sets is convex and contains A. It is therefore  Every set A has a smallest enclosing convex set. In fact, if S is the set of convex sets containing A, then the intersection the smallest convex set containing A.  Note that the set S is nonempty because the whole space Rd is a convex set containing A.  Therefore, the notion of a convex hull is well-deﬁned, and every set of points has a convex hull.  There is another, equivalent deﬁnition of convex that is sometimes used in place of the deﬁnition given above. Namely, a set is convex if and only if it is equal to the intersection of some set of half-spaces. In R3, a half-space is a set that lies on one side of a plane, or more precisely, a half-space is a set of the form {x : n · x > a} for some nonzero vector n and scalar a. With this deﬁnition of convex set, the convex hull of A is the set of points that lie in every half-space that contains A. Equivalently, a point y is not in the convex hull of A if and only if there is a half-space such that A lies entirely in the half-space and y is not in the half-space.  It should be intuitively clear that the deﬁnition of convex hulls in terms of intersections of half-spaces is equivalent to our deﬁnition of convex hulls in terms of line segments. How- ever, giving a formal proof that these two deﬁnitions of convexity are equivalent is fairly difﬁcult: the proof is beyond the scope of this book, but the reader can ﬁnd a proof in the texts  Gr¨unbaum, 1967  or  Ziegler, 1995 .  You might want to try your hand at proving this equivalence in dimensions 2 and 3 to get a feel for what is involved in the proof.  We have adopted the deﬁnition based on line segments since it makes it easy to prove that the convex hull of a set A is precisely the set of points that can be expressed as weighted averages of points from A.  Deﬁnition Let A be a set and x a point. We say that x is a weighted average of points in A if and only if there is a ﬁnite set of points y1, . . . , yk in A such that x is equal to a weighted average of y1, . . . , yk.  Theorem IV.8 Let A be a set of points. The convex hull of A is precisely the set of points that are weighted averages of points in A.  Proof Let WA A  be the set of points that are weighted averages of points in A. We ﬁrst prove that WA A  is convex, and since A ⊆ WA A , this implies that the convex hull of A is a subset of WA A . Let y and z be points in WA A . We wish to prove that the line segment between   IV.4 Interpolation and Homogeneous Coordinates  119  these points is also contained in WA A . Since this line segment is just the set of points that are weighted averages of y and z, it is enough to show that if 0 ≤ α ≤ 1 and w =  1 − α y + αz, then w is in WA A . Since y and z are weighted averages of points in A, they are equal to  i=1  βi xi  γi xi , i=1 γi = 1. We can assume the same k points x1, . . . , xk with each βi , γi ≥ 0 and are used in both weighted averages because we can freely add extra terms with coefﬁcients 0 to a weighted average. Now  and βi = 1 and  i  i  z = k cid:27   cid:28    cid:28   y = k cid:27   w = k cid:27   i=1    1 − α βi + αγi  xi ,  and the coefﬁcients on the right-hand side are clearly nonnegative and sum to 1. Therefore, w ∈ WA A . Thus, we have shown that WA A  is convex, and hence WA A  contains the convex hull of A.  For the second half of the proof, we need to show that every element of WA A  is in the convex hull of A. For this, we prove, by induction on k, that any weighted average of k points in A is in the convex hull. For k = 1, this is trivial because the convex hull of A contains A. For k > 1, let  w = a1x1 + a2x2 + ··· + akxk ,  where αk  cid:16 = 1. This formula for w can be rewritten as x2 + ··· + ak−1 1−ak  w =  1 − ak   x1 + a2 1−ak  a1 1−ak  %  &  xk−1  + akxk .   cid:3  be the vector in square brackets in this last formula, we ﬁnd that w   cid:3  Letting w average of k − 1 points in A and thus, by the induction hypothesis, w of A. Now, w is a weighted average of the two points w line segment from w  is a weighted is in the convex hull and xk; in other words, w is on the  cid:1   and xk are both in the convex hull of A, so is w.  to xk. Since w   cid:3    cid:3    cid:3    cid:3   IV.4 Interpolation and Homogeneous Coordinates  This section takes up the question of what it means to form weighted averages of homogeneous vectors. The context is that we have a set of homogeneous vectors  4-tuples  representing points in R3. We then form a weighted average of the four tuples by calculating the weighted averages of the x-, y-, z, and w-components independently. The question is, What point in R3 is represented by the weighted average obtained in this way?  A key observation is that a given point in R3 has many different homogeneous representa- tions, and the weighted average may give different results depending on which homogeneous representation is used. An example of this was already given above on page 102. In that ex- = 2v1; so v0 is a homogeneous ample, we set v0 =  cid:5 0, 0, 0, 1 cid:6  and v1 =  cid:5 1, 0, 0, 1 cid:6  and v  cid:3  1 representation of 0, and v1 and v are both homogeneous representations of i. In Equation IV.6, , 0, 0, 1 cid:6 , which represents  not unexpectedly  the point the average 1 1 is equal to  cid:5 1, 0, 0, 3  cid:6 ,  cid:3  midway between 0 and i. On the other hand, the average 1 which represents the point  cid:5  2 , 0, 0 cid:6 : this is the point that is two-thirds of the way from 0 to i.  cid:3  The intuitive reason for this is that the point v 1 has w-component equal to 2 and that the importance  or, weight  of the point i in the weighted average has therefore been doubled.  2 v1 was seen to be cid:5  1  2 v0 + 1 2 v  2 v0 + 1  2  3  2   cid:3   We next give a mathematical derivation of this intuition about the effect of forming weighted  averages of homogeneous coordinates.   120  Averaging and Interpolation  To help increase readability of formulas involving homogeneous coordinates, we introduce a new notation. Suppose x =  cid:5 x1, x2, x3 cid:6  is a point in R3 and w is a nonzero scalar. Then the notation  cid:5 x, w cid:6  will denote the 4-tuple  cid:5 x1, x2, x3, w cid:6 . In particular, if x is a point in R3, then the homogeneous representations of x all have the form  cid:5 wx, w cid:6 . Suppose x1, x2, . . . , xk are points in R3, and w1, w2, . . . , wk are positive scalars so that the 4-tuples  cid:5 wi xi , wi cid:6  are homogeneous representations of the points xi . Consider a weighted average of the homogeneous representations, that is  α1 cid:5 w1x1, w1 cid:6  + α2 cid:5 w2x2, w2 cid:6  + ··· + αk cid:5 wkxk , wk cid:6 .  The result is a 4-tuple; but the question is, What point y in R3 has this 4-tuple as its homogeneous representation? To answer this, calculate as follows:  α1 cid:5 w1x1, w1 cid:6  + α2 cid:5 w2x2, w2 cid:6  + ··· + αk cid:5 wkxk , wk cid:6  =  cid:5 α1w1x1, α1w1 cid:6  +  cid:5 α2w2x2, α2w2 cid:6  + ··· +  cid:5 αk wkxk , αk wk cid:6   cid:21  =  cid:5 α1w1x1 + α2w2x2 + ··· + αk wkxk , α1w1 + α2w2 + ··· + αk wk cid:6  ≡  α1w1x1 + α2w2x2 + ··· + αk wkxk   cid:22   ,  α1w1 + α2w2 + ··· + αk wk  , 1  where the last equality  ≡  means only that the homogeneous coordinates represent the same point in R3, namely the point  y = k cid:27   i=1  αi wi  α1w1 + ··· + αk wk  · xi .  IV.26  It is obvious that the coefﬁcients on the xi ’s sum to 1, and thus IV.26 is an afﬁne combination of the xi ’s. Furthermore, the αi ’s are nonnegative, and at least one of them is positive. Therefore, each coefﬁcient in IV.26 is in the interval [0,1], and thus IV.26 is a weighted average.  Equation IV.26 shows that a weighted average  α1 cid:5 w1x1, w1 cid:6  + α2 cid:5 w2x2, w2 cid:6  + ··· + αk cid:5 wkxk , wk cid:6   gives a homogeneous representation of a point y in R3 such that y is a weighted average of x1, . . . , xk:  The coefﬁcients β1, . . . , βk have the property that they sum to 1, and the ratios  y = β1x1 + β2x2 + ··· + βkxk .  β1 : β2 : β3 :  : βk−1 : βk  ···  are equal to the ratios  α1w1 : α2w2 : α3w3 :  : αk−1wk−1 : αk wk .  ···  Thus, the wi values serve as “weights” that adjust the relative importances of the xi ’s in the weighted average.  The preceding discussion has established the following theorem:  Theorem IV.9 Let A be a set of points in R3 and AH a set of 4-tuples so that each member of AH is a homogeneous representation of a point in A. Further suppose that the fourth component  the w-component  of each member of AH is positive. Then any weighted average of 4-tuples from AH is a homogeneous representation of a point in the convex hull of A.   IV.5 Hyperbolic Interpolation  121  As we mentioned earlier, using weighted averages of homogeneous representations can greatly extend the power of B´ezier and B-spline curves – these are the so-called rational B´ezier curves and rational B-spline curves. In fact, it is only with the use of weighted averages in homogeneous coordinates that these spline curves can deﬁne conic sections such as circles, ellipses, parabolas, and hyperbolas.  A second big advantage of using weighted averages in homogeneous coordinates instead of in ordinary Euclidean coordinates is that weighted averages in homogeneous coordinates are preserved not only under afﬁne transformations but also under perspective transformations. In fact, weighted averages  and more generally, linear combinations  of homogeneous represen- tations are preserved under any transformation that is represented by a 4 × 4 homogeneous matrix. That is to say, for any 4 × 4 matrix M, any set of 4-tuples ui , and any set of scalars αi ,  ’ cid:27      =   cid:27   i  M  αi ui  i  αi M ui  .  Exercise IV.12 Work out the following example of how weighted averages of Euclidean points in R3 are not preserved under perspective transformations. Let the perspective transformation act on points in R3 by mapping  cid:5 x, y, z cid:6  to  cid:5 x z, y z, 0 cid:6 . Give a 4 × 4 homogeneous matrix that represents this transformation  cf. Section II.3.2 . What are the values of the three points cid:5 0, 0, 3 cid:6 , cid:5 2, 0, 1 cid:6  and cid:5 1, 0, 2 cid:6  under this transformation? Explain how this shows that weighted averages are not preserved by the transformation.  IV.5 Hyperbolic Interpolation  The previous section discussed the effect of interpolation in homogeneous coordinates and what interpolation of homogeneous coordinates corresponds to in terms of Euclidean coor- dinates. Now we discuss the opposite direction: how to convert interpolation in Euclidean coordinates into interpolation in homogeneous coordinates. This process is called “hyper- bolic interpolation” or sometimes “rational linear interpolation”  see  Blinn, 1992  and  Heckbert and Moreton, 1991  . The situation is the following: we have points in Euclidean space speciﬁed with homoge- neous coordinates  cid:5 xi , wi cid:6 , i = 1, 2, . . . , k  usually there are only two points, and so k = 2 . These correspond to Euclidean points yi = xi  wi . An afﬁne combination of the points is given as  αi = 1. The problem is to ﬁnd values of βi so that  where combination of homogeneous vectors  βi = 1 and so the afﬁne   cid:28   is a homogeneous representation of the same point z. From our work in the previous section, we know that the values βi and αi must satisfy the condition that the values αi are proportional to the products βi wi . Therefore, we may choose   cid:27   i  αi yi ,  βi cid:5 xi , wi cid:6   z =  cid:28   cid:27   i  i  αi  wi cid:28  for i = 1, 2, . . . , n.  βi =  j  ,  α j  w j   122  Averaging and Interpolation  Hyperbolic interpolation is useful for interpolating values in stage 4 of the rendering pipeline  see Chapter II . In stage 4, perspective division has already been performed, and thus we are working with points lying in the two-dimensional screen space. As described in Section II.4, linear interpolation is performed in screen space to ﬁll in color, normal, and texture coordinate values for pixels inside a polygon. The linear interpolation along a line gives a weighted average   1 − α y1 + αy2  specifying a point in screen coordinates in terms of the endpoints of a line segment. However, linear interpolation in screen coordinates is not really correct; it is often better to interpolate in spatial coordinates because, after all, the object that is being modeled lies in 3-space. In addition, interpolating in screen coordinates means that the viewed object will change as the viewpoint changes.  Therefore, it is often desirable that values speciﬁed at the endpoints, such as color or texture coordinates, be interpolated using hyperbolic interpolation. For the hyperbolic interpolation, weights  1 − β  and β are computed so that  1 − β x1 + βx2 is a homogeneous representation of  1 − α y1 + αy2. The weights  1 − β  and β are used to obtain the other interpolated values. This does complicate the Bresenham algorithm somewhat, but it is still possible to use an extension of the Bresenham algorithm  cf.  Heckbert and Moreton, 1991  .  Hyperbolic interpolation is most useful when a polygon is being viewed obliquely with the near portion of the polygon much closer to the viewer than the far part. For an example of how hyperbolic interpolation can help with compensating for perspective distortion, see Figure V.2 on page 128.  IV.6 Spherical Linear Interpolation  This section discusses “spherical linear interpolation,” also called “slerp”-ing, which is a method of interpolating between points on a sphere.5 Fix a dimension d > 1 and consider the unit sphere in Rd. This sphere consists of the unit vectors x ∈ Rd. In R2, the unit sphere is just the unit circle. In R3, the unit sphere is called S2 or the “2-sphere” and is an ordinary sphere. In R4, it is called S3 or the “3-sphere” and is a hypersphere.  Let x and y be points on the unit sphere and further assume that they are not antipodal  i.e., are not directly opposite each other on the sphere . Then, there is a unique shortest path from x to y on the sphere. This shortest path is called a geodesic and lies on a great circle. A great circle is deﬁned to be the intersection of a plane containing the origin  i.e., a two-dimensional linear subspace of Rd  and the unit sphere. Thus, a great circle is an ordinary circle of radius 1. Now suppose also that α is between 0 and 1. We wish to ﬁnd the point z on the sphere that is fraction α of the distance from the point x to y along the geodesic, as shown in Figure IV.18. This is sometimes called “slerp”-ing for “Spherical Linear intERPolation,” and is denoted by z = slerp x, y, α . The terminology comes from  Shoemake, 1985  who used slerping in R4 for interpolating quaternions on the 3-sphere  see Section XII.3.7 .  An important aspect of spherical linear interpolation is that it is nonlinear: in particular, it  is not good enough to form the interpolant by the formula   1 − α x + αy  1 − α x + αy ,  because this will traverse the geodesic at a nonconstant rate with respect to α. Instead, we want to let z be the result of rotating the vector x a fraction α of the way toward y. That is, if the angle  5 The material in this section is not needed until the discussion of interpolation of quaternions in  Section XII.3.7.   IV.6 Spherical Linear Interpolation  123  y  z  x  ϕ  αϕ  Figure IV.18. The angle between x and y is ϕ, and slerp x, y, α  is the vector z obtained by rotating x a fraction α of the way toward y. All vectors are unit vectors because x, y, and z lie on the unit sphere.  between x and y is equal to ϕ, then z is the vector coplanar with 0, x, and y that is obtained by rotating x through an angle of αϕ toward y. We now give a mathematical derivation of the formulas for spherical linear interpolation  slerping . Recall that ϕ is the angle between x and y; we have 0 ≤ ϕ < 180 . If ϕ = 180 ◦ , then slerping is undeﬁned, since there is no unique direction or shortest geodesic from x to y. Referring to Figure IV.19, we let v be the component of y that is perpendicular to x and let w be the unit vector in the same direction as v.  ◦  since this calculation rotates x through an angle of αϕ.  An alternative formulation of the formula for slerping can be given by the following deri-  IV.27  v = y −  cos ϕ x = y −  y · x x, w = v sin ϕ  v√ v · v  =  .  Then we can deﬁne slerp x, y, α  by  slerp x, y, α  = cos αϕ x + sin αϕ w,  vation:  slerp x, y, α  = cos αϕ x + sin αϕ w = cos αϕ x + sin αϕ   y −  cos ϕ x  sin ϕ  w  y  v  z  x  Figure IV.19. Vectors v and w are used to derive the formula for spherical linear interpolation. The vector v is the component of y perpendicular to x, and w is the unit vector in the same direction. The magnitude of v is sin ϕ.   124  Averaging and Interpolation   cid:12   x + sin αϕ  sin ϕ  y  x + sin αϕ  sin ϕ  y   cid:11   cos ϕ sin ϕ  cos αϕ  − sin αϕ   = = sin ϕ cos αϕ  − sin αϕ  cos ϕ = sin ϕ − αϕ  = sin  1 − α ϕ   sin ϕ x + sin αϕ  sin ϕ  sin ϕ  x + sin αϕ  sin ϕ  y.  y  IV.28 The next-to-last equality was derived using the sine difference formula sin a − b  = sin a cos b − sin b cos a.  sin ϕ  The usual method for computing spherical linear interpolation is based on Equation IV.28. Since typical applications of slerping require multiple uses of interpolation between the same two points x and y, it makes sense to precompute the values of ϕ and s = sin ϕ. This is done by the following pseudocode:  Precompute_for_Slerp x, y  {  Set c = x · y; Set ϕ = acos c ; Set s = sin ϕ ;  }     Cosine of ϕ    Compute ϕ with arccos function    Sine of ϕ  An alternative method for precomputing ϕ and s can provide a little more stability for very  small angles ϕ without much extra computation:  Precompute_for_Slerp x, y  {  Set c = x · y; Set v = y − cx; v · v; Set s = Set ϕ = atan2 s,c ;  √     Cosine of ϕ     Sine of ϕ    Compute ϕ = arctan s c   } Then, given any value for α, 0 ≤ α ≤ 1, compute slerp x, y, α  by  Slerp x, y, α  {     ϕ and s=sin ϕ have already been precomputed.  sin  1 − α ϕ   sin ϕ  x + sin αϕ  sin ϕ  y;  Set z =  Return z;  } As written above, there will a divide-by-zero error when ϕ = 0 because then sin ϕ = 0. In addition, for ϕ close to zero, the division by a near-zero value can cause numerical instability. To avoid this, you should use the following approximations when ϕ ≈ 0:  sin  1 − α ϕ   sin ϕ  ≈  1 − α   and  sin αϕ   sin ϕ  ≈ α.   125 IV.6 Spherical Linear Interpolation These approximations are obtained by using sin ψ ≈ ψ when ψ ≈ 0. The error in these approx- imations can be estimated from the Taylor series expansion of sin ψ; namely, sin ψ ≈ ψ − 1 ψ 3. The test of ϕ ≈ 0 can be replaced by the condition that roundoff error makes 1 − 1 ϕ2 eval- uate to the value 1. For single-precision ﬂoating point, this condition can be replaced by the −4. For double-precision ﬂoating point, the condition ϕ < 10 −9 can be condition that ϕ < 10 used.  6  6   V  Texture Mapping  V.1 Texture Mapping an Image  Texture mapping, in its simplest form, consists of applying a graphics image, a picture, or a pattern to a surface. A texture map can, for example, apply an actual picture to a surface such as a label on a can or a picture on a billboard or can apply semirepetitive patterns such as wood grain or stone surfaces. More generally, a texture map can hold any kind of information that affects the appearance of a surface: the texture map serves as a precomputed table, and the texture mapping then consists simply of table lookup to retrieve the information affecting a particular point on the surface as it is rendered. If you do not use texture maps, your surfaces will either be rendered as very smooth, uniform surfaces or will need to be rendered with very small polygons so that you can explicitly specify surface properties on a ﬁne scale.  Texture maps are often used to very good effect in real-time rendering settings such as computer games since they give good results with a minimum of computational load. In addition, texture maps are widely supported by graphics hardware such as graphics boards for PCs so that they can be used without needing much computation from a central processor.  Texture maps can be applied at essentially three different points in the graphics rendering  process, which we list more or less in order of increasing generality and ﬂexibility:    A texture map can hold colors that are applied to a surface in “replace” or “decal” mode: the texture map colors just overwrite whatever surface colors are otherwise present. In this case, no lighting calculations should be performed, as the results of the lighting calculations would just be overwritten.    A texture map can hold attributes such as color, brightness, or transparency that affect the surface appearance after the lighting model calculations are completed. In this case, the texture map attributes are blended with, or modulate, the colors of the surface as calculated by the lighting model. This mode and the ﬁrst one are the most common modes for using texture maps.    A texture map can hold attributes such as reﬂectivity coefﬁcients, normal displacements, or other parameters for the Phong lighting model or the Cook–Torrance model. In this case, the texture map values modify the surface properties that are input to the lighting model. A prominent example of this is “bump mapping,” which affects the surface normals by specifying virtual displacements to the surface.  Of course, there is no reason why you cannot combine various texture map techniques by applying more than one texture map to a single surface. For example, one might apply both  126   V.1 Texture Mapping an Image  127  an ordinary texture map that modulates the color of a surface together with a bump map that perturbs the normal vector. In particular, one could apply texture maps both before and after the calculation of lighting.  A texture map typically consists of a two-dimensional, rectangular array of data indexed with two coordinates s and t that both vary from 0 to 1. The data values are usually colors but could be any other useful value. The data in a texture map can be generated from an image such as a photograph, a drawing, or the output of a graphics program. The data can also be procedurally generated; for example, simple patterns like a checkerboard pattern can easily be computed. Procedurally generated data can either be precomputed and stored in a two-dimensional array or can be computed as needed. Finally, the texture map may be created during the rendering process itself; an example of this would be generating an environment map by prerendering the scene from one or more viewpoints and using the results to build a texture map used for the ﬁnal rendering stage.  This chapter will discuss the following aspects of texture mapping. First, as a surface is rendered, it is necessary to assign texture coordinates s and t to vertices and then to pixels. These s and t values are used as coordinates to index into the texture and specify what position in the texture map is applied to the surface. Methods of assigning texture coordinates to positions on a surface are discussed in Section V.1.2. Once texture coordinates are assigned to vertices on a polygon, it is necessary to interpolate them to assign texture coordinates to rendered pixels: the mathematics behind this is discussed in Section V.1.1. Texture maps are very prone to bad visual effects from aliasing; this can be controlled by “mipmapping” and other techniques, as is discussed in Section V.1.3. Section V.2 discusses bump mapping, and Section V.3 discusses environment mapping. The remaining sections in this chapter cover some of the practical aspects of using texture mapping and pay particular attention to the most common methods of utilizing texture maps in OpenGL.  V.1.1 Interpolating a Texture to a Surface  The ﬁrst step in applying a two-dimensional texture map to a polygonally modeled surface is to assign texture coordinates to the vertices of the polygons: that is to say, to assign s and t values to each vertex. Once this is done, texture coordinates for points in the interior of the polygon may be calculated by interpolation. If the polygon is a triangle  or is triangulated , you may use barycentric coordinates to linearly interpolate the values of the s and t coordinates across the triangle. If the polygon is a quadrilateral, you may use bilinear interpolation to interpolate the values of s and t across the interior of the quadrilateral. The former process is shown in Figure V.1, where a quadrilateral is textured with a region of a checkerboard texture map; the distortion is caused by the fact that the s and t coordinates do not select a region of the texture map that is the same shape as the quadrilateral. The distortion is different in the upper right and the lower left halves of the quadrilateral because the polygon was triangulated, and the linear interpolation of the texture coordinates was applied independently to the two triangles. For either linear or bilinear interpolation of texture coordinates, it may be desirable to include the hyperbolic interpolation correction that compensates for the change in distance affecting the rate of change of texture coordinates. When a perspective projection is used, hyperbolic interpolation corrects for the difference between interpolating in screen coordinates and inter- polating in the coordinates of the 3-D model. This is shown in Figure V.2, where hyperbolic interpolation makes more distant squares be correctly foreshortened. Refer to Section IV.5 for the mathematics of hyperbolic interpolation.  Hyperbolic interpolation can be enabled in OpenGL by using the command  glHint  GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST  ;   128  Texture Mapping   cid:1 0, 1 cid:2   4 cid:2   cid:1  3 4 , 3   cid:1 0, 0 cid:2   4 , 0 cid:2   cid:1  3  Figure V.1. The square on the left is a texture map. The square on the right is ﬁlled with a quadrilateral region of this texture map. The coordinates labeling the corners of the square are s, t values indexing into the texture map. The subregion of the checkerboard texture map selected by the s and t coordinates is shown in the left square. This subregion of the texture map was converted to two triangles ﬁrst, and each triangle was mapped by linear interpolation into the corresponding triangle in the square on the right: this caused the visible diagonal boundary between the triangles.  The disadvantage of hyperbolic interpolation is that it requires extra calculation and thus may be slower. Hyperbolic interpolation is necessary mostly when textures are applied to large, obliquely viewed polygons. For instance, if d1 and d2 are the minimum and maximum distances from the view position to points on the polygon, and if the difference in the distances, d2 − d1, is comparable to or bigger than the minimum distance d1, then hyperbolic interpolation may be noticeably helpful.  V.1.2 Assigning Texture Coordinates  We next discuss some of the issues involved in assigning texture coordinates to vertices on a surface. In many cases, the choice of texture coordinates is a little ad hoc and depends greatly on the type of surface and the type of texture, as well as other factors. Because most surfaces are not ﬂat, but we usually work with ﬂat two-dimensional textures, there is often no single best method of assigning texture coordinates. We will deal with only some of the simplest examples of how texture map coordinates are assigned: namely, for cylinders, for spheres, and for tori. We also discuss some of the common pitfalls in assigning texture coordinates. For more sophisticated mathematical tools that can aid the process of assigning texture coordi- nates to more complex surfaces, consult the article  Bier and Sloan Jr., 1986  or the textbook  Watt and Watt, 1992 .  First, consider the problem of mapping a texture map onto a shape whose faces are ﬂat surfaces – for example, a cube. Since the faces are ﬂat and a two-dimensional texture map is ﬂat, the process of mapping the texture map to the surface does not involve any nonlinear stretching or distortion of the texture map. For a simple situation such as a cube, one can usually  Without hyperbolic interpolation Figure V.2. The ﬁgure on the right uses hyperbolic interpolation to render the correct perspective fore- shortening. The ﬁgure on the left does not.  With hyperbolic interpolation   V.1 Texture Mapping an Image  129  Figure V.3. A texture map and its application to a cylinder.  just set the texture coordinates explicitly by hand. Of course, a single vertex on a cube belongs to three different faces of the cube, and thus it generally is necessary to draw the faces of the cube independently so as to use the appropriate texture maps and different texture coordinates for each face. To apply texture maps to surfaces other than individual ﬂat faces, it is convenient if the surface can be parametrically deﬁned by some function p u, v , where  cid:5 u, v cid:6  ranges over some region of R2. In most cases, one sets the texture coordinates s and t as functions of u and v, but more sophisticated applications might also let the texture coordinates depend on p u, v , the surface normal, or both.  For the ﬁrst example of a parametrically deﬁned surface, consider how to map texture coordinates onto the surface of a cylinder. We will pay attention only to the problem of how to map a texture onto the side of the cylinder, not onto the top or bottom face. Suppose the cylinder has height h and radius r and that we are trying to cover the side of the cylinder by a texture map that wraps around the cylinder much as a label on a food can wraps around the can  see Figure V.3 . The cylinder’s side surface can be parametrically deﬁned by the variables θ and y with the function  p θ, y  =  cid:5 r sin θ, y, r cos θ cid:6 ,  which places the cylinder in “standard” position with its center at the origin and with the y-axis as the central axis of the cylinder. We let y range from −h 2 to h 2 so the cylinder has height h. One of the most natural choices for assigning texture coordinates to the cylinder would be  to use  s = θ 360  and  t = y + h 2  .  h  V.1  This lets s vary linearly from 0 to 1 as θ varies from 0 to 360  we are still using degrees to measure angles  and lets t vary from 0 to 1 as y varies from −h 2 to h 2. This has the effect of pasting the texture map onto the cylinder without any distortion beyond being scaled to cover the cylinder; the right and left boundaries meet at the front of the cylinder along the line where x = 0 and z = r.  ◦  Exercise V.1 How should the assignment of cylinder texture coordinates be made to have the left and right boundaries of the texture map meet at the line at the rear of the cylinder where x = 0 and z = −r?  Although mapping texture coordinates to the cylinder is very straightforward, there is one potential pitfall that can arise when drawing a patch on the cylinder that spans the line where   130  z  y  w  x  w  x  z  y  Texture Mapping  Figure V.4. The quadrilateral x, y, z, w selects a region of the texture map. The crosshatched region of the texture map is not the intended region of the texture map. The shaded area is the intended region.  the texture boundaries meet. This is best explained with an example. Suppose we are drawing the patch shown in Figure V.4, which has vertices x, y, z, and w. For x and w, the value of θ is, say, −36 ◦ . Now if you compute the texture coordinates with 0 ≤ s ≤ 1, then we get s = 0.9 for the texture coordinate of x and w and s = 0.1 for the points y and z. This would have the unintended effect of mapping the long cross-hatched rectangular region of the texture map shown in Figure V.4 into the patch on the cylinder.  , and, for y and z, the value of θ is 36  ◦  To ﬁx this problem, one should use a texture map that repeats, or “wraps around.” A repeating texture map is an inﬁnite texture map that covers the entire st-plane by tiling the plane with inﬁnitely many copies of the texture map. Then, you can let s = 0.9 for x and w and s = 1.1 for y and z.  Or you can use s = −0.1 and s = 0.1, respectively, or, more generally, you can add on any integer amount to the s values.  Of course this means that you need to use a certain amount of care in how you assign texture coordinates. Recall from Section II.4.2 that small roundoff errors in positioning a vertex can cause pixel-sized gaps in surfaces. Because of this, it is important that any point speciﬁed more than once by virtue of being part of more than one surface patch always has its position speciﬁed with exactly the same θ and y value. The calculation of the θ and y values must be done by exactly the same method each time to avoid roundoff error. However, the same point may be drawn multiple times with different texture values. An example of this is the point y of Figure V.4, which may need s = 0.1 sometimes and s = 1.1 sometimes. In particular, the texture coordinates s and t are not purely functions of θ and y; so you need to keep track of the “winding number,” that is, the number of times that the cylinder has been wound around. There is still a residual risk that roundoff error may cause s = 0.1 and s = 1.1 to correspond to different pixels in the texture map. This would be expected to cause serious visible defects in the image only rarely.  We now turn to the problem of assigning texture coordinates to a sphere. Unlike the case of a cylinder, a sphere is intrinsically curved, which means that there is no way to cover  even part of  a sphere with a ﬂat piece paper without causing the paper to stretch, fold, tear, or otherwise distort. This is also a problem faced by map makers, since it means there is no completely accurate, distortion-free way to represent the surface of the Earth on a ﬂat map.  The Mercator map is an often-used method to map a spherical surface to a ﬂat map but suffers from the problem of distorting relative sizes as well as from the impossibility of using it to map all the way to the poles.   The problem of assigning texture coordinates to points on a sphere is the problem faced by map makers, but in reverse: instead of mapping points on the sphere to a ﬂat map, we are as- signing points from a ﬂat texture map onto a sphere. The sphere can be naturally parameterized by variables θ and ϕ using the parametric function  p θ, ϕ  =  cid:5 r sin θ cos ϕ, r sin ϕ, r cos θ cos ϕ cid:6 .   V.1 Texture Mapping an Image  131  Figure V.5. Two applications of a texture map to a sphere. The sphere on the left has a checkerboard texture applied with texture coordinates given by the spherical map of Equation V.2. The sphere on the right uses texture coordinates given by the cylindrical projection of Equation V.3. The spheres are drawn with a tilt and a small rotation.  Here, θ represents the heading angle  i.e., the rotation around the y-axis , and ϕ represents the azimuth or “pitch” angle. As the value of θ varies from 0 to 360 , and the value of ϕ ranges from −90 to 90  , the points p θ, φ  sweep out all of the sphere.  ◦  ◦  The ﬁrst natural choice for assigning texture map coordinates would be  s = θ 360  t = ϕ 180 This assignment works relatively well.  and  + 1 2  .  the ϕ value for t. Namely,  s = θ 360  and  t = sin ϕ 2  + 1 2  .  A second choice for assigning texture coordinates would be to use the y value in place of  V.2  V.3  This assignment is mapping the sphere orthogonally outward to the surface of a cylinder and then unwrapping the cylinder to a ﬂat rectangle. One advantage of this second map is that it is area preserving.  Figure V.5 shows a checkerboard pattern applied to a sphere with the two texture-coordinate assignment functions. Both methods of assigning texture coordinates suffer from the problem of bunching up at the poles of the sphere. Since the sphere is intrinsically curved, some kind of behavior of this type is unavoidable.  Finally, we consider the problem of how to apply texture coordinates to the surface of a torus. Like the sphere, the torus is intrinsically curved; thus, any method of assigning texture map coordinates on a torus must involve some distortion. Recall from Exercise III.3 on page 80 that the torus has the parametric equation  p θ, ϕ  =  cid:5  R + r cos ϕ  sin θ, r sin ϕ,  R + r cos ϕ  cos θ cid:6 ,  where R is the major radius, r is the minor radius, and both θ and ϕ range from 0 to 360 most obvious way to assign texture coordinates to the torus would be  ◦  . The  s = θ 360  and  t = ϕ 360  .  Figure V.6 illustrates the application of a checkerboard texture map to a torus.  Exercise V.2 Where would the center of the texture map appear on the torus under the preceding assignment of texture coordinates to the torus? How would you change the assignment so as to make the center of the texture map appear at the front of the torus  on the positive z-axis ?   132  Texture Mapping  Figure V.6. A checkerboard texture map applied to a torus.  V.1.3 Mipmapping and Antialiasing  Texture maps often suffer from problems with aliasing. The term “aliasing” means, broadly speaking, any problem that results from conversion between digital and analog or from conver- sion between differently sampled digital formats. In the case of texture maps, aliasing problems can occur whenever there is not a one-to-one correspondence between screen pixels and texture pixels. For the sake of discussion, we assume that texture coordinates are interpolated from the vertices of a polygon to give a texture coordinate to each individual pixel in the interior of the polygon. We then assume that the texture coordinates for a screen pixel are rounded to the nearest pixel position in the texture and that the color of that texture map pixel is displayed on the screen in the given pixel location. In other words, each screen pixel holds the color from a single texture map pixel. We will shortly discuss better ways to assign color to screen pixels from the texture map colors, but we make this assumption for the moment to discuss how this straightforward method of copying from a texture map to the screen leads to problems.  First, consider the case in which the texture map resolution is less than the corresponding resolution of the screen. In this case, a single texture map pixel will correspond to a block of pixels on the screen. This will make each texture map pixel appear as a  probably more-or-less rectangularly shaped  region of the screen. The result is a blown up version of the texture map that shows each pixel as a too-large block.  Second, consider the  potentially much worse  case in which the screen pixel resolution is similar to, or is less than, the resolution of the texture map. At ﬁrst thought, one might think that this is a good situation, for it means the texture map has plenty of resolution to be drawn on the screen. However, as it turns out, this case can lead to very bad visual effects such as interference and ﬂashing. The problems arise from each screen pixel’s being assigned a color from only one texture map pixel. When the texture map pixel resolution is higher than the screen resolution, this means that only a fraction of the texture map pixels are chosen to be displayed on the screen. As a result, several kinds of problems may appear, including unwanted interference patterns, speckled appearance, graininess, or other artifacts. When rendering a moving texture map, different pixels from the texture map may be displayed in different frames; this can cause further unwanted visual effects such as strobing, ﬂashing, or scintillating. Similar effects can occur when the screen resolution is slightly higher than the texture map resolution owing to the fact that different texture map pixels may correspond to different numbers of screen pixels. Several methods are available to ﬁx, or at least partially ﬁx, the aliasing problems with texture maps. We will discuss three of the more common ones: bilinear interpolation, mipmapping, and stochastic supersampling.  Interpolating Texture Map Pixels. One relatively easy way to smooth out the problems that occur when the screen resolution is about the same as the texture map resolution is to   V.1 Texture Mapping an Image  133  bilinearly interpolate the color values from several texture map pixels and use the resulting average color for the screen pixel. This is done by ﬁnding the exact s and t texture coordinates for the screen pixels, locating the four pixels in the texture map nearest to the  cid:5 s, t cid:6  position of the texture map, and using bilinear interpolation to calculate a weighted average of the four texture map pixel colors.  For the case in which the texture map resolution is signiﬁcantly greater  more than twice as great, say  than the screen resolution, one could use more than just four pixels from the texture map to form an average color to display on the screen. Indeed, from a theoretical point of view, this is more or less exactly what you would wish to do: namely, ﬁnd the region of the texture map that corresponds to a screen pixel and then calculate the average color of the pixels in that region, taking care to properly average in fractions of pixels that lie on the boundary of the region. This can be a potentially expensive process, however, and thus instead it is common to use “mipmapping” to precompute some of the average colors.  Mipmapping. The term “mipmapping” was coined by  Williams, 1983 , who introduced it as a technique of precomputing texture maps of reduced resolution – in other words, as a “level of detail”  LOD  technique. The term “mip” is an acronym for a Latin phrase, multum in parvo, or “many in one.” Mipmapping tries to avoid the problems that arise when displaying a texture map that has greater resolution than the screen by precomputing a family of lower resolution texture maps and always displaying a texture map whose resolution best matches the screen resolution. The usual way to create mipmap textures is to start with a high resolution texture map of dimension N × M. It is convenient to assume that N and M are powers of two. Then form a reduced resolution texture map of size  N  2  ×  M 2  by letting the pixel in row i, column j in the reduced resolution texture map be given the average of the four pixels in rows 2i and 2i + 1 and in columns 2 j and 2 j + 1 of the original texture map. Then recursively apply this process as often as needed to get reduced resolution texture maps of arbitrarily low resolution. When a screen pixel is to be drawn using a texture map, it can be drawn using a pixel from the mipmapped version of the texture map that has resolution no greater than that of the screen. Thus, when the texture-mapped object is viewed from a distance, a low-resolution mipmap will be used; whereas, when viewed up close, a high-resolution version will be used. This will get rid of many of the aliasing problems, including most problems with ﬂashing and strobing. There can, however, be a problem when the distance from the viewer to the texture-mapped surface is changing, since switching from one mipmap version to another can cause a visible “pop” or “jump” in the appearance of the texture map. This can largely be avoided by rendering pixels using the two mipmap versions closest to the screen resolution and linearly interpolating between the results of the two texture maps.  A nice side beneﬁt of the use of mipmaps is that it can greatly improve memory usage, provided the mipmap versions of texture maps are properly managed. Firstly, if each mipmap version is formed by halving the pixel dimensions of the previous mipmap, then the total space used by each successive mipmap is only one quarter the space of the previous mipmap. Since  1 + 1 4  + 1 16  + 1 64  + ··· = 1  ,  1 3  this means that the use of mipmaps incurs only a 33 percent memory overhead. Even better, in any given scene, it is usual for only relatively few texture maps to be viewed from a close distance, whereas many texture maps may be viewed from a far distance. The more distant texture maps would be viewed at lower resolutions, and so only the lower resolution mipmap   134  Texture Mapping  Figure V.7. In the ﬁrst ﬁgure, the nine supersample points are placed at the centers of the nine subpixels. In the second ﬁgure, the supersample points are jittered but are constrained to stay inside their subpixel.  versions of these need to be stored in the more accessible memory locations  e.g., in the cache or on a graphics chip . This allows the possibility of more effectively using memory by keeping only the needed mipmap versions of texture maps available; of course, this may require sophisticated memory management.  One big drawback to mipmapping is that it does not fully address the problem that arises when surfaces are viewed obliquely. In this case, the ratio of the texture map resolution and the screen resolution may be quite different along different directions of the texture map, and thus no single mipmap version may be fully appropriate. Since the oblique view could come from any direction, there is no good way to generate enough mipmaps to accommodate all view directions.  V.1.4 Stochastic Supersampling  The term supersampling refers to rendering an image at a subpixel level of resolution and then averaging over multiple subpixels to obtain the color value for a single pixel. This technique can be adapted to reduce aliasing with texture maps by combining it with a stochastic, or randomized, sampling method.  The basic idea of nonstochastic supersampling is as follows. First, we divide each pixel into subpixels; for the sake of discussion, we assume each pixel is divided into nine subpixels, but other numbers of subpixels could be used instead. The nine subpixels are arranged in a 3 × 3 array of square subpixels. We render the image as usual into the subpixels, just as we would usually render the image for pixels, but use triple the resolution. Finally, we take the average of the results for the nine pixels and use this average for the overall pixel color.  Ninefold nonstochastic supersampling can be useful in reducing texture map aliasing prob- lems or at least in delaying their onset until the resolution of the texture map is about three times as high as the resolution of the screen pixels. However, if the texture map contains regular pat- terns of features or colors, then even with supersampling there can be signiﬁcant interference effects.  The supersampling method can be further improved by using stochastic supersampling. In its simplest form, stochastic supersampling chooses points at random positions inside a pixel, computes the image color at the points, and then averages the colors to set the color value for the pixel. This can cause unrepresentative values for the average if the randomly placed points are clumped poorly, and better results can be obtained by using a jitter method to select the supersampling points. The jitter method works as follows: Initially, the supersample points are distributed evenly across the pixel. Then each supersample point is “jittered”  i.e., has its position perturbed slightly . A common way to compute the jitter on nine supersample points is to divide the pixel into a 3 × 3 array of square subpixels and then place one supersample point randomly into each subpixel. This is illustrated in Figure V.7.   V.2 Bump Mapping  135  Figure V.8. A bump-mapped torus. Note the lack of bumps on the silhouette. Four white lights are shining on the scene plus a low level of ambient illumination. This picture was generated with the ray tracing software described in Appendix B. See Color Plate 6.  It is important that the positions of the supersampling points be jittered independently for  each pixel; otherwise, interference patterns can still form.  Jittering is not commonly used for ordinary texture mapping but is often used for antialiasing in non-real-time environments such as ray-traced images. Figure IX.9 on page 245 shows an example of jittering in ray tracing. It shows three pool balls on a checkerboard texture; part  a  does not use supersampling, whereas part  b  does. Note the differences in the checkerboard pattern off towards the horizon on the sides of the image.  Jittering and other forms of stochastic supersampling decrease aliasing but at the cost of increased noise in the resulting image. This noise generally manifests itself as a graininess similar to that seen in a photograph taken at light levels that were too low. The noise can be reduced by using higher numbers of supersample points.  V.2 Bump Mapping  Bump mapping is used to give a smooth surface the appearance of having bumps or dents. It would usually be prohibitively expensive to model all the small dents and bumps on a surface with polygons because this would require a huge number of very small polygons. Instead, bump mapping works by using a “height texture” that modiﬁes surface normals. When used in conjunction with Phong lighting or Cook–Torrance lighting, the changes in lighting caused by the perturbations in the surface normal will give the appearance of bumps or dents.  An example of bump mapping is shown in Figure V.8. Looking at the silhouette of the torus, you can see that the silhouette is smooth with no bumps. This shows that the geometric model for the surface is smooth: the bumps are instead an artifact of the lighting in conjunction with perturbed normals.  Bump mapping was ﬁrst described by  Blinn, 1978 , and this section presents his approach to efﬁcient implementation of bump mapping. Suppose we have a surface that is speciﬁed parametrically by a function p u, v . We also assume that the partial derivatives  are deﬁned and nonzero everywhere and that we are able to compute them.  All the points and vectors in our discussion are functions of u and v even if we do not always indicate this explicitly.  As was discussed in Section III.1.6, a unit vector normal to the surface is given by  pu = ∂p ∂u  and  pv = ∂p  ,  ∂v  n u, v  = pu × pv pu × pv .   136  Texture Mapping   cid:1 u2, v2 cid:2    cid:1 u1, v1 cid:2   Figure V.9. The dashed curve represents a cross section of a two-dimensional surface. The surface is imagined to be displaced perpendicularly a distance d u, v  to form the dotted curve. The outward direction of the surface is upward, and thus the value d u1, v1  is positive and the value d u2, v2  is negative.  The bump map is a texture map of scalar values d u, v  that represent displacements in the direction of the normal vector. That is, a point on the surface p u, v  is intended to undergo a “virtual” displacement of distance d u, v  in the direction of the normal vector. This process is shown in Figure V.9. However, remember that the surface is not actually displaced by the texture map, but rather we just imagine the surface as being displaced in order to adjust  only  the surface normals to match the normals of the displaced surface.  The formula for a point on the displaced surface is  ∗ p   u, v  = p + dn.  The normals to the displaced surface can be calculated as follows. First, ﬁnd the partial deriva- tives to the new surface by  ∗ ∂p ∂u ∗ ∂p ∂v  ∗  ∂p ∂u ∗ ∂p ∂v  = ∂p ∂u = ∂p ∂v  + ∂d ∂u + ∂d ∂v  n + d  n + d  ∂n ∂u  ,  ∂n ∂v  .  ≈ ∂p ∂u ≈ ∂p ∂v  + ∂d ∂u + ∂d ∂v  n,  n.  By taking the cross product of these two partial derivatives, we can obtain the normal to the perturbed surface; however, ﬁrst we simplify the partial derivatives by dropping the last terms to obtain the approximations  We can justify dropping the last term on the grounds that the displacement distances d u, v  are small because only small bumps and dents are being added to the surface and that the partial derivatives of n are not too large if the underlying surface is relatively smooth. Note, however, that the partial derivatives ∂d ∂u and ∂d ∂v cannot be assumed to be small since the bumps and dents would be expected to have substantial slopes. With this approximation, we can approximate the normal of the displaced surface by calculating   cid:11   cid:11   m ≈  =  ∂p ∂u  ∂p ∂u  + ∂d ∂u × ∂p ∂v   cid:11   cid:11    cid:12   cid:12   n  ×  +   cid:12   cid:12    cid:11   ∂p ∂v  + ∂d ∂v  n  ∂d ∂u  n × ∂p  ∂v  −  ∂d ∂v  n × ∂p ∂u   cid:12   .  V.4  The vector m is perpendicular to the displaced surface but is not normalized: the unit vector normal to the displaced surface is then just n  ∗ = m m.   V.3 Environment Mapping  137  Note that Equation V.4 uses only the partial derivatives of the displacement function d u, v ; the values d u, v  are not directly needed at all. One way to compute the partial derivatives is to approximate them using ﬁnite differences. However, a simpler and more straightforward method is not to store the displacement function values themselves but instead to save the partial derivatives as two scalar values in the texture map. ∗ The algorithm for computing the perturbed normal n  will fail when either of the partial derivatives ∂p ∂u or ∂p ∂v is equal to zero. This happens for exceptional points on many common surfaces; for instance, at the north and south poles of a sphere using either the spherical or the cylindrical parameterization. Thus, you need to be careful when applying a bump map in the neighborhood of a point where a partial derivative is zero.  It has been presupposed in the preceding discussion that the bump map displacement dis- tance d is given as a function of the variables u and v. It is sometimes more convenient to have a bump map displacement distance function D s, t , which is a function of the texture coordinates s and t. The texture coordinates are of course functions of u and v, that is, we have s = s u, v  and t = t u, v , expressing s and t as either linear or bilinear functions of u and v. Then the bump map displacement function d u, v  is equal to D s u, v , t u, v  . The chain rule then tells us that ∂s ∂u  ∂d ∂u  ∂t ∂u  = ∂ D ∂s = ∂ D ∂s  ∂s ∂v  + ∂ D ∂t + ∂ D ∂t  ∂d ∂v  ∂t ∂v  .  The partial derivatives of s and t are either constant in a given u, v-patch in the case of linear interpolation or can be found from Equation IV.19 on page 109 in the case of bilinear interpolation.  Bump-mapped surfaces can have aliasing problems when viewed from a distance – par- ticularly when the distance is far enough that the bumps are rendered at about the size of an image pixel or smaller. As usual, stochastic supersampling can reduce aliasing. A more ad hoc solution is to reduce the height of the bumps gradually based on the level of detail at which the bump map is being rendered; however, this does not accurately render the specular highlights from the bumps.  Bump mapping is not supported in the standard version of OpenGL. This is because the design of the graphics-rendering pipeline in OpenGL only allows texture maps to be applied after the Phong lighting calculation has been performed. Bump mapping must precede Phong lighting model calculations because Phong lighting depends on the surface normal. For this reason, it would also make sense to combine bump mapping with Phong interpolation but not with Gouraud interpolation.  Bump mapping can be implemented in extensions of OpenGL that include support for  programming modern graphics hardware boards with pixel shaders.  V.3 Environment Mapping  Environment mapping, also known as “reﬂection mapping,” is a method of rendering a shiny surface showing a reﬂection of a surrounding scene. Environment mapping is relatively cheap compared with the global ray tracing discussed later in Chapter IX but can still give good effects – at least for relatively compact shiny objects.  The general idea of environment mapping is as follows: We assume we have a relatively small reﬂecting object. A small, ﬂat mirror or spherical mirror  such as on a car’s passenger side door , or a compact object with a mirror-like surface such as a shiny teapot, chrome faucet, toaster, or silver goblet are typical examples. We then obtain, either from a photograph or by   138  Texture Mapping  Figure V.10. An environment map mapped into a sphere projection. This is the kind of environment map supported by OpenGL. See Color Plate 7.  The scene is the same as is shown in Figure V.11. Note that the front wall has the most ﬁdelity and the back wall the least. For this reason, spherical environment maps are best used when the view direction is close to the direction used to create the environment map.  computer rendering, a view of the world as seen from the center position of the mirror or object. From this view of the world, we create a texture map showing what is visible from the center position. Simple examples of such texture maps are shown in Figures V.10 and V.11.  When rendering a vertex on the reﬂecting object, one can use the viewpoint position, the vertex position, and surface normal to calculate a view reﬂection direction. The view reﬂection direction is the direction of perfect reﬂection from the viewpoint; that is, a ray of light emanat- ing from the viewer’s position to the vertex on the reﬂecting object would reﬂect in the view reﬂection direction. From the view reﬂection direction, one calculates the point in the texture map that corresponds to the view reﬂection direction. This gives the texture coordinates for the vertex.  The two most common ways of representing environment maps are shown in Figures V.10 and V.11. The ﬁrst ﬁgure shows the environment map holding the “view of the world” in  Figure V.11. An environment map mapped into a box projection consists of the six views from a point mapped to the faces of a cube and then unfolded to make a ﬂat image. This scene shows the reﬂection map from the point at the center of a room. The room is solid blue except for yellow writing on the walls, ceiling, and ﬂoor. The rectangular white regions of the environment map are not used. See Color Plate 8.   V.4 Texture Mapping in OpenGL  139  a circular area. This is the same as you would see reﬂected from a perfectly mirror-like small sphere viewed orthogonally  from a point at inﬁnity . The mathematics behind calculating the environment map texture coordinates is discussed a little more in Section V.4.6.  Figure V.11 shows the environment map comprising six square regions corresponding to the view seen through the six faces of a cube centered at the environment mapped object. This “box” environment map has a couple advantages over the former “sphere” environment map. Firstly, it can be generated for a computer-rendered scene using standard rendering methods by just rendering the scene six times from the viewpoint of the object in the directions of the six faces of a cube. Secondly, the “box” environment map can be used effectively from any view direction, whereas the “sphere” environment map can be used only from view directions close to the direction from which the environment was formed.   cid:1   Exercise V.3 Derive formulas and an algorithm for converting the view reﬂection di- rection into texture coordinates for the “box” environment map. Make any assumptions necessary for your calculations.  An interesting and fairly common use of environment mapping is to add specular highlights to a surface. For this, one ﬁrst creates an environment texture map that holds an image of the specular light levels in each reﬂection direction. The specular light from the environment map can then be added to the rendered image based on the reﬂection direction at each point. A big advantage of this approach is that the specular reﬂection levels from multiple lights can be precomputed and stored in the environment map; the specular light can then be added late in the graphics pipeline without the need to perform specular lighting calculations again.  V.4 Texture Mapping in OpenGL  We now discuss the most basic uses of texture mapping in OpenGL. Three sample programs are supplied  TextureBMP, FourTextures, and TextureTorus  that illustrate simple uses of texture mapping. You should refer to these programs as you read the descriptions of the OpenGL commands below.  V.4.1 Loading a Texture Map  To use a texture map in OpenGL, you must ﬁrst build an array holding the values of the texture map. This array will typically hold color values but can also hold values such as luminance, intensity, or alpha  transparency  values. OpenGL allows you to use several different formats for the values of the texture map, but the most common formats are ﬂoating point numbers  ranging from 0 to 1  or unsigned 8-bit integers  ranging from 0 to 255 .  Once you have loaded the texture map information into an array  pixelArray , you must call an OpenGL routine to load the texture map into a “texture object.” The most basic method for this is to call the routine glTexImage2D. A typical use of glTexImage2D might have the following form, with pixelArray an array of float’s:  glPixelStorei GL_UNPACK_ALIGNMENT, 1 ; glTexImage2D   GL_TEXTURE_2D, 0, GL_RGBA, textureWidth, textureHeight,  0, GL_RGBA, GL_FLOAT, pixelArray  ;  Another typical usage, with data stored in unsigned bytes, would have the form  glPixelStorei GL_UNPACK_ALIGNMENT, 1 ; glTexImage2D   GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight,  0, GL_RGB, GL_UNSIGNED_BYTE, pixelArray  ;   140  Texture Mapping  but now with pixelArray an array of unsigned char’s. The call to glPixelStorei tells OpenGL not to expect any particular alignment of the texture data in the pixel array.  This is actually needed only for data stored in byte formats rather than ﬂoating point format.   The parameters to glTexImage2D have the following meanings: The ﬁrst parame- ter, GL_TEXTURE_2D, speciﬁes that a texture is being loaded  as compared with using GL_PROXY_TEXTURE_2D, which checks if enough texture memory is available to hold the texture . The second parameter speciﬁes the mipmapping level of the texture; the highest res- olution image is level 0. The third parameter speciﬁes what values are stored in the internal OpenGL texture map object: GL_RGB and GL_RGBA indicate that color  and alpha  values are stored. The next two parameters specify the width and height of the texture map in pixels; the minimum dimension of a texture map  for level 0  is 64 × 64. The sixth parameter is 0 or 1 and indicates whether a border strip of pixels has been added to the texture map; the value 0 indicates no border. The seventh and eighth parameters indicate the format of the texture val- ues as stored in the programmer-created array of texture information. The last parameter is a pointer to the programmer-created array of texture values. The width and height of a texture map are required to equal a power of 2 or 2 plus a power of 2 if there is a border.  There are a huge number of options for the glTexImage2D command, and you should  refer to the OpenGL programming manual  Woo et al., 1999  for more information.  Frequently, one also wants to generate mipmap information for textures. Fortunately, OpenGL has a utility routine gluBuild2DMipmaps that does all the work of generating texture maps at multiple levels of resolution for you: this makes the use of mipmapping com- pletely automatic. The mipmap textures are generated by calling  for example :  gluBuild2DMipmaps  GL_TEXTURE_2D, GL_RGBA, textureWidth,  textureHeight, GL_RGBA, GL_FLOAT, pixelArray  ;  The parameters to gluBuild2DMipmaps have the same meanings as the parameters to glTexImage2D except that the level parameter is omitted since the gluBuild2DMipmaps is creating all the levels for you and that borders are not supported. The routine gluBuild2DMipmaps checks how much texture memory is available and decreases the resolution of the texture map if necessary; it also rescales the texture map dimensions to the nearest powers of two. It then generates all the mipmap levels down to a 1 × 1 texture map. It is a very useful routine and is highly recommended, at least for casual users.  OpenGL texture maps are always accessed with s and t coordinates that range from 0 to 1. If texture coordinates outside the range [0, 1] are used, then OpenGL has several options of how they are treated: ﬁrst, in GL_CLAMP mode, values of s and t outside the interval [0, 1] will index into a 1-pixel-wide border of the texture map, or, if there is no border, then the pixels on the edge of the texture are used instead. Second, GL_CLAMP_TO_EDGE mode clamps s and t to lie in the range 0 to 1: this acts like GL_CLAMP except that, if a border is present, it is ignored  CLAMP_TO_EDGE is supported only in OpenGL 1.2 and later . Finally, GL_REPEAT makes the s and t wrap around, namely the fractional part of s or t is used; that is to say, s −  cid:25 s cid:26  and t −  cid:25 t cid:26  are used in “repeat” mode. The modes may be set independently for the s and t texture coordinates with the following command:    glTexParameteri GL_TEXTURE_2D,  GL_TEXTURE_WRAP_S GL_TEXTURE_WRAP_T  ,  GL_REPEAT GL_CLAMP  GL_CLAMP_TO_EDGE  The default, and most useful, mode is the “repeat” mode for s and t values.  Section V.1.3 discussed the methods of averaging pixel values and of using mipmaps with multiple levels of detail to  partly  control aliasing problems and prevent interference effects        ;   V.4 Texture Mapping in OpenGL  and “popping.” When only a single texture map level is used, with no mipmapping, the following OpenGL commands allow the averaging of neighboring pixels to be enabled or disabled:  glTexParameteri GL_TEXTURE_2D,  GL_TEXTURE_MAG_FILTER GL_TEXTURE_MIN_FILTER  ,  GL_NEAREST GL_LINEAR   ;   cid:1   141   cid:2    cid:2    cid:1   The option GL_NEAREST instructs OpenGL to set a screen pixel color with just a single texture map pixel. The option GL_LINEAR instructs OpenGL to set the screen pixel by bilin- early interpolating from the immediately neighboring pixels in the texture map. The settings for “GL_TEXTURE_MIN_FILTER” apply when the screen pixel resolution is less than  that is, coarser than  the texture map resolution. The setting for “GL_TEXTURE_MAG_FILTER” applies when the screen resolution is higher than the texture map resolution.  When mipmapping is used, there is an additional option to set. OpenGL can be instructed either to use the “best” mipmap level  i.e., the one whose resolution is closest to the screen resolution  or to use linear interpolation between the two best mipmap levels. This is controlled with the following command:  glTexParameteri GL_TEXTURE_2D,  GL_NEAREST_MIPMAP_NEAREST  GL_LINEAR_MIPMAP_NEAREST GL_NEAREST_MIPMAP_LINEAR GL_LINEAR_MIPMAP_LINEAR   ;  GL_TEXTURE_MIN_FILTER,  This command is really setting two options at once. The ﬁrst ‘NEAREST’ or ‘LINEAR’ controls whether only one pixel is used from a given mipmap level or whether neighbor- ing pixels on a given mipmap level are averaged. The second part, ‘MIPMAP_NEAREST’ or ‘MIPMAP_LINEAR’, controls whether only the best mipmap level is used or whether the linear interpolation of two mipmap levels is used.  OpenGL has several additional advanced features that give you ﬁne control over mipmap- ping; for documentation on these, you should again consult the OpenGL programming manual.  V.4.2 Specifying Texture Coordinates  It is simple to specify texture coordinates in OpenGL. Before a vertex is drawn with glVer- tex*, you give the s and t texture coordinates for that vertex with the command  glTexCoord2f  s, t  ;  This command is generally given along with a glNormal3f command if lighting is enabled. Like calls to glNormal3f, it must be given before the call to glVertex*.  V.4.3 Modulating Color  In OpenGL, the colors and Phong lighting calculations are performed before the application of textures. Thus, texture properties cannot be used to set parameters that drive Phong lighting calculations. This is unfortunate in that it greatly reduces the usability of textures; on the other hand, it allows the texture coordinates to be applied late in the graphics rendering pipeline, where it can be done efﬁciently by special purpose graphics hardware. As graphics hard- ware becomes more powerful, this situation is gradually changing; however, for the moment, OpenGL supports only a small amount of posttexture lighting calculations through the use of a separate specular color  as described in Section V.4.4 .   142  Texture Mapping  The simplest form of applying a texture to a surface merely takes the texture map color and “paints” it on the surface being drawn with no change. In this situation, there is no need to set surface colors and normals or perform Phong lighting since the texture color will just overwrite any color already on the surface. To enable this simple “overwriting” of the surface color with the texture map color, you use the command  glTexEnvi  GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL  ;  There is a similar, less commonly used, option, GL_REPLACE, which acts just like GL_DECAL when the texture map does not have an alpha component.  The “decal” option, however, does not usually give very good results when used in a setting with lighting since the lighting does not affect the appearance of textured surfaces when the textures are applied in decal mode. The easiest and most common method of combining textures with lighting is to do the following: render the surface with Phong lighting enabled  turn this on with glEnable GL_LIGHTING  as usual , give the surface material a white or gray ambient and diffuse color and a white or gray specular color, and then apply the texture map with the GL_MODULATE option. This option is activated by calling  glTexEnvi  GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE  ;  What the “modulate” option does is take the colors rs, gs, and bs that were calculated for the surface with the Phong lighting model and the colors rt, gt, and bt from the texture map and form the products rsrt, gsgt, and bsbt. These products then become the new color of the screen pixel. This has the effect that the texture map color is modulated by the brightness of the lighting of the surface.  There are many other ways to control the interaction of texture map colors and surface colors. However, the two methods above are probably the most commonly used and the most useful. As usual, refer to the OpenGL programming manual  Woo et al., 1999  for more information on other ways to apply texture maps to surfaces.  V.4.4 Separate Specular Highlights  The previous section discussed the “GL_MODULATE” method for applying a texture map in conjunction with the use of Phong lighting. The main problem with this method is that the modulation of the Phong lighting color by the texture color tends to mute or diminish the visibility of specular highlights. Indeed, specular highlights tend to be the same color as the light; that is, they are usually white because lights are usually white. For instance, a shiny plastic object will tend to have white specular highlights, regardless of the color of the plastic itself. Unfortunately, when a white specular highlight is modulated  multiplied  by a texture color, it turns into the color of the texture and does not keep its white color.  Recent versions of OpenGL  since version 1.2  can circumvent this problem by keeping the specular component of the Phong lighting model separate from the diffuse, ambient, and emissive components of light. This feature is turned off by default and can be turned off and on with the commands    glLightModeli  GL_LIGHT_MODEL_COLOR_CONTROL,  GL_SINGLE_COLOR  GL_SEPARATE_SPECULAR_COLOR  When the separate specular color mode is enabled, the Phong lighting model stores both the sum of the ambient, diffuse, and emissive components from all light sources and the sum of specular light components from all light sources. When the texture map is applied, it is applied only to the nonspecular light component. After the texture has been applied, then the specular component of the light is added on unaltered by the texture.      ;   V.4 Texture Mapping in OpenGL  143  Another way to add specular highlights after texturing is to use multiple texture maps, where the last texture map is an environment map that adds specular highlights  see the discussion of this in the last paragraph of Section V.3 .  V.4.5 Managing Multiple Texture Maps  OpenGL provides a simple mechanism to manage multiple texture maps as “texture objects.” This allows your program to load or create multiple texture maps and give them to OpenGL to be stored in OpenGL’s texture memory. We sketch below the basic functionality of texture objects in OpenGL; you should look at the FourTextures program supplied with this book to see an example of how to use multiple texture maps in OpenGL.  The OpenGL commands for handling multiple texture maps are glGenTextures  , glBindTexture  , and glDeleteTextures  . The glGenTextures command is used to get the names  actually, integer indices  for one or more new texture objects. This has the effect of reserving texture map names for future use. The glBindTextures   func- tion takes a texture map name as input and makes that texture the currently active texture map. Subsequent uses of commands such as glTexImage*  , glTexParameter*  , gluBuild2DMipmaps  , glTexCoord*  , and so on will apply to the currently active texture map.  To reserve new names for texture objects, use commands such as  GLuint textureNameArray[N ]; glGenTextures  N , textureNameArray  ;  where N is the integer number of texture names requested. The call to glGenTextures   returns N texture names in the array. Each texture name is a GLuint, an unsigned integer. The texture name 0 is never returned by glGenTextures; instead, 0 is the texture name reserved for the default texture object.  To select a 2-D texture object, use the command  glBindTexture  GL_TEXTURE_2D, textureName  ;  The second parameter, textureName, is a GLuint unsigned integer that names a texture. When glBindTexture is called as above for the ﬁrst time with a given textureName value, it sets the texture type to 2-D and sets the various parameters. On subsequent calls, it merely se- lects the texture object as the current texture object. It is also possible to use GL_TEXTURE_1D or GL_TEXTURE_3D: refer to the OpenGL programming manual  Woo et al., 1999  for infor- mation on one-dimensional and three-dimensional texture maps.  A texture object is freed with the command  glDeleteTextures  N , textureNameArray  ;  which frees the N texture names in the array pointed to by the second parameter.  Some implementations of OpenGL support “resident textures” as a means of managing a cache of textures: resident textures are intended mostly for use with special-purpose hardware  graphics boards  that incorporates special texture buffers.  V.4.6 Environment Mapping in OpenGL  OpenGL supports the spherical projection version of environment maps  see Section V.3 . The OpenGL programming manual  Woo et al., 1999  suggests the following procedure for generating a texture map for environment mapping: take a photograph of a perfectly reﬂecting   144  Texture Mapping  sphere with a camera placed an inﬁnite distance away; then scan in the resulting photograph. This, of course, is not entirely practical, but it is mathematically equivalent to what should be done to generate the texture map for OpenGL environment mapping.  To turn on environment mapping in OpenGL, you need to give the following commands  in  addition to enabling texture mapping and loading a texture map :  glTexGeni GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP ; glTexGeni GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP ; glEnable GL_TEXTURE_GEN_S ; glEnable GL_TEXTURE_GEN_T ;  When rendering an object with an environment map, the surface normal direction, the view- point, and the view direction are used to determine the texture coordinates. If the viewer is not local, that is, if the view direction is ﬁxed to be  cid:5 0, 0,−1 cid:6  with the viewer positioned at a point at inﬁnity, then texture coordinates are generated in the following way: If the normal to the surface is equal to the unit vector  cid:5 nx , n y, nz cid:6 , then the s and t texture coordinates are set equal to  s = 1 2  nx + 1 2  t = 1 2  n y + 1 2  and  V.5 The effect is that the texture coordinates lie in the circle of radius 1 2 centered at  cid:5  1  cid:6 , and thus the values for s and t can range as low as 0 and as high as 1. For a sphere, this is the same as projecting the sphere orthogonally into a disk.  , 1 2  2  .  For a local viewer, the viewer is by convention placed at the origin, and the position and normal of the surface are used to compute the view reﬂection direction, that is, the direction in which a ray of light from the view position would be specularly reﬂected by the surface. Given the view reﬂection direction, one then computes the unit vector n that would cause a nonlocal viewer to have the same view reﬂection direction. The s, t texture coordinates are then set by Equation V.5.  The overall effect is that the view reﬂection direction is used to compute the s, t values generated for a nonlocal viewer with the same view reﬂection direction. That is to say, the texture coordinates s, t are determined by the view reﬂection direction.   cid:1   Exercise V.4 As in the Phong lighting model, let v be the unit vector in the direction of the viewer and n be the surface normal. Show that the view reﬂection direction is in the direction of the unit vector  cid:3  = 2 n · v n − v. r  For a nonlocal viewer, v would be  cid:5 0, 0, 1 cid:6 ; for a local viewer, the vector v is the normal- ization of the position of the point on the surface  since the local viewer is presumed to be positioned at the origin .  cid:6  be a unit vector in the view reﬂection direction computed for a + 1 cid:6  is perpendicular to the surface that gives the   cid:3  =  cid:5 r   cid:3  =  cid:5 r  local viewer. Show that n nonlocal viewer the same view reﬂection direction.  Let r  , r  , r  , r  , r   cid:3  2   cid:3  3   cid:3  1   cid:3  2   cid:3  3   cid:3  1   cid:3  The vector n  of the exercise can be normalized, and then its ﬁrst two components give the  s and t coordinates by the calculation in Equation V.5.  Other Texture Map Features of OpenGL. OpenGL supports many additional features for working with texture maps, too many for us to cover here. These other features   V.4 Texture Mapping in OpenGL  include things such as  145   a  The texture matrix – a homogeneous matrix for transforming texture coordinates.  This is selected by setting the matrix mode to GL_TEXTURE.   b  One-dimensional texture maps.  c  Three-dimensional texture maps.  d  Creation of texture maps by rendering into the frame buffer.  e  Manipulation of a region or subimage of a texture map.  f  More options for mipmapping and controlling level of detail.  g  Numerous options for controlling the way a texture map modiﬁes the color of a   h  Optional ability to perform “multitexturing,” where multiple textures are succes-  surface.  sively applied to the same surface.  are only one example of this .   i  Several ways of automatically generating texture coordinates  environment maps   j  Management of the available texture memory with texture proxies.  k  Management of resident textures in graphics hardware systems.  For more information on these features, you should consult the OpenGL programming manual.   VI  Color  This chapter brieﬂy discusses some of the issues in color perception and color represen- tation that are important for computer graphics. Color perception and color representa- tion are complicated topics, and more in-depth information can be found in references such as  Berns, Billmeyer, and Saltzman, 2000 ;  Jackson, MacDonald, and Freeman, 1994 ;  Foley et al., 1990 ; Volume I of  Glassner, 1995 ; or  Hall, 1989 . Also recommended is the short, readable introduction to the physics of color and the physiological aspects of color perception in  Feynman, 1989 . Some more detailed recommendations for further reading are given at the end of this chapter.  The ﬁrst section of this chapter discusses the physiology of color perception and its implica- tions for computer graphics. The second, more applied section discusses some of the common methods for representing color in computers.  VI.1 Color Perception  The basic theories of how humans perceive color were formulated already in the nineteenth century. There were two competing theories of color perception: the trichromatic theory and the opponent color theory. These two theories will appear contradictory at ﬁrst glance, but in fact they are both correct in that they are grounded in different aspects of human color perception.  The Trichromatic Theory of Vision. The trichromatic theory was  formulated by G. Palmer in 1777 and then again by T. Young in 1801; it was extended later by Helmholtz. This theory states that humans perceive color in three components: red, green, and blue. That is, that we see the colors red, green, and blue independently and that all other colors are formed from combinations of these three primary colors.  It was later discovered that the retina of the eye contains several kinds of light-sensitive receptors called cones and rods after their shapes. The human eye contains three kinds of cones: one kind is most sensitive to red light, one to green light, and one to blue light. Rods, the fourth kind of light-sensitive cell, are mostly used for vision in very low light levels and for peripheral vision and do not have the ability to distinguish different colors  thus, in very dark settings, you are unable to see colors but instead see only shades of gray and dark .  For direct viewing of objects in normal light levels, the cones are the primary color recep- tors, and, although the cones are each sensitive to a wide range of colors, the fact that the  146   VI.1 Color Perception  147  three different kinds are selectively more sensitive to red, to green, and to blue provides a physiological basis for the trichromatic theory.  The Opponent Theory of Vision. The opponent theory was formulated by Ewald Hering in 1878. It states that humans perceive light in three opposing components: namely, light versus dark, red versus green, and blue versus yellow. This theory accounts for some aspects of our subjective perception of color such as that one cannot perceive mixtures of red and green or mixtures of blue and yellow  thus there are no colors that are reddish green or blueish yellow, for instance .  Although this theory would appear to be in conﬂict with the trichromatic theory, there is in fact a simple explanation of how both theories can be valid. The trichromatic theory applies to the different light sensitivities of cones in the retina, and the opponent color theory reﬂects the way the cells in the retina process color into signals sent to the brain. That is, the neurons in the retina encode color in “channels” so that the neural signals from the eyes to the brain have different channels for encoding the amount of light versus dark, the amount of red versus green, and the amount of blue versus yellow.  The trichromatic theory is the main theoretical foundation for computer graphics, whereas the opponent theory seems to have little impact on computer graphics.1 Indeed, the princi- pal system of color representation is the RGB system, which is obviously based directly on the trichromatic theory. For applications in computer graphics, the main implications of the trichromatic theory are twofold. First, the space of visible colors forms a three-dimensional vector space since colors are differentiated according to how much they stimulate the three kinds of cones.2 Second, characterizing colors as being a combination of red, green, and blue light is a fairly good choice because these colors correspond to the light sensitivities of the different cones.  One consequence of the assumption that perceived colors form a three-dimensional space is that there are light sources that have different spectral qualities  i.e., have different intensities of visible light at given wavelengths  but that are indistinguishable to the human eye. This is a consequence of the fact that the set of possible visible light spectra forms an inﬁnite dimensional space. It follows that there must be different light spectra that are equivalent in the sense that the human eye cannot perceive any difference in their colors. This phenomenon is called metamerism.  There have been extensive experiments to determine how to represent different light spectra as combinations of red, green, and blue light. These experiments use the tristimulus method and proceed roughly as follows: Fixed light sources of pure red, pure green, and pure blue are chosen as primary colors. Then, for a given color C, one tries to ﬁnd a way to mix different intensities of the red, green, and blue lights so as to create a color that is equivalent to  i.e., visually indistinguishable from  the color C. The result is expressed by an equation  C = rC R + gC G + bC B,  where rC , gC , bC are scalars indicating the intensities of the red, green, and blue lights. This means that when the three reference lights are combined at the intensities given by the three scalars, the resulting light looks identical in color to C. It has been experimentally veriﬁed  1 One exception to this is that the opponent theory was used in the design of color encoding for television. In order to compress the resolution of television signals suitably and retain backward compatibility with black and white television transmissions, the opponent theory was used to aid the decision of what information to remove from the color channels.  2 The opponent theory of color also predicts that the perceivable colors form a three-dimensional space.   148  Color  that all colors can be expressed as linear combinations of red, green, and blue in this way.3 Furthermore, when colors are combined, they act as a vector space. Thus, the combination of two colors C1 and C2 is equivalent to the color  + rC2 R +  gC1  + gC2 G +  bC1  + bC2 B.   rC1  There is one big, and unfortunate, problem: sometimes the coefﬁcients rC , gC , bC are negative! The physical interpretation of a negative coefﬁcient, say if bC < 0, is that the reference color  blue, say  must be added to the color C to yield a color that is equivalent to a combination of red and green colors. That is to say, the interpretation of negative coefﬁcients on colors is that the formula should be rearranged by moving terms to the other side of the equality so as to make all coefﬁcients positive.  The reason it is unfortunate that the tristimulus coefﬁcients can be negative is that, since there is no way to make a screen or a drawing emit negative light intensities, it follows that there are some colors that cannot be rendered by a red–blue–green color scheme. That is to say, there are some colors that can be perceived by the human eye but that cannot be rendered on a computer screen, even in principle, at least as long as the screen is rendering colors using a system of three primary colors. The same considerations apply to any kind of color printing system based on three primary colors. Some high-quality printing systems use more than three primary colors to achieve a broader range of perceptual colors.4  So far our discussion has concerned the color properties of light. The color properties of materials are considerably more complicated. In Chapter III, the Phong and Cook–Torrance illumination models treated each material as having reﬂectance properties for the colors red, green, and blue, with each color treated independently. However, a more physically accurate approach would treat every spectrally pure color independently; that is, for each wavelength of light, the material has reﬂectance properties, and these properties vary with the wavelength. This more physically accurate model would allow for illuminant metamerism, where two materials may appear to be the same color under one illumination source and to be a different color under another illumination source. There seems to be no way to extend the Phong and Cook–Torrance light models easily to allow for reﬂectance properties that vary with wavelength except to use more than three primary colors. This is called spectral sampling and is sometimes used for high-quality, photorealistic renderings. For spectral sampling, each light source is treated as consisting of multiple pure components, and each surface has reﬂectance properties for each of the light components. The illumination equations are similar to those Chapter III described but are carried out for more wavelengths. At the end, it is necessary to reduce back to three  4  3 We are describing the standard, idealized model of color perception. The experiments only apply to colors at a constant level of intensity, and the experimental results are not as clear cut as we are making them sound. In addition, there is considerable variation in how different people distinguish colors. It is curious, to this author at least, that we are so unconcerned about the quality of color reproduction. Most people are perfectly happy with the rather low range of colors available from a CRT or a television. In contrast, systems for sound reproduction are widespread, and home stereo systems routinely provide high-quality recording and reproduction of audio signals  music  accurately across the full audible spectrum. It is surprising that there has been no corresponding improvement in color reproduction systems for television nor even any demand for such improvement – at least from the general consumer.  It is certainly conceivable that improved color rendition could be developed for CRTs and televi- sions; for instance, one could envision a display system in which each pixel could emit a combination of two pure, narrow-spectrum, wavelengths of light, with the two wavelengths individually tunable. Such a system would be able to render nearly every perceptual color.   VI.2 Representation of Color Values  149   a    b   Figure VI.1.  a  The additive colors are red, green, and blue.  b  The subtractive colors are cyan, magenta, and yellow. See Color Plate 2.  primary colors for printing or display purposes. The book  Hall, 1989  discusses algorithms for spectral sampling devised by Hall and by Meyer.  VI.2 Representation of Color Values  This section discusses some of the principal ways in which colors are represented by computers. We discuss ﬁrst the general theory of subtractive versus additive colors and then discuss how RGB values are typically encoded. Finally, we discuss alternate representations of color based on hue, saturation, and luminance.  VI.2.1 Additive and Subtractive Colors  The usual method of displaying red, green, and blue colors on a CRT monitor is called an ad- ditive system of colors. In an additive system of colors, the base or background color is black, and then varying amounts of three primary colors – usually red, green, and blue – are added. If all three colors are added at full intensity, the result is white. Additive colors are pictured in part  a  of Figure VI.1 in which the three circles should be viewed as areas that generate or emit light of the appropriate color. Where two circles overlap, they combine to form a color: red and green together make yellow, green and blue make cyan, and blue and red make magenta. Where all three circles overlap, the color becomes white. The additive representation of color is appro- priate for display systems such as monitors, televisions, or projectors for which the background or default color is black and the primary colors are added in to form composite colors.  In the subtractive representation of light, the background or base color is white. Each primary color is subtractive in that it removes a particular color from the light by absorption or ﬁltering. The subtractive primary colors are usually chosen as magenta, cyan, and yellow. Yellow represents the ﬁltering or removal of blue light, magenta the removal of green light, and cyan the removal of red light. Subtractive primaries are relevant for settings such as painting, printing, or ﬁlm, where the background or default color is white and primary colors remove a single color from the white light. In painting, for instance, a primary color consists of a paint that absorbs one color from the light and reﬂects the rest of the colors in the light. Subtractive colors are illustrated in part  b  of Figure VI.1. You should think of these colors as being in front of a white light source, and the three circles are ﬁltering out components of the white light.   150  Color  There can be confusion between the colors cyan and blue, or the colors magenta and red. Cyan is a light blue or greenish blue, whereas blue is a deep blue. Magenta is a purplish or bluish red; if red and magenta are viewed together, then the red frequently has an orangish appearance. Sometimes, cyan and magenta are referred to as blue and red, and this can lead to confusion over the additive and subtractive roles of the colors.  The letters RGB are frequently used to denote the additive red–green–blue primary colors, and CMY is frequently used for the subtractive cyan–magenta–yellow primary colors. Often, one uses these six letters to denote the intensity of the color on a scale 0 to 1. Then, the nominal way to convert from a RGB color representation to CMY is by the formulas  C = 1 − R M = 1 − G Y = 1 − B.  We call this the “nominal” way because it often gives poor results. The usual purpose of converting from RGB to CMY is to change an image displayed on a screen into a printed image. It is, however, very difﬁcult to match colors properly as they appear on the screen with printed colors, and to do this well requires knowing the detailed spectral properties  or color equivalence properties  of both the screen and the printing process. A further complication is that many printers use CMYK colors, which use a K channel in addition to C,M,Y. The value of K represents the level of black in the color and is printed with a black ink rather than a combination of primary colors. There are several advantages to using a fourth black color: First, black ink tends to be cheaper than combining three colored inks. Second, less ink needs to be used, and thus the paper does not get so wet from ink, which saves drying time and prevents damage to the paper. Third, the black ink can give a truer black color than is obtained by combining three colored inks.  VI.2.2 Representation of RGB Colors  This section discusses the common formats for representing RGB color values in computers. An RGB color value typically consists of integer values for each of the R, G, B values, these values being rescaled from the interval [0, 1] and discretized to the resolution of the color values.  The highest commonly used resolution for RGB values is the so-called 32-bit or 24-bit color. On a Macintosh, this is called “millions of colors,” and on a PC it is referred to variously as “32-bit color,” “16,777,216 colors,” or “true color.” The typical storage for such RGB values is in a 32-bit word: 8 bits are reserved for specifying the red intensity, 8 bits for green, and 8 bits for blue. Since 224 = 16, 777, 216, there are that many possible colors. The remaining 8 bits in the 32-bit word are either ignored or are used for an alpha  α  value. Typical uses of the alpha channel are for transparency or blending effects  OpenGL supports a wide range of transparency and blending effects . Because each color has 8 bits, each color value may range from 0 to 255.  The second-highest resolution of the commonly used RGB color representations is the 16-bit color system. On a Macintosh, this is called “thousands of colors”; on a PC it will be called “high color,” “32,768 colors,” or “16-bit color.” In 16-bit color, there are, for each of red, green, and blue, 5 bits that represent the intensity of that color. The remaining one bit is sometimes used to represent transparency. Thus, each color has its intensity repre- sented by a number between 0 and 31, and altogether there are 215 = 32,768 possible color combinations.   VI.2 Representation of Color Values  151  The lowest resolution still extensively used by modern computers is 8-bit color. In 8-bit color, there are 256 possible colors. Usually, three of the bits are used to represent the red intensity, three bits represent the green intensity, and only two bits represent the blue intensity. An alternative way to use eight bits per pixel for color representation is to use a color lookup table, often called a CLUT or a LUT, for short. This method is also called indexed color. A LUT is typically a table holding 256 distinct colors in 16-bit, 24-bit, or 32-bit format. Each pixel is then given an 8 bit color index. The color index speciﬁes a position in the table, and the pixel is given the corresponding color. A big advantage of a LUT is that it can be changed in accordance with the contents of a window or image on the screen. Thus, the colors in the LUT can reﬂect the range of colors actually present in the image. For instance, if an image has many reds, the lookup table might be loaded with many shades of red and with relatively few nonred colors. For this reason, using 8-bit indexed color can give much better color rendition of a particular image than just using the standard 8-bit color representation with 3 + 3 + 2 bits for red, green, and blue intensities.  Color lookup tables are useful in situations in which video memory is limited and only 8 bits of memory per pixel are available for storing color information. They are also useful for compressing ﬁles for transmission in bandwidth-limited or bandwidth-sensitive applications such as when ﬁles are viewed over the Internet. The widely used Compuserve GIF ﬁle format incorporates indexed color: a GIF ﬁle uses a k-bit index to specify the color of a pixel, where 1 ≤ k ≤ 8. In addition, the GIF ﬁle contains a color lookup table of 2k color values. Thus, with k = 8, there are 256 possible colors; however, smaller values for k can also be used to further reduce the ﬁle size at the cost of having fewer colors. This allows GIF ﬁles to be smaller than they would otherwise be and thereby faster to download without sacriﬁcing too much in image quality. To be honest, we should mention that there is a second reason GIF ﬁles are so small: they use a sophisticated compression scheme, known as LZW  after its inventors Lempel, Ziv, and Welch  that further compresses the ﬁle by removing certain kinds of redundant information. Internet software, such as Netscape or Internet Explorer, uses a standard color index scheme for “browser-safe” or “Web-safe” colors. This scheme is based on colors that are restricted to six levels of intensity for red, for green, and for blue, which makes a total of 63 = 216 standard colors. In theory at least, browsers should render these 216 colors identically on all hardware.  VI.2.3 Hue, Saturation, and Luminance  Several methods exist for representing color other than in terms of its red, green, and blue components. These methods can be more intuitive and user-friendly for color speciﬁcation and color blending.  We will discuss only one of the popular methods of this type, the “HSL” system, which speciﬁes a color in terms of its hue, saturation, and luminance. The hue  or chromaticity  of a light is its dominant color. The luminance  also called intensity, or value, or brightness  speciﬁes the overall brightness of the light. Finally, the saturation  also called chroma or colorfulness  of a color measures the extent to which the color consists of a pure color versus consists of white light.  These various terms with similar meanings are not precisely synonymous but instead have different technical deﬁnitions in different settings. For other methods of color speciﬁcation similar in spirit to HSL, you may consult, for instance,  Foley et al., 1990 .   ◦ In the HSL system, hue is typically measured as an angle between 0 and 360  . A pure red , and a pure blue color has . Intermediate angles for the hue indicate the blending of two of the primary indicates a color contains equal mixtures of red and green, that is,  color has hue equal to 0 , a pure green color has hue equal to 120 hue equal to 240 ◦ colors. Thus, a hue of 60 the color yellow. Figure VI.2 shows the hues as a function of angle.  ◦  ◦  ◦   Green  Yellow  Color  152  Cyan  Red  Blue  Magenta  Figure VI.2. Hue is measured in degrees representing an angle around the color wheel. Pure red has hue ◦ equal to 0, pure green has hue equal to 120  ◦ , and pure blue has hue equal to 240  . See Color Plate 3.  The luminance refers to the overall brightness of the color. In the HSL system, luminance is calculated from RGB values by taking the average of the maximum and minimum intensities of the red, green, and blue colors.  The saturation is measured in a fairly complex fashion, but generally speaking, it measures the relative intensity of the brightest primary color versus the least bright primary color and scales the result into the range [0, 1].  The advantage of using HSL color speciﬁcation is that it is a more intuitive method for deﬁning colors. The disadvantage is that it does not correspond well to the physical processes of displaying colors on a monitor or printing colors with ink or dyes. For this, it is necessary to have some way of converting between HSL values and either RGB or CMY values.  The most common algorithm for converting RGB values into HSL values is the following:     Input: R, G, B.    Output: H, S, L.  All in the range [0, 1]. H∈ [0, 360], and S, L ∈ [0, 1].     Luminance     Achromatic, unsaturated.    Hue is undefined.  Set Max = max{R, G, B}; Set Min = min{R, G, B}; Set Delta = Max - Min; Set L =  Max+Min  2; If  Max==Min  { Set S = 0; Set H = 0;  } Else {  If   L<1 2   { } Else { } If   R == Max   {  Set S = Delta  Max+Min ;     Saturation  Set S = Delta  2-Max-Min ;    Saturation  Set H = 60* G-B  Delta; If   H<0    Set H = 360+H;     Hue  }   VI.2 Representation of Color Values  153  Else if   G == Max   { } Else { }  }  Set H = 120 + 60* B-R  Delta;    Hue  Set H = 240 + 60* R-G  Delta;    Hue  The H, S, and L values are often rescaled to be in the range 0 to 255.  To understand how the preceding algorithm works, consider the case in which R is the dominant color and B the least bright so that R > G > B. Then the hue will be calculated by  H = 60 · G − B R − B  = 60 · G − Min R − Min  .  in proportion to  G − Min   R − Min . If we think of ◦ Thus, the hue will range from 0 to 60 the base intensity Min as the amount of white light, then R − Min is the amount of red in the color and G − Min is the amount of green in the color. So, in this case, the hue measures the ratio of the amount of green in the color to the amount of red in the color.  On the other hand, the conversion from RGB into HSL does not seem to be completely ideal in the way it computes brightness: for instance, the color yellow, which has R,G,B values of 1,1,0, has luminance L = 1 2. Likewise, the colors red and green, which have R,G,B values of 1,0,0 and of 0,1,0, respectively, also have luminance L = 1 2. However, the color yellow is usually a brighter color than either red or green. There seems to be no way of easily evading this problem.  The formulas for computing saturation from RGB values are perhaps a little mysterious.  They are  S = Max − Min Max + Min  and  S =  Max − Min  2 −  Max + Min   ,  where the formula on the left is used if Max + Min ≤ 1; otherwise, the formula on the right is used. Note that when Max + Min = 1, then the two formulas give identical results, and thus the saturation is a continuous function. Also note that if Max = 1, then S = 1. Finally, the formula on the right is obtained from the formula on the left by replacing Max by 1 − Min and Min by 1 − Max.  It is not hard to see that the algorithm converting RGB into HSL can be inverted, and thus it is possible to calculate the RGB values from the HSL values. Or rather, the algorithm could be inverted if HSL values were stored as real numbers; however, the discretization to integer values means that the transformation from RGB to HSL is not one-to-one and cannot be exactly inverted.  Exercise VI.1 Give an algorithm for converting HSL values to RGB values. You may treat all numbers as real numbers and consequently do not need to worry about discretization problems. [Hint: First compute Min and Max from L and S.]  The translation from RGB into HSL is a nonlinear function; thus, a linear interpolation process such as Gouraud shading will give different results when applied to RGB values than to HSL values. Generally, Gouraud shading is applied to RGB values, but in some applications, it might give better results to interpolate in HSL space. There are potential problems with interpolating hue, however; for instance, how would one interpolate from a hue of 0 to a hue ◦ of 180  ?  ◦   154  Color  Further Reading: Two highly recommended introductions to color and its use in computer graphics are the book  Jackson, MacDonald, and Freeman, 1994  and the more advanced book  Berns, Billmeyer, and Saltzman, 2000 ; both are well written with plenty of color illustrations. They also include discussion of human factors and good design techniques for using color in a user-friendly way.  For a discussion of human abilities to perceive and distinguish colors, consult  Glassner, 1995 ,  Wyszecki and Stiles, 1982 , or  Fairchild, 1998 . Discussions of monitor and display design, as well as color printing, are given by  Glassner, 1995; Hall, 1989; Jackson, MacDonald, and Freeman, 1994 .  A major tool for the scientiﬁc and engineering use of color is the color representation stan- dards supported by the Commission International d’Eclairage  CIE  organization. For computer applications, the 1931 CIE   ¯x, ¯y, ¯z  representation is the most relevant, but there are several other standards, including the 1964 10 observer standards and the CIELAB and CIELUV color representations, that better indicate human abilities to discriminate colors. The CIE stan- dards are described to some extent in all of the aforementioned references. A particularly comprehensive mathematical explanation can be found in  Wyszecki and Stiles, 1982 ; for a shorter mathematical introduction, see Appendix B of  Berns, Billmeyer, and Saltzman, 2000 . Also,  Fairman, Brill, and Hemmendinger, 1997  describe the mathematical deﬁnition of the 1931 CIE color standard and its historical motivations.  ◦  The early history of scientiﬁc theories of color is given by  Bouma, 1971, Chap. 12 .   VII  B´ezier Curves  A spline curve is a smooth curve speciﬁed succinctly in terms of a few points. These two aspects of splines, that they are smooth and that they are speciﬁed succinctly in terms of only a few points, are both important. First, the ability to specify a curve with only a few points reduces storage requirements. In addition, it facilitates the computer-aided design of curves and surfaces because the designer or artist can control an entire curve by varying only a few points. Second, the commonly used methods for generating splines give curves with good smoothness properties and without undesired oscillations. Furthermore, these splines also allow for isolated points where the curve is not smooth, such as points where the spline has a “corner.” A third important property of splines is that there are simple algorithms for ﬁnding points on the spline curve or surface and simple criteria for deciding how ﬁnely a spline must be approximated by linear segments to obtain a sufﬁciently faithful representation of the spline. The main classes of splines discussed in this book are the B´ezier curves and the B-spline curves. B´ezier curves and patches are covered in this chapter, and B-splines in the next chapter.  Historically, splines were speciﬁed mechanically by systems such as ﬂexible strips of wood or metal that were tied into position to record a desired curve. These mechanical systems were awkward and difﬁcult to work with, and they could not be used to give a permanent, reproducible description of a curve. Nowadays, mathematical descriptions are used instead of mechanical devices because the mathematical descriptions are, of course, more useful and more permanent, not to mention more amenable to computerization. Nonetheless, some of the terminology of physical splines persists such as the use of “knots” in B-spline curves.  B´ezier curves were ﬁrst developed by automobile designers to describe the shape of exterior car panels. B´ezier curves are named after B´ezier for his work at Renault in the 1960s  B´ezier, 1968; 1974 . Slightly earlier, de Casteljau had already developed mathe- matically equivalent methods of deﬁning spline curves at Citro¨en  de Casteljau, 1959; 1963 .1 This chapter discusses B´ezier curves, which are a simple kind of spline. For the sake of concreteness, the ﬁrst ﬁve sections concentrate on the special case of degree three B´ezier curves in detail. After that, we introduce B´ezier curves of general degree. We then cover how to form B´ezier surface patches and how to use B´ezier curves and surfaces in OpenGL. In addition, we  1 We do not attempt to give a proper discussion of the history of the development of B´ezier curves and B-splines. The textbooks of  Farin, 1997 ,  Bartels, Beatty, and Barsky, 1987 , and especially  Rogers, 2001  and  Schumaker, 1981  contain some historical material and many more references on the development of B´ezier curves and B-splines.  155   156  p1  B´ezier Curves  p2  q u   p0 Figure VII.1. A degree three B´ezier curve q u . The curve is parametrically deﬁned with 0 ≤ u ≤ 1, and it interpolates the ﬁrst and last control points with q 0  = p0 and q 1  = p3. The curve is “pulled towards” the middle control points p1 and p2. At p0, the curve is tangent to the line segment joining p0 and p1. At p3, it is tangent to the line segment joining p2 and p3.  p3  describe rational B´ezier curves and patches and how to use them to form conic sections and surfaces of revolution. The last sections of the chapter describe how to form piecewise B´ezier curves and surfaces that interpolate a desired set of points.  For a basic understanding of degree three B´ezier curves, you should start by reading Sections VII.1 through VII.4. After that, you can skip around a little. Sections VII.6–VII.9 and VII.12– VII.14 discuss general-degree B´ezier curves and rational B´ezier curves and are intended to be read in order. But it is possible to read Sections VII.10 and VII.11 about patches and about OpenGL immediately after Section VII.4. Likewise, Sections VII.15 and VII.16 on interpolating splines can be read immediately after Section VII.4. The mathematical proofs are not terribly difﬁcult but may be skipped if desired.  VII.1 B´ezier Curves of Degree Three  The most common B´ezier curves are the degree three polynomial curves, which are speciﬁed by four points called control points. This is illustrated in Figure VII.1, where a parametric curve q = q u  is deﬁned by four control points p0, p1, p2, p3. The curve starts from p0 initially in the direction of p1, then curves generally towards p2, and ends up at p3 coming from the direction of p2. Only the ﬁrst and last points, p0 and p3, lie on q. The other two control points, p1 and p2, inﬂuence the curve: the intuition is that these two middle control points “pull” on the curve. You can think of q as being a ﬂexible, stretchable curve that is constrained to start at p0 and end at p3 and in the middle is pulled by the two middle control points. Figure VII.2 shows two more examples of degree three B´ezier curves and their control points.  p1  p3  p2  p1  p0  p2  p0  p3  Figure VII.2. Two degree three B´ezier curves, each deﬁned by four control points. The curves interpolate only their ﬁrst and last control points, p0 and p3. Note that, just as in Figure VII.1, the curves start off, and end up, tangent to line segments joining control points.   VII.1 B´ezier Curves of Degree Three  157  We say that a curve interpolates a control point if the control point lies on the curve. In general, B´ezier curves do not interpolate their control points, except for the ﬁrst and last points. For example, the degree three B´ezier curves shown in Figures VII.1 and VII.2 interpolate the ﬁrst and last control points p0 and p3 but not the middle control points.  Deﬁnition Degree three B´ezier curves are deﬁned parametrically by a function q u : as u varies from 0 to 1, the values of q u  sweep out the curve. The formula for a degree three B´ezier curve is  q u  = B0 u p0 + B1 u p1 + B2 u p2 + B3 u p3,  where the four functions Bi  u , called blending functions, are scalar-valued and are deﬁned by  VII.1  VII.2  represents the “choice function” counting the number of subsets of size m of   cid:12  ui  1 − u 3−i .   cid:11   cid:10   3 i  Bi  u  =  cid:9   cid:12   cid:11   The notation a set of size n, namely,  n m  n m  =  n!  m! n − m !  .  Much of the power and convenience of B´ezier curves comes from their being deﬁned in a uniform way independent of the dimension d of the space containing the curve. The control points pi deﬁning a B´ezier curve lie in d-dimensional space Rd for some d. On the other hand, the blending functions Bi  u  are scalar-valued functions. The B´ezier curve itself is a parametrically deﬁned curve q u  lying in Rd. B´ezier curves can thus be curves in the plane R2 or in 3-space R3, and so forth. It is also permitted for d to equal 1, in which case a B´ezier curve is a scalar-valued “curve.” For instance, if u measures time and d = 1, then the “curve” represents a time-varying scalar value.  The functions Bi  u  are special cases of the Bernstein polynomials. When we deﬁne B´ezier curves of arbitrary degree in Section VII.6, the Bernstein polynomials of degree three will be denoted by B3 i instead of just Bi . But for now, we omit the superscript 3 to keep our notation from being overly cluttered.  The blending functions Bi  u  are clearly degree three polynomials. Indeed, when their  deﬁnitions are expanded they are equal to  B0 u  =  1 − u 3 B1 u  = 3u 1 − u 2  B2 u  = 3u2 1 − u  B3 u  = u3.  These four functions are graphed in Figure VII.3. Obviously, the functions take on values in the interval [0, 1] for 0 ≤ u ≤ 1. Less obviously, the sum of the four functions is always equal to 1: this can be checked by summing the polynomials, or, more elegantly, by the binomial theorem we have   cid:11    cid:12   Bi  u  = 3 cid:27   3 cid:27   i=0  3 i  ui  1 − u 3−i =  u +  1 − u  3 = 1.  i=0  In addition, B0 0  = 1 and B3 1  = 1. From this, we see immediately that q u  is always computed as a weighted average of the four control points and that q 0  = p0 and q 1  = p3, conﬁrming our observation that q u  starts at p0 and ends at p3. The function B1 u  reaches its   B´ezier Curves  158  y  1  B1  0  B0  B3  B2  1  u  Figure VII.3. The four blending functions for degree three B´ezier curves. We are only interested in their values in the interval [0, 1]. Each Bi  u  is a degree three polynomial.  9 , at u = 1  maximum value, namely 4 3 ; therefore, the control point p1 has the greatest inﬂuence over the curve at u = 1 3 . Symmetrically, p2 has the greatest inﬂuence over the curve at u = 2 3 . This coincides with the intuition that the control points p1 and p2 “pull” the hardest on the curve at u = 1 3 and u = 2 3 . If we calculate the derivatives of the four blending functions by hand, we of course ﬁnd that their derivatives are degree two polynomials. If we then evaluate these derivatives at u = 0 and u = 1, we ﬁnd that 0 0  = −3  cid:3  0 1  = 0  cid:3   2 0  = 0  cid:3  2 1  = −3  cid:3   3 0  = 0  cid:3  3 1  = 3.  cid:3   1 0  = 3  cid:3  1 1  = 0  cid:3   B  B  B  B  B  B  B  B  The derivative of the function q u  can easily be expressed in terms of the derivatives of the blending functions, namely, 0 u p0 + B  cid:3   2 u p2 + B  cid:3   1 u p1 + B  cid:3    u  = B   cid:3  3 u p3.   cid:3  q  This is of course a vector-valued derivative because q is a vector-valued function. At the beginning and end of the curve, the values of the derivatives are  VII.3   cid:3   q   cid:3  q   0  = 3 p1 − p0   1  = 3 p3 − p2 .  Graphically, this means that the curve q u  starts at u = 0 traveling in the direction of the vector from p0 to p1. Similarly, at the end, where u = 1, the curve q u  is tangent to the vector from p2 to p3. Referring back to Figures VII.1 and VII.2, we note that this corresponds to the curve’s starting at p0 initially tangent to the line segment joining the ﬁrst control point to the second control point and ending at p3 tangent to the line segment joining the third and fourth control points.  Exercise VII.1 A degree three B´ezier curve in R2 satisﬁes q 0  =  cid:5 0, 1 cid:6 , q 1  =  cid:5 3, 0 cid:6 ,  0  =  cid:5 3, 3 cid:6  and q  1  =  cid:5 −3, 0 cid:6 . What are the control points for this curve? Give a  cid:3   cid:3  q rough freehand sketch of the curve, being sure to show the slopes at the beginning and end of the curve clearly.   VII.2 De Casteljau’s Method  p1  r1  s1  s0  t0  r0  p2  r2  159  p0 Figure VII.4. The de Casteljau method for computing q u  for q, a degree three B´ezier curve. This illustrates the u = 1 3 case.  p3  VII.2 De Casteljau’s Method  The qualitative methods described above allow you to make a reasonable freehand sketch of a degree three Bezier curve based on the positions of its control points. In particular, the curve starts at p0, ends at p3, and has initial and ﬁnal directions given by the differences p1 − p0 and p3 − p2. Finding the exact values of q u  for a given value of u can be done by using Formulas VII.1 and VII.2 of course. However, an easier method, known as de Casteljau’s method, can also be used to ﬁnd values of q u . De Casteljau’s method is not only simpler for hand calculation but is also more stable numerically for computer calculations.2 In addition, de Casteljau’s method will be important later on as the basis for recursive subdivision. Let p0, p1, p2, p3 deﬁne a degree three B´ezier curve q. Fix u ∈ [0, 1] and suppose we want to compute q u . The de Casteljau method for computing q u  works as follows: First, form three points r0, r1, r2 by linear interpolation from the control points of q by  ri =  1 − u  · pi + u · pi+1.  VII.4 Recall from Section IV.1.1 that this means that ri lies between pi and pi+1 with ri at the point that is fraction u of the distance from pi to pi+1.  This is illustrated in Figures VII.4 and VII.5.  Then deﬁne s0 and s1 by linear interpolation from the ri ’s by  si =  1 − u  · ri + u · ri+1.  t0 =  1 − u  · s0 + u · s1.  Finally deﬁne t0 by linear interpolation from s0 and s1 by  VII.5  VII.6  Then, it turns out that t0 is equal to q u . We will prove a generalization of this fact as Theorem VII.6; however, for the special case of degree three B´ezier curves, the reader can easily verify that t0 = q u  by expressing t0 as an explicit function of u and the four control points. In the special case of u = 1 2, the de Casteljau method becomes particularly simple. Then, ri = pi + pi+1  t0 = s0 + s1  VII.7  ,  ,  .  2  2 That is to say, q  1  2   = t0 = 1  8 p0 + 3  si = ri + ri+1 8 p1 + 3 8 p2 + 1  2  8 p3.  Exercise VII.2 Prove that t0, as computed by Equation VII.6, is equal to q u .  2 See  Daniel and Daubisse, 1989; Farouki, 1991; Farouki and Rajan, 1987; 1988  for technical dis- cussions on the stability of the de Casteljau methods. They conclude that the de Castaljau method is preferable to conventional methods for polynomial representation and evaluation, including Horner’s method.   160  p1  r1  t0  s0  s1  p2  r0  q1 u   q2 u   r2  B´ezier Curves  p3  p0 Figure VII.5. The de Casteljau method for computing q u  for q a degree three B´ezier curve is the basis for ﬁnding the new points needed for recursive subdivision. Shown here is the u = 1 2 case. The points p0, r0, s0, t0 are the control points for the B´ezier curve q1 u  that is equal to the ﬁrst half of the curve q u , that is, starting at p0 and ending at t0. The points t0, s1, r2, p3 are the control points for the curve q2 u  equal to the second half of q u , that is, starting at t0 and ending at p3.  Exercise VII.3 Let q u  be the curve from Exercise VII.1. Use the de Casteljau method to compute q  1  4  .  Save your work for Exercise VII.4.   2   and q  3  VII.3 Recursive Subdivision  Recursive subdivision is the term used to refer to the process of splitting a single B´ezier curve into two subcurves. Recursive subdivision is important for several reasons, but the most important, perhaps, is for the approximation of a B´ezier curve by straight line segments. A curve that is divided into sufﬁciently many subcurves can be approximated by straight line segments without too much error. As we discuss in the latter part of this section, this can help with rendering and other applications such as intersection testing.  Suppose we are given a B´ezier curve q u  with control points p0, p1, p2, p3. This is a cubic  curve of course, and if we let  q1 u  = q u 2   and  q2 u  = q  u + 1  2 ,  VII.8  then both q1 and q2 are also cubic curves. We restrict q1 and q2 to the domain [0, 1]. Clearly, for 0 ≤ u ≤ 1, q1 u  is the curve that traces out the ﬁrst half of the curve q u , namely, the part of q u  with 0 ≤ u ≤ 1 2. Similarly, q2 u  is the second half of q u . The next theorem gives a simple way to express q1 and q2 as B´ezier curves. Theorem VII.1 Let q u , q1 u , and q2 u  be as above. Let ri , si , and t0 be deﬁned as in Section VII.2 for calculating q u  with u = 1 2; that is to say, they are deﬁned accord- ing to Equation VII.7. Then the curve q1 u  is the same as the B´ezier curve with control points p0, r0, s0, t0. And the curve q2 u  is the same as the B´ezier curve with control points t0, s1, r2, p3.  Theorem VII.1 is illustrated in Figure VII.5.  One way to prove Theorem VII.1 is just to use a “brute force” evaluation of the deﬁnitions of q1 u  and q2 u . The two new B´ezier curves are speciﬁed with control points ri , si , and t0 that have been deﬁned in terms of the pi ’s. Likewise, from Equations VII.8, we get equations for q1 u  and q2 u  in terms of the pi ’s. From this, the theorem can be veriﬁed by straightforward calculation. This brute force proof is fairly tedious and uninteresting, and so we omit it. The interested reader may work out the details or, better, wait until we give a proof of the more general Theorem VII.7. Theorem VII.1 explained how to divide a B´ezier curve into two halves with the subdivision breaking the curve at the middle position u = 1 2. Sometimes, one wishes to divide a B´ezier   161 VII.3 Recursive Subdivision curve into two parts of unequal size, at a point u = u0. That is to say, one wants curves q1 u  and q2 u  deﬁned on [0, 1] such that  q1 u  = q u0u   and  q2 u  = q u0 +  1 − u0 u .  The next theorem explains how to calculate control points for the subcurves q1 u  and q2 u  in this case.  Theorem VII.2 Let q u , q1 u , and q2 u  be as above. Let 0 < u0 < 1. Let ri , si , and t0 be deﬁned as in Section VII.2 for calculating q u  with u = u0. That is, they are deﬁned by Equations VII.4–VII.6 so that t0 = q u0 . Then the curve q1 u  is the same as the B´ezier curve with control points p0, r0, s0, t0. Also, the curve q2 u  is the same as the B´ezier curve with control points t0, s1, r2, p3. For an illustration of Theorem VII.2, refer to Figure VII.4, which shows the u = 1 3 case. The curve from p0 to t0 is the same as the B´ezier curve with control points p0, r0, s0, and t0. The curve from t0 to p3 is the same as the B´ezier curve with control points t0, s1, r2, and p3.  Like Theorem VII.1, Theorem VII.2 may be proved by direct calculation. Instead, we will  prove a more general result later as Theorem VII.7.  Exercise VII.4 Consider the curve q u  of Exercise VII.1. Use recursive subdivision to split q u  into two curves at u0 = 1  2 . Repeat with u0 = 3 4 .  Applications of Recursive Subdivision There are several important applications of recursive subdivision. The ﬁrst, most prominent application is for rendering a B´ezier curve as a series of straight line segments; this is often necessary because graphics hardware typically uses straight line segments as primitives. For this, we need a way to break a B´ezier curve into smaller and smaller subcurves until each subcurve is sufﬁciently close to being a straight line so that rendering the subcurves as straight lines gives adequate results. To carry out this subdivision, we need to have a criterion for “sufﬁciently close to being a straight line.” Generally, this criterion should depend not just on the curvature of the curve but also on the rendering context. For instance, when rendering to a rectangular array of pixels, there is probably no need to subdivide a curve that is so straight that the distance between the curve and a straight line approximation is less than a single pixel. Here is one way of making this criterion of “sufﬁciently close to a straight line” more precise: ﬁrst, based on the distance of the curve from the viewer and the pixel resolution of the graphics rendering context, calculate a value δ > 0 so that any discrepancy in rendering of absolute value less than δ will be negligible. Presumably this δ would correspond to some fraction of a pixel dimension. Then recursively subdivide the curve into subcurves, stopping whenever the error in a straight line approximation to the curve is less than δ. A quick and dirty test to use as a stopping condition would be to check the position of the midpoint of the curve; namely, the stopping condition could be that  q  1  2   − 1  2  p0 + p3  < δ.  In most cases, this condition can be checked very quickly: in the degree three B´ezier case, 2   is equal to t0 = 1 q  1 8 p3. A quick calculation shows that the stopping condition becomes merely  8 p1 + 3  8 p0 + 3  8 p2 + 1 p0 − p1 − p2 + p32 <  8δ 3 2,  which can be efﬁciently computed.   162  p1  r1  t0  s0  s1  p2  r0  q1 u   q2 u   r2  B´ezier Curves  p0 Figure VII.6. The convex hull of the control points of the B´ezier curves shrinks rapidly during the process of recursive subdivision. The whole curve is inside its convex hull, that is, inside the quadrilateral p0p1p2p3. After one round of subdivision, the two subcurves are known to be constrained in the two convex shaded regions.  p3  This “quick and dirty” test can occasionally fail since it is based on only the midpoint of the B´ezier curve. A more reliable test would check whether the intermediate control points, p1 and p2, lie approximately on the line segment p0p3.  A second important application of recursive subdivision involves combining it with convex hull tests to determine regions where the B´ezier curve does not lie. For example, in Chapters IX and X, we are interested in determining when a ray  a half line  intersects a surface, and we will see that it is particularly important to have efﬁcient methods of determining when a line does not intersect the surface. As another example, suppose we are rendering a large scene of which only a small part is visible at any given time. To render the scene quickly, it is necessary to be able to decide rapidly what objects are not visible by virtue, for example, of being outside the view frustum. A test for nonintersection or for nonvisibility would be based on the following fact: for a B´ezier curve deﬁned with control points pi , the points q u , for 0 ≤ u ≤ 1, all lie in the convex hull of the control points. This is a consequence of the fact that the points on the B´ezier curve are computed as weighted averages of the control points.  To illustrate the principle of recursive subdivision combined with convex hull testing, we consider the two-dimensional analogue of the ﬁrst example. The extension of these principles to three-dimensional problems is straightforward. Suppose we are given a B´ezier curve q u  and a line or ray L and want to decide whether the line intersects the B´ezier curve and, if so, ﬁnd where this intersection occurs. An algorithm based on recursive subdivision would work as follows: Begin by comparing the line L with the convex hull of the control points of q.3 Since the curve lies entirely in the convex hull of its control points, if L does not intersect the convex hull, then L does not intersect the B´ezier curve: in this case the algorithm may return false to indicate no intersection occurs. If L does intersect the convex hull, then the algorithm performs recursive subdivision to divide the B´ezier curve into two halves, q1 and q2. The algorithm then recursively calls itself to determine whether the line intersects either of the subcurves. However, before performing the recursive subdivision and recursive calls, the algorithm checks whether the B´ezier curve is sufﬁciently close to a straight line and, if so, the algorithm merely performs a check for whether the line L intersects the straight line approximation to the B´ezier curve. If so, this intersection, or nonintersection, is returned as the answer.  For algorithms using recursive subdivision for testing nonintersection or nonvisibility to perform well, it is necessary for the convex hulls to decrease rapidly in size with each successive subdivision. One step of this process is illustrated in Figure VII.6, which shows the convex  3 See Section X.1.4 for an efﬁcient algorithm for ﬁnding the intersection of a line and polygon.   VII.4 Piecewise B´ezier Curves  163  p1,2 p1,3 = p2,0  p2,1  p1,2  p1,1  q1 u   p1,1  p2,2  q2 u   q1 u   p1,3 = p2,0  q2 u   p2,2  p2,1  p1,0   a   p2,3  p1,0   b   p2,3  Figure VII.7. Two curves, each formed from two B´ezier curves, with control points as shown. The curve in part  a  is G1-continuous but not C 1-continuous. The curve in part  b  is neither C 1-continuous nor G1-continuous. Compare these curves with the curves of Figures VII.5 and VII.6 which are both C 1-continuous and G1-continuous.  hulls of the two subcurves q1 and q2 obtained by recursive subdivision. Actually, the shrinkage of the convex hulls of subcurves proceeds even more rapidly than is apparent in the ﬁgure: the “width” of the convex hull will decrease quadratically with the “length” of the convex hull. This fact can be proved by elementary calculus, just from the fact that B´ezier curves have continuous second derivatives.  VII.4 Piecewise B´ezier Curves  There is only a limited range of shapes that can described by a single degree-three B´ezier curve. In fact, Figures VII.1 and VII.2 essentially exhaust the types of shapes that can be formed with a single B´ezier curve. However, one frequently wants curves that are more complicated than can be formed with a single degree-three B´ezier curve. For instance, in Section VII.15, we will deﬁne curves that interpolate an arbitrary set of points. One way to construct more complicated curves would be to use higher degree B´ezier curves  look ahead to Figure VII.9 c , for an example . However, higher degree B´ezier curves are not particularly easy to work with. So, instead, it is often better to combine multiple B´ezier curves to form a longer, more complicated curve called a piecewise B´ezier curve.  This section discusses how to join B´ezier curves together – especially how to join them so as to preserve continuity and smoothness  i.e., continuity of the ﬁrst derivative . For this, it is enough to show how to combine two B´ezier curves to form a single smooth curve because generalizing the construction to combine multiple B´ezier curves is straightforward. We already saw the converse process in the previous section, where recursive subdivision was used to split a B´ezier curve into two curves.  Suppose we want to build a curve q u  consisting of two constituent curves q1 u  and q2 u  that are both degree three B´ezier curves. That is, we want to have q u  deﬁned in terms of q1 u  and q2 u  so that Equation VII.8 holds. Two examples of this are illustrated in Figure VII.7. Note that q u  will generally not be a single B´ezier curve; rather it is a union of two B´ezier curves. For i = 1, 2, let pi,0, pi,1, pi,2, and pi,3 be the control points for qi  u . In order for q u  to be a continuous curve, it is necessary for q1 1  to equal q2 0 . Since B´ezier curves begin and end at their ﬁrst and last control points, this is equivalent to requiring that p1,3 = p2,0. In order for q u  to have a continuous ﬁrst derivative at u = 1 1 1  = q  cid:3   cid:3  2 , it is necessary to have q 2 0 , that is, by Equation VII.3, to have p1,3 − p1,2 = p2,1 − p2,0.  If  and only if  these conditions are met, q u  will be continuous and have continuous ﬁrst derivatives. In this case, we say that q u  is C 1-continuous.   B´ezier Curves  164  1  H0  H3  H1  0  u  1 H2  Figure VII.8. The degree three Hermite polynomials. Deﬁnition Let k ≥ 0. A function f u  is C k-continuous if f has kth derivative deﬁned and continuous everywhere in the domain of f. For k = 0, the convention is that the zeroth derivative of f is just f itself, and so C 0-continuity is the same as continuity.  ∞  -continuous if it is C k-continuous for all k ≥ 0.  The function f u  is C  In some situations, having continuous ﬁrst derivatives is important. For example, if the curve q u  will be used to parameterize motion as a function of u, with u measuring time, then the C 1-continuity of q u  will ensure that the motion proceeds smoothly with no instantaneous changes in velocity or direction. However, in other cases, the requirement that the ﬁrst derivative be continuous can be relaxed somewhat. For example, if the curve q u  is being used to deﬁne a shape, then we do not really need the full strength of C 1-continuity. Instead, it is often enough just to have the slope of q u  be continuous. That is, it is often enough if the slope of q1 u  at u = 1 is equal to the slope of q2 u  at u = 0. This condition is known as G1-continuity or geometric continuity. Intuitively, G1-continuity means that when the curve is drawn as a static object, it “looks” smooth. A rather general deﬁnition of G1-continuity can be given as follows.  Deﬁnition A function f u  is G1-continuous provided f is continuous and there is a function t = t u  that is continuous and strictly increasing such that the function g u  = f t u   has continuous, nonzero ﬁrst derivative everywhere in its domain.  In practice, one rarely uses the full power of this deﬁnition. Rather, a sufﬁcient condition for the G1-continuity of the curve q u  is that p1,3 − p1,2 and p2,1 − p2,0 both be nonzero and that one can be expressed as a positive scalar multiple of the other.  Exercise VII.5 Give an example of a curve that is C 1-continuous but not G1-continuous. [Hint: The derivative of the curve can be zero at some point.]  VII.5 Hermite Polynomials  Hermite polynomials provide an alternative to B´ezier curves for representing cubic curves. Hermite polynomials allow a curve to be deﬁned in terms of its endpoints and its derivatives at its endpoints.  The degree three Hermite polynomials H0 u , H1 u , H2 u , and H3 u  are chosen so that  H0 0 =1 0 0 =0  cid:3  H 0 1 =0  cid:3  H H0 1 =0  H1 0 =0 1 0 =1  cid:3  H 1 1 =0  cid:3  H H1 1 =0  H2 0 =0 2 0 =0  cid:3  H 2 1 =1  cid:3  H H2 1 =0  H3 0 =0 3 0 =0  cid:3  H 3 1 =0  cid:3  H H3 1 =1.   VII.6 B´ezier Curves of General Degree  165  The advantage of Hermite polynomials is that if we need a degree three polynomial f u  that has value equal to a at u = 0 and equal to d at u = 1 and has ﬁrst derivative equal to b at u = 0 and c at u = 1, then we can just deﬁne  f u  = aH0 u  + bH1 u  + cH2 u  + dH3 u .  Since a degree three polynomial is uniquely determined by its values and ﬁrst derivatives at the two points u = 0 and u = 1, there is only one way to deﬁne the Hermite polynomials Hi to satisfy the preceding conditions. Some simple calculus and algebra shows that the degree three Hermite polynomials are4  H0 u  =  1 + 2u  1 − u 2 = 2u3 − 3u2 + 1 H1 u  = u 1 − u 2 = u3 − 2u2 + u H2 u  = −u2 1 − u  = u3 − u2 H3 u  = u2 3 − 2u  = − 2u3 + 3u2.  The Hermite polynomials are scalar-valued functions but can be used to deﬁne curves in Rk by using vectors as coefﬁcients. This allows any degree three B´ezier curve to be expressed in a Hermite form. In fact, it is easy to convert a B´ezier curve q u  with control points p0, p1, p2,  0  = 3 p1 − p0  and p3 in Rk into a Hermite representation: because the initial derivative is q  cid:3  and the ending derivative is q q u  = p0 H0 u  + 3 p1 − p0 H1 u  + 3 p3 − p2 H2 u  + p3 H3 u .   1  = 3 p3 − p2 , the Hermite representation must be   cid:3   Unlike B´ezier curves, the Hermite representation of a curve is not a weighted average since the sum H1 + H2 + H3 + H4 does not generally equal 1. The coefﬁcients of H0 and H3 are points  the starting and end points of the curve , but the coefﬁcients of H1 and H2 are vectors. As a consequence, the Hermite polynomials lack many of the nice properties of B´ezier curves; their advantage, however, is that sometimes it is more natural to deﬁne a curve in terms of its initial and ending positions and velocities than with control points.  For the opposite direction, converting a Hermite representation of a curve,  q u  = r0 H0 u  + r1 H1 u  + r2 H2 u  + r3 H3 u ,  into a B´ezier representation of the curve is also simple. Just let p0 = r0, let p3 = r3, let p1 = p0 + 1  3 r1, and let p2 = p3 − 1  3 r2.  Exercise VII.6 Let q u  be the curve of Exercise VII.1. Express q u  with Hermite poly- nomials.  VII.6 B´ezier Curves of General Degree  We now take up the topic of B´ezier curves of arbitrary degree. So far we have considered only degree three B´ezier curves, but it is useful to consider curves of other degrees. For instance, in Section VII.13 we will use degree two, rational B´ezier curves for rendering circles and other conic sections. As we will see, the higher  and lower  degree B´ezier curves behave analogously to the already studied degree three B´ezier curves.  4 Another way to derive these formulas for the Hermite polynomials is to express them as B´ezier curves that take values in R. This is simple enough, as we know the functions’ values and derivatives at the endpoints u = 0 and u = 1.   166 Deﬁnition Let k ≥ 0. The Bernstein polynomials of degree k are deﬁned by  B´ezier Curves   cid:12  ui  1 − u k−i .   cid:11   k i  i  u  = Bk  When k = 3, the Bernstein polynomials B3 i  u  are identical to the Bernstein polynomials Bi  u  deﬁned in Section VII.1. It is clear that the Bernstein polynomials Bk i  u  are degree k polyno- mials. Deﬁnition Let k ≥ 1. The degree k B´ezier curve q u  deﬁned from k + 1 control points p0, p1, . . . , pk is the parametrically deﬁned curve given by  The next theorem gives some simple properties of the Bernstein polynomials.  q u  = k cid:27   i=0  Bk i  u pi ,  on the domain u ∈ [0, 1].  k  1 .  b. c. Bk  Theorem VII.3 Let k ≥ 1.  cid:27  0  0  = 1 = Bk a. Bk i  u  = 1 for all u. k Bk i=0 i  u  ≥ 0 for all 0 ≤ u ≤ 1.  cid:12   cid:11  k cid:27   i  u  = k cid:27   Bk  k i  i=0  i=0  Proof Parts a. and c. are easily checked. To prove part b., use the binomial theorem:  ui  1 − u k−i =  u +  1 − u  k = 1.   cid:1   The properties of Bernstein functions in Theorem VII.3 immediately imply the correspond- ing properties of the curve q u . By a., the curve starts at q 0  = p0 and ends at q 1  = pk. Prop- erties b. and c. imply that each point q u  is a weighted average of the control points. As a con- sequence, by Theorem IV.8, a B´ezier curve lies entirely in the convex hull of its control points. We have already seen several examples of degree three B´ezier curves in Figures VII.1 and VII.2. Figure VII.9 shows some examples of B´ezier curves of degrees 1, 2, and 8 along with their control points. The degree one B´ezier curve is seen to have just two control points and to consist of linear interpolation between the two control points. The degree two B´ezier curve has three control points, and the degree eight B´ezier curve has nine. In all the examples, the B´ezier curve is seen to be tangent to the ﬁrst and last line segments joining its control points at u = 0 and u = 1. This general fact can be proved from the following theorem, which gives a formula for the derivative of a B´ezier curve.  Theorem VII.4 Let q u  be a degree k B´ezier curve, with control points p0, . . . , pk. Then its ﬁrst derivative is given by Bk−1   u  = k · k−1 cid:27    u  pi+1 − pi  .   cid:3  q  i  i=0   cid:3  Therefore, the derivative q  u  of a B´ezier curve is itself a B´ezier curve: the degree is decreased by one and the control points are k pi+1 − pi  . A special case of the theorem gives the following formulas for the derivatives of q u  at its starting and end points:  Corollary VII.5 Let q u  be a degree k B´ezier curve. Then  1  = k pk − pk−1 .   0  = k p1 − p0   and   cid:3  q  q   cid:3    VII.6 B´ezier Curves of General Degree  167  p1  p1  p0  p2   a  Degree one   b  Degree two  p1  p2  p5  p7  p0  p0  p3  p4  p6  p8   c  Degree eight  Figure VII.9.  a  A degree one B´ezier curve is just a straight line interpolating the two control points.  b  A degree two B´ezier curve has three control points.  c  A degree eight B´ezier curve has nine control points. The dotted straight line segments are called the control polygon of the B´ezier curve.  This corollary proves the observation that the beginning and ending directions of the B´ezier curve are in the directions of p1 − p0 and of pk − pk−1. Proof The corollary is easily proved from Theorem VII.4 with the aid of Theorem VII.3. To prove Theorem VII.4, one may either obtain it as a special case of Theorem VIII.8 on page 221, which we will state and prove in the next chapter, or one can prove it directly by the following argument. Using the deﬁnition of the Bernstein polynomials, we have  k − i ui  1 − u k−i−1.   cid:11   Note that the ﬁrst term is zero if i = 0 and the second is zero if i = k. Thus, the derivative of q u  is equal to  k i  k i  k i  k i  i=0  i=0   cid:11    cid:12   d du   cid:12  i  u  = iui−1 1 − u k−i − Bk  cid:12   cid:12   cid:11   cid:11  iui−1 1 − u k−i pi − k cid:27  k cid:27   cid:11   cid:12  iui−1 1 − u k−i pi − k−1 cid:27  = k cid:27   cid:12   cid:11  = k−1 cid:27   i + 1 ui  1 − u k−1−i pi+1 − k−1 cid:27  k  cid:12   cid:11   cid:11  i + 1 ui  1 − u k−1−i pi+1 − k−1 cid:27  = k−1 cid:27  k − 1  cid:12   cid:11  = k−1 cid:27  i k − 1 k−1 cid:27  i  i=0 ui  1 − u k−1−i  pi+1 − pi    i=0  i=1  i=0  i=0  k i  k i  k  k  k  Bk−1  i   u  pi+1 − pi  ,  i=0 = k  i=0   k − i ui  1 − u k−1−i pi  cid:11   cid:12    k − i ui  1 − u k−1−i pi   cid:11   k i i=0 k − 1 i   cid:12   k − i ui  1 − u k−1−i pi  cid:12   ui  1 − u k−1−i pi  and Theorem VII.4 is proved.   cid:1    168  B´ezier Curves  B´ezier curves of arbitrary degree k have many of the properties we discussed earlier in connection with degree three curves. These include the convex hull property mentioned pre- viously. Another property is invariance under afﬁne transformations; namely, if M is an afﬁne transformation, then the result of applying M to a B´ezier curve q u  is identical to the re- sult of applying M to the control points. In other words, the curve M q u   is equal to the B´ezier curve formed from the control points M pi  . The afﬁne invariance property follows from the characterization of the point q u  as a weighted average of the control points and from Theorem IV.1.  An additional property of B´ezier curves is the variation diminishing property. Deﬁne the control polygon to be the series of straight line segments connecting the control points p0, p1, . . . , pk in sequential order  see Figure VII.9 . Then the variation diminishing property states that, for any line L in R2  or, any plane P in R3 , the number of times the curve q u  crosses the line  or the plane  is less than or equal to the number of times the control polygon crosses the line  or the plane . A proof of the variation diminishing property may be found in  Farin, 1997 ; this proof is also sketched in Exercise VII.9.  It is of course possible to create piecewise degree k B´ezier curves using the same approach discussed in Section VII.4 for degree three curves. Let p1,i be the control points for the ﬁrst curve and p2,i be the control points for the second curve  where 0 ≤ i ≤ k . A necessary and sufﬁcient condition for continuity is that p1,k = p2,0 so that the second curve will start at the end of the ﬁrst curve. A necessary and sufﬁcient condition for C 1-continuity is that p1,k − p1,k−1 equals p2,1 − p2,0 so that the ﬁrst derivatives will match up  see Corollary VII.5 . A sufﬁcient condition for G1-continuity is that p1,k − p1,k−1 and p2,1 − p2,0 are both nonzero and are positive scalar multiples of each other. These conditions are equivalent to those we encountered in the degree three case! For the next exercise, we adopt the convention that two curves q1 u  and q2 u  are the same if and only if q1 u  = q2 u  for all u ∈ [0, 1]. Otherwise, the two curves are said to be different. Exercise VII.7 Prove that, for a given degree k B´ezier curve, there is a unique set of control points p0, . . . , pk that deﬁnes that B´ezier curve. That is, two different sequences of k + 1 control points deﬁne two different B´ezier curves. [Hint: This should be clear for p0 and pk; for the rest of the control points, use induction on the degree and the formula for the derivative of a B´ezier curve.]  A degree k polynomial curve is a curve of the form  q u  =  cid:5 x u , y u , z u  cid:6   with x u , y u , and z u  polynomials of degree ≤ k. A degree two  respectively, degree three  polynomial curve is also called a quadratic curve  respectively, cubic curve . Note that every degree k B´ezier curve is a degree k polynomial curve.  Exercise VII.8 Let q u  be a degree k polynomial curve. Prove that there are control points p0, . . . , pk that represent q u  as a degree k B´ezier curve for u ∈ [0, 1]. [Hint: Prove that the dimension of the vector space of all degree k polynomial curves is equal to the dimension of the vector space of all degree k B´ezier curves. You will need to use the previous exercise.]  VII.7 De Casteljau’s Method Revisited  Recall from Section VII.2 that de Casteljau gave a simple, and numerically stable, method for computing a point q u  on a degree three B´ezier curve for a particular value of u. As we show next, the de Casteljau method can be generalized to apply to B´ezier curves of arbitrary degree in the more or less obvious way.   VII.8 Recursive Subdivision Revisited  169 Let a degree k B´ezier curve q u  have control points pi , i = 0, . . . , k. Fix u ∈ [0, 1]. We i  u  = pi . Second, for r > 0 and 0 ≤ i ≤  i  u  as follows. First, for r = 0, let p0  deﬁne points pr k − r, let  i  u  =  1 − u pr−1 pr = lerp pr−1   u  + upr−1 i+1  u , u .   u , pr−1  i+1  u   i  i  In Section VII.2, for the degree k = 3 case, we used different names for the variables. Those  variables can be translated into the new notation by ri = p1  i , si = p2  i , and t0 = p3 0.  The next theorem generalizes the de Casteljau method to the general degree case.  Theorem VII.6 Let q u  and pr  i be as above. Then, for all u, q u  = pk  0 u .  Proof To prove the theorem, we prove the following more general claim. The theorem is an immediate consequence of the r = k case of the following claim. Claim Let 0 ≤ r ≤ k and 0 ≤ i ≤ k − r. Then  i  u  = r cid:27   pr  j=0  j  u pi+ j . Br  VII.9  We prove this claim by induction on r. The base case, r = 0, is obvious. Or, if you prefer to take r = 1 as the base case, the claim is also easily veriﬁed for r = 1. Now, suppose Equation VII.9 holds for r: we wish to prove it holds for r + 1. We have  pr+1  i   u  =  1 − u pr  = r cid:27  = r+1 cid:27   j=0  j=0  i  u  + upr  i+1 u   j  u pi+ j + r cid:27   j=0 j  u  + u Br   1 − u Br  cid:9    1 − u Br   cid:10   j−1 u   pi+ j ,  u Br  j  u pi+ j+1  where the last sum should interpreted by letting the quantities   r and Br that  r+1 u , be deﬁned to equal zero. Because   r  1 − u Br  j−1 u  = Br+1  j  u  + u Br  j   +   r   u ,  j  from whence the claim, and thus Theorem VII.6, are proved.  r+1   and   r−1  , and thus Br−1 u  j  , it is easy to verify  j−1   =   r+1   cid:1   VII.8 Recursive Subdivision Revisited  The recursive subdivision technique of Section VII.3 can be generalized to B´ezier curves of arbitrary degree. Let q u  be a degree k B´ezier curve, let u0 ∈ [0, 1], and let q1 u  and q2 u  be the curves satisfying q1 u  = q u0u   q2 u  = q u0 +  1 − u0 u .  and  Thus, q1 u  is the ﬁrst u0-fraction of q u  and q2 u  is the rest of q u : both curves q1 u  and q2 u  have domain [0, 1]. Also, let the points pr i  u0  be deﬁned as in Section VII.7 with u = u0. i  = pr   170  B´ezier Curves  Theorem VII.7 Let q, q1, q2, and pr a. The curve q1 u  is equal to the degree k B´ezier curve with control points p0 0 b. The curve q2 u  is equal to the degree k B´ezier curve with control points pk 0  i be as above.  , p2 0  , p1 0  , . . . , pk 0. , pk−1 ,  1  pk−2  2  , . . . , p0 k.  Proof We will prove part a.; part b. is completely symmetric. To prove a., we need to show that  holds. Expanding the left-hand side with the deﬁnition of B´ezier curves and the right-hand side with Equation VII.9 of the claim, we ﬁnd this is equivalent to  B j i  u0 pi .  Bk  Bk  Bk  j=i  i=0  i=0  i=0  j=0  j=0  j  u   0 u0   i  u0 pi .  j  u p j Bk  j  u B j Bk  j cid:27   q u0u  = k cid:27  i  u0u pi = k cid:27  k cid:27  k cid:27  k cid:27  i  u0u  = k cid:27   cid:12   u0u i  1 − u0u k−i = k cid:27   cid:12   1 − u0u k−i = k cid:27   cid:11  k−i cid:27  = k−i cid:27    cid:12  k − i u j  1 − u0  j  1 − u k−i− j  cid:12   cid:11  j k − i j  k − i j − i  j  u B j Bk  i  u0 ,   cid:11    cid:11   j=0  j=i  j=i  j=i  k j  k i  j=0  =   u − u0u  +  1 − u  k−i =  1 − u0u k−i ,   u − u0u  j  1 − u k−i− j  With the summations reordered, the right-hand side of the equation is equal to  Therefore, equating coefﬁcients of the pi ’s, we need to show that  that is, cid:11    cid:12  cid:11    cid:12   j i  0 1 − u k− j  1 − u0  j−i .  u j ui  If we divide both sides by  u0u i and use the fact that   k that  i   =   k  i    k−i  j    j  j−i  , this reduces to showing  u j−i  1 − u k− j  1 − u0  j−i .  By a change of variables from “ j” to “ j + i” in the summation, the right-hand side is equal to  where the second equality follows from the binomial theorem. This is what we needed to show  cid:1  to complete the proof of Theorem VII.7.   VII.9 Degree Elevation   cid:1   171  Exercise VII.9 Fill in the details of the following sketch of a proof of the variation diminishing property of B´ezier curves. First, ﬁx a line  or, in R3, a plane  and a continuous curve  the curve may consist of straight line segments . Consider the following operation on the curve: choose two points on the curve and replace the part of the curve between the two points by the straight line segment joining the two points. Prove that this does not increase the number of times the curve crosses the line. Second, show that the process of going from the control polygon of a B´ezier curve to the two control polygons of the two subcurves obtained by using recursive subdivision to split the curve at u = 1 2 involves only a ﬁnite number of uses of the operation from the ﬁrst step. Therefore, the total number of times the two new control polygons cross the line is less than or equal to the number of times the original control polygon crossed the curve. Third, prove that, as the curve is repeatedly recursively subdivided, the control polygon approximates the curve. Fourth, argue that this sufﬁces to prove the variation diminishing property  this last point is not entirely trivial .  VII.9 Degree Elevation  The term “degree elevation” refers to the process of taking a B´ezier curve of degree k and reexpressing the same curve as a higher degree B´ezier curve. Degree elevation is useful for converting a low-degree B´ezier curve into a higher degree represention. For example, Section VII.13 will describe several ways to represent a circle with degree two B´ezier curves, and one may need to elevate their degree to three for use in a software program. The PostScript language, for example, supports only degree three B´ezier curves, not degree two. Of course, it should not be surprising that degree elevation is possible. Indeed, any degree k polynomial can be viewed also as a degree k + 1 polynomial by just treating it as having a leading term 0x k+1 with coefﬁcient zero. It is not as simple to elevate the degree of B´ezier curves, for we must deﬁne the curve in terms of its control points. To be completely explicit, the degree elevation problem is the following:  We are given a degree k B´ezier curve q u  deﬁned in terms of control points pi ,  i = 0, . . . , k. We wish to ﬁnd new control points*pi , i = 0, . . . , k, k + 1 so that the degree k + 1 B´ezier curve*q u  deﬁned by these control points is equal to q u , that is,*q u  = q u  for all u.  It turns out that the solution to this problem is fairly simple. However, before we present the general solution, we ﬁrst use the k = 2 case as an example.  See Exercise VII.17 on page 184 *p0 = p0 and*p3 = p2 so that the degree three curve*q u  will start at p0 and end at p2. Also, for an example of an application of this case.  In this case, we are given three control points, p0, p1, p2, of a degree two B´ezier curve q u . Since q 0  = p0 and q 1  = p2, we must have  the derivatives at the beginning and end of the curve are equal to  Therefore, by Equation VII.3 for the derivative of a degree three B´ezier curve, we must have   cid:3   q   cid:3  q   0  = 2 p1 − p0   1  = 2 p2 − p1 . *p1 =*p0 + 1 *p2 =*p3 − 1   cid:3  q   cid:3  q  3  3   0  = 1   1  = 2  3 p0 + 2 3 p1 3 p1 + 1  3 p2,   172  B´ezier Curves  p1   cid:1 p2   cid:1 p1  p2 =  cid:1 p3   cid:1 p0 = p0  Now, we turn to the general case of degree elevation. Suppose q u  is a degree k curve  Figure VII.10. The curve q u  =*q u  is both a degree two B´ezier curve with control points p0, p1, and p2 and a degree three B´ezier curve with control points*p0,*p1,*p2, and*p3. as shown in Figure VII.10. These choices for control points give*q u  the right starting and ending derivatives. Since q u  and*q u  both are polynomials of degree ≤ 3, it follows that *q u  is equal to q u . with control points p0, . . . , pk: we wish to ﬁnd k + 1 control points*p0, . . . ,*pk+1 which deﬁne the degree k + 1 B´ezier curve*q u  that is identical to q u . For this, the following deﬁnitions work: *p0 = p0 *pi = Note that the ﬁrst two equations, for*p0 and*pk+1, can be viewed as special cases of the third Theorem VII.8 Let q u ,*q u , pi , and*pi be as above. Then*q u  = q u  for all u.  *pk+1 = pk pi−1 + k − i + 1 k + 1  by deﬁning p−1 and pk+1 to be arbitrary points.  i k + 1  pi .  ui  1 − u k−i pi .  cid:12   pi  .  Proof We need to show that   cid:11    cid:12   k i   cid:11    cid:11   k+1 cid:27   i=0  k+1 cid:27   i=0  k + 1 i  k + 1 i   cid:12  ui  1 − u k−i+1*pi = k cid:27   cid:12  ui  1 − u k−i+1   cid:11   i=0  The left-hand side of this equation is also equal to  pi−1 + k − i + 1 k + 1  cid:12   k − i + 1 k + 1  i k + 1  cid:11   cid:10  = cid:9   k + 1  cid:10  i  cid:12   cid:11   k+1 i  k i   cid:11    cid:11    cid:12  k + 1 i + 1  cid:12   k i  i + 1  cid:9  k + 1  ui+1 1 − u k−i +  cid:10   = cid:9   i+1 k+1  k+1 i+1  k i   u +  1 − u  ui  1 − u k−i =  Using the identities  ui  1 − u k−i+1.  k−i+1 k+1 , we ﬁnd this is further equal to ui  1 − u k−i .  Regrouping the summation, we calculate the coefﬁcient of pi in this last equation to be equal to  VII.10  Thus, we have shown that pi has the same coefﬁcient on both sides of Equation VII.10, which  cid:1  proves the desired equality.   VII.10 B´ezier Surface Patches  173  p0,3  p3,3  p0,0 Figure VII.11. A degree three B´ezier patch and its control points. The control points are shown joined by straight line segments.  p3,0  VII.10 B´ezier Surface Patches  This section extends the notion of B´ezier curves to deﬁne B´ezier patches. A B´ezier curve is a one-dimensional curve; a B´ezier patch is a two-dimensional parametric surface. Typically, a B´ezier patch is parameterized by variables u and v, which both range over the interval [0, 1]. The patch is then the parametric surface q u, v , where q is a vector-valued function deﬁned on the unit square [0, 1]2.  VII.10.1 Basic Properties of B´ezier Patches B´ezier patches of degree three are deﬁned using a 4 × 4 array of control points pi, j , where i, j take on values 0, 1, 2, 3. The B´ezier patch with these control points is given by the formula  Bi  u B j  v pi, j .  VII.11  q u, v  = 3 cid:27   3 cid:27   i=0  j=0  An example is shown in Figure VII.11. Intuitively, the control points act similarly to the control points used for B´ezier curves. The four corner control points, p0,0, p3,0, p0,3, and p3,3 form the four corners of the B´ezier patch, and the remaining twelve control points inﬂuence the patch by “pulling” the patch towards them.  Equation VII.11 can be equivalently written in either of the forms  VII.12  VII.13  Consider the cross sections of q u, v  obtained by holding the value of v ﬁxed and varying u. Some of these cross sections are shown going from left to right in Figure VII.12. Equation VII.12 shows that each such cross section is a degree three B´ezier curve with control points ri equal to the inner summation, that is,  q u, v  = 3 cid:27  q u, v  = 3 cid:27   i=0  ’ ’  j=0  Bi  u  ·  B j  v  ·  3 cid:27  3 cid:27   j=0  i=0       B j  v pi, j  Bi  u pi, j  .  ri = 3 cid:27   j=0  B j  v pi, j .   174  B´ezier Curves  Figure VII.12. A degree three B´ezier patch and some cross sections. The cross sections are B´ezier curves.  Thus, the cross sections of the B´ezier patch obtained by holding v ﬁxed and letting u vary are ordinary B´ezier curves. The control points ri for the cross section are functions of v of course and are in fact given as B´ezier curves of the control points pi, j .  Similarly, from Equation VII.13, if we hold u ﬁxed and let v vary, then the cross sections are again B´ezier curves and the control points s j of the B´ezier curve cross sections are computed as functions of u as B´ezier curve functions:  s j = 3 cid:27   i=0  Bi  u pi, j .  Now consider what the boundaries of the B´ezier patch look like. The “front” boundary is where v = 0 and u ∈ [0, 1]. For this front cross section, the control points ri are equal to pi,0. Thus, the front boundary is the degree three B´ezier curve with control points p0,0, p1,0, p2,0, and p3,0. Similarly, the “left” boundary where u = 0 is the B´ezier curve with control points p0,0, p0,1, p0,2, and p0,3. Likewise, the other two boundaries are B´ezier curves that have as control points the pi, j ’s on the boundaries.  The ﬁrst-order partial derivatives of the B´ezier patch q u, v  can be calculated with aid of Theorem VII.4 along with equations VII.12 and VII.13. This can be used to calculate the normal vector to the B´ezier patch surface via Theorem III.1. Rather than carrying out the calculation of the general formula for partial derivatives here, we will instead consider only the partial derivatives at the boundary of the patches because these will be useful in the discus- sion about joining together B´ezier patches with C 1- and G1-continuity  see Section VII.10.2 . By using Equation VII.3 for the derivatives of a B´ezier curve at its endpoints and Equations VII.12 and VII.13, we can calculate the partial derivatives of q u, v  at its boundary points as  i=0   u, 0  = 3 cid:27   u, 1  = 3 cid:27   0, v  = 3 cid:27   1, v  = 3 cid:27   j=0  i=0  j=0  ∂q ∂v  ∂q ∂v  ∂q ∂u  ∂q ∂u  3Bi  u  pi,1 − pi,0   3Bi  u  pi,3 − pi,2   3B j  v  p1, j − p0, j    3B j  v  p3, j − p2, j  .  VII.14  VII.15  VII.16  VII.17   VII.10 B´ezier Surface Patches  175  These four partial derivatives are the partial derivatives in the directions pointing perpendic- ularly to the boundaries of the patch’s domain. The other partial derivatives at the boundary, such as  ∂q ∂u  u, 0 , can easily be calculated from the fact that the boundaries of the patch are B´ezier curves.  Later, in Section VII.16, we will need to know the formulas for the second-order mixed partial derivatives at the corners of the patch. Using Equation VII.3 or Corollary VII.5 and Equation VII.14, we have   0, 0  = 9 ·  p1,1 − p0,1 − p1,0 + p0,0 .  Similarly, at the other three corners of the patch, we have   0, 1  = 9 ·  p1,3 − p0,3 − p1,2 + p0,2   1, 0  = 9 ·  p3,1 − p2,1 − p3,0 + p2,0   1, 1  = 9 ·  p3,3 − p2,3 − p3,2 + p2,2 .  ∂ 2q ∂u∂v  ∂ 2q ∂u∂v ∂ 2q ∂u∂v ∂ 2q ∂u∂v  VII.18  VII.19  The second-order mixed partial derivatives at the corners are called twist vectors.   cid:1   Exercise VII.10 partial derivatives of a B´ezier patch, ∂q u, v  ∂u and ∂q u, v  ∂v.  Use Theorem VII.4 to work out the general formula for the ﬁrst-order  Exercise VII.11 Derive an extension of the de Casteljau algorithm for degree three curves  see Section VII.2  that applies to B´ezier patches of degree three.  Exercise VII.12 Derive a recursive subdivision method for degree three B´ezier patches based on recursive subdivision for B´ezier curves. Your method should either subdivide in the u direction or in the v direction and split a patch into two patches  i.e., it should not subdivide in both directions at once .  VII.10.2 Joining B´ezier Patches  A common use of B´ezier patches is to combine multiple patches to make a smooth surface. With only 16 control points, a single B´ezier patch can make only a limited range of surface shapes. However, by joining multiple patches, a wider range of surface shapes can be approximated. Let us start by considering how to join two patches together so as to make a continuous or C 1- or G1-continuous surface. The situation is that we have two B´ezier patches q1 u, v  and q2 u, v . The control points of q1 are pi, j , and those of q2 are the points ri, j . In addition, q2 has domain [0, 1]2 as usual, but the surface q1 has been translated to have domain [−1, 0] × [0, 1]  by use of the change of variables u  cid:13 → u + 1 . We wish to ﬁnd conditions on the control points that will cause the two surfaces to join smoothly at their boundary where u = 0 and 0 ≤ v ≤ 1, as shown in Figure VII.13. Recall that the right boundary of q1  where u = 0  is the B´ezier curve with control points p3, j , j = 0, 1, 2, 3. Likewise, the left boundary of q2 is the B´ezier curve with control points r0, j . Thus, in order for the two boundaries to match, it is necessary and sufﬁcient that p3, j = r0, j for j = 0, 1, 2, 3.  Now we assume that the patches are continuous at their boundary and consider continuity of the partial derivatives at the boundary between the patches. First, since the boundaries are equal, clearly the partials with respect to v are equal. For the partials with respect to u, it follows   p3,3 = r0,3  176  p0,3  q1  r3,3  q2  B´ezier Curves  p0,0  p3,0 = r0,0  r3,0  Figure VII.13. Two B´ezier patches join to form a single smooth surface. The two patches q1 and q2 each have 16 control points. The four rightmost control points of q1 are the same as the four leftmost control points of q2. The patches are shown forming a C 1-continuous surface.  from Equations VII.16 and VII.17 that a necessary and sufﬁcient condition for C 1-continuity, that is, for ∂q2 ∂u   0, v    0, v  = ∂q1 ∂u to hold for all v, is that  p3, j − p2, j = r1, j − r0, j  for j = 0, 1, 2, 3.  VII.20  For G1-continuity, it is sufﬁcient that these four vectors are nonzero and that there is a scalar α > 0 so that  p3, j − p2, j = α r1, j − r0, j    for j = 0, 1, 2, 3.  In Section VII.16, we will use the condition VII.20 for C 1-continuity to help make surfaces that interpolate points speciﬁed on a rectangular grid.  Subdividing B´ezier Patches In Exercise VII.12, you were asked to give an algorithm for recursively subdividing degree three B´ezier patches. As in the case of B´ezier curves, recursive subdivision is often used to divide a surface until it consists of small patches that are essentially ﬂat. Each ﬂat patch can be approximated as a ﬂat quadrilateral  or, more precisely, can be divided into two triangles, each of which is necessarily planar . These ﬂat patches can then be rendered as usual. In the case of recursive subdivision of patches, there is a new problem: since some patches may need to be subdivided further than others, it can happen that a surface is subdivided and its neighbor is not. This is pictured in Figure VII.14, where q1 and q2 are patches. After q1 is divided into two subpatches, there is a mismatch between the  formerly common  boundaries of q1 and q2. If this mismatch is allowed to persist, then we have a problem known as cracking in which small gaps or small overlaps can appear in the surface.  One way to ﬁx cracking is to replace the boundary by a straight line. Namely, once the decision has been made that q2 needs no further subdivision  and will be rendered as a ﬂat patch , replace the boundary between q1 and q2 with a straight line. This is done by redeﬁning   VII.10 B´ezier Surface Patches  177  q1  q2  q1  q2  Figure VII.14. Nonuniform subdivision can cause cracking. On the left, two B´ezier patches share a com- mon boundary. On the right, after subdivision of the left patch q1, the boundaries no longer match up.  the two middle control points along the common boundary. This forces the boundary of q1 also to be straight, and this straightness is preserved by subsequent subdivision.  Unfortunately, just replacing the boundary by a straight line is not enough to ﬁx the cracking problem completely. First, as discussed at the end of Chapter II, there may be problems with pixel-size holes along the boundary  see the discussion accompanying Figure II.29 on page 66 . Second, and more seriously, it is also important that the surface normals on the boundary between the two patches match up in order for lighting computations to be consistent. Still worse, being consistent about assigning surface normals to the vertices is not enough: this is because Gouraud interpolation is used to shade the results of the lighting calculation along the boundary between the patches. If the boundary is divided into two pieces in one patch and left as one piece in the other patch, Gouraud interpolation will give different results in the two patches. This could happen if three quadrilaterals were rendered as shown on the left in Figure VII.15 since the lighting calculated at the center vertex may not be consistent with the light values obtained by Gouraud interpolation when rendering patch q2. One possible solution to this problem is shown on the right in Figure VII.15, where the quadrilateral patch q2 has been split into a triangle and another quadrilateral. With this solution, the boundary is rendered only in separate pieces, never as a single edge, and Gouraud interpolation yields consistent results on both sides of the boundary.  We have discussed only degree three B´ezier patches above, but of course, B´ezier patches can also be deﬁned with other degrees. In addition, a B´ezier patch may have a different degree in u than in v. In general, if the B´ezier patch has degree ku in u and degree kv in v, then there are  ku + 1  kv + 1  control points pi, j with 0 ≤ i ≤ ku and 0 ≤ j ≤ kv. The B´ezier patch is given by  q u, v  = ku cid:27   kv cid:27   i=0  j=0  Bku i  u Bkv  j  v pi, j .  We will not develop the theory of B´ezier patches of general degree any further; however, an example of a B´ezier patch that is degree three in one direction and degree two in the other is shown in Section VII.14 on page 188.  q1  q2  q1  q2  Figure VII.15. Two solutions to the cracking problem. On the left, the subdivided q1 and the original q2 share a common straight boundary. However, the lighting and shading calculations may cause the surface to be rendered discontinuously at the boundary. On the right, the patch q2 has been subdivided in an ad hoc way to allow the common boundary to have the same points and normals with respect to both patches.   178  B´ezier Curves  VII.11 B´ezier Curves and Surfaces in OpenGL  VII.11.1 B´ezier Curves  OpenGL has several routines for automatic generation of B´ezier curves of any degree. How- ever, OpenGL does not have generic B´ezier curve support; instead, its B´ezier curve functions are linked directly to drawing routines. Unfortunately, this means that the OpenGL B´ezier curve routines can be used only for drawing; thus, if you wish to use B´ezier curves for other applications, such as animation, you cannot use the built-in OpenGL routines.  Instead of having a single command for generating B´ezier curves, OpenGL has separate commands for deﬁning or initializing a B´ezier curve from its control points and for displaying part or all of the B´ezier curve.  Deﬁning B´ezier Curves. To deﬁne and enable  i.e., activate  a B´ezier curve, the following  two OpenGL commands are used:  glMap1f GL_MAP1_VERTEX_3, float umin, float umax,  int stride, int order, float* controlpointsptr  ;  glEnable GL_MAP1_VERTEX_3 ;  The values of umin and umax give the range of u values over which the curve is deﬁned.  These are typically set to 0 and 1.  The last parameter points to an array of ﬂoats that contains the control points. A typical  usage would deﬁne controlpoints as an array of x, y, z values,  float controlpoints[M][3];  and then the parameter controlpointsptr would be &controlpoints[0][0]. The stride value is the distance  in ﬂoats  from one control point to the next; that is, the control point pi is pointed to by controlpointsptr+i*stride. For the preceding deﬁnition of controlpoints, stride equals 3.  The value of order is equal to one plus the degree of the B´ezier curve; thus, it also equals the number of control points. Consequently, for the usual degree three B´ezier curves, the order M equals 4.  As mentioned above, B´ezier curves can be used only for drawing purposes. In fact, several B´ezier curves can be active at one time to affect different aspects of the drawn curve such as its location and color. The ﬁrst parameter to glMap1f   describes how the B´ezier curve is used when the curve is drawn. The parameter GL_MAP1_VERTEX_3 means that the Bezi´er curve is deﬁning the x, y, z values of points in 3-space as a function of u. There are several other useful constants that can be used for the ﬁrst parameter. These include GL_MAP1_VERTEX_4, which means that we are specifying x, y, z, w values of a curve, that is, a rational B´ezier curve  see Sections VII.12 and VII.13 for information on rational curves . Also, one can use GL_MAP1_COLOR_4 as the ﬁrst parameter: this means that, as the B´ezier curve is being drawn  by the commands described below , the color values will be speciﬁed as a B´ezier function of u. You should consult the OpenGL documentation for other permitted values for this ﬁrst parameter. Finally, a reminder: do not forget to give the glEnable command for any of these parameters you wish to activate!  Drawing B´ezier Curves. Once the B´ezier curve has been speciﬁed with glMap1f  , the curve can be drawn with the following commands. The most basic way to specify a point on the curve is with the command  glEvalCoord1f  float u  ;   VII.11 B´ezier Curves and Surfaces in OpenGL  179  which must be given between a glBegin   and glEnd  . The effect of this command is similar to specifying a point with glVertex* and, if the appropriate curves are enabled, with glNormal* and glTexCoord* commands. However, the currently active normal and texture coordinates are not changed by a call to glEvalCoord1f  .  When you use glEvalCoord1f  , you are explicitly drawing the points on the curve. However, frequently you want to draw an entire curve or a portion of a curve at once instead of having to make multiple calls to glEvalCoord1f. For this, OpenGL has several commands that will automatically draw points at equally spaced intervals along the curve. To use these commands, after calling glMap1f and the corresponding glEnable, you must next tell OpenGL the “grid” or “mesh” of points on the curve to be drawn. This is done with the following command:  glMapGrid1f int N , float ustart, float uend ; which tells OpenGL that you want the curve to be discretized as N + 1 equally spaced points starting with the value u = ustart and ending with u = uend. It is required that umin ≤ ustart ≤ uend ≤ umax.  A call to glMapGrid1f   only sets a grid of u values. To actually draw the curve,  you should then call  glEvalMesh1 GL_LINE, int pstart, int pend ; This causes OpenGL to draw the curve at grid values, letting p range from pstart to pend and drawing the points on the B´ezier curve with coordinates u =   N − p ustart + p · uend   N . The ﬁrst parameter, GL_LINE, tells OpenGL to draw the curve as a sequence of straight lines. This has the same functionality as drawing points after a call to glBe- gin GL_LINE_STRIP . To draw only the points on the curve without the connecting lines, use GL_POINT instead  similar in functionality to using glBegin GL_POINTS  . The values of pstart and pend should satisfy 0 ≤ pstart ≤ pend ≤ N .  You can also use glEvalPoint1  int p   to draw a single point from the grid. The functions glEvalPoint1 and glEvalMesh1 are not called from inside glBegin   and glEnd  .  VII.11.2 B´ezier Patches  B´ezier patches, or B´ezier surfaces, can be drawn using OpenGL commands analogous to the commands described in the previous section for B´ezier curves. Since the commands are very similar, only very brief descriptions are given of the OpenGL routines for B´ezier patches. The SimpleNurbs program in the software accompanying this book shows an example of how to render a B´ezier patch in OpenGL.  To specify a B´ezier patch, one uses the glMap2f   routine:  glMap2f GL_MAP2_VERTEX_3,  float umin, float umax, int ustride, int uorder, float vmin, float vmax, int vstride, int vorder, float* controlpoints  ; glEnable GL_MAP2_VERTEX_3 ; The controlpoints array is now a  uorder × vorder  array and would usually be  speciﬁed by  float controlpointsarray[Mu][Mv][3];   180  B´ezier Curves  where Mu and Mv are the uorder and vorder values. In this case, the value vstride would equal 3, and ustride should equal 3Mv. Note that the orders  which equal 1 plus the degrees  of the B´ezier curves are allowed to be different for the u and v directions.  Other useful values for the ﬁrst parameter to glMap2f   include GL_MAP2_VERTEX_4 for rational B´ezier patches, GL_MAP2_COLOR_4 to specify colors, and GL_MAP2_ TEXTURE_COORD_2 to specify texture coordinates. Again, you must give the glEnable command to activate these settings for the parameter. For many typical applications of texture coordinates to B´ezier patches, one wants the texture coordinates s, t just to be equal to u and v. This is done by specifying a degree one  order= 2  B´ezier curve; for instance,  float texpts[8]={0,0, 0,1, 1,0, 1,1}; glMap2f GL_MAP2_TEXTURE_COORD_2,0,1,4,2,0,1,2,2,&texpts[0] ; glEnable GL_MAP2_TEXTURE_COORD_2 ;  The normals to the patch may be speciﬁed by a B´ezier formula using GL_MAP2_NORMAL as the ﬁrst parameter to glMap2f  . However, this is rarely useful because typically one wants the true normals to the B´ezier surface. OpenGL will calculate these true normals for you  according to Formula III.12 if applicable , if you give the command  glEnable GL_AUTO_NORMAL ;  commands are available:  To display the B´ezier patch, or a portion of the B´ezier surface, the following OpenGL  glEvalCoord2f float u, float v ; glMapGrid2f int Nu, float ustart, float uend,  int Nv, int vstart, int vend ;  glEvalMesh2 GL_FILL, int pstart, pend, qstart, qend ; glEvalPoint2 int p, int q ;  The ﬁrst parameter to glEvalMesh2   may be also GL_LINE or GL_POINT. These com- mands work analogously to the commands for one-dimensional B´ezier curves. The most direct method of drawing a B´ezier patch is to call glMapGrid2f and then glEvalMesh2.  Exercise VII.13 Build a ﬁgure such as a teapot, coffee pot, vase, or other shape of similar complexity. The techniques described in Blinn’s article  Blinn, 1987  on the famous Utah teapot can make this fairly straightforward. Make sure that normals are calculated so that lighting is applied correctly  OpenGL can compute the normal for you .  Optionally, refer ahead to Sections VII.13 and VII.14 to learn how to make surfaces of revolution with rational B´ezier patches. Apply this to make the cross sections of your object perfectly circular.  One difﬁculty with completing the preceding exercise is that OpenGL does not always calculate normals on B´ezier surfaces correctly. In particular, OpenGL has problems with normals when an edge of a B´ezier patch consists of a single point. Remember that you should use glEnable GL_NORMALIZE  when transforming illuminated objects. The sample program SimpleNurbs shows how to use OpenGL to render a B´ezier patch with correct normals and illumination.  VII.12 Rational B´ezier Curves  A B´ezier curve is called rational if its control points are speciﬁed with homogeneous coordi- nates. Using homogeneous representations for control points may seem obscure or mystifying at ﬁrst, but, in fact, there is nothing especially mysterious about the use of homogeneous   VII.12 Rational B´ezier Curves   cid:1 3p1, 3 cid:2    cid:1 p3, 1 cid:2   181   cid:1 p0, 1 cid:2   1  3 p2, 1  3  Figure VII.16. A degree three, rational B´ezier curve. The control points are the same as in the left-hand side of Figure VII.2 on page 156, but now the control point p1 is weighted 3 and the control point p2 is weighted only 1 3. The other two control points have weight 1. In comparison with the curve of Figure VII.2, this curve more closely approaches p1 but does not approach p2 nearly as closely.  coordinates for control points. In R3  say , the control points are speciﬁed as 4-tuples pi =  cid:5 x, y, z, w cid:6 : the curve’s values q u  are expressed as weighted averages of the control points,   cid:27   q u  =  Bk i  u pi ,  i  and so the values of q u  specify the points on the curve in homogeneous coordinates too.  There are several advantages to rational B´ezier curves. These include the following:  a. The use of homogeneous coordinates allows the w-coordinate value to serve a weight factor that can be used to increase or decrease the relative weight of a control point. A higher weight for a control point causes the B´ezier curve to be “pulled” harder by the control point.  b. The use of weights in this form allows rational B´ezier curves to deﬁne circular arcs, ellipses,  hyperbolas, and other conic curves.  c. Rational B´ezier curves are preserved under perspective transformations, not just afﬁne transformations. This is because the points on a B´ezier curve are computed as weighted averages and afﬁne combinations of homogeneous coordinates are preserved under per- spective transformations  see Section IV.4 .  d. Control points can be placed at inﬁnity, giving extra ﬂexibility in the deﬁnition of a B´ezier  curve. To understand a., recall from Section IV.4 the notation  cid:5 wp, w cid:6 , where p ∈ R3 and w  cid:16 = 0, and where  cid:5 wp, w cid:6  is the 4-tuple that is the  unique  homogeneous representation of p, which has w as its fourth component. Then a point q u  on the curve is deﬁned by a weighted average of homogeneous control points, namely i  u  cid:5 wi pi , wi cid:6 . Bk   cid:27   i  The point q u  is also a 4-tuple and thus is a homogeneous representation of a point in R3. By the earlier discussion in Section IV.4, it represents the following point in R3:  q u  =  cid:27    cid:28   i  wi Bk  i  u  w j Bk  j  i  u   pi .  Thus, the w-components of the control points act like extra weighting factors. Figure VII.16 shows an example of how weights can affect a B´ezier curve.   B´ezier Curves  182 p0 =  cid:1 0, 1, 1 cid:2   q u   p1 = 1, 0, 0  p2 = 0, 1, 1 Figure VII.17. The situation of Theorem VII.9. The middle control point is actually a point at inﬁnity, and the dotted lines joining it to the other control points are actually straight and are tangent to the circle at p0 and p2.  We used the representation cid:5 wp, w cid:6  for the homogeneous representation of p, with last com- ponent w. That is, if p =  cid:5  p1, p2, p3 cid:6  ∈ R3, then  cid:5 wp, w cid:6  is the 4-tuple  cid:5 wp1, wp2, wp3, w cid:6 . This notation is a little confusing and user-unfriendly. Accordingly, drawing software or CAD programs usually use a different convention: these programs allow a user to set, independently, a control point p and a weight w, but they hide from the user the fact that the components of p are being multiplied by w. You can refer to Figure VII.19 for an example of this convention, where the control points in R2 are given in terms of their nonhomogeneous representation plus their weight.  VII.13 Conic Sections with Rational B´ezier Curves  A major advantage to using rational B´ezier curves is that they allow the deﬁnition of conic sections as quadratic B´ezier curves. We start with an example that includes a point at inﬁnity.5 Let p0 =  cid:5 0, 1, 1 cid:6 , p1 =  cid:5 1, 0, 0 cid:6 , and p2 =  cid:5 0,−1, 1 cid:6  be homogeneous Theorem VII.9 representations of points in R2. Let q u  be the degree two B´ezier curve deﬁned with these control points. Then, the curve q u  traces out the right half of the unit circle x 2 + y2 = 1 as u varies from 0 to 1.  The situation of Theorem VII.9 is shown in Figure VII.17. Note that the middle control point is actually a point at inﬁnity. However, we will see that the points q u  on the curve are not points at inﬁnity but are always ﬁnite points. To interpret the statement of the theorem properly, note that the points q u  as computed from the three control points are actually homogeneous representations of points in R2. That is, q u  is a triple  cid:5 q1 u , q2 u , q3 u  cid:6  and is the homogeneous representation of the point  cid:5 q1 u  q3 u , q2 u  q3 u  cid:6  in R2. The import of the theorem is that the points q u , when interpreted as homogeneous representations of points in R2, trace out the right half of the unit circle.  We now prove Theorem VII.9. From the deﬁnition of B´ezier curves,  q u  =  1 − u 2p0 + 2u 1 − u p1 + u2p2  =  1 − u 2 cid:5 0, 1, 1 cid:6  + 2u 1 − u  cid:5 1, 0, 0 cid:6  + u2 cid:5 0,−1, 1 cid:6  =  cid:5 2u 1 − u ,  1 − u 2 − u2,  1 − u 2 + u2 cid:6 .  cid:22   It is easy to check that the third component is nonzero for 0 ≤ u ≤ 1. Thus, q u  is the homogeneous representation of the point   cid:21    cid:5 x u , y u  cid:6  =  2u 1 − u   1 − u 2 + u2  ,   1 − u 2 − u2  1 − u 2 + u2  .  5 Most of our examples of constructions of circular arcs by B´ezier curves in this section and by B-spline  curves in Section VIII.11 can be found in the article  Piegl and Tiller, 1989 .   VII.13 Conic Sections with Rational B´ezier Curves  183  p1  T2  p2  T0  p0  Figure VII.18. A portion of a branch of a conic section C is equal to a rational quadratic B´ezier curve. Control points p0 and p2 have weight 1, and p1 gets weight w1 ≥ 0.  We need to show two things. The ﬁrst is that each point q u  lies on the unit circle. This is proved by showing that x u 2 + y u 2 = 1 for all u. For this, it is sufﬁcient to prove that  [2u 1 − u ]2 + [ 1 − u 2 − u2]2 = [ 1 − u 2 + u2]2,  VII.21  which is almost immediate. The second thing to show is that q u  actually traces out the correct portion of the unit circle: for this we need to check that x u  ≥ 0 for all u ∈ [0, 1] and that y u  is decreasing on the same interval [0, 1]. Both these facts can be checked readily, and we leave this to the reader. ✷  Now that we have proved Theorem VII.9, the reader might reasonably ask how we knew to use the control point p1 =  cid:5 1, 0, 0 cid:6  for the middle control point. The answer is that we ﬁrst tried the control point  cid:5 h, 0, 0 cid:6  with h as a to-be-determined constant. We then carried out the construction of the theorem’s proof but used the value h where needed. The resulting analogue of Equation VII.21 then had its ﬁrst term multiplied by h2; from this we noted that equality holds only with h = ±1, and h = +1 was needed to get the right half of the curve.  This construction generalizes to a procedure that can be used to represent any ﬁnite segment of any conic section as a quadratic B´ezier curve. Let C be a portion of a conic section  a line, parabola, circle, ellipse, or hyperbola  in R2. Let p0 and p2 be two points on  one branch of  the conic section. Our goal is to ﬁnd a third control point p1 with appropriate weight w1 so that the quadratic curve with these three control points is equal to the portion of the conic section between p0 and p1  refer to Figure VII.18 .  Let T0 and T2 be the two lines tangent to the conic section at p0 and p2. Let p1 be the point in their intersection  or the appropriate point at inﬁnity if the tangents are parallel, as in Theorem VII.9 . We further assume that the segment of the conic section between p0 and p2 lies in the triangle formed by p0, p1, and p2 – this rules out the case in which the segment is ◦ more than 180  of a circle, for instance.  Theorem VII.10 Let C, p0, p2, T0, T2, and p1 be as above. Let p0 and p2 be given weight 1. Then there is a value w1 ≥ 0 such that when p1 is given weight w1, the rational degree two B´ezier curve q u  with control points p0, p1, and p2 traces out the portion of C between p0 and p2.  Proof This was originally proved by  Lee, 1987 ; we give here only a quick and incomplete sketch of a proof. In the degenerate case in which C is a line, take p1 to be any point between p0 and p2; then any value for w1 ≥ 0 will work. Otherwise, for each h ≥ 0, let qh u  be the B´ezier curve obtained when w1 = h. At h = 0, qh 1 2  lies on the line segment from p0 to p2. As h → ∞, qh 1 2  tends to p1. Thus, there must be a value h > 0 such that qh 1 2  lies on the conic section. By Theorem VII.11 below, the curve qh u  is a conic section. Furthermore,   184  p2 =  cid:1 0, 1 cid:2 ; w2 = 1  √  2 2  p1 =  cid:1 1, 1 cid:2 ; w1 = p0 =  cid:1 1, 0 cid:2 ; w0 = 1  B´ezier Curves  p1 =  cid:1 0, 2 cid:2 ; w1 = 1 2  p2 =  cid:1 −√ w2 = 1  2 cid:2 ; 2 , 1  3  p0 =  cid:1 √ w0 = 1  2 cid:2 ; 2 , 1  3  Figure VII.19. Two ways to deﬁne circular arcs with rational B´ezier curves without control points at inﬁnity.  there is a unique conic section that  a  contains the three points p0, qh 1 2 , and p2 and  b  is tangent to T0 and T2 at p0 and p2. Therefore, with w1 = h, the resulting B´ezier curve must  cid:1  trace out C.  Theorem VII.10 gives the general framework for designing quadratic B´ezier curves that form conic sections. Note that the fact that p1 lies at the intersection of the two tangent lines T0 and T2 is forced by the fact that the initial  respectively, the ﬁnal  derivative of a B´ezier curve points from the ﬁrst  respectively, the second  control point towards the second point  respectively, the third point . It can be shown, using the equivalence of rational B´ezier curves to B´ezier curves with weighting, that this fact holds also for rational B´ezier curves.  The next three exercises give some ways to form circles as quadratic B´ezier curves that do  not require the use of a point at inﬁnity.  √ 2 2,  √ Exercise VII.14 Let q u  be the rational, degree two B´ezier curve with homogeneous 2 2 cid:6  and p2 =  cid:5 0, 1, 1 cid:6 . Prove that 2 2, arc of the unit circle in R2 from the point  cid:5 1, 0 cid:6  to  control points p0 =  cid:5 1, 0, 1 cid:6 , p1 =  cid:5 √ ◦ this B´ezier curve traces out the 90  cid:5 0, 1 cid:6 . See Figure VII.19 where the control points are shown in R2 with their weights. neous control points p0 =  cid:5 √ Exercise VII.15 Let q u  be the rational, degree two B´ezier curve deﬁned with homoge- 3 2, 1 2, 1 cid:6 . 3 2, 1 2 cid:6  to  cid:5 −√  3 2, 1 2, 1 cid:6 , p1 =  cid:5 0, 1, 1 2 cid:6 , and p2 =  cid:5 −√ arc of the unit circle in R2 from cid:5 √  ◦ Prove that this B´ezier curve traces out the 120  3 2, 1 2 cid:6 . See Figure VII.19.   cid:1   Exercise VII.16 Generalize the constructions of the previous two exercises. Suppose that p0 and p2 lie on the unit circle separated by an angle of θ, 0 . Show that the arc from p0 to p2 can be represented by a degree two B´ezier curve, where p0 and p2 are given weight 1, and p1 is given weight w1 = cos θ 2 . Also, give a formula expressing  or, if you prefer, an algorithm to compute  the position of p1 in terms of the positions of p0 and p2.  ◦ < θ < 180  ◦  Sometimes it is desirable to use degree three curves instead of degree two curves for conic sections. There are many ways to deﬁne conic sections with degree three curves: the next exercise suggests that one general method is ﬁrst to form the curve as a degree two conic section and then to elevate the degree to degree three using the method of Section VII.9.  Exercise VII.17 Apply degree elevation to the degree two B´ezier curve of Theorem VII.9  Figure VII.17  to prove that the following degree three B´ezier curve traces out the right half of the unit circle: the degree three curve is deﬁned with control points p0 =  cid:5 0, 1 cid:6 , p1 =  cid:5 2, 1 cid:6 , p2 =  cid:5 2,−1 cid:6  and p3 =  cid:5 0,−1 cid:6 , with p0 and p3 having weight 1 and p1 and p2 having weight 1 3  see Figure VII.20 .   VII.13 Conic Sections with Rational B´ezier Curves p0 =  cid:1 0, 1 cid:2 ; w0 = 1  p1 =  cid:1 2, 1 cid:2 ; w1 = 1 3  p2 =  cid:1 2,−1 cid:2 ; w2 = 1 3  p3 =  cid:1 0,−1 cid:2 ; w3 = 1  185  Figure VII.20. A semicircle as a degree three B´ezier curve. See Exercise VII.17.  The next exercise shows that it is also possible to use negatively weighted control points for rational B´ezier curves. This is more of an oddity than a genuinely useful construction; in particular, the convex hull property is lost when negatively weighted points are allowed  see Theorem IV.9 .  control point is redeﬁned as p1 =  −√  Exercise VII.18 Investigate what happens with negatively weighted control points. For instance, investigate what happens to the B´ezier curve of Exercise VII.14 if the middle 2 2 , that is, is a homogeneous representation of the same point but now in negated form. [Answer: You obtain the other three quarters of the unit circle.]  2 2,−√  2 2,−√  Theorem VII.10 shows that ﬁnite portions of conic sections can be represented by quadratic B´ezier curves. Its proof depended on the next theorem, which asserts that conic sections are the only curves that can be represented by quadratic B´ezier curves. Theorem VII.11 Let q u  =  cid:5 x u , y u , w u  cid:6  be a rational quadratic curve in R2. Then there is a conic section such that every point of q u  lies on the conic section. Proof Recall that a conic section is deﬁned as the set of points  cid:5 x, y cid:6  ∈ R2 that satisfy  Ax 2 + Bx y + C y2 + Dx + E y + F = 0  for some constants A, B, C, D, E , F not all zero. If we represent points with homogeneous coordinates  cid:5 x, y, w cid:6 , then this condition is equivalent to Ax 2 + Bx y + C y2 + Dxw + E yw + F w2 = 0.  VII.22  Namely, a conic section is the set of points whose homogeneous representations satisfy equa- tion VII.22. Claim Let x = x u , y = y u , and w = w u  be parametric functions of u. Let M be a trans- formation of R2 deﬁned by an invertible 3 × 3 matrix that acts on homogeneous coordinates. Then, in R2, the curve M q u   lies on a conic section if and only if q u  lies on a conic section.  To prove the claim, let xM , yM , and wM be the functions of u deﬁned so that   cid:5 xM , yM , wM cid:6  = M cid:5 x, y, w cid:6 .  Suppose that, for all u,  + BxM yM + C y2  M  + DxM wM + E yM wM + F w2  = 0  M  Ax 2 M  VII.23  with not all the coefﬁcients zero  i.e., M q  lies on a conic section . Since each of xM , yM , and wM is a linear combination of x, y, and w, Equation VII.23 can be rewritten in the form   186  B´ezier Curves  of Equation VII.22 but with different values for the coefﬁcients. Since M is invertible, this process can be reversed; therefore, the coefﬁcients of Equation VII.22 for x, y, w are not all zero. Consequently, we have shown that if M q  lies on a conic section, then so does q. Since M is invertible, the converse implication holds as well and the claim is proved.  We return to the proof of Theorem VII.11 and note that since q u  is quadratic, it is equal to a B´ezier curve  see Exercise VII.8 on page 168 . Let p0, p1, and p2 be the homogeneous control points of this B´ezier curve. If these three control points represent points in R2 that are collinear, then the curve q u  lies in the line containing the control points and therefore on a  degenerate  conic section. Otherwise, since a line in R2 corresponds to a two-dimensional linear subspace of homogeneous x yw-space, the three points p0, p1, and p2 are linearly in- dependent in homogeneous space  see Section II.2.5 . Therefore, there is an invertible linear transformation M of homogeneous space, that is, a nonsingular 3 × 3 matrix M, that sends the three points p0, p1, and p2 to the three control points  cid:5 0, 1, 1 cid:6 ,  cid:5 1, 0, 0 cid:6 , and  cid:5 0,−1, 1 cid:6  of Theorem VII.9. That is, the projective transformation M maps the curve q u  to a circle. Therefore, M q  lies on a conic section, and thus, by the claim q u  lies on a conic section.  cid:1  The next two exercises show that we cannot avoid the use of homogeneous coordinates  when representing conic sections.  Exercise VII.19 Prove that there is no nonrational degree two B´ezier curve that traces out a nontrivial part of a circle. [Hint: A quadratic curve consists of segments of the form  cid:5 x u , y u  cid:6  with x u  and y u  degree two polynomials. To have only points on the unit circle, they must satisfy  x u  2 +  y u  2 = 1.] Exercise VII.20 Prove that there is no nonrational B´ezier curve of any degree that traces out a nontrivial part of a circle.  Lest one get the overly optimistic impression that rational B´ezier curves are universally good for everything, we end this section with one last exercise showing a limitation on what curves can be deﬁned with  piecewise  B´ezier curves.  Exercise VII.21  Requires advanced math.  Consider the helix spiraling around the z-axis, which is parametrically deﬁned by q u  =  cid:5 cos u , sin u , u cid:6 . Prove that there is no rational B´ezier curve that traces out a nontrivial portion of this spiral. [Hint: Suppose there is a rational curve q u  =  cid:5 x u , y u , z u , w u  cid:6  that traces out a nontrivial portion of the helix. Then we must have   cid:12    cid:1    cid:11   = cos  x u  w u   z u  w u   on some interval. But this is impossible because the lefthand side is a rational function and the righthand side is not.]  Another way to think about how to prove the exercise, at least for the quadratic case, is to note that if a nontrivial part of the helix is a B´ezier curve, then its projection onto the xz-plane is a rational quadratic curve. But this projection is the graph of the function x = cos z , which contradicts Theorem VII.11 because the graph of cos z  is not composed of portions of conic sections.   Farouki and Sakkalis, 1991  gave another approach to Exercise VII.21. They proved that there is no rational polynomial curve q u , of any degree, that gives a parametric deﬁnition of any curve other than a straight line such that q u  traverses the curve at a uniform speed with respect to the parameter u. In other words, it is not possible to parameterize any curve other than a straight line segment by rational functions of its arclength. For the special case of the circle, this means that there is no way to parameterize circular motion with a B´ezier curve   VII.14 Surface of Revolution Example  187  that traverses the circle at a uniform speed. For the circle, the impossibility of a B´ezier curve’s traversing a circle at uniform speed is equivalent to Exercise VII.21 because a B´ezier curve tracing out the spiral could be reinterpreted with the z-value as time.  When we deﬁne B-splines in the next chapter, we will see that B-spline curves are equivalent to piecewise B´ezier curves  in Section VIII.9 . Therefore, the impossibility results of Exercises VII.19–VII.21 and of Farouki and Sakkalis also apply to B-spline curves.  VII.14 Surface of Revolution Example  This section presents an example of how to form a surface of revolution using rational B´ezier patches with control points at inﬁnity.  Our point of departure is Theorem VII.9, which showed how to form a semicircle with a single quadratic B´ezier curve. We will extend this construction to form a surface of revolution using B´ezier patches with quadratic cross sections. First, however, it useful to examine semi- circles more closely; in particular, we want to understand how to translate, rotate, and scale circles. Refer back to the semicircle shown in Figure VII.17 on page 182. That semicircle is centered at the origin. Suppose we want to translate the semicircle to be centered, for example, at  cid:5 4, 2 cid:6 . We want to express the translated semicircle as a rational quadratic B´ezier curve. Let p0, p1, and p2 be the control points shown in Figure VII.17. The question is, What are the control ∗ points p i for the translated circle? Obviously, the ﬁrst and last control points should now be =  cid:5 4, 3, 1 cid:6  and p2 =  cid:5 4, 1, 1 cid:6 , as obtained by direct translation. But what is the point p ∗ ∗ p 1 0 at inﬁnity? Here, it does not make sense to translate the point at inﬁnity; instead, the correct = p1 =  cid:5 1, 0, 0 cid:6 . Intuitively, the reason for this is as follows: We chose ∗ control point is p 1 the point p1 to be the point at inﬁnity corresponding to the intersection of the two horizontal projective lines tangent to the circle at the top and bottom points  see Theorem VII.10 . When the circle is translated, the tangent lines remain horizontal, and so they still contain the same point at inﬁnity. To be more systematic about translating the semicircle, we can work with the 3 × 3 homo-  geneous matrix that performs the translation, namely, the matrix   .  1 0 4  0 1 2 0 0 1  M =  It is easy to check that  ∗ p 0  = Mp0,  ∗ p 1  = Mp1,  and  ∗ p 2  = Mp2.  This proves the correctness of the control points for the translated semicircle.  Exercise VII.22 Consider the effect of rotating the semicircle from Figure VII.17 through a counterclockwise angle of 45 around the origin. Prove that the result is the same as the quadratic rational B´ezier curve with control points , 0 cid:6 ,  =  cid:5 − √  =  cid:5  √  =  cid:5  √  ,− √  , 1 cid:6 ,  , 1 cid:6 .  √  √  ◦  ,  ,  ∗ and p 2  ∗ p 0  2 2  2 2  2 2  2 2  2 2  2 2  [Hint: The rotation is performed by the homogeneous matrix  ∗ p 0  √  2 √ 2 2 2 0  .  0  0 1  − √ √  2 2 2 2 0   188   cid:1  3 2 , 1  2 , 0 cid:2    cid:1 2, 1, 0 cid:2   −   cid:1 2, 1, 0 cid:2    cid:1 3, 0, 0 cid:2   B´ezier Curves  Figure VII.21.  a  A silhouette of a surface of revolution  the control points are in x, y, z-coordinates .  b  The front half of the surface of revolution. This example is implemented in the SimpleNurbs progam.   b   Exercise VII.23 Consider the effect of scaling the semicircle from Figure VII.17 by a factor of r so that it has radius r. Prove that the result is the same as the quadratic rational B´ezier curve with control points  =  cid:5 0, r, 1 cid:6 ,  ∗ p 0  =  cid:5 r, 0, 0 cid:6 ,  ∗ and p 2  =  cid:5 0,−r, 1 cid:6 .  [Hint: The scaling is performed by the homogeneous matrix   a   ∗ 0  p  r  0 0  .  0 0 1  0 r 0  We now give an example of how to form a surface of revolution. Figure VII.21 shows an example of a surface of revolution. The silhouette of the surface is deﬁned by a cubic  nonrational  B´ezier curve; the silhouette is deﬁned as a curve in the x y-plane, and the surface ◦ is formed by revolving around the y-axis. We will show how to deﬁne a 180 arc of the surface with a single B´ezier patch using control points at inﬁnity. The entire surface can be formed with two such patches.  Section VII.10.1 discussed how the control points of a B´ezier patch deﬁne the patch; most notably, each cross section is itself a B´ezier curve and the control points of the cross sections are deﬁned by B´ezier curves. Considering the vertical cross sections  i.e., the cross sections that go up and down with the axis of revolution , we can see clearly that the control points of each vertical cross section must be obtained by revolving the control points shown in part  a  of Figure VII.21. Now these revolved control points can therefore be deﬁned with B´ezier curves that trace out semicircles.  These considerations let us deﬁne 180  of the surface of revolution shown in Figure VII.21 b  as a single rational B´ezier patch that has order 4 in one direction and order 3 in the other direction. The control points for the patch are as follows:  ◦   cid:5 −2,−1, 0, 1 cid:6   cid:5 −3, 0, 0, 1 cid:6   cid:5 − 3 , 0, 1 cid:6   cid:5 −2, 1, 0, 1 cid:6   , 1 2  2   cid:5 0, 0, 2, 0 cid:6   cid:5 0, 0, 3, 0 cid:6   cid:5 0, 0, 3 , 0 cid:6   cid:5 0, 0, 2, 0 cid:6   2   cid:5 2,−1, 0, 1 cid:6   cid:5 3, 0, 0, 1 cid:6   cid:5  3 , 0, 1 cid:6  , 1 2  cid:5 2, 1, 0, 1 cid:6 .  2  Each of the four rows of the table holds three control points that deﬁne a semicircular curve in R3. Taking vertical cross sections of the four semicircles gives the four control points for the corresponding vertical cross section of the surface of revolution.   VII.15 Interpolating with B´ezier Curves  189  VII.15 Interpolating with B´ezier Curves  Frequently, one wishes to deﬁne a smooth curve that interpolates  i.e., passes through, or contains  a given set of points. For example, suppose we are given a set of points that deﬁne the positions of some object at different times; if we then ﬁnd a smooth curve that interpolates these points, we can use the curve to deﬁne  or estimate  the positions of the object at intermediate times.  The scenario is as follows. We are given a set of interpolation points p0, . . . , pm and a set of “knot values” u0, . . . , um. The problem is to deﬁne a piecewise  degree three  polynomial curve q u , so that q ui   = pi for all i. There are several ways to deﬁne the interpolating curves as piecewise B´ezier curves. The general idea is to deﬁne a series of B´ezier curves connecting pairs of successive interpolation points. For each appropriate value of i, there will be a B´ezier curve that starts at pi and ends at pi+1. Putting these curves together forms the entire curve. This automatically makes a piecewise B´ezier curve that interpolates the points pi of course, but more work is needed to make the curve smooth at the points pi . For this, we need to use the methods of Section VII.4 to make the curve C 1-continuous.  We describe three ways to deﬁne interpolating piecewise B´ezier curves. The ﬁrst is the Catmull–Rom splines, and the second is a generalization of Catmull–Rom splines called Overhauser splines. Catmull–Rom splines are used primarily when the points pi are more or less evenly spaced and with ui = i. The Overhauser splines allow the use of more general values for ui as well as chord-length parameterization to give better results when the distances between successive points pi vary considerably. A more general variation on these splines is the tension–continuity–bias interpolation methods, which allow a user to vary parameters to obtain a desirable curve.  VII.15.1 Catmull–Rom Splines Catmull–Rom splines are speciﬁed by a list of m + 1 interpolation points p0, . . . , pm and are piecewise degree three polynomial curves of the type described in Section VII.4 that interpolate all the points except the endpoints p0 and pm. For Catmull–Rom splines, ui = i, and so we want q i  = pi for 1 ≤ i < m. The Catmull–Rom spline will consist of m − 2 B´ezier curves with the ith B´ezier curve beginning at point pi and ending at point pi+1. Catmull–Rom splines are deﬁned by making an estimate for the ﬁrst derivative of the curve passing through pi . These ﬁrst derivatives are used to deﬁne additional control points for the B´ezier curves. Figure VII.22 illustrates the deﬁnition of a Catmull–Rom spline segment. Let  li = 1 2   pi+1 − pi−1   and deﬁne  + p i  = pi + 1 3  li  and  − p i  = pi − 1 3  li .  − i+1 , p  Then let qi  u  be the B´ezier curve – translated to have domain i ≤ u ≤ i + 1 – deﬁned with + , pi+1. Deﬁne the entire Catmull–Rom spline q u  by piecing to- control points pi , p gether these curves so that q u  = qi  u  for i ≤ u ≤ i + 1. i Since B´ezier curves interpolate their ﬁrst and last control points, the curve q is continuous and q i  = pi for all integers i such that 1 ≤ i ≤ m − 1. In addition, q has continuous ﬁrst derivatives with   cid:3  q   i  = li =  pi+1 − pi−1  2.   B´ezier Curves  p+ i  p− i+1 pi+1  p+  i+1  2li+1  2li  pi+2  190  pi  p−  i  pi−1  Figure VII.22. Deﬁning the Catmull–Rom spline segment from the point pi to the point pi+1. The points i are collinear and parallel to pi+1 − pi−1. The points pi , p + − + − i+1, and pi+1 form the control p i , p i , pi , and p points of a degree three B´ezier curve, which is shown as a dotted curve.  It follows that q u  is C 1-continuous. This formula for the ﬁrst derivatives, q  i , also explains the motivating idea behind the deﬁnition of Catmull–Rom splines. Namely, since q i − 1  = pi−1 and q i + 1  = pi+1, the average rate of change of q u  between u = i − 1 and u = i + 1 must equal  pi+1 − pi−1  2. Thus, the extra control points, p − + i and p i , are chosen so as to  cid:3  make q   i  equal to this average rate of change.  Figure VII.23 shows two examples of Catmull–Rom splines.   cid:3   VII.15.2 Bessel–Overhauser Splines  The second curve in Figure VII.23 b  shows that bad effects can result when the interpolated points are not more or less equally spaced; bad “overshoot” can occur when two close control points are next to widely separated control points. One way to solve this problem is to use chord-length parameterization. For chord-length parameterization, the knots ui are chosen so that ui+1 − ui is equal to pi+1 − pi. The idea is that the arclength of the curve between  p1  p2  p0  p3  p4  p5  p6  p7  p0  p1  p5  p4  p3  p2  Figure VII.23. Two examples of Catmull–Rom splines with uniformly spaced knots.   VII.15 Interpolating with B´ezier Curves  191  pi and pi+1 will be approximately proportional to the distance from pi to pi+1 and therefore approximately proportional to ui+1 − ui . If one views the parameter u as time, then, as u varies, the curve q u  will be traversed at roughly a constant rate of speed.6  Of course, to use chord-length parameterization, we need to modify the formalization of Catmull–Rom splines to allow for nonuniform knot positions: in particular, it is necessary to − + ﬁnd an alternative deﬁnition of the extra control points p i and p i . More generally, to handle arbitrary nonuniform knot positions, we use a method called the Bessel tangent method or the Overhauser method  Overhauser, 1968 . Assume that we are given knot positions  not necessarily obtained from a chord-length parameterization  and that all knot positions are distinct with ui < ui+1. Deﬁne  = pi+1 − pi ui+1 − ui  .  vi+ 1  2  The idea is that vi+ 1 is the average velocity at which the interpolating spline is traversed from pi to pi+1. Of course, if we have deﬁned the knot positions using a chord-length interpolation, then the velocities vi+ 1  will be unit vectors. Then we deﬁne a further velocity  2  2  vi =  ui+1 − ui  vi− 1  +  ui − ui−1 vi+ 1  2  ,  2  ui+1 − ui−1  which is a weighted average of the two velocities of the curve segments just before and just after the interpolated point pi . The weighted average is deﬁned so that the velocities vi± 1 are weighted more heavily when the elapsed time, ui±1 − ui, between being at the control point pi±1 and being at the control point pi is less. Finally, deﬁne  2  − p i + p i  = pi − 1 = pi + 1  3  ui − ui−1 vi 3  ui+1 − ui  vi .  These points are then used to deﬁne B´ezier curves in exactly the manner used for the uniform − i+1, and pi+1 and is Catmull–Rom curves. The ith segment, qi  u , has control points pi , p linearly transformed to be deﬁned for u in the interval [ui , ui+1]. The entire piecewise B´ezier curve q u  is deﬁned by patching these curves together, with q u  = qi  u  for ui ≤ u ≤ ui+1. Two examples of chord-length parameterization combined with the Overhauser method are shown in Figure VII.24. These interpolate the same points as the Catmull–Rom splines in Figure VII.23 but give a smoother and nicer curve – especially in the second example in the ﬁgures. Another example is given in Figure VII.25.  + i , p  Exercise VII.24 Let p0 = p1 =  cid:5 0, 0 cid:6 , p2 =  cid:5 10, 0 cid:6  and p3 = p4 =  cid:5 10, 1 cid:6 . Also, let u0 = 0, u1 = 1, u2 = 2, u3 = 2.1 and u4 = 3.1. Find the control points for the corre- sponding Overhauser spline, q u , with q ui   = pi for i = 1, 2, 3. Verify that your curve corresponds to the curve shown in Figure VII.25.  Second, draw the Catmull–Rom curve deﬁned by these same interpolation points. Qual-  itatively compare the Catmull–Rom curve with the Overhauser spline.  Exercise VII.25 Investigate the chord-length parameterization Overhauser method curve from p0 to p2 when p0, p1, p2 are collinear. What is the velocity at p1? Consider separately the cases in which p1 is, and is not, between p0 and p2.  6 Another common choice for knot parameterization is the centripetal parameterization where ui+1 − ui √pi+1 − pi. This presumably has an effect intermediate between uniform knot  is set equal to spacing and chord-length parameterization.   B´ezier Curves  192  p1  p2  p0  p3  p4  p5  p6  p7  p0  p1  p5  p4  p3  p2  Figure VII.24. Two examples of Overhauser spline curves. The knot positions were set by chord-length parameterization. These are deﬁned from exactly the same control points as the Catmull–Rom curves in Figure VII.23.  Exercise VII.26 It should be clear that the Overhauser method gives G1-continuous curves. Prove that, in fact, the Overhauser method gives C 1-continuous curves. [Hint:  ui   = vi . You will need to take into account the fact that qi  u  has domain  cid:3  Prove that q [ui , ui+1].]  There is another nice characterization of the Overhauser method in terms of blending two quadratic polynomials that provides a second justiﬁcation for its appropriateness. Deﬁne fi  u  to be the  unique  quadratic polynomial such that fi  ui−1  = pi−1, fi  ui   = pi , and fi  ui+1  = pi+1. Similarly deﬁne fi+1 u  to be the quadratic polynomial with the values pi , pi+1, pi+2 at u = ui , ui+1, ui+2. Then deﬁne  qi  u  =  ui+1 − u fi  u  +  u − ui  fi+1 u   VII.24 Clearly qi  u  is a cubic polynomial and, further, for ui ≤ u ≤ ui+1, qi  u  is equal to the curve qi  u  obtained with the Overhauser method.  ui+1 − ui  .   cid:1   Exercise VII.27 verify that qi  u  has the correct values and derivatives at its endpoints ui and ui+1.]  Prove the last assertion about the Overhauser method. [Suggestion:  y  p0 = p1  p3 = p4  p2  x  Figure VII.25. The Overhauser spline that is the solution to Exercise VII.24.   VII.15 Interpolating with B´ezier Curves  193  Exercise VII.28 Write a program that takes a series of positions speciﬁed with mouse clicks and draws a Catmull–Rom curve, Bessel–Overhauser spline, or both so that the curve interpolates them. Make the curves also interpolate the ﬁrst and last point by doubling the ﬁrst and last points  i.e., treat the ﬁrst and last points as if they occur twice . The supplied program ConnectDots can be used as a starting point; it accepts mouse clicks and joins the points with straight line segments.  VII.15.3 Tension–Continuity–Bias Splines  There are a variety of modiﬁed versions of Catmull–Rom interpolation schemes. Many of these are tools that let a curve designer specify a broader range of shapes for curves. For instance, someone may want to design a curve that is “tighter” at some points and “looser” at other points. One widely used method is the TCB  tension–continuity–bias  method of  Kochanek and Bartels, 1984 , which uses the three parameters of tension, continuity, and − bias that affect the values of the tangents and thereby the extra control points p i . The parameter of tension is used to control the tightness of curve, the continuity parameter controls the  dis continuity of ﬁrst derivatives, and the bias controls how the curve overshoots or undershoots an interpolation point. − The TCB method is a reﬁnement of Catmull–Rom splines that adjusts the control points p + i and p i according to the three new parameters. To describe how the TCB method works, we ﬁrst reformulate the Catmull–Rom method slightly by introducing notations for the left and right ﬁrst derivatives of the curve at an interpolation point pi as follows:  + i and p  = 3 pi − p  − i  ,  = 3 p + i  − pi  .  − Dq i  + Dq i  = lim u→u = lim u→u  − i  + i  q ui   − q u   ui − u  q u  − q ui    u − ui + i and Dq + 3 Dq i  If we set values for Dq  − i , then this determines p = pi − 1 and The basic Catmull–Rom splines can be deﬁned by setting  = pi + 1  − p i  + p i  + i and p − 3 Dq i  .  − i by  2  ,  vi− 1  vi+ 1  − Dq i  + 1 2  = 1 2  = Dq + VII.25 i = pi − pi−1. The TCB splines work by modifying Equation VII.25 but leaving the  where vi− 1 rest of the deﬁnition of the splines unchanged. The tension parameter, denoted t, adjusts the tightness or looseness of the curve. The default value is t = 0; positive values should be less than 1 and make the curve tighter, and negative values make the curve looser. Mathematically, this has the effect of setting  2  2   cid:11    cid:12   − Dq i  = Dq + i  =  1 − t   1 2  vi− 1  2  + 1 2  vi+ 1  2  ,  that is, of multiplying the derivative by  1 − t . Positive values of t make the derivative smaller: this has the effect of making the curve’s segments between points pi straighter and making the velocity of the curve closer to zero at the points pi . Negative values of t make the curve looser and can cause it to take bigger swings around interpolation points. The effect of setting tension to 1 2 and to −1 2 is shown in Figure VII.26.   194  p0  t = 1 2  t = −1 2  p6  B´ezier Curves  p1  t = 0  p5  Figure VII.26. The effects of the tension parameter.  The continuity parameter is denoted c. If c = 0, then the curve is C 1-continuous; otherwise, the curve has a corner at the control point pi and thus a discontinuous ﬁrst derivative. The mathematical effect of the continuity parameter is to set  = 1 − c = 1 + c  2  − Dq i  + Dq i  vi− 1  2  2  vi− 1  2  + 1 + c + 1 − c  2  2  vi+ 1  2  vi+ 1  2  .  Typically, −1 ≤ c ≤ 0, and values c < 0 have the effect of turning the slope of the curve towards the straight line segments joining the interpolation points. Setting c = −1 would make the curve’s left and right ﬁrst derivatives at pi match the slopes of the line segments joining pi to pi−1 and pi+1. The effect of c = −1 2 and c = −1 is shown in Figure VII.27. The effect of c = −1 2 in this ﬁgure looks very similar to the effect of tension t = 1 2 in Figure VII.26; however, the effects are not as similar as they look. With t = 1 2, the curve still has a continuous ﬁrst derivative, and the velocity of a particle following the curve with u measuring time will be slower near the point where t = 1 2. On the other hand, with c = −1 2, the curve has a “corner” where the ﬁrst derivative is discontinuous, but there is no slowdown of velocity in the vicinity of the corner.  The bias parameter b weights the two average velocities vi− 1  either undershoot or overshoot. The mathematical effect is  and vi+ 1  2  2  differently to cause  − Dq i  = Dq + i  = 1 + b  2  vi− 1  2  + 1 − b  2  vi+ 1  2  .  The curve will have more tendency to overshoot pi if b > 0 and to undershoot it if b < 0. The effect of bias b = 1 2 and bias b = −1 2 is shown in Figure VII.28.  The tension, continuity, and bias parameters can be set independently to individual interpo- lation points or uniformly applied to an entire curve. This allows the curve designer to modify the curve either locally or globally. The effects of the three parameters can be applied together.  p0  c = −1 2  c = −1  p6  p1  c = 0  p5  Figure VII.27. The effects of the continuity parameter.   VII.16 Interpolating with B´ezier Surfaces  195  p0  b = 1 2  b = −1 2  p6  p1  b = 0  p5  Figure VII.28. The effects of the bias parameter.  This results in the following composite formula, which replaces Equation VII.25:  =  1 − t  1 − c  1 + b  =  1 − t  1 + c  1 + b   2  − Dq i  + Dq i  vi− 1  2  vi− 1  2  +  1 − t  1 + c  1 − b  +  1 − t  1 − c  1 − b   2  vi+ 1  2  vi+ 1  2  .  2  2   cid:1   Exercise VII.29 Catmull–Rom splines.  Extend the TCB parameters to apply to Overhauser splines instead of  VII.16 Interpolating with B´ezier Surfaces   cid:1   The previous sections have discussed methods of interpolating points with a series of B´ezier curves that connects the interpolated points together with a smooth curve. The analogous problem for surfaces is to interpolate a two-dimensional mesh of control points with a smooth surface formed from B´ezier patches. For this, suppose we are given control points pi, j for i = 0, . . . , m and j = 0, . . . , n and we want to ﬁnd a smooth surface q u, v  so that q i, j  = pi, j for all appropriate i and j. To formulate the problem a little more generally, let I and J be ﬁnite sets of real numbers,  I = {u0, u1, . . . , um}  and  J = {v0, v1, . . . , vn},  where ui < ui+1 and v j < v j+1 for all i, j. For 0 ≤ i ≤ m and 0 ≤ j ≤ n, let pi, j be a point in R3. Then, we are seeking a smooth surface q u, v  so that q ui , v j   = pi, j for all 0 < i < m and 0 < j < n.  We deﬁne the surface q u, v  as a collection of B´ezier patches analogous to the Catmull– Rom and Bessel–Overhauser splines deﬁned with multiple B´ezier curves that interpolate a sequence of points. The corners of the B´ezier patches comprising q u, v  will meet at the interpolation points pi, j , and the B´ezier patches will form a mesh of rectangular patches. One big advantage of this method is that the B´ezier patches are deﬁned locally, that is, each B´ezier patch depends only on nearby interpolation points. We discuss primarily the case in which the interpolation positions ui and v j are equally spaced with ui = i and v j = j, but we will also discuss how to generalize to the non-equally- spaced case. We deﬁne degree three B´ezier patches Qi, j  u, v  with domains the rectangles [ui , ui+1] × [v j , v j+1]. The complete surface q u, v  will be formed as the union of these patches Qi, j . Of course, we will need to be sure that the patches have the right continuity and C 1-continuity prop- erties. The control points for the B´ezier patch Qi, j will be 16 points, pα,β, where α ∈ {i, i + 1 , i + 2 , j + 1}. Of course, this means that the patch Qi, j will interpolate the points pi, j , pi+1, j , pi, j+1, and pi+1, j+1, which is exactly what we want. It remains to deﬁne the other 12 control points of the patch.  , i + 1}, and β ∈ { j, j + 1  , j + 2  3  3  3  3   196  B´ezier Curves  3  As the ﬁrst step towards deﬁning the other 12 control points for each patch, we deﬁne the control points that lie on the boundary, that is, the control points pα,β, where either α or β is an integer. Fix, for the moment, the value of j and the value of v as v = v j . Consider the cross section of the surface q u, v  for this value of v, namely, the curve q j  u  = q u, v j  . This cross section is piecewise degree three B´ezier curves deﬁned with control points pα, j . It also interpolates the point pi, j at α = ui . Thus, it seems natural to deﬁne the other control points pi± 1 , j , for all values of i, using the Catmull–Rom or Bessel–Overhauser method.  Recall that the Catmull–Rom and Bessel–Overhauser methods are identical in the equally spaced case. The Bessel–Overhauser method should be used in the non-equally-spaced case.  The control points pi± 1 , j are chosen so that the curve q j smoothly interpolates the points pi, j for this ﬁxed 3 value of j. Dually, if i is held ﬁxed and u = ui , the cross-sectional curves of q ui , v  are likewise piecewise degree three B´ezier curves. Thus, the control points pi,β can be deﬁned using the Catmull–Rom or Bessel–Overhauser method to obtain a curve that interpolates the points pi, j for a ﬁxed value of i.  3  3  3  3  3  3  3  3  3  , j+ 2  , j+ 1  , j+ 1  , j+ 2  , pi+ 1  , pi+ 2  , and pi+ 2  It now remains to pick the four interior control points for each patch Qi, j , namely, the control points pi+ 1 . As we will see, these four control points can be determined by choosing appropriate twist vectors. To simplify the details of how to set these control points, we now make the assumption that the interpolation positions ui and v j are equally spaced: in fact, we assume that ui = i and v j = j for all i and j.  The patches Qi, j and Qi−1, j share a common border. In order to have C 1-continuity between the two patches, it is necessary that the partial derivatives match up along the boundary. As was discussed in Section VII.10.2, to match up partial derivatives, it is necessary and sufﬁcient to ensure that  pi,β − pi− 1  pα, j − pα, j− 1  for each β ∈ { j, j + 1 must have  ,β − pi,β VII.26 , j + 1}. Likewise, in joining up patches Qi, j and Qi, j−1, we − pα, j ,  ,β = pi+ 1 , j + 2 = pα, j+ 1 VII.27 , i + 1}. Equations VII.26 and VII.27 were derived for a particular for α ∈ {i, i + 1 patch Qi, j , but since all the patches must join up smoothly these equations actually hold for all values of i and j. We deﬁne the twist vector τ i, j by + pi, j  . Then, by Equation VII.26, with β = j and β = j + 1 , j  .  τ i, j = 9 pi, j+ 1  τ i, j = 9 pi+ 1  − pi, j + pi− 1  − pi, j+ 1  3 , we obtain  − pi+ 1  − pi− 1  , i + 2  , j+ 1  , j+ 1  , j  3  3  3  3  3  3  3  3  3  3  3  By similar reasoning, with Equation VII.27 for α equal to i + 1  3  3  3  3  3 , i and i − 1  3 , we have also  τ i, j = 9 pi+ 1 τ i, j = 9 pi, j − pi− 1  − pi, j − pi+ 1 − pi, j− 1  + pi, j− 1 , j− 1  , j− 1 + pi− 1  , j  , j  3  3  3  3  3  3  3      .  3  pi+ 1  , j+ 1  pi− 1  , j+ 1  3  3  = 1 9 = − 1 9  τ i, j + pi, j+ 1 τ i, j + pi, j+ 1  + pi+ 1 + pi− 1  , j  3  3  3  − pi, j − pi, j  , j  3  3  3  Rewriting these four equations, we get formulas for the inner control points:  VII.28   VII.16 Interpolating with B´ezier Surfaces + pi+ 1 + pi− 1  τ i, j + pi, j− 1 = − 1 9 τ i, j + pi, j− 1  pi+ 1  pi− 1  , j− 1  , j− 1  , j  3  3  3  3  3  3  3  3  = 1 9  , j  − pi, j − pi, j .  197  Thus, once the twist vectors τ i, j have been ﬁxed, the remaining control points for the B´ezier patches are completely determined.  The twist vector has a simple geometric meaning as the second-order partial derivatives of the B´ezier surfaces; namely, by equations VII.18 and VII.19 on page 175 and by the deﬁnition of the twist vector,  ∂ 2 Qi, j ∂u∂v   ui , v j   = τ i, j .  Thus, the twist vector τ i, j is just the second-order mixed partial derivative at the corners of the patches that meet at  cid:5 ui , v j cid:6 .  To ﬁnish specifying all the control points, it only remains to set the value of the twist vector. The simplest method is just to set the twist vectors τ i, j all equal to zero. This yields the so-called Ferguson patches since it is equivalent to a construction from  Ferguson, 1964 . The disadvantage of just setting the twist vector to zero is that it tends to make the surface q u, v  too ﬂat around the interpolation points. For specular surfaces in particular, this can make artifacts on the surface, known as “ﬂats,” where the surface is noticeably ﬂattened around interpolation points. It is better to set the twist vector by estimating the second-order mixed partial derivative of q u, v  at an interpolation point  cid:5 ui , v j cid:6 . Here we are still making the assumption that interpolation positions are equally spaced, that is, that ui = i and v j = j. Then, a standard estimate for the partial derivative is  ∂ 2q ∂u∂v   i, j  = 1 4 = 1 4   q i + 1, j + 1  − q i − 1, j + 1  − q i + 1, j − 1  + q i − 1, j − 1    pi+1, j+1 − pi−1, j+1 − pi+1, j−1 + pi−1, j−1 .  VII.29  Using this value as the value of τ can give a better quality interpolating surface.  The estimate of Equation VII.29 is not entirely ad hoc: indeed, it can be justiﬁed as a generalization of the Bessel–Overhauser curve method. For surface interpolation, we refer to it as just the Bessel twist method, and the idea is as follows. Let fi, j  u, v  be the degree two polynomial  “degree two” means degree two in each of u and v separately  that interpolates the nine control points pα,β for α ∈ {ui−1, ui , ui+1} and β ∈ {v j−1, v j , v j+1}; thus, fi, j  α, β  = pα,β for these nine values of α and β. Then deﬁne the patch Qi, j by blending four of these functions, namely,  Qi, j  u, v   =  u − ui   v − v j   +  ui+1 − u  v − v j     cid:15 ui  cid:15 v j  fi+1, j+1 u, v  +  u − ui   v j+1 − v    cid:15 ui  cid:15 v j  fi, j+1 u, v  +  ui+1 − u  v j+1 − v   fi+1, j  u, v    cid:15 ui  cid:15 v j  VII.30 where  cid:15 ui = ui+1 − ui and  cid:15 v j = v j+1 − v j . Note that this way of deﬁning Qi, j is a direct generalization of the Bessel–Overhauser method of Equation VII.24. The patch Qi, j deﬁned by Equation VII.30 is obviously a bicubic patch  i.e., is degree three in each of u and v separately .  fi, j  u, v ,   cid:15 ui  cid:15 v j   198  B´ezier Curves  As a bicubic patch it can be expressed as a degree three B´ezier patch. In view of Exercise VII.27, the corners and boundary control points of Qi, j deﬁned by Equation VII.30 are equal to the control points deﬁned using the ﬁrst method. We claim also that the four interior control points of the patch Qi, j as deﬁned by Equation VII.30 are the same as the control points calculated by using Equation VII.29 with the twist vector estimate of Equation VII.29. To prove this for the case of equally spaced interpolation positions, we can evaluate the mixed partial derivatives of the right-hand side of Equation VII.30 and use the fact that the four functions fi+1, j+1, fi, j+1, fi+1, j and fi, j are equal at  cid:5 ui , v j cid:6 , that  ∂ fi, j  ∂u  ui , v j   =  ∂ fi, j+1 ∂u  ui , v j  , and that  ∂ fi, j  ∂v  ui , v j   =  ∂ fi+1, j  ∂v  ui , v j  . We ﬁnd that  ∂ 2 Qi, j ∂u∂v   ui , v j   = ∂ 2 fi, j ∂u∂v   ui , v j  .  This holds even in the case of non-equally-spaced interpolation positions. We leave the details of the calculations to the reader.  Finally, we claim that  ui , v j   = 1 4  ∂ 2 fi, j ∂u∂v   pi+1, j+1 − pi−1, j+1 − pi+1, j−1 + pi−1, j−1   VII.31  when the interpolation positions are equally spaced. This is straightforward to check, and we leave its veriﬁcation to the reader, too. With this, the Bessel method is seen to be equivalent to using the last formula of Equation VII.29 to calculate the twist vector.  We now generalize to the case of non-equally-spaced interpolation positions. We have already described how to set the corner and boundary control points of each patch Qi, j . We still let the twist vector τ i, j be the mixed partial derivative at cid:5 ui , v j cid:6 . Now the Equations VII.28 become  VII.32  pi+ 1  , j+ 1  3  3  3  3  pi− 1  , j+ 1  pi+ 1  , j− 1  pi− 1  , j− 1  3  3  3  3  =  cid:15 ui  cid:15 v j τ i, j 9 = − cid:15 ui−1 cid:15 v j = − cid:15 ui  cid:15 v j−1 =  cid:15 ui−1 cid:15 v j−1  3  + pi, j+ 1 τ i, j 9 τ i, j 9 τ i, j 9  + pi, j+ 1 + pi, j− 1 + pi, j− 1  3  3  3  + pi+ 1  , j  3  − pi, j  , j  , j  3  + pi− 1 + pi+ 1 + pi− 1  3  , j  3  − pi, j − pi, j − pi, j .  In addition, Equation VII.31 is no longer correct: instead, we let  Ti, j = pi+1, j+1 − pi+1, j − pi, j+1 + pi, j ,  and then we have   ui , v j    ∂ 2 fi, j ∂u∂v =  cid:15 ui  cid:15 v j Ti−1, j−1 +  cid:15 ui  cid:15 v j−1Ti−1, j +  cid:15 ui−1 cid:15 v j Ti, j−1 +  cid:15 ui−1 cid:15 v j−1Ti, j =  cid:15 ui  cid:15 v j Ti−1, j−1 +  cid:15 ui  cid:15 v j−1Ti−1, j +  cid:15 ui−1 cid:15 v j Ti, j−1 +  cid:15 ui−1 cid:15 v j−1Ti, j    cid:15 ui +  cid:15 ui−1   cid:15 v j +  cid:15 v j−1   .   ui+1 − ui−1  v j+1 − v j−1   Thus, for non-equally-spaced interpolation points, we recommend setting the twist vector τ i, j equal to this last equation and setting the control points with Equations VII.32.   VII.16 Interpolating with B´ezier Surfaces  199  There are several other ways of computing twist vectors: see  Farin, 1997  and the references  cited therein.  Further Reading: The preceding discussion has been limited to surfaces formed by regular patterns of retangular patches. Not all surfaces can be conveniently approximated by rectangular patches, however; in fact, some cannot be approximated by a single array of rectangular patches at all. One alternative is to work with triangular patches; for example, the books  Farin, 1997  and  Hoschek and Lasser, 1993  discuss B´ezier patches deﬁned on triangles. More generally, it is desirable to be able to model surfaces containing an arbitrary topology of triangles, rectangles, and other polygons. Extensive work has been conducted on subdivision surfaces for the purpose of modeling surfaces with a wide range of topologies. Subdivision surfaces are beyond the scope of this book, but for an introduction you can consult the Siggraph course notes  Schr¨oder, Zorin, et al., 1998  or the book  Warren and Weimer, 2002 .   VIII  B-Splines  This chapter covers uniform and nonuniform B-splines, including rational B-splines  NURBS . B-splines are widely used in computer-aided design and manufacturing and are supported by OpenGL. B-splines are a powerful tool for generating curves with many control points and provide many advantages over B´ezier curves – especially because a long, complicated curve can be speciﬁed as a single B-spline. Furthermore, a curve designer has much ﬂexibility in adjusting the curvature of a B-spline curve, and B-splines can be designed with sharp bends and even “corners.” In addition, it is possible to translate piecewise B´ezier curves into B-splines and vice versa. B-splines do not usually interpolate their control points, but it is possible to deﬁne interpolating B-splines. Our presentation of B-splines is based on the Cox– de Boor deﬁnition of blending functions, but the blossoming approach to B-splines is also presented.  The reader is warned that this chapter is a mix of introductory topics and more advanced, specialized topics. You should read at least the ﬁrst parts of Chapter VII before this chapter. Sections VIII.1–VIII.4 give a basic introduction to B-splines. The next four sections cover the de Boor algorithm, blossoming, smoothness properties, and knot insertion; these sections are fairly mathematical and should be read in order. If you wish, you may skip these math- ematical sections at ﬁrst, for the remainder of the chapter can be read largely independently. Section VIII.9 discusses how to convert a piecewise B´ezier curves into a B-spline. The very short Section VIII.10 discusses degree elevation. Section VIII.11 covers rational B-splines. Section VIII.12 very brieﬂy describes using B-splines in OpenGL. Section VIII.13 gives a method for interpolating points with B-splines. You should feel free to skip most of the proofs if you ﬁnd them confusing; most of the proofs, especially the more difﬁcult ones, are not needed for the practical use of splines.  Splines – especially interpolating splines – have a long history, and we do not try to describe it here. B-spline functions were deﬁned by  Shoenberg, 1946; Curry and Shoenberg, 1947 . The name “B-spline,” with the “B” standing for “basis,” was coined by  Shoenberg, 1967 . The terminology “basis spline” refers to the practice of deﬁning B-splines in terms of “basis functions.”  We use the term “blending function” instead of “basis function.”  B-splines be- came popular after de Boor  de Boor, 1972 , Cox  Cox, 1972 , and Mansﬁeld discovered the fundamental Cox–de Boor formula for recursively deﬁning the blending functions.  Figure VIII.1 shows one of the simplest possible examples of how B-spline curves can be used. There are nine control points, p0, . . . , p8, that completely deﬁne the B-spline curves. The curve shown in part  a  is a uniform degree two B-spline curve; the curve in part  b  is  200   VIII.1 Uniform B-Splines of Degree Three  201  p1  p2  p5  p7  p0  p0  p3  p4  p6  p8   a  Degree two B-spline curve.  p1  p2  p5  p7  p3  p4  p6  p8   b  Degree three B-spline curve.  Figure VIII.1. Degree two and degree three B-spline curves with uniformly spaced knots and nine control points. The degree three curve is smoother than the degree two curve, whereas, the degree two curve approaches the control points a little more closely. Compare with the degree eight B´ezier curve of Figure VII.9 c  on page 167.  a uniform degree three curve.  The mathematical deﬁnitions of these curves are in Sections VIII.1 and VIII.2.  Qualitatively, the curves are “pulled towards” the control points in much the same way that a B´ezier curve is pulled towards its interior control points. Unlike B´ezier curves, B-spline curves do not necessarily interpolate their ﬁrst and last control points; rather, the degree two curve starts and ends midway between two control points, and the degree three curve starts and ends near the control points adjacent to the starting and ending points. However, there are ways of deﬁning B-spline curves that ensure that the ﬁrst and last control points are interpolated.  A big advantage of B-spline curves over B´ezier curves is that they act more ﬂexibly and intu- itively with a large number of control points. Indeed, if you compare the curves of Figure VIII.1 with the degree eight B´ezier curve of Figure VII.9 c  on page 167, you will see that the B-spline curves are pulled more deﬁnitely by the control points. The B´ezier curve seems to be barely affected by the placement of individual control points, whereas the B-spline curves are clearly affected directly by the control points. This makes B-spline curves much more useful for designing curves.  We will ﬁrst treat the case of uniform B-splines and then the more general case of nonuniform  B-splines.  VIII.1 Uniform B-Splines of Degree Three  Before presenting the general deﬁnition of B-splines in Section VIII.2, we ﬁrst introduce one of the simplest and most useful cases of B-splines, namely, the uniform B-splines of degree three. Such a B-spline is deﬁned with a sequence p0, p1, p2, . . . , pn of control points. Together with a set of blending  or basis  functions N0 u , N1 u , . . . , Nn u , this parametrically deﬁnes a curve q u  by  q u  = n cid:27   i=0  Ni  u  · pi  3 ≤ u ≤ n + 1.   202  p1  p0  p5  p6  p2  q3  q4  p3  q6  q5  p4  B-Splines  Figure VIII.2. A degree three uniform B-spline curve with seven control points.  We deﬁne these blending functions later in this section, but for the moment, just think of the blending functions Ni as having an effect analogous to the Bernstein polynomials Bi used in the deﬁnition of B´ezier curves. An important property of the uniform degree three blending functions Ni is that Ni  u  will equal zero if either u ≤ i or i + 4 ≤ u. That is, the support of Ni  u  is the open interval  i, i + 4 . In particular, this means that we can rewrite the formula for q u  as  q u  =  Ni  u  · pi  provided u ∈ [ j, j + 1], 3 ≤ j ≤ n  VIII.1  j cid:27   i= j−3  since the terms omitted from the summation are all zero. This means that the B-spline has local control; namely, if a single control point pi is moved, then only the portion of the curve q u  with i < u < i + 4 is changed, and the rest of the B-spline remains ﬁxed. Local control is an important feature enhancing the usefulness of B-spline curves: it allows a designer or artist to edit one portion of a curve without causing changes to distant parts of the curve. In contrast, B´ezier curves of higher degree do not have local control, for each control point affects the entire curve. Figure VIII.2 shows an example of a degree three B-spline curve q u  deﬁned with seven control points and deﬁned for 3 ≤ u ≤ 7. The curve q is split into four subcurves q3, . . . , q6, where q3 is the portion of q u  corresponding to 3 ≤ u ≤ 4, q4 is the portion with 4 ≤ u ≤ 5, and so on. More generally, qi  u  = q u  for i ≤ u ≤ i + 1. The intuition of how the curve q u  behaves is as follows. The beginning point of q3, where u = 3, is being pulled strongly towards the point p1 and less strongly towards the points p0 and p2. The other points on q3 are calculated as weighted averages of p0, p1, p2, p3. The other segments are similar; namely, the beginning of qi is being pulled strongly towards pi−2, the end of qi is being pulled strongly towards pi−1, and the points interior to qi are computed as weighted averages of the four control points pi−3, pi−2, pi−1, pi . Finally, the segments qi  u  are degree three polynomial curves; thus, q u  is piecewise a degree three polynomial curve. Furthermore, q u  has continuous second derivatives everywhere it is deﬁned. These properties of the curve q u  all depend on properties of the blending functions Ni  u .1 Figure VIII.3 shows the graphs of the functions Ni  u . At u = 3, we have N1 3  > N0 3  = N2 3  > 0, and Ni  3  = 0 for all other values of i. In fact, we will see that N1 3  = 2 3 and N0 3  = N2 3  = 1 6. Therefore, q 3  is equal to the weighted average  p0 + 4p1 + p2  6, which is consistent with what we earlier observed in Figure VIII.2 about the beginning point of the curve q3. The other assertions we made about the curves q3, . . . , q6 can likewise be seen to follow from the properties of the blending functions Ni  u . Note that Equation VIII.1 is borne out by the behavior of the blending functions in Figure VIII.3. Similarly, it is also clear that a control point pi affects only the four segments qi , qi+1, qi+2, qi+3.  1 When we develop the theory of B-splines of arbitrary degree, these blending functions Ni  u  will be denoted Ni,4 u . Another mathematical derivation of these blending functions is given in the ﬁrst example of Section VIII.3.   VIII.1 Uniform B-Splines of Degree Three  203  y  1  0  N0  N1  N2  N3  N4  N5  N6  1  2  3  4  5  6  7  8  9  10  u  Figure VIII.3. The blending functions for a uniform, degree three B-spline. Each function Ni has sup- port  i, i + 4 .  The blending functions should have the following properties:   a  The blending functions are translates of each other, that is,  Ni  u  = N0 u − i .   b  The functions Ni  u  are piecewise degree three polynomials. The breaks between the pieces  occur only at integer values of u.  i  Ni  u  = 1   c  The functions Ni  u  have continuous second derivatives, that is, they are C 2-continuous.  d  The blending functions are a partition of unity, that is,   cid:27  for 3 ≤ u ≤ 7.  Or, for 3 ≤ u ≤ n + 1 when there are n + 1 control points p0, . . . , pn.  This property is necessary for points on the B-spline curve to be deﬁned as weighted averages of the control points.   e  Ni  u  ≥ 0 for all u. Therefore, Ni  u  ≤ 1 for all u.  f   Ni  u  = 0 for u ≤ i and for i + 4 ≤ u. This property of the blending functions gives the  B-spline curves their local control properties.  Because of conditions  a  and  f , the blending functions will be fully speciﬁed once we deﬁne the function N0 u  on the domain [0, 4]. For this purpose, we will deﬁne four functions R0 u , R1 u , R2 u , R3 u  for 0 ≤ u ≤ 1 by  R0 u  = N0 u  R1 u  = N0 u + 1   R2 u  = N0 u + 2  R3 u  = N0 u + 3 .  Thus, the functions Ri  u  are the translates of the four segments of N0 u  to the interval [0, 1] and, to ﬁnish the deﬁnition of N0 u  it sufﬁces to deﬁne the four functions Ri  u . These four functions are degree three polynomials by condition  b . In fact, we claim that the following choices for the Ri functions work  and this is the unique way to deﬁne these functions to satisfy the six conditions  a – f  :  R0 u  = 1 6 u3 6  −3u3 + 3u2 + 3u + 1  R1 u  = 1 6  3u3 − 6u2 + 4  R2 u  = 1 R3 u  = 1 6  1 − u 3.   cid:28  It takes a little work to verify that conditions  a – f  hold when N0 u  is deﬁned from these i Ri  u  = 1; thus,  d  holds. choices for R0, . . . , R3. Straightforward calculation shows that Also, it can be checked that Ri  u  ≥ 0 for i = 0, 1, 2, 3 and all u ∈ [0, 1]; hence  e  holds. For  c  to hold, N0 u  needs to have continuous second derivative. Of course, this also means N0 u  is continuous and has continuous ﬁrst derivative. These facts are proved by noticing that   204  B-Splines  when the Ri functions are pieced together, their values and their ﬁrst and second derivatives match up. That is,  6  R0 0 =0 R0 1 = 1 R1 1 = 2 R2 1 = 1 R3 1 =0  6  3  =R1 0  =R2 0  =R3 0   2  0 0 = 0  cid:3  =R 0 1 = 1  cid:3  1 1 = 0 =R  cid:3  =R 2 1 =−1  cid:3  3 1 = 0  cid:3   2  R R R R R   cid:3  1 0   cid:3  2 0   cid:3  3 0   0  0 = 0  cid:3  cid:3  0  1 = 1 =R  cid:3  cid:3  1  1 =−2=R  cid:3  cid:3  2  1 = 1 =R  cid:3  cid:3  3  1 = 0  cid:3  cid:3   R R R R R   cid:3  cid:3  1  0   cid:3  cid:3  2  0   cid:3  cid:3  3  0   Exercise VIII.1 Graph the four functions Ri on the interval [0, 1]. [Hint: These are portions of the blending functions shown in Figure VIII.3.]  Exercise VIII.2 Give formulas for the ﬁrst and second derivatives of the Ri functions. Verify the 15 conditions needed for the C 2-continuity of the blending function N0 u .   cid:28  i Ri  u  = 1. Prove that Ri  u  > 0 for i = 0, 1, 2, 3 and for Exercise VIII.3 Verify that all u ∈  0, 1 . Exercise VIII.4 Verify that R0 u  = R3 1 − u  and that R1 u  = R2 1 − u . Show that this means that uniform B-splines have left–right symmetry in that, if the order of the control points is reversed, the curve q is unchanged except for being traversed in the opposite direction.  Exercise VIII.5 Describe the effect of repeating control points in degree three uniform B-splines. Qualitatively describe the curve obtained if one control point is repeated – for instance, if p3 = p4. Secondly, suppose p2  cid:16 = p3 = p4 = p5  cid:16 = p6. Show that the curve q interpolates the point p3 with q 6  = p3. Further show that the segments q5 and q6 are straight lines.  VIII.2 Nonuniform B-Splines  The degree three uniform B-spline of the previous section were deﬁned so that the curve q u  was “pulled” by the control points in such way that q i  is close to  or at least, strongly affected by  the control point pi−2. These splines are called “uniform” since the values ui where the curve q u  is most strongly affected by control points are evenly spaced at integer values ui = i. These values ui are called knots. A nonuniform spline is one for which the knots ui are not necessarily uniformly spaced. The ability to space knots nonuniformly makes it possible to deﬁne a wider range of curves, including curves with sharp bends or discontinuous derivatives. The uniform B-splines are just the special case of nonuniform B-splines where ui = i.  We deﬁne a knot vector to be a sequence  [u0, u1, . . . , u cid:11 −1, u cid:11 ]  of real numbers u0 ≤ u1 ≤ u2 ≤ ··· ≤ u cid:11 −1 ≤ u cid:11  called knots. A knot vector is used with a sequence of n + 1 control points p0, p1, . . . , pn to deﬁne a nonuniform B-spline curve.  When deﬁning an order m B-spline curve, that is, a curve of degree k = m − 1, we have n =  cid:11  − m.  You should think of the spline curve as being a ﬂexible and stretchable curve: its ﬂexibility is limited and thus it resists being sharply bent. The curve is parameterized by the variable u, and we can think of u as measuring the time spent traversing the length of the curve. The control points “pull” on parts of the curve; you should think of there being a stretchable string, or   VIII.2 Nonuniform B-Splines  205  1  Doubled knot  Tripled knot  N8,4  N0,4 N1,4  N2,4 N3,4 N4,4 N5,4 N6,4 N7,4  N9,4 N10,4 N11,4  0  1  2  3  4  5  6  7  8  9  10  11  12  Figure VIII.4. Example of order four  degree three  blending functions with repeated knots. The knot vector is [0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 8, 8, 9, 10, 11, 12] so that the knot 4 has multiplicity two and the knot 8 has multiplicity three.  u  rubber band, attached to a point on the curve and tied also to the control point pi . These pull on the spline, and the spline settles down into a smooth curve. Now, you might expect that the “rubber bands” tie the control point pi to the point on the curve where u = ui . This, however, is not correct. Instead, when deﬁning a B-spline curve of order m, you should think of the control point pi as being tied to the curve at the position u = ui+m 2. If m is odd, we need to interpret the position ui+m 2 as lying somewhere between the two knots ui+ m−1  2 and ui+ m+1  2. This corresponds to what we observed in the case of uniformly spaced knots deﬁning a degree three curve, where m = 4: the curve q u  is most strongly inﬂuenced by the control point pi at the position with u = ui+2. It is possible for knots to be repeated multiple times. If a knot position has multiplicity two, that is, if it occurs twice with ui−1 < ui = ui+1 < ui+2, then the curve will be affected more strongly by the corresponding control point. The curve will also lose some continu- ity properties for its derivatives. For instance, if q u  is a degree three curve with a knot ui = ui+1 of multiplicity two, then q u  will generally no longer have continuous second derivatives at ui , although it will still have a continuous ﬁrst derivative at ui . Further, if q u  has a knot of multiplicity three, with ui−1 < ui = ui+1 = ui+2 < ui+3, then q u  will interpolate the point pi−1 and will generally have a “corner” at pi−1 and thus not be C 1- or G1-continuous. However, unlike the situation in Exercise VIII.5, the adjacent portions of the B- spline curve will not be straight line segments. These behaviors are exhibited in Figures VIII.4 and VIII.5.  If a knot position occurs four times  in a degree three curve , then the curve can actually become discontinuous! Knots that repeat four times are usually used only at the beginning or end of the knot vector and thus do not cause a discontinuity in the curve.  Next, we give the Cox–de Boor mathematical deﬁnition of nonuniform B-spline blending functions. So far, all of our examples have been degree three splines, but it is now convenient to generalize to splines of degree k = m − 1, which are also called order m splines. Assume the knot vector u0 ≤ u1 ≤ ··· ≤ u cid:11  has been ﬁxed. The blending functions Ni,m u  for order m splines depend only on the knot positions, not on the control points, and are deﬁned by induction  p1  p3  p5  p7  p9  p11  p2  p0 Figure VIII.5. Example of an order four B-spline created with repeated knots. This curve is created with the knot vector and blending functions shown in Figure VIII.4. It has domain [3, 9].  p10  p8  p4  p6   206 on m ≥ 1 as follows. First, for i = 0, . . . ,  cid:11  − 1, let  Ni,1 u  =  if ui ≤ u < ui+1 otherwise.   cid:1   1 0  B-Splines  There is one minor exception to the preceding deﬁnition, which is to include the very last point u = u cid:11  in the domain of the last nonzero function: namely, if ui−1 < ui = u cid:11 , then we let Ni−1,1 u  = 1 when ui−1 ≤ u ≤ ui . In this way, the theorems stated below hold also for u = u cid:11 . Second, for m ≥ 1, letting m = k + 1, Ni,k+1 u  is deﬁned by the Cox–de Boor formula:  Ni,k+1 u  = u − ui ui+k − ui  Ni,k u  + ui+k+1 − u ui+k+1 − ui+1  Ni+1,k u   The Cox–de Boor formula  When there are repeated knots, some of the denominators above may be zero: we adopt the convention that 0 0 = 0 and  a 0 0 = 0. Since Ni,k u  will be identically zero when ui+k = ui  see the next paragraph , this means that any term with denominator equal to zero may be ignored. The form of the Cox–de Boor recursive formulas for the blending functions immediately implies that the functions Ni,m u  are piecewise degree m − 1 polynomials and that the breaks between pieces occur at the knots ui . Secondly, it is easy to prove, by induction on m ≥ 1, that the function Ni,m u  has support in [ui , ui+m]  i.e., Ni,m u  = 0 for u < ui and for ui+m < u . From similar considerations, it is easy to see that the deﬁnition of the blending function Ni,m u  depends only on the knots ui , ui+1, . . . , ui+m.  VIII.3 Examples of Nonuniform B-Splines  To gain a qualitative understanding of how nonuniform B-splines work, it is helpful to do some simple examples.  Example: Uniformly Spaced Knots We start with what is perhaps the simplest example, namely, the case in which the knots are uniformly spaced with the knot vector equal to just [0, 1, 2, 3, . . . ,  cid:11 ]. That is, the knots are ui = i. Of course, we expect this case to give the same degree three results as the uniform B-splines discussed in Section VIII.1 with the functions Ni,4 u  equal to the functions Ni  u  of that section. To deﬁne the blending functions, Ni,m u , we start with the order m = 1 case, that is, the degree k = 0 case. For this we have merely the step functions, for i = 0, . . . ,  cid:11  − 1,   cid:1   Ni,1 u  =  1 if i ≤ u < i + 1 0 otherwise.  These functions are piecewise degree zero  i.e., piecewise constant ; of course, they are dis- continuous at the knot positions ui = i. the fact that ui = i, we deﬁne these from the Cox–de Boor formula as  Next, we compute the order two  piecewise degree one  blending functions Ni,2 u . Using  Ni,2 u  = u − i  Ni,1 u  + i + 2 − u  Ni+1,1 u ,  1  1   1  0  VIII.3 Examples of Nonuniform B-Splines  207  y  N0,2 N1,2 N2,2 N3,2 N4,2 N5,2 N6,2 N7,2 N8,2  1  2  3  4  5  6  7  8  9  10  u  Figure VIII.6. The order two  piecewise degree one  blending functions with uniformly spaced knots, ui = i. Here  cid:11  = 10, and there are  cid:11  + 1 knots and  cid:11  − 1 blending functions. The associated B-spline curve of Equation VIII.2 is deﬁned for 1 ≤ u ≤  cid:11  − 1. for i = 0, . . . ,  cid:11  − 2. Specializing to the case i = 0, we have  and from the deﬁnitions of N0,1 u  and N1,1 u , this means that  N0,2 u  = u N0,1 u  +  2 − u N1,1 u ,   u  2 − u 0  if 0 ≤ u < 1 if 1 ≤ u < 2 otherwise.  N0,2 u  =  Because the knots are uniformly spaced, similar calculations apply to the rest of the order two blending functions Ni,2 u , and these are all just translates of N0,2 u  with Ni,2 u  = N0,2 u − i . The order two blending functions are graphed in Figure VIII.6. linear. Since clearly Ni,2 u  ≥ 0 and “curve” q u  as   cid:28  Note that the order two blending functions are continuous  C 0-continuous  and piecewise i Ni,2 u  = 1 for all u ∈ [1,  cid:11  − 1], we can deﬁne a  Ni,2 u pi ,  1 ≤ u ≤  cid:11  − 1,  VIII.2  q u  =  cid:11 −2 cid:27   i=0  with control points p0, . . . , p cid:11 −2. By inspection, this “curve” consists of straight line segments connecting the control points p0, . . . , p cid:11 −2 in a “connect-the-dots” fashion with q ui+1  = pi for i = 0, . . . ,  cid:11  − 2. the Cox–de Boor formula with m = 3 or k = 2,  Next, we compute the order three  piecewise degree two  blending functions, Ni,3 u . From  Ni,3 u  = u − i  Ni,2 u  + i + 3 − u  Ni+1,2 u .  2  These are deﬁned for i = 0, . . . ,  cid:11  − 3. As before, we specialize to the case i = 0 and have  N0,3 u  = 1  2 u N0,2 u  + 1  2  3 − u N1,2 u .  Considering separately the cases 0 ≤ u < 1 and 1 ≤ u < 2 and 2 ≤ u < 3, we have if 0 ≤ u < 1 if 1 ≤ u < 2 if 2 ≤ u < 3 otherwise.  1 2 u2 2 u 2 − u  + 1 1 2  3 − u 2  2  3 − u  u − 1  = 1  2  6u − 2u2 − 3   N0,3 u  =  0  1  2    It is straightforward to check that N0,3 u  has a continuous ﬁrst derivative. In addition, direct calculation shows that N0,3 u  ≥ 0 for all u. Because the knots are uniformly spaced, the rest  cid:28  cid:11 −3 of the order three blending functions, Ni,3 u , are just translates of N0,3 u , with Ni,3 u  = N0,3 u − i : these functions are shown in Figure VIII.7. It is also straightforward to check i=0 Ni,3 u  = 1 for 2 ≤ u ≤  cid:11  − 2. Also note that the function Ni,3 u  is maximized at that u = i + 3 2, where it takes on the value 3 4. A degree two B-spline curve can be deﬁned with   208  y  1  0  N0,3 N1,3 N2,3 N3,3 N4,3 N5,3 N6,3 N7,3  1  2  3  4  5  6  7  8  9  10  u  Figure VIII.7. The order three  piecewise degree two  blending functions with uniform knot positions ui = i. We still have  cid:11  = 10; there are  cid:11  + 1 knots and  cid:11  − 2 blending functions. The associated B-spline curve of Equation VIII.3 is deﬁned for 2 ≤ u ≤  cid:11  − 2.  these blending functions as  q u  =  cid:11 −3 cid:27   i=0  Ni,3 u pi ,  2 ≤ u ≤  cid:11  − 2.  B-Splines  VIII.3  By using the Cox–de Boor formula again, we could deﬁne the order four  piecewise degree three  blending functions Ni,4 u . We do not carry out this computation; however, the results obtained would be identical to the blending functions Ni  u  used in Section VIII.1 and shown in Figure VIII.3. We leave it as an exercise for the reader to verify this fact.  Example: B´ezier Curve as B-Spline For our second example, we let the knot vector be [0, 0, 0, 0, 1, 1, 1, 1] and compute the order 1, 2, 3, and 4 blending functions for this knot vector. Here we have ui = 0 for i = 0, 1, 2, 3 and ui = 1 for i = 4, 5, 6, 7. The order one blending functions are just   cid:1   N3,1 u  =  1 if 0 ≤ u ≤ 1 0 otherwise  and Ni,1 u  = 0 for i  cid:16 = 3. The order two blending functions Ni,2 u  are zero except for i = 2, 3. Also, for every order m ≥ 1, every blending function will be zero for u   1. Both these facts use the conventions for the Cox–de Boor equations that 0 0 = 0 and  a 0  · 0.  The reader should verify all our assertions!  For i = 2, 3 and 0 ≤ u ≤ 1, the Cox–de Boor equations with k = 1 give  N2,2 u  = u − u2 u3 − u2 = u − 0 0 − 0 N3,2 u  = u − u3 u4 − u3 = u − 0 1 − 0  · N2,1 u  + u4 − u u4 − u3 · 0 + 1 − u · 1 = 1 − u 1 − 0 · N3,1 u  + u5 − u u5 − u4 · 1 + 1 − u · 0 = u. 1 − 1  · N3,1 u   · N4,1 u   The order three blending functions are zero except for i = 1, 2, 3, and N1,3 u , N2,3 u , and N3,3 u  are zero outside the domain [0, 1]. Calculations from the Cox–de Boor equations, similar to the preceding, give, for 0 ≤ u ≤ 1,  VIII.4  N1,3 u  =  1 − u 2 N2,3 u  = 2u 1 − u  N3,3 u  = u2.   VIII.3 Examples of Nonuniform B-Splines  209 The order four  piecewise degree three  blending functions Ni,4 u  are nonzero for i = 0, 1, 2, 3 and have support contained in [0, 1]. Further calculations from the Cox–de Boor equations give  N0,4 u  =  1 − u 3 N1,4 u  = 3u 1 − u 2 N2,4 u  = 3u2 1 − u  N3,4 u  = u3  for 0 ≤ u ≤ 1. Surprisingly, these four blending functions are equal to the Bernstein polyno- i  u  = Ni,4 u . Therefore, the B-spline curve deﬁned with the mials of degree three, namely, B3 four control points p0, p1, p2, p3 and knot vector [0, 0, 0, 0, 1, 1, 1, 1] is exactly the same as the degree three B´ezier curve with the same control points.  Some generalizations of this example are given later in the ﬁrst half of Section VIII.9, where it is shown how to represent multiple B´ezier curves as a single B-spline curve: see Theorem VIII.12 on page 226.  Example: Nonuniformly Spaced and Repeated Knots Consider the nonuniform knot vector  [0, 0, 0, 0, 1, 2, 2 4 5  , 3 1 5  , 4, 5, 6, 7, 7, 8, 9, 10, 10, 10, 10].  This was obtained by starting with knots at integer values 0 through 10, quadrupling the ﬁrst and last knots, doubling the knots at u = 3 and u = 7, and then separating the knots at 3 slightly to be at 2 4  5 . As usual, for i = 0, . . . , 18, ui denotes the ith knot as shown:  5 and 3 1  i: ui :  0  0  1  0  2  0  3  0  4  1  5  2  6 2 4 5  7 3 1 5  8  4  9  5  10  6  11  7  12  7  13  8  14  9  15  10  16  10  17  10  18  10  The degree zero blending functions Ni,1 u  are deﬁned for 0 ≤ i ≤ 17. These are the step functions deﬁned to have value 1 on the half-open interval [ui , ui+1  and value zero elsewhere. For values i such that ui = ui+1, this means that Ni,1 u  is equal to zero for all u. This happens for i equal to 0, 1, 2, 11, 15, 16, 17. The degree one blending functions are Ni,2 u , for 0 ≤ i ≤ 16, and are shown in Figure VIII.8. When ui , ui+1, and ui+2 are distinct, then the graph of the function Ni,2 u  rises linearly from zero at ui to 1 at ui+1 and then decreases linearly back to zero at ui+2. It is zero outside the interval  ui , ui+2 . On the other hand, when ui = ui+1  cid:16 = ui+2, then Ni,2 is discontinuous at ui : it jumps from the value zero for u < ui to the value 1 at ui . It then decreases  cid:16 = ui+1 = ui+2. In Figure VIII.8, linearly back to zero at ui+2. The situation is dual when ui N10,2 and N11,2 are both discontinuous at u = 7. If ui = ui+2, as happens for i = 0, 1, 15, 16, then Ni,2 u  is equal to the constant zero everywhere. The degree two blending functions are Ni,3 u , for 0 ≤ i ≤ 15, and are shown in part  b  of Figure VIII.8. The functions Ni,3 u  have support in the interval [ui , ui+3]. More than this is  cid:16 = ui+1, then Ni,3 ui   = 0, and similarly, if ui+2  cid:16 = ui+3, then Ni,3 ui+3  = 0. Even true: if ui further, if ui = ui+1  cid:16 = ui+2, then Ni,3 ui   = 0: this happens when i = 2, 11. However, in this case, Ni,3 u  has discontinuous ﬁrst derivative at ui . The symmetric case of ui+1  cid:16 = ui+2 = ui+3 can be seen with i = 9 and i = 13. When there is a knot of multiplicity≥ 3 and ui = ui+2  cid:16 = ui+3, then we have Ni,3 ui   = 1: in  cid:16 = ui+1 = ui+3, as happens with u = 14, our example, this happens for i = 1. Dually, when ui   210  N2,2  1  Doubled knot  N10,2N11,2  N3,2 N4,2N5,2 N6,2 N7,2 N8,2 N9,2  N12,2 N13,2 N14,2  B-Splines  1  2  2.8 3.2  4  5  6  7  8  9   a  Degree one blending functions.  Doubled knot  N1,3  1  N2,3 N3,3 N4,3  N5,3 N6,3 N7,3 N8,3 N9,3  N11,3 N12,3 N13,3  N10,3  N14,3  1  2  2.8 3.2  4  5  6  7  8  9   b  Degree two blending functions.  Doubled knot  N0,4  1  N1,4N2,4 N3,4  N4,4 N5,4 N6,4 N7,4 N8,4  N9,4N10,4  N11,4N12,4  N14,4  N13,4  u  10  u  10  u  10  1  2  2.8 3.2  4  5  6  7  8  9   c  Degree three blending functions.  Figure VIII.8. Degree one, two, and three blending functions for a nonuniform knot sequence. The knot 7 has multiplicity two, and the knots 0 and 10 have multiplicity 4.  then Ni,3 ui+2  = 1. For i = 0, 15, Ni,3 u  is just the constant zero everywhere. At the doubled knot u11 = u12 = 7, the blending function N10,3 u  is continuous and equal to 1 but has a discontinuous ﬁrst derivative. A degree two B-spline curve formed with this knot vector will interpolate p10 at u = 7 but will, in general, have a corner there. The degree three blending functions, Ni,4 u , are shown in part  c  of Figure VIII.8. They are deﬁned for 0 ≤ i ≤ 14 and have support in the interval [ui , ui+4]. Where a knot has multiplicity ≥ 4, say if ui = ui+3  cid:16 = ui+4, then the right limit limu→u Ni,4 u  is equal to 1. Likewise, if  cid:16 = ui+1 = ui+4, then the left limit limu→u Ni,4 u  equals1. In this example, these situations ui happen only at the endpoints of the curve. The degree three blending functions are C 2-continuous everywhere except at the doubled knot position u = 7, where N8,4 u , N9,4 u , N10,4 u , and N11,4 u  are only C 1-continuous.  − i+1  + i  The next two exercises ask you to work out some details of the standard knot vectors for  degree two and degree three. For general degree k, the standard knot vectors have the form  [0, 0, . . . , 0, 1, 2, 3, . . . , s − 2, s − 1, s, s, . . . , s],   VIII.4 Properties of Nonuniform B-Splines  211  1  N0,3  N1,3  N2,3  N3,3  N4,3  N5,3  u  1  2  3  4  Figure VIII.9. The degree two blending functions, Ni,3 u , for the knot vector of Exercise VIII.6. where the knots 0 and s have multiplicity k + 1 and the rest of the knots have multiplicity 1. For these knot vectors, the B-spline curve will interpolate the ﬁrst and last control points: the exercises ask you to verify this for some particular examples. In Section VIII.13, we will work again with the standard knot vector for degree three B-spline curves to interpolate a set of control points.  Exercise VIII.6 Derive the formulas for the quadratic  order three, degree two  B-spline blending functions for the knot vector [0, 0, 0, 1, 2, 3, 4, 4, 4]. How many control points are needed for a quadratic B-spline curve with this knot vector? What is the domain of the B-spline curve? Show that the curve begins at the ﬁrst control point and ends at the last control point. Check your formulas for the blending functions against Figure VIII.9.  Exercise VIII.7 Repeat the previous exercise, but with cubic B-spline curves with the knot vector [0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 6, 6]. The graph of the blending functions for this curve is shown in Figure VIII.10.  If you actually do this exercise, you might wish to use a computer algebra program to derive the formulas to avoid excessive hand calculation.   VIII.4 Properties of Nonuniform B-Splines  We now introduce some of the basic properties of the B-spline blending functions. Theorem VIII.1 describes the domain of deﬁnition for B-spline blending functions and shows they can be used to form weighted averages. Theorem VIII.2 explains the continuity properties of derivatives of B-splines.  Throughout this section, we use m to denote the order of the blending functions, that is,  m is 1 plus the degree k of the blending functions. Theorem VIII.1 Let u0 ≤ u1 ≤ ··· ≤ u cid:11  be a knot vector. Then the blending functions Ni,m u , for 0 ≤ i ≤  cid:11  − m, satisfy the following properties.  a  Ni,m has support in [ui , ui+m] for all m ≥ 1.  b  Ni,m u  ≥ 0 for all u.  c    cid:28  cid:11 −m i=0 Ni,m u  = 1 for all u such that um−1 ≤ u ≤ u cid:11 −m+1.  N0,4  1  N1,4 N2,4  N3,4  N4,4  N5,4  N6,4 N7,4  N8,4  u  1  2  3  4  5  6  Figure VIII.10. The degree three blending functions, Ni,4 u , for the knot vector [0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 6, 6] of Exercise VIII.7.   212  B-Splines  It can become very confusing to keep track of all the precise values for subscripts and their  ranges. Referring to Figures VIII.3, VIII.6, and VIII.7 can help with this.  Proof As discussed earlier, conditions  a  and  b  are readily proved by induction on m. Condition  c  is also proved by induction on m by the following argument. The base case, with m = 1, is obviously true. For the induction step, we assume condition  c  holds and then prove it with m + 1 in place of m. Assume um ≤ u ≤ u cid:11 −m. By the Cox–de Boor formula,  Ni,m+1 u   i=0   cid:11    cid:11 −m−1 cid:27  =  cid:11 −m−1 cid:27  = u − u0 um − u0  i=0  = N0,m u  +  cid:11 −m−1 cid:27  =  cid:11 −m cid:27   i=1 Ni,m u  = 1.  i=0   cid:12   u − ui ui+m − ui  Ni,m u  + ui+m+1 − u ui+m+1 − ui+1  u − ui   +  ui+m − u   N0,m u  +  cid:11 −m−1 cid:27   Ni+1,m u   Ni,m u   ui+m − ui  i=1 + u cid:11  − u u cid:11  − u cid:11 −m 1 · Ni,m u  + N cid:11 −m,m u   N cid:11 −m,m u   The ﬁnal equality follows from the induction hypothesis. The derivation of the next to last N0,m u  = N0,m u . This holds since um ≤ u; in particular, line needed the fact that = 1. Similarly, the fact that if um < u then N0,m u  = 0 by  a , and if um = u then u−u0 um−u0 u cid:11 −u  cid:1  u cid:11 −u cid:11 −m  N cid:11 −m,m u  = N cid:11 −m,m u  is justiﬁed by u ≤ u cid:11 −m.  u−u0 um−u0  The importance of conditions  b  and  c  is that they allow the blending functions to be used as coefﬁcients of control points to give a weighted average of control points. To deﬁne an order m  degree m − 1  B-spline curve, one needs n + m + 1 knot positions u0, . . . , un+m and n + 1 control points p0, . . . , pn. Then  cid:11  = n + m and the B-spline curve equals  Ni,m u pi  for um−1 ≤ u ≤ u cid:11 −m+1 = un+1.  q u  = n cid:27  j cid:27   i=0  q u  =  Ni,m u pi  i= j−m+1  The bounded interval of support given in condition  a  means that  provided u j ≤ u < u j+1. Thus, the control points provide local control over the B-spline curve, since changing one control point only affects m segments of the B-spline curve. The next theorem describes the smoothness properties of a B-spline curve. Because a B-spline consists of pieces that are degree m − 1 polynomials, it is certainly C ∞ -continuous at all values of u that are not knot positions. If there are no repeated knots and if m > 1, then, as we will prove, the curve is in fact continuous everywhere in its domain and, even more, the curve is C m−2-continuous everywhere in its domain. For instance, a degree three B-spline with   VIII.4 Properties of Nonuniform B-Splines  213  no repeated knots has its second derivatives deﬁned and continuous everywhere in its domain, including at the knot positions.  The case of repeated knots is more complicated. We say that a knot has multiplicity µ if it occurs µ times in the knot vector. Since the knots are linearly ordered, these µ occurrences must be consecutive values in the knot vector. That is, we have  ui−1 < ui = ui+1 = ··· = ui+µ−1 < ui+µ.  In this case, the curve will have its  m − µ − 1 th derivative deﬁned and continuous at u = ui . For instance, a degree three B-spline will have a continuous ﬁrst derivative at a twice repeated knot position but in general will be only continuous at a knot position of multiplicity three. In the latter case, the curve will generally have a “corner” or “bend” at that knot position. A B-spline curve of degree three can be discontinuous at a knot position of multiplicity four.  The ability to repeat knots and make the curve have fewer continuous derivatives is important for the usefulness of B-splines because it allows a single curve to include both smooth portions and sharply bending portions.  We combine the assertions above about the smoothness of B-splines into the next theorem.  Theorem VIII.2 Let q u  be a B-spline curve of order m, and let the knot ui have multiplicity µ. Then the curve q u  has continuous  m − µ − 1 th derivative at u = ui .  It is fairly difﬁcult to give a direct proof of this theorem, and so the proof of Theorem VIII.2 is postponed until Section VIII.7, where we present a proof based on the use of the blossoms introduced in Section VIII.6.  The last property of B-splines discussed in this section concerns the behavior of blending functions near repeated knots. In general, if a degree k B-spline curve has a knot of multiplic- ity ≥ k, then there is a blending function Ni,k+1 u  that goes to 1 at the knot. Examples of this are the blending functions shown in Figures VIII.8–VIII.10, where the ﬁrst and last knots are repeated many times and the ﬁrst and last blending functions reach the value 1 at the ﬁrst and last knots, respectively. It can also happen that interior knot positions have multiplicity k as well, and at such knots the appropriate blending function s  will reach the value 1; see Figures VIII.4 and VIII.8 b  for examples of this.  The next theorem formalizes these facts. In addition to helping us understand the behavior of B-spline curves at their endpoints, the theorem will be useful in the next two sections for the development of the de Boor algorithm and for the proof of Theorem VIII.2. Theorem VIII.3 Let k ≥ 1.  a  Suppose that ui = ui+k−1 < ui+k, and so ui has multiplicity at least k. Then   b  Dually, suppose ui−1 < ui = ui+k−1, and so ui has multiplicity at least k. Then  VIII.5  VIII.6  Ni−1,k+1 u  = 1  lim u→u + i and, for j  cid:16 = i − 1,  N j,k+1 u  = 0.  lim u→u + i  Ni−1,k+1 u  = 1  lim u→u − i and, for j  cid:16 = i − 1,  N j,k+1 u  = 0.  lim u→u − i   214  B-Splines  Proof To prove  a  and  b , it will sufﬁce to prove that equations VIII.5 and VIII.6 hold since the fact that the other limits equal zero will then follow from the partition of unity property of Theorem VIII.1 c . We prove VIII.5 by induction on k. The base case is k = 1.  Refer to ﬁgures VIII.6 and VIII.8 a .  Using the deﬁnitions of the N j,1 u  blending functions as step functions, that ui+1 − ui  ’   cid:16 = 0, and the Cox–de Boor formula, we have Ni−1,2 u  = lim u→u  Ni−1,1 u  + ui+1 − u ui+1 − ui  u − ui−1 ui − ui−1 = 0 + 1 · 1 = 1.  + i  lim u→u + i     Ni,1 u   The induction step applies to k ≥ 2. In this case, we have  Ni−1,k+1 u   lim u→u + i  ’  u − ui−1  = lim ui+k−1 − ui−1 u→u = 1 · 1 + 1 · 0 = 1.  + i     Ni−1,k u  + ui+k − u ui+k − ui  Ni,k u   Here we have used the induction hypothesis and the fact that ui = ui+k−1.  The proof of VIII.6 is completely dual, and we omit it.   cid:1   Exercise VIII.8 Use Theorem VIII.3 to prove that B-splines deﬁned with the standard knot vector interpolate their ﬁrst and last control points. [Hint: Use i = 0 and i = s + k − 1.]  VIII.5 The de Boor Algorithm  The de Boor algorithm is a method for evaluating a B-spline curve q u  at a single value of u. The de Boor algorithm is similar in spirit to the de Casteljau method for B´ezier curves in that it works by repeatedly linearly interpolating between pairs of points. This makes the de Boor algorithm stable, robust, and less prone to roundoff errors than methods that work by calculating values of the blending functions Ni,m u . The de Boor algorithm is also an important construction for understanding the mathematical properties of B-spline curves, and it will be used to establish the “blossoming” method for B-splines in the next section. Suppose that q u  is a B-spline curve of degree k ≥ 1 and is deﬁned by the control points p0, p1, . . . , pn and the knot vector [u0, . . . , un+m], where m = k + 1 is the order of q u . Therefore, the curve’s domain of deﬁnition is [uk , un+1]. As usual, q u  is deﬁned by  The next theorem provides the main tool needed to derive the de Boor algorithm. Theorem VIII.4 For all u ∈ [uk , un+1]  or, for all u ∈ [uk , un+1  if k = 1 ,  Ni,k+1 u pi .  i=0  q u  = n cid:27  q u  = n cid:27   u  = ui+k − u ui+k − ui  p 1  i  i=1  Ni,k u p 1  i   u ,  where  pi−1 + u − ui ui+k − ui  pi .  VIII.7  VIII.8  VIII.9   VIII.5 The de Boor Algorithm  215  If any knot has multiplicity > k; we can have ui = ui+k; the value p 1    u  is undeﬁned. With our conventions on division by zero, the theorem still makes sense in this case, for then the function Ni,k u  is the constant zero function. Proof We expand equation VIII.7 using the Cox–de Boor formula.  i  i=0  i=0  q u  = n cid:27  = n cid:27  = n cid:27  = n cid:27  = n cid:27   i=0  i=1  i=1   cid:11   Ni,k+1 u pi u − ui ui+k − ui u − ui ui+k − ui u − ui  cid:11  ui+k − ui ui+k − u ui+k − ui   cid:12   Ni+1,k u   pi  Ni,k u pi−1  Ni,k u pi−1  Ni,k u  + ui+k+1 − u ui+k+1 − ui+1 Ni,k u pi + n+1 cid:27  ui+k − u Ni,k u pi + n cid:27  ui+k − ui ui+k − u  cid:12  ui+k − ui pi−1 + u − ui ui+k − ui  i=1  i=1  pi  Ni,k u .  It is necessary to justify the fourth equality above, which reduces the domains of the summa- tions. First note that, since N0,k u  has support contained in [u0, uk] and is right continuous at uk, N0,k u  = 0 for u ≥ uk. This justiﬁes dropping the i = 0 term from the ﬁrst summation. For the second summation, we need to show that Nn+1,k u  = 0. Note that Nn+1,k u  has support in [un+1, un+m], and so the desired equality Nn+1,k u  = 0 certainly holds if u < un+1. It remains to consider the case where k > 1 and u = un+1. Now, if un+1 < un+m, then Nn+1,k un+1  = 0 by the Cox–de Boor formula. On the other hand, if un+1 = un+m, then Nn+1,k u  is the constant zero function.  cid:1  That sufﬁces to prove the theorem. It is possible restate Theorem VIII.4 without the special case for k = 1. For this, let the order k functions Ni,k u  be deﬁned from the knot vector [u0, . . . , un+m−1] instead of the knots [u0, . . . , un+m]. Then Equation VIII.8 holds for all u ∈ [uk , un+1] for all k ≥ 1. At ﬁrst glance, Equation VIII.8 may appear to deﬁne q u  as a degree k − 1 B-spline curve. This is not quite correct however, since the new “control points” p 1   u  depend on u. Nonethe- i less, it is convenient to think of the theorem as providing a method of “degree lowering,” and we can iterate the construction of the theorem to lower the degree all the way down to degree one. For this, we deﬁne   u  = pi ,  u  = ui+k− j+1 − u ui+k− j+1 − ui  p  j  i  and, for 1 ≤ j ≤ k, we generalize Equation VIII.9 to u − ui ui+k− j+1 − ui The following theorem shows that, for a particular value of j and a particular u, q u  can be expressed in terms of a B-spline curve of degree k − j. Theorem VIII.5 Let 0 ≤ j ≤ k. Let u ∈ [uk , un+1]  or u ∈ [uk , un+1  if j = k . Then  p  j−1  i−1  p  j−1   VIII.10  +  .  i  p 0  i  q u  = n cid:27   i= j  Ni,k+1− j  u p  j  i   u .  This theorem is proved by induction on j using Theorem VIII.4.  VIII.11  ✷   216  B-Splines  p 2  s−k+2  ...  p 2  s−1 p 2   s  ...  ···  p 1  s−k+1  ...  p 1  s−2 p 1  s−1 p 1   s  p 0  s−k  =  p s−k  ...  ...  p 0  s−2 = p 0  s−1 = = p 0   s  p s−2 p s−1 ps  p k−1  s−1 p k−1   s  p k   s  Figure VIII.11. The control points obtained as q u  is expressed as B-spline curves of lower degrees. For j > 0, the values p  j   i depend on u.  For the rest of this section, we suppose q u  has degree k and that every knot position has multiplicity ≤ k except that possibly the ﬁrst and last knot positions have multiplicity k + 1. It follows from Theorem VIII.2 that q u  is a continuous curve. These assumptions can be made without loss of generality since the B-spline curve can be discontinuous at any knot with multiplicity ≥ k + 1, and if such knots do occur the B-spline curve can be split into multiple B-spline curves. We are now ready to describe the de Boor algorithm. Suppose we are given a value for u such that us ≤ u < us+1, and we wish to compute q u . By Theorem VIII.5, with j = k, we have q u  = p k  s  u . This is because the degree zero blending function Ns,1 u  is equal to 1 on the interval containing u. The de Boor algorithm thus consists of evaluating p k  s  u  by using equation VIII.10 recursively. As shown in Figure VIII.11, p k  s  u  does not in gen- eral depend on all of the original control points pi but instead only on the control points pi with s − k ≤ i ≤ s. The de Boor algorithm presented at the conclusion of this section works by computing the control points p  j   u , which are shown in Figure VIII.11. That is, it computes  u  for j = 1, . . . , k and for i = s − k + j, . . . , s. An example of the de Boor algorithm p  j  i is also illustrated in Figure VIII.12. There is one special case in which the de Boor algorithm can be made more efﬁcient. When u is equal to the knot us, it is not necessary to iterate all the way to j = k. Instead, suppose  i  p1  p0  p2   1  3  p  p3   2  4  p   1  4  p  p4   2  5  p   3  5  p   1  5  p  p7  p6  p5  Figure VIII.12. The use of the de Boor algorithm to compute q u . The degree three spline has the uniform knot vector ui = i for 0 ≤ i ≤ 11 and control points pi . The points p  j  are computed by the de Boor algorithm with u = 5 1  i  2 and p 3   5  = q 5 1 2  .   217 VIII.6 Blossoms the knot u = us has multiplicity µ. Let δ = min k, µ . Since us < us+1, we have us−δ+1 = us, and applying Theorem VIII.3 b  with i = s − δ + 1 gives  q u  = p k−δ  s−δ .  The pseudocode for the de Boor algorithm is presented below. The algorithm works by  u  for successive values of j up to j = k − µ; these values are stored in computing values p  j  an array r[]. For a given value of j, r[ cid:11 ] is computed to equal p  j  s−k+ j+ cid:11  u . To ﬁnd the formula for computing successive values of r[ cid:11 ], make the change of variables  cid:11  = i −  s − k + j  in Equation VIII.10 to obtain  i  s−k+ j+ cid:11  u  = p  j   us+ cid:11 +1 − u  us+ cid:11 +1 − us−k+ j+ cid:11   p  j−1  s−k+ j+ cid:11 −1  + u − us−k+ j+ cid:11  us+ cid:11 +1 − us−k+ j+ cid:11   p  j−1  s−k+ j+ cid:11 . VIII.12  De Boor Algorithm Input: A degree k B-spline curve q  thus of order m = k + 1 , given by:  Control points p0, p1, . . . , pn, Knot positions u0, u1, . . . , un+m. A value u such that uk ≤ u ≤ un+1.  Result: Return value is q u . Algorithm:  Return pn;  If   u==un+m   {    If so, also u = un+1 holds. } Set s to be the value such that us ≤ u < us+1; Set δ = 0;    The next three lines are optional! Letting δ = 0    always works. If   u==us   { }    Initialize for j=0: For  cid:11  = 0, 1, ..., k − δ { Set r[ cid:11 ] = ps−k+ cid:11 ; }    Main loop: For j = 1,2,..., k − δ {  Set δ = min δ, the multiplicity of us ;  For  cid:11  = 0, 1, ..., k − δ − j { ;  u − us−k+ j+ cid:11   Set α = Set r[ cid:11 ] = lerp r[ cid:11 ],r[ cid:11  + 1],α ;  us+ cid:11 +1 − us−k+ j+ cid:11   }  } Return r[0];  VIII.6 Blossoms  Blossoms are a method of representing polynomial curves with symmetric, multiafﬁne func- tions. As such they provide an elegant tool for working with B-splines. Apart from mathematical elegance, the most important aspect of blossoms for us is that they give a simple algorithm for   218  B-Splines  computing the control points of a B-spline curve from the polynomial segments of the curve. Blossoms will be useful for obtaining formulas for the derivative of a B-spline. In addition, they give an easy method for deriving algorithms for knot insertion.  Suppose q u  is a degree k B-spline curve and that us < us+1 are two knots. The curve q u  consists of polynomial pieces; on the interval [us , us+1], q u  is deﬁned by a  single  polynomial, which we call f u . We will ﬁnd a new function b x1, x2, . . . , xk  that takes k real numbers as arguments but has the diagonal property that  b u, u, . . . , u  = f u .  VIII.13 This function b x1, . . . , xk  is called the “blossom” of f. The blossom b will also satisfy the following two properties:  Symmetry Property: Changing the order of the inputs to b does not change the value of b; namely, for any permutation π of {1, . . . , k} and for all values of x1, . . . xk, b xπ 1 , xπ 2 , . . . , xπ k   = b x1, x2, . . . , xk . A function with this property is called a symmetric function.  Multiafﬁne Property: For any scalars α and β with α + β = 1, the blossom satisﬁes , x2, x3, . . . , xk .  b αx1 + βx By the symmetry property, the same property holds for any of the other inputs x2, . . . , xk in place of x1.  , x2, x3, . . . , xk  = αb x1, x2, x3, . . . , xk  + βb x   cid:3  1   cid:3  1  Normally, the term “afﬁne” is used for a function of a single variable that is deﬁned by a polynomial of degree one.  This is equivalent to how “afﬁne” was deﬁned in Chapter II; however, now we are working with functions that take scalar inputs instead of inputs from R2 or R3.  In other words, a function h x  is afﬁne if it is of the form h x  = ax + b. Such functions h are precisely the functions that satisfy h αx + βy  = αh x  + βh y  for all values of x, y, α, and β with α + β = 1. Since blossoms are afﬁne in each input variable separately, they are called “multiafﬁne.” We next deﬁne the blossom of a polynomial curve q u  in Rd. First, some notation is necessary. For k > 0, we let [k] = {1, 2, . . . , k}. For J a subset of [k], we deﬁne the term x J to be the product  +  x J =  x j .  j∈J  For example, if J = {1, 3, 6}, then x J = x1x3x6. For the empty set, we deﬁne x∅ = 1. Deﬁnition Let q have degree ≤ k so that  q u  = rkuk + rk−1uk−1 + ··· + r2u2 + r1u1 + r0,  where the coefﬁcients ri are points from Rd for some d.  These coefﬁcients ri should not be confused with the control points of a B-spline curve.  We deﬁne the degree k blossom of q u  to be the k variable polynomial  b x1, . . . , xk  = k cid:27    cid:27    cid:11    cid:12 −1  k i  ri x J ,  i=0  J⊆[k] J=i  VIII.14  where J denotes the cardinality of J . We need to check that the deﬁnition of the blossom b satisﬁes the three properties described above. First, it is immediate, just from the form of the deﬁnition, that b is a symmetric function. Second, the terms in the polynomial deﬁning b   VIII.6 Blossoms  contain at most one occurrence of each variable; therefore, b is degree one in each variable separately and thus is afﬁne in each variable. Finally, since there are many subsets J of k of size i, it is easy to see that b u, u, . . . , u  = q u .  k i   cid:9    cid:10   219  As an example, let q u  be the quadratic curve  q u  = au2 + bu + c.  Then, the degree two blossom of q u  is the polynomial  b x1, x2  = ax1x2 + 1  2 b x1 + x2  + c.  There is also a degree three blossom for q u . For this, we think of q u  as being a degree three polynomial with leading coefﬁcient zero. Then the degree three blossom of q u  equals  3 a x1x2 + x1x3 + x2x3  + 1  b x1, x2, x3  = 1 Exercise VIII.9 Let q u  = au3 + bu2 + cu + d. What is the degree three blossom of q u ?  3 b x1 + x2 + x3  + c.  The key reason that blossom functions are useful is that they can be used to compute the control points of a B-spline curve from the polynomial equation of the curve. This is expressed by the next theorem. Theorem VIII.6 Let q u  be a degree k, order m = k + 1 B-spline curve with knot vector [u0, . . . , un+m] and control points p0, . . . , pn. Suppose us < us+1, where k ≤ s ≤ n. Let q u  be equal to the polynomial qs u  for u ∈ [us , us+1 . Let b x1, . . . , xk  be the blossom of qs u .2 Then the control points ps−k , . . . , ps are equal to  VIII.15  pi = b ui+1, ui+2, . . . , ui+k ,  for i = s − k, . . . , s.  This theorem lets us obtain the control points that affect a single segment of a B-spline from the blossom of the segment. In particular, it means that k + 1 consecutive control points can be calculated from just the one segment that they all affect!  Proof To prove Theorem VIII.6, we relate the blossom’s values to the intermediate values obtained in the de Boor algorithm. For this, it is convenient to make a change of variables by setting i = s − k +  cid:11  and rewriting equation VIII.15 as  ps−k+ cid:11  = b us−k+ cid:11 +1, us−k+ cid:11 +2, . . . , us+ cid:11  .  It will thus sufﬁce to prove Equation VIII.16 holds for  cid:11  = 0, 1, . . . , k.  VIII.16  Consider the values of the blossom function, as shown in Figure VIII.13. To save space, we is used to denote i occurrences have used two notational conveniences. First, the notation u   = of the parameter u; for example, the diagonal property VIII.13 can be reexpressed as b u qs u . Second, for i < j, the notation u[i, j] denotes the sequence of values ui , ui+1, . . . , u j . Figure VIII.13 looks very much like Figure VIII.11, which describes the de Boor algorithm.   cid:5 k cid:6    cid:5 i cid:6   Indeed, the next lemma shows that it corresponds exactly to Figure VIII.11. Lemma VIII.7 Suppose the equality VIII.16 holds for all  cid:11  = 0, . . . , k. Then, for j = 0, . . . , k and  cid:11  = 0, . . . , k − j,  s−k+ j+ cid:11  u  = b us−k+ j+ cid:11 +1, . . . , us+ cid:11 , u p  j    cid:5  j cid:6    .  2 The B-spline curve q u  is only piecewise polynomial, and so it does not have a blossom. But, of  course the subcurve qs u  does have a blossom.   220  B-Splines  b u[s−k+3,s], u   cid:4 2 cid:5    ...  ...  ···  b u[s,s+k−3], u b u[s+1,s+k−2], u   cid:4 2 cid:5    cid:4 2 cid:5    b u[s−k+2,s], u   ...  b u[s−k+1,s]   ...  b u[s−1,s+k−3], u  b u[s,s+k−2], u  b u[s+1,s+k−1], u   b u[s−1,s+k−2]  b u[s,s+k−1]  b u[s+1,s+k]    cid:4 k cid:5     cid:5 k cid:6   b u   on the left is equal to qs u . The blossom Figure VIII.13. A table of blossom values. The value b u values in the right column are equal to the control points of the B-spline curve. The symmetry and multiafﬁne properties of the blossom function mean that each blossom value is a weighted average of the two blossom values that point to it as expressed in Equation VIII.17. The lemma is proved by induction on j. The base case is j = 0, and for this case, the lemma holds by the hypothesis that VIII.16 holds. To prove the induction step for j > 0, note that the symmetry and multiafﬁne properties of b imply that b us−k+ j+ cid:11 +1, . . . , us+ cid:11 , u    equals   cid:5  j cid:6    cid:5  j−1 cid:6      b us−k+ j+ cid:11 +1, . . . , us+ cid:11 , u, u  =  us+ cid:11 +1 − u  us+ cid:11 +1 − us−k+ j+ cid:11   +  u − us−k+ j+ cid:11   us+ cid:11 +1 − us−k+ j+ cid:11   b us−k+ j+ cid:11 , . . . , us+ cid:11 , u   cid:5  j−1 cid:6      VIII.17  b us−k+ j+ cid:11 +1, . . . , us+ cid:11 +1, u   cid:5  j−1 cid:6    .   cid:5  j−1 cid:6   The induction hypothesis tells us that b us−k+ j+ cid:11 , . . . , us+ cid:11 , u  cid:5  j−1 cid:6  . . . , us+ cid:11 +1, u Equation VIII.12,    are equal to p  j−1     and b us−k+ j+ cid:11 +1, s−k+ j+ cid:11  u , respectively. Therefore, by  s−k+ j+ cid:11 −1 u  and p  j−1    = p  j   cid:5  j cid:6   s−k+ j+ cid:11  u .  b us−k+ j+ cid:11 +1, . . . , us+ cid:11 , u  That completes the proof of the lemma.  if  the control points ps−k , . . . , ps  then the correct curve qs u   The lemma immediately implies that,  satisfy the values Equation VIII.16, b us−k+ cid:11 +1, us−k+ cid:11 +2, . . . , us+ cid:11   are a possible set of control points for qs u . On the other hand, vector space dimensionality considerations imply that there is at most a single set of pos- sible control points for qs u . Namely, for a curve lying in Rd, the vector space of all degree k polynomials has dimension  k + 1 d, and the space of possible control points ps−k , . . . , ps has  cid:1  the same dimension. Thus, Theorem VIII.6 is proved.  is obtained. That  is,  Exercise VIII.10 Verify the following special case of Theorem VIII.6. Let  q u  =  1 − u 2p0 + 2u 1 − u p1 + u2p2  be the degree two B-spline with the knot vector [0, 0, 0, 1, 1, 1] and control points p0, p1, p2.  See Equations VIII.4 on page 208.  Give the formula for the blossom b x1, x2  of q. What are the values of b 0, 0 , b 0, 1 , and b 1, 1 ?  It is possible to develop the theory of B´ezier curves and B-spline curves using the blossoms as the central concept. This alternate approach differs from our treatment in this book by using blossoms instead of blending functions Ni,k as the main tool for deﬁning B-splines. The textbook  Farin, 1997  describes this alternate approach. Two early papers describing the   VIII.7 Derivatives and Smoothness of B-Spline Curves  221  use of blossoms are  Seidel, 1988; 1989 ; his work is based on the original developments by de Casteljau and Ramshaw.  VIII.7 Derivatives and Smoothness of B-Spline Curves  This section derives formulas for the derivative of a B-spline curve and proves Theorem VIII.2 about the number of continuous derivatives of a B-spline. It is a pleasant discovery that the derivative of a degree k B-spline curve is itself a B-spline curve of degree k − 1. Theorem VIII.8 Let q u  be a degree k = m − 1 B-spline curve with control points p0, . . . , pn. Then its ﬁrst derivative is pi − pi−1 ui+k − ui   u  = n cid:27   k Ni,k u   VIII.18  q  .   cid:3   i=1  u  is the degree k − 1 B-spline curve with control points equal to k   cid:3  In particular, q  VIII.19  =  ∗ p i  ui+k − ui   pi − pi−1 .  We prove Theorem VIII.8 in stages. First, we prove that Equation VIII.18 is valid for all values of u that are not knots. We then use continuity considerations to conclude that Equation VIII.18 holds also for u a knot.3 After proving Theorem VIII.8, we use it to help prove Theorem VIII.2.  The next lemma will be used for the ﬁrst stage of the proof of Theorem VIII.8. This lemma explains how to express the blossom of the ﬁrst derivative of a function in terms of the blossom of the function. Lemma VIII.9 Let f u  be a polynomial curve of degree ≤ k, and let b x1, . . . , xk  be its degree k blossom.   x1, . . . , xk−1  be the degree k − 1 blossom of the ﬁrst derivative f ∗  a  Let b  x1, . . . , xk−1  = k ·  b x1, . . . , xk−1, 1  − b x1, . . . , xk−1, 0  . ∗ b   cid:3    u  of f u . Then,   b  More generally, for all s  cid:16 = t,  ∗ b  Proof Let f u  = cid:28    x1, . . . , xk−1  = k t − s  cid:11   cid:27   tion VIII.14 can be rewritten as  b x1, . . . , xk  =   b x1, . . . , xk−1, t  − b x1, . . . , xk−1, s  .  cid:12 −1  kJ  J⊆[k]  rJx J .  k i=0 ri ui . The deﬁnition of the degree k blossom of f u  given by equa-  VIII.20  VIII.21  VIII.22  3   u  is always the degree k − 1 B-spline curve with control points p   For any practical use of splines, you can ignore this footnote.  To be completely rigorous, it is not  cid:3  ∗ quite true that q i . Namely, at points where the degree k − 1 curve is discontinuous, the ﬁrst derivative of q is undeﬁned. However, if the ﬁrst derivative is extended to isolated points by taking right limits, we have equality. For similar reasons, Equation VIII.18 does not always hold either. A more correct way to say this is that Equation VIII.18 holds whenever the expression on the right-hand side is continuous at u as well as whenever q  u  is deﬁned.   cid:3    222  The ﬁrst derivative of f u  is f   cid:3    u  = cid:28   cid:11   cid:12 −1  cid:27  i=0  i + 1 ri+1ui , and its degree k − 1 blossom is k−1 k − 1J   J + 1 rJ+1x J .  B-Splines  ∗ b   x1, . . . , xk−1  =  J⊆[k−1]  VIII.23 Now consider the difference b x1, . . . , xk−1, 1  − b x1, . . . , xk−1, 0 . Examining the for- mula VIII.22 for b, we see that terms for subsets J ’s that do not contain xk cancel out in the difference, and terms for J ’s that do contain xk survive but with the factor xk removed. Thus,   cid:11    cid:27    cid:12 −1  b x1, . . . , xk−1, 1  − b x1, . . . , xk−1, 0  =  Now, VIII.20 follows immediately from VIII.23 and VIII.24 and the identity k · cid:9   i + 1  · cid:9   Part  b  is proved using  a . By the multiafﬁne property, since s +  1 − s  = 1 and s · 1 +  . So  a  is proved.   cid:10  =  J + 1  rJ+1x J .  J⊆[k−1]  VIII.24  k−1 i  k i+1  k   cid:10   1 − s  · 0 = s,  b x1, . . . , xk−1, s  = s · b x1, . . . , xk−1, 1  +  1 − s  · b x1, . . . , xk−1, 0 .  Therefore,  b x1, . . . , xk−1, s  − b x1, . . . , xk−1, 0  = s ·  b x1, . . . , xk−1, 1  − b x1, . . . , xk−1, 0  . VIII.25  Similarly, with t in place of s,  b x1, . . . , xk−1, t  − b x1, . . . , xk−1, 0  = t ·  b x1, . . . , xk−1, 1  − b x1, . . . , xk−1, 0  . VIII.26  cid:1   Equation VIII.21 follows from Equations VIII.20, VIII.25, and VIII.26.  Returning to the proof of Theorem VIII.8, we can now show that q   u  is the B-spline curve ∗ with control points p i . For this, by Theorem VIII.6, it will sufﬁce to prove the following: For two distinct adjacent knots, us < us+1, if b and b  u  on the  ui+1, . . . , ui+k−1  for all i such that i ≤ s < i + k. This is ∗ interval  us , us+1 , then p proved as follows using Lemma VIII.9 b  with s = ui and t = ui+k: i   cid:3  are the blossoms of q u  and q  = b ∗  ∗   cid:3   ∗ b   ui+1, . . . , ui+k−1  =  k  k  ui+k − ui ui+k − ui ui+k − ui  k  =  =   b ui+1, . . . , ui+k−1, ui+k  − b ui+1, . . . , ui+k−1, ui     b ui+1, . . . , ui+k−1, ui+k  − b ui , ui+1, . . . , ui+k−1    pi − pi−1  = p ∗ i  .  It follows from what we have proved so far that Equation VIII.18 holds for all values of u that are not knots. It remains to establish the appropriate continuity conditions. This will complete the proof of Theorem VIII.8, since a function that is continuous and whose ﬁrst derivative is equal to a continuous function except at isolated points has a continuous ﬁrst derivative. This is formalized by the following fact from real analysis  which we leave to the reader to prove :   VIII.8 Knot Insertion  223  Lemma VIII.10 Let f be a continuous function, whose ﬁrst derivative is deﬁned in a neigh-  u  = borhood of ui such that the left and right limits of f L = limu→u That concludes the proof of Theorem VIII.8.   u  at u = ui satisfy limu→u   ui   exists and is equal to L.   u . Then f  + i  − i  f  f   cid:3    cid:3    cid:3    cid:3   We are now ready to prove Theorem VIII.2. It is certainly enough to prove the following statement: For all B-spline curves q u  of degree k, if a knot ui has multiplicity µ, then q u  has continuous  k − µ th derivative at u = ui . We prove this statement by holding the knot vector and thus the multiplicity µ of ui ﬁxed and using induction on k starting at k = µ. The base case, k = µ, is a direct consequence of Theorem VIII.3. Ni−1,k+1 u  has limit 1 on both sides of ui and thus value 1 at u = ui . For j  cid:16 = i − 1, N j,k+1 u  is continuous and equal to zero at ui . So, in this case, q u  is continuous at u = ui with q ui   = pi−1.  The induction step uses the Cox–de Boor formula to establish continuity and Theorem VIII.8 and Lemma VIII.10 to establish the continuity of the derivatives. Assume k > µ. The induction hypothesis implies that, for all j, N j,k u  is continuous and is C k−µ−1-continuous at ui  the induction hypothesis applies to N j,k u  since it is a real-valued, degree k − 1 B-spline curve . The Cox–de Boor formula expresses each N j,k+1 u  in terms of N j,k u  and N j+1,k u , and so the induction hypothesis applied to these two functions implies that N j,k+1 u  has continuous  k − µ − 1 th derivative at ui . Thus, any degree k B-spline curve q u  with this knot vector is C k−µ−1-continuous at ui . Theorem VIII.8 further implies that the ﬁrst derivative of q u  is equal to a degree k − 1 B-spline curve, except possibly at knots. By the induction hypothesis, this degree k − 1 curve is C k−µ−1-continuous at ui . It follows that q u  has a continuous  k − µ th derivative, by using Lemma VIII.10 with f u  equal to the  k − µ − 1 th derivative of q u . ✷  VIII.8 Knot Insertion  An important tool for practical interactive use of B-spline curves is the technique of knot insertion, which allows one to add a new knot to a B-spline curve without changing the curve or its degree. For instance, when editing a B-spline curve with a CAD program, one may wish to insert additional knots in order to be able to make further adjustments to a curve: having additional knots in the area of the curve that needs adjustment allows more ﬂexibility in editing the curve. Knot insertion also allows the multiplicity of a knot to be increased, which provides more control over the smoothness of the curve at that point. A second use of knot insertion is to convert a B-spline curve into a series of B´ezier curves, as will be seen in Section VIII.9. A third use of knot insertion is that, by adding more knots and control points, the control polygon will more closely approximate the B-spline curve. This can be useful, for instance, in combination with the convex hull property, since the convex hull will be smaller and will more closely approximate the curve. This is similar to the way recursive subdivision can be used for B´ezier curves. However, one complication is that, for B-spline curves with many knot positions, you should not work with the convex hull of the entire set of control points. Instead, you should use the local support property and deﬁne a sequence of convex hulls of k + 1 consecutive control points so that the union of these convex hulls contains the B-spline curve. A fourth use of knot insertion is for knot reﬁnement, whereby two curves with different knot vectors can each have new knot positions inserted until the two curves have the same knot vectors.  There are two commonly used methods for knot insertion. The B¨ohm method  B¨ohm, 1980; B¨ohm and Prautsch, 1985  allows a single knot at a time to be inserted into a curve, and the Oslo method  Cohen, Lyche, and Riesenfeld, 1980; Prautsch, 1984  allows multiple knots to be inserted at once. We will discuss only the B¨ohm method; of course, multiple knots may be inserted by iterating this method. The proof of the B¨ohm method’s correctness will be based   B-Splines  224  p0 =  cid:1 p0  p1 =  cid:1 p1  p2 =  cid:1 p2  p7 =  cid:1 p8   cid:1 p5  p5   cid:1 p6  p6   cid:1 p7  p8 =  cid:1 p9  p3 =  cid:1 p3  p4 =  cid:1 p4   a  Knot vector becomes [0, 1, 2, 3, 4, 5, 6, 7, 7 3  4 , 8, 9, 10, 11].  p1 =  cid:1 p1  p2 =  cid:1 p2  p5 =  cid:1 p5  p8 =  cid:1 p9  p0 =  cid:1 p0  p3 =  cid:1 p3  p4 =  cid:1 p4   cid:1 p7   cid:1 p6  p6  p7 =  cid:1 p8  p9 =  cid:1 p10   b  Knot vector becomes [0, 1, 2, 3, 4, 5, 6, 7, 7 3  4 , 7 3  4 , 8, 9, 10, 11].  Figure VIII.14. Showing the insertion of knots into a degree three curve. The original knot vector is the uniform knot vector [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]. We insert the value 7 3 4 into the curve twice, each time adding a new control point and making the control polygon more closely approximate the curve near 7 3 4 . The dotted straight lines show the control polygon before the insertion of the new knot position.  The dashed straight lines are the control polygon after the insertion.  In  b , the dashed line from*p6 to*p7 point positions. The open circles are the changed control point positions. The control points*pi of  a  control point*p7 would be equal to the point on the curve at u = 7 3  are renamed pi in  b . In both ﬁgures, one new knot has been inserted and some of the control points have been moved, but the B-spline curve itself is unchanged. If we inserted 7 3 4 a third time, then the new  is so close to the curve that it cannot be seen in the graph.  The ﬁlled circles are the original control  4 .  on blossoming. For other methods of knot insertion, the reader can consult  Farin, 1997  and  Piegl and Tiller, 1997  and the references cited therein. Suppose q u  is an order m, degree k = m − 1, B-spline curve deﬁned with knot vector  [u0, . . . , un+m] and control points p0, . . . , pn. We wish to insert a new knot position*u where us ≤*u < us+1 and then choose new control points so that the curve q u  remains unchanged. The new knot vector is denoted [*u0, . . . ,*un+m+1], where, of course, *ui =  The method of choosing the new control points is less obvious, for we must be sure not to change the curve. The B¨ohm algorithm gives the following deﬁnition of the control points:  remember, k = m − 1 :  pi−1 + *u − ui  *pi = It is implicit in the deﬁnitions of the*pi ’s that us+1 > us. This can always be arranged by  pi if s − k < i ≤ s  if i ≤ s − k  ui+k − ui  if s < i .  VIII.27  inserting a new repeated knot at the end of a block of repeated knots rather than the beginning   ui *u if i ≤ s if i = s + 1 ui−1 if i > s + 1.  pi ui+k −*u ui+k − ui pi−1   VIII.8 Knot Insertion  old control points pi−1 and pi .  or the middle. Note that the new control points*pi are deﬁned as weighted averages of pairs of Theorem VIII.11 Suppose k ≥ 1 and let*q u  be the degree k B-spline curve deﬁned with the knot vector [*u0, . . . ,*un+m+1] and control points*p0, . . . ,*pn+1. Then,*q u  = q u  for all u.  The correctness of the B¨ohm algorithm for knot insertion is stated by the next theorem.  225  Proof Because of the way blossoms determine control points, it will sufﬁce to show that  q u  = *q u   for u ∈ [us , us+1 .  For this, it is enough to show that the blossom b of q on the interval [us , us+1  is also the  blossom for*q on the intervals [us ,*u  and [*u, us+1 . To prove this, it is necessary and sufﬁcient positions and control points of*q, namely, that for all i such that s − k ≤ i ≤ s + 1,  to show that the blossom b has the properties given by Theorem VIII.6 with respect to the knot  *pi = b *ui+1,*ui+2, . . . ,*ui+k . *ps−k = ps−k  For i = s − k, this is easily shown by  = b *us−k+1,*us−k+2, . . . ,*us  = b us−k+1, us−k+2, . . . , us   since u j =*u j for j ≤ s. Likewise, for i = s + 1,  *ps+1 = ps  It remains to consider the case in which s − k < i ≤ s. Let  = b *us+2,*us+3, . . . ,*us+k+1 . = b us+1, us+2, . . . , us+k  α = ui+k −*u β = *u − ui Then, by the deﬁnition of*pi and since i ≤ s < i + k, ui+k − ui ui+k − ui *pi = αpi−1 + βpi = b ui+1, ui+2, . . . , us ,*u, us+1, . . . , ui+k−1  = αb ui , ui+1, . . . , ui+k−1  + βb ui+1, ui+2, . . . , ui+k  = b *ui+1,*ui+2, . . . ,*ui+k .  and  .  and because α + β = 1 and αui + βui+k =*u.  The third equality above is justiﬁed by the symmetry and multiafﬁne properties of the blossom  cid:1   Exercise VIII.11 In Exercise VII.17 on page 184, a half-circle is expressed as a quadratic rational B´ezier curve. Rewrite this as a degree two rational B-spline with knot vector [0, 0, 0, 1, 1, 1]. Insert u = 1 2 as a new knot position. What are the new control points? Graph the curve and its new control polygon. Compare with Figure VIII.17 on page 229.   cid:1   Exercise VIII.12 Prove that B-spline curves satisfy the variation diminishing property. [Hint: Combine the ideas of Exercise VII.9 with the fact that repeatedly inserting knots in the correct sequence can make the control polygon approximate the B-spline curve arbitrarily well.]   226  B-Splines  VIII.9 B´ezier and B-Spline Curves  We now discuss methods for translating between B´ezier curves and B-spline curves. These methods are degree preserving in that they will transform a degree k B´ezier curve into a degree k B-spline and vice versa. Of course, there is a bit of a mismatch: a B´ezier curve consists of a single degree k curve speciﬁed by k + 1 control points whereas a B-spline curve consists of a series of pieces, each piece a degree k polynomial. Accordingly, the translation between B-spline curves and B´ezier curves will transform a series of degree k pieces that join together to make a single curve. Such a series of curve pieces can be viewed as either a single B-spline curve or as a collection of B´ezier curves.  From B´ezier Curves to B-Spline Curves First, we consider the problem of converting a single B´ezier curve into a B-spline curve. Suppose we have a degree three B´ezier curve q u  deﬁned with control points p0, p1, p2, p3 that are deﬁned over the range 0 ≤ u ≤ 1. To construct a deﬁnition of this curve as a B-spline curve with the same control points, we let [0, 0, 0, 0, 1, 1, 1, 1] be the knot vector and keep the control points as p0, p1, p2, p3. It can be veriﬁed by direct computation that the B-spline curve is in fact the same curve q u  as the B´ezier curve  see pages 208–209 . In fact, we have the following general theorem. Theorem VIII.12 Let k ≥ 1 and q u  be a degree k B´ezier curve deﬁned by control points p0, . . . , pk. Then q u  is identical to the degree k B-spline curve deﬁned with the same control points over the knot vector consisting of the knot 0 with multiplicity k + 1 followed by the knot 1 also with multiplicity k + 1.  To prove this theorem, let Ni,k+1 u  be the basis functions for the B-spline with the knot  vector [0, . . . , 0, 1, . . . , 1] containing 2k + 2 many knots. Then we claim that   cid:11    cid:12   k i  Ni,k+1 u  =  ui  1 − u k−i .  VIII.28  The right-hand side of this equation is just the same as the Bernstein polynomials used to deﬁne B´ezier curves, and so the theorem follows immediately from Equation VIII.28. Equation VIII.28 is easy to prove by induction on k, and we leave the proof to the reader. ✷ The most useful cases of the previous theorem are when k = 2 and k = 3. As we saw in Section VII.13, the k = 2 case is frequently used for deﬁning conic sections, including circles, via B´ezier curves. In the k = 2 case, a degree two B´ezier curve with the three control points p0, p1, p2 is equivalent to the degree two B-spline curve with the same three control points and with knot vector [0, 0, 0, 1, 1, 1].   cid:3  0   cid:3  , p 1  Often one wants to combine two or more B´ezier curves into a single B-spline curve. For instance, suppose one has degree two B´ezier curves q0 u  and q1 u  deﬁned with control  cid:3  points p0, p1, p2 and p , p 2. We wish to combine these curves into a single curve q u  that consists of q1 u  followed by q2 u . That is, q u  = q1 u  for 0 ≤ u ≤ 1, and q u  = q2 u − 1  for 1 ≤ u ≤ 2. By Theorem VIII.12, q u  is equivalent to the degree two B-spline  cid:3  curve with knot vector [0, 0, 0, 1, 1, 1, 2, 2, 2] and with the six control points p0, . . . , p 2. However, usually the two B´ezier curves form a single continuous curve, that is, p2 = p  cid:3  0. In this case, q u  is the same as the B-spline curve with knot vector [0, 0, 0, 1, 1, 2, 2, 2] and  cid:3   cid:3  with ﬁve control points p0, p1, p2, p , p 2. Note that one knot position and the duplicate control 1 point have been omitted. This construction is demonstrated by the calculation in the next exercise.   VIII.10 Degree Elevation  227  Exercise VIII.13 Calculate the degree two blending functions for the knot vector [0, 0, 0, 1, 1, 2, 2, 2]. Show that the results are the degree two Bernstein polynomials on the interval [0, 1], followed by the same degree two Bernstein polynomials translated to the interval [1, 2]. Conclude that a quadratic B-spline formed with this knot vector and control points p0, p1, p2, p3, p4 will be the concatenation of the two quadratic B´ezier curves with control points p0, p1, p2 and with control points p2, p3, p4.  The construction in this exercise can be generalized in several ways. First, if one has three degree two B´ezier curves that form a single continuous curve, then they are equivalent to a degree two B-spline curve with knot vector [0, 0, 0, 1, 1, 2, 2, 3, 3, 3]. This generalizes to allow a continuous curve that consists of any number of quadratic B´ezier curves to be expressed as a single B-spline curve. Second, the construction generalizes to other degrees: for instance, a continuous curve that consists of two degree three B´ezier curves is the same as the degree three B-spline curve that has knot vector [0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2] and has the same seven points as its control points. We leave the proofs of these statements to the reader.  Exercise VIII.14 Prove that the de Casteljau algorithm for a B´ezier curve is the same as the de Boor algorithm for the equivalent B-spline curve.  From B-Spline Curve to Piecewise B´ezier Curve We now discuss how to convert a general B-spline curve into constituent B´ezier curves. A priori, it is always possible to convert a degree k B-spline curve into a series of degree k B´ezier curves merely because the B-spline curve consists of piecewise polynomials of degree k and any ﬁnite segment of a degree k polynomial can be represented as a degree k B´ezier curve  see Exercise VII.8 .  Here is an algorithm to convert a B-spline curve into multiple B´ezier pieces: use repeated knot insertion to insert multiple occurrences of the knots until the ﬁrst and last knots have multiplicity k + 1 and each interior knot has multiplicity k. By the discussion about combining multiple B´ezier curves into a B-spline curve, this means that the control points of the resulting B-spline curve  that is, the control points that result from the knot insertion  are also the control points for B´ezier curves between the knot positions.  VIII.10 Degree Elevation  Section VII.9 discussed degree elevation for B´ezier curves. Degree elevation can also be applied to B-spline curves. In analogy to the situation with B´ezier curves, suppose we are given a degree k B-spline curve q u  and wish to ﬁnd a way to describe the  same  curve as a degree k + 1 B-spline curve. The ﬁrst thing to notice is that if a knot u has multiplicity µ in the degree k curve, then q u  has continuous  k − µ th derivative at u  by Theorem VIII.2  but may well not have a continuous  k − µ + 1 th derivative at u. Thus, to represent q u  as a degree k + 1 curve, it is necessary for the knot position u to have multiplicity µ + 1. In other words, to elevate the degree of a curve, it will generally be necessary to increase the multiplicity of all the knots by one.  Because of the need to add so many  duplicate  knot positions, the algorithms for de- gree elevation are not particularly simple. We do not cover them but instead refer the reader to  Farin, 1997  or  Piegl and Tiller, 1997  for algorithms and references for other algorithms. Piegl and Tiller suggest the following algorithm: ﬁrst, use knot insertion or knot reﬁnement to make all knots have multiplicity k in order to convert the curve into degree k B´ezier curve segments; second, use the degree elevation algorithm for B´ezier   B-Splines   cid:1 p1, 1 cid:2    cid:1 p2, 1 cid:2    cid:1 3p5, 3 cid:2   228   cid:1 p0, 1 cid:2    cid:1 p7,1 cid:2    cid:1 p8, 1 cid:2    cid:1  1 3 cid:2  3 p3, 1   cid:1 p4, 1 cid:2    cid:1 3p6, 3 cid:2   Figure VIII.15. A degree three, rational B-spline curve. The control points are the same as in Figure VIII.1 on page 201, but now the control point p3 is weighted only 1 3, and the two control points p5 and p6 are weighted 3. All other control points have weight 1. In comparison with the curve of Figure VIII.1 b , this curve more closely approaches p5 and p6 but does not approach p3 as closely.  curves; and then, third, reduce the knot multiplicities by a process called “knot elimination.” Other algorithms are available that do not need to add excess knots, for example, based on blossoms.  VIII.11 Rational B-Splines and NURBS  A B-spline curve is called a rational curve if its control points are speciﬁed with homoge- neous coordinates. These curves are sometimes called “NURBS,” which is an acronym for “nonuniform, rational B-splines.”  Rational B´ezier curves were already discussed earlier in Sections VII.12 and VII.13; much of what was said about rational B´ezier curves also applies to rational B-splines. A rational B-spline has 4-tuples  cid:5 x, y, z, w cid:6  as control points; the curve’s values q u  are expressed as weighted averages of the control points,   cid:27   q u  =  Ni,m u pi ,  i  and so q u  represents the points on the curve in homogeneous coordinates. As with rational B´ezier curves, the w component of a control point acts as a weight factor: a control point cid:5 wpi , w cid:6  weights the point pi by a factor of w. This is illustrated in Figure VIII.15. Also, like rational B´ezier curves, rational B-splines are preserved under perspective transfor- mations and may have control points at inﬁnity.  Section VII.13 described the construction of B´ezier curves that trace out a semicircle or, more generally, a portion of a conic section. B-splines can do better in that a single B-spline can deﬁne an entire circle or an entire conic section. This is done by patching together several quadratic B´ezier curves to form a quadratic B-spline curve that traces out an entire circle or conic section. As was shown in Section VIII.9, two quadratic B´ezier curves may be patched together into a single B-spline curve by using the knot vector [0, 0, 0, 1, 1, 2, 2, 2]. Similarly, three quadratic B´ezier curves can be combined into a single B-spline curve using the knot vector [0, 0, 0, 1, 1, 2, 2, 3, 3, 3], and a similar construction works for combining four B´ezier curves into a single B-spline curve, and so forth. As an example, Theorem VII.9 on page 182 implies that if we use the knot vector [0, 0, 0, 1, 1, 2, 2, 2] and the control points  p0 =  cid:5 0, 1, 1 cid:6  p1 =  cid:5 1, 0, 0 cid:6  p2 =  cid:5 0,−1, 1 cid:6   p3 =  cid:5 −1, 0, 0 cid:6  p4 = p0,  then the resulting B-spline will trace out the unit circle.  Similar constructions also give the unit circle as a B-spline consisting of either three or four B´ezier segments without using control points at inﬁnity. These are based on the results   VIII.13 Interpolating with B-Splines  229  p1  p3  p4  p5  p2  p6  p1  p7  p0 = p8  p2  p0 = p6  p3  p5  p4  Figure VIII.16. Two ways to form a complete circle with a quadratic B-spline curve. The ﬁrst curve has knot vector [0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 4], and the control points pi have weight 1 when i is even and √ 2 2 when i is odd. The second curve has knot vector [0, 0, 0, 1, 1, 2, 2, 3, 3, 3], and the control weight points pi have weight 1 when i is even and weight 1  2 when i is odd.  from Exercises VII.14 and VII.15 and are pictured in Figure VIII.16. Compare this Figure with VII.19 on page 184.  Another well-known construction of the unit circle by a degree two B-spline curve is shown in Figure VIII.17; we leave the proof of its correctness to the reader  see Exercise VIII.11 on page 225 .  VIII.12 B-Splines and NURBS Surfaces in OpenGL  OpenGL provides routines for drawing  nonuniform  B-spline surfaces in the glu library. By specifying the control points in homogeneous coordinates, this includes the ability to render NURBS surfaces. The B-spline routines include gluNewNurbsRenderer and gluDeleteNurbsRenderer to allocate and deallocate, respectively, a B-spline renderer; these routines are misnamed, for they can also be used to render nonrational B-splines. The routines gluBeginSurface   and gluEndSurface   are used to bracket one or more calls to gluNurbsSurface. The latter routine allows speciﬁcation of an array of knots and control points. Since it renders a surface, it uses two knot arrays and a two-dimensional array of control points. The routine gluNurbsProperty allows you to control the level of detail at which the B-spline surface is rendered.  The interested reader should refer to the OpenGL documentation for more details.  VIII.13 Interpolating with B-Splines  Frequently, one wishes to deﬁne a smooth curve that interpolates  i.e., passes through, or contains  a given set of points. Chapter VII explained ways of forming interpolating curves using the Catmull–Rom and Overhauser splines, which consist of piecewise B´ezier curves. The Catmull–Rom and Overhauser curves are C 1-continuous but generally do not have  p2  p3  p1  p0 = p6  p5  p4 Figure VIII.17. Another way to form a complete circle with a quadratic B-spline curve. The curve has knot vector [0, 0, 0, 1, 2, 2, 3, 4, 4, 4], the control points p0, p3, and p6 have weight 1, and the other control points p1, p2, p4, and p5 have weight 1 2 . Exercise VIII.11 on page 225 shows a way to prove the correctness of this B-spline curve.   230  B-Splines  continuous second derivatives. On the other hand, we know  see Section VIII.4  that degree three splines can have continuous second derivatives provided the knots have multiplicity one. Thus, we might hope to get better, smoother curves by using B-splines to interpolate a set of points.  Unfortunately, the B-spline curves that have been deﬁned so far are not particularly con- venient for this purpose; they have been deﬁned from control points, which merely inﬂuence the curve and usually are not interpolated; thus, the control points usually do not lie on the curve. When control points are interpolated, it is generally because of repeated knot values, but then the curve loses its good smoothness properties and may even have discontinuous ﬁrst derivatives.  Our strategy for constructing interpolating B-spline curves with good smoothness properties will be ﬁrst to choose knot positions and then solve for control points that will make the B- spline curve interpolate the desired points. The algorithm for ﬁnding the control points will be based on solving a system of linear equations, which will be tridiagonal and thus easily solved. Consider the following problem. We are given points q0, q1, q2, . . . , qn and positions u0, u1, u2, . . . , un with ui < ui+1 for all i. The problem is to ﬁnd a degree three B-spline curve q u  so that q ui   = qi for all i. This still leaves too many possibilities, and so we further make the rather arbitrary assumption that the B-spline curve is to be formed with the standard knot vector  [u0, u0, u0, u0, u1, u2, u3, . . . , un−2, un−1, un, un, un, un],  where the ﬁrst and last knots have multiplicity 4 and the rest of the knots have multiplicity 1.  Refer to Exercises VIII.6 and VIII.7 for a qualitative understanding of the blending functions deﬁned from this knot vector.  Note that there are n + 7 knot positions, and thus there must be n + 3 control points. The conditions are still not strong enough to determine the B-spline, fully for there are only n + 1 conditions q ui   = qi but n + 3 control points to be determined. Therefore, we make one more arbitrary assumption, namely, that the ﬁrst derivative of q u  at u0 and at un is equal to zero. This means that the ﬁrst two control points must be equal so  cid:3  that q   u0  = 0, and the last two control points must be equal so that q  cid:3    un  = 0.  The control points can thus be denoted  p0, p0, p1, p2, . . . , pn−2, pn−1, pn, pn.  q u  =  N0,4 u  + N1,4 u  p0 + n−1 cid:27   i=1  The equation for the curve q u  based on these knot positions and control points is  Ni+1,4 u pi +  Nn+1,4 u  + Nn+2,4 u  pn.  Since the ﬁrst and last knots have multiplicity 4, we have  q u0  = p0  and  q un  = pn  and thus need p0 = q0 and pn = qn. Theorem VIII.1 and the continuity of the blending func- tions tell us where these blending functions are nonzero, and so we have, for 1 ≤ i ≤ n − 1,  q ui   = Ni,4 ui  pi−1 + Ni+1,4 ui  pi + Ni+2,4 ui  pi+1.  Of course, we want this value to equal qi . Letting αi = Ni,4 ui  , βi = Ni+1,4 ui  , and γi = Ni+2,4 ui  , we want  qi = αi pi−1 + βi pi + γi pi+1.       VIII.13 Interpolating with B-Splines  231  We can write the desired conditions as a single matrix equation:  1 0 0 ··· α1 β1 γ1 0 ··· 0 α2 β2 γ2 0 0 0 α3 β3 γ3 ... . . .  . . .  ··· ··· 0 . . .  0 ... ···  ··· 0 αn−1 βn−1 γn−1 1  ··· 0  0  0       =     .  q0 q1 q2 q3 ... qn−1 qn  p0 p1 p2 p3 ... pn−1 pn  We need to solve this matrix equation to ﬁnd values for the control points pi . Because the matrix equation is tridiagonal, it is particularly easy to solve for the pi ’s. The algorithm that calculates the pi ’s uses two passes: ﬁrst, we transform the matrix into an upper diagonal matrix by subtracting a multiple of the ith row from the  i + 1 st row, for i = 1, 2, . . . , n − 1. This makes the matrix upper diagonal and in the form  1  2  γ1 0 ···  γ2 0 ···  1 0 0 ··· 0 β cid:3  0 0 β cid:3  0 0 0 β cid:3  ... . . .  ··· 0 ... γ3 0 ··· . . . . . . ··· 0 0 β cid:3  n−1 0  ··· 0  γn−1 1  0  3       =     .   cid:3  q  cid:3  0 q  cid:3  1 q  cid:3  2 q 3 ...  cid:3  n−1 q  cid:3  q n  p0 p1 p2 p3 ... pn−1 pn  Second, we can easily solve the upper diagonal matrix by setting pn = q n and setting pi =  cid:3   cid:3   q i  − γi pi+1  β cid:3  The complete algorithm for calculating the pi ’s is as follows:  i , for i = n − 1, n − 2, . . . , 0.     Pass One Set β cid:3  0 = 1; Set γ0 = 0;  cid:3  Set q 0 = q0; For i = 1, 2, . . ., n − 1 {  Set mi = αi  β cid:3  i−1; i = βi − mi γi−1; Set β cid:3  i = qi − mi q  cid:3   cid:3  i−1; Set q  } Set q   cid:3  n = qn;    Pass two  cid:3  Set pn = q    Same as qn. n; For i = n − 1, n − 2, . . ., 2, 1 { − γi pi+1  β cid:3  i ; } Set p0 = q   cid:3  Set pi =  q i     Same as q0.   cid:3  0;  Note that the algorithm is only linear time, that is, has runtime O n . This is possible because  the matrix is tridiagonal. For general matrices, matrix inversion is much more difﬁcult.   B-Splines  232  p6  p0  p7  p1  p5  p4  p3  p2  Figure VIII.18. Degree three interpolating spline. The dotted curve uses uniform knot spacing. The solid curve uses chord-length parameterization. It is clear that chord-length parameterization gives much better results. The interpolation points are the same as used for the interpolating Catmull–Rom and Overhauser splines shown in Figures VII.23 and VII.24 on pages 190 and 192.  The B-spline interpolating curve does not enjoy local control properties: moving a single interpolation point qi can affect the curve along its entire length. However, in usual cases, moving a control point has only slight effects on distant parts of the B-spline.  Figure VIII.18 shows an interpolating B-spline and can be compared with the earlier ex- amples of interpolating Catmull–Rom and Overhauser splines. The ﬁgure shows two curves. The dotted curve is based on uniformly spaced values for ui , with ui = i. The solid curve uses chord-length parameterization with the values ui chosen so that ui − ui−1 = pi − pi−1. Evidently, just like the Overhauser splines, B-spline interpolation can beneﬁt from the use of chord-length parameterization.   IX  Ray Tracing  Ray tracing is a technique that performs, by a single uniﬁed technique, global calculations of lighting and shading, hidden surface elimination, reﬂection and transmission of light, casting of shadows, and other effects. As such, it signiﬁcantly extends the local lighting models such as the Phong and Cook–Torrance lighting models from Chapter III. Ray tracing also eliminates the use of a depth buffer for hidden surface determination. In addition, it allows for many special effects and can create images that are more realistic looking than those that can be easily obtained by the methods we have discussed so far.  With all these advantages, ray tracing sounds too wonderful to be true; however, it has the big disadvantage of being computationally very expensive. Indeed, a single ray-traced image may take minutes, hours, or occasionally even days to render. For example, modern computer- animated movies routinely use ray tracing to render scenes; it is not unusual for an average frame of a movie to require an hour of computation time to render, and individual frames might require 10 hours or more to render. A quick calculation shows that this means that a movie with 24 frames per second, lasting for 100 minutes, may require 6,000 CPU days to render, which is over 16 CPU years! It is fortunate that individual frames can be ray traced independently in parallel, and it is common for animated movies to be developed with the aid of hundreds of computers dedicated to rendering images. Despite the high computational costs of ray tracing, it has become a widely used technique for generating high quality and photorealistic images – especially because computers are becoming cheaper and faster and ray tracing techniques are becoming more sophisticated.  The basic idea behind ray tracing is to follow the paths of light rays around a 3-D scene. Typically, one follows the light rays’ paths from the position of the viewer back to their source. When light rays hit objects in the 3-D scene, one computes the reﬂection direction for the light ray and continues to follow the light ray in the reﬂection direction. Continuing this process, perhaps through multiple reﬂections  and possibly transmissions through transparent media , one can trace the path of a light ray from its origination at a light source until it reaches the view position.  Ray tracing is generally combined with a local lighting model such as the Phong or the Cook–Torrance model but adds many global lighting effects that cannot be achieved with just these local lighting models. The global lighting phenomena that can be obtained with basic ray tracing include the following:   Reﬂections – glossy or mirror-like reﬂections.   Shadows – sharp shadows cast by lights.   Transparency and refraction.  233   234  Ray Tracing  The basic form of ray tracing is covered in Section IX.1. That section discusses the way rays are traced backwards from the view position to the light sources. It also discusses the mathematical models for transmission of light through semitransparent materials. The basic ray tracing method can generate effects such as reﬂection, transparency, refraction, and shadows. There are many more advanced models of ray tracing. Many of these go under the name of “distributed ray tracing” and involve tracing a multiplicity of rays. Applications of distributed ray tracing include antialiasing, depth of ﬁeld, motion blur, and simulation of diffuse light- ing. Distributed ray tracing is covered in Section IX.2.1. Section IX.2.2 covers the so-called backwards ray tracing, where light rays are traced starting from the positions of the lights.  OpenGL does not support ray tracing, and so it is necessary to use custom code  such as the ray tracing code provided with this book  to perform all the rendering calculations from scratch. However, a variety of tricks, or “cheats,” exist that can be used in OpenGL to give effects similar to ray tracing with substantially less computation. Some of these are surveyed in Section IX.3.  Appendix B covers the features of a ray tracing software package developed for this book. The software package is freely available from the Internet and may be used without restriction. Radiosity is another global lighting method that is complementary in many ways to ray tracing. Whereas ray tracing is good at handling specular lighting effects and less good at handling special diffuse lighting effects, radiosity is very good at diffuse lighting effects but does not handle specularity. Radiosity will be covered in Chapter XI.  IX.1 Basic Ray Tracing  The basic idea behind ray tracing is to follow the paths taken by rays of light, or photons, as they travel from the light sources until they eventually reach the viewer’s eye position. Of course, most light rays never reach the eye position at all but instead either leave the scene or are absorbed into a material. Thus, from a computational point of view, it makes more sense to trace the paths traveled by rays of light from the eye by going backwards until eventually a light source is reached since, in this way, we do not waste time on tracing rays that do not ever reach the viewer.1  The simplest kind of ray tracing is illustrated in Figure IX.1. The ﬁgure shows, ﬁrst, a 3-D scene containing two boxes and a sphere  which are represented by two rectangles and a circle ; second, a single light source; and, third, a viewer. The viewer is looking at the scene through a virtual viewport rectangle, and our task is to render the scene as seen through the viewport. To determine the color of a pixel P in the viewport, a ray is sent from the eye through the center of the pixel, and then we determine the ﬁrst point of intersection of the ray with the objects in the scene. In the ﬁgure, the ray would intersect both the lower rectangle and the circle. However, it intersects the rectangle ﬁrst, and thus this is what is seen through the pixel. The point of intersection on the rectangle is shaded  colored  according to a local lighting model such as the Phong model, and the result is the contents of the pixel P.  In the simple form described so far, ray tracing would not achieve any new visual effects beyond those already obtainable by a local lighting model and the depth buffer hidden-surface algorithm. Indeed, so far all that has changed is that the depth buffer method of culling hidden  1  In a confusing twist of terminology, the process of following rays from the eye position back to their point of origin from a light is sometimes called forward ray tracing, whereas, tracing paths from a light up to the viewpoint is called backwards ray tracing. To add to the confusion, many authors reverse the meaning of these terms. Section IX.2.2 covers backwards ray tracing.   IX.1 Basic Ray Tracing  235  light  eye  viewport  Figure IX.1. The simplest kind of ray tracing, nonrecursive ray tracing, involves casting rays of light from the view position through pixel positions. A local lighting model is used to calculate the illumination of the surface intersected by the ray.  surfaces has been replaced by a ray tracing method for determining visible surfaces. More interesting effects are obtained with ray tracing as we add reﬂection rays, transmission rays, and shadow feelers.  Shadow Feelers A shadow feeler is a ray sent from a point u on the surface of an object towards a light source to determine whether the light is visible from the point u or whether it is occluded by intervening objects. As you will recall from Chapter III, the local lighting models  Phong or Cook–Torrance  do not form any shadows; instead, they assume that every light is visible at all times and that no objects are blocking the light and creating shadows. Examples of shadow feelers are shown in Figure IX.2: four rays are traced from the eye through the centers of four pixels in the viewport  not shown  until they hit points in the scene. From each of these four points, a ray, called a shadow feeler, is traced from the point to the light source. If the shadow feeler hits an object before reaching the light, then the light is presumed to be occluded by the object so that the point is in a shadow and is not directly lit by the light. In the ﬁgure, two of the shadow feelers ﬁnd intersections; these rays are marked with an “X” to show they are blocked. In one case, a point on the box surface is being shadowed by the box itself.  Reﬂection Rays What we have described so far accounts for light rays that originate from a point light, hit a surface, and then reﬂect from the surface to the eye. However, light can also travel more complicated paths, perhaps bouncing multiple times from surfaces before reaching the eye. This phenomenon can be partially simulated by adding reﬂection rays to the ray tracing algorithm. When a ray from the eye position hits a surface point, we generate a further reﬂection ray in the direction of perfect specular reﬂection. This reﬂection ray is handled in the same way as the ray from the eye; namely, we ﬁnd the ﬁrst point where it hits an object in the scene and calculate that point’s illumination from all the light sources. This process can continue recursively with reﬂection rays themselves spawning their own reﬂection rays.   Ray Tracing  light  236  eye  eye  Figure IX.2. Shadow feelers: Rays from the eye are traced to their intersections with objects in the scene. Shadow feeler rays, shown as dotted lines, are sent from the points in the scene to each light to determine whether the point is directly illuminated by the point light source or whether it is in a shadow. The two shadow feelers marked with an “X” show that the light is not directly visible from the point.  This process is illustrated in Figure IX.3, where a single ray from the eye hits an object, and from this point another ray is sent in the direction of perfect specular reﬂection. This second ray hits another object, then generates another reﬂection ray, and so on.  Although it is not shown in Figure IX.3, each time a ray hits an object, we generate shadow feelers to all the light sources to determine which lights, if any, are illuminating the surface. In Figure IX.3, the ﬁrst and third points hit by the ray are directly illuminated by the light; the second point is not directly illuminated.  The purpose of tracing reﬂections is to determine the illumination of the point that is visible to the viewer  i.e., of the point hit by the ray from the eye through the pixel position . This is  light  Figure IX.3. Reﬂection rays: The path of the ray from the eye is traced through multiple reﬂections. This calculates approximations to the lighting effects of multiple reﬂections.   IX.1 Basic Ray Tracing  237  light  eye  Figure IX.4. Transmission and reﬂection rays: The path of the ray from the eye is traced through multiple reﬂections and transmissions. Reﬂection rays are shown as solid lines, and transmission rays as dotted lines. The shadow feeler rays would still be used but are not shown.  computed by a formula of the form  I = Ilocal + ρrg Ireﬂect.  IX.1  Here, Ilocal is the lighting as computed by the local illumination model  Phong lighting, say , and Ireﬂect is the lighting of the point in the direction of the reﬂection ray. The scalar ρrg is a new material property: it is a factor specifying what fraction of the light from the reﬂection direction is reﬂected. Like the diffuse and specular material properties, the ρrg value is wavelength dependent, and thus there are separate reﬂection coefﬁcients for red, green, and blue. The subscript “rg” stands for “reﬂection, global.” The intensity of the incoming reﬂected light, Ireﬂect, is computed recursively by Equation IX.1.  Sections IX.1.1 and IX.1.3 give more details about how the local lighting is calculated and  about the recursive calculations.  Transmission Rays Ray tracing can also model transparency effects by using transmission rays in addition to reﬂection rays. Transmission rays can simulate refraction, the bending of light that occurs when light passes from one medium to another  e.g., from air into water .  A transmission ray is generated when a ray hits the surface of a transparent object: the transmission ray continues on through the surface. Refraction causes the direction of the transmitted ray to change. This change in direction is caused physically by the difference in the speed of light in the two media  air and water, for instance . The amount of refraction is calculated using the index of refraction, as discussed in Section IX.1.2.  Transmitted rays are recursively traced in the same manner as reﬂected rays. Of course, the transmission rays may be inside an object, and their ﬁrst intersection with the scene could be the boundary of an object hit from the inside. When the transmitted ray hits a point, it will again spawn a reﬂection ray and a transmission ray. This process continues recur- sively. Figure IX.4 illustrates the generation of both reﬂection and transmission rays. In the ﬁgure, a single ray from the eye is traced through three bounces, spawning a total of 12 addi- tional rays: the transmission rays are shown as dotted lines to distinguish them from reﬂection rays.   238  Ray Tracing  I in   cid:7   n  Ireflect  rv  I  v  Figure IX.5. The usual setup for reﬂection rays in basic recursive ray tracing. The vector v points in the direction opposite to the incoming ray. The direction of perfect reﬂection is shown by the vector rv. The vector  cid:7  points to a point light source, I is the outgoing light intensity as seen from the direction given by v, Ireﬂect is the incoming light from the reﬂection direction rv. and I in is the intensity of the light from the light source.  Compare this with Figure III.7 on page 72.   When transmission rays are used, the lighting formula has the form  I = Ilocal + ρrg Ireﬂect + ρtg Ixmit.  The new term ρtg Ixmit includes the effect of recursively calculating the lighting in the trans- mission direction scaled by the material property ρtg. The scalar ρtg is wavelength dependent and speciﬁes the fraction of light transmitted through the surface. The subscript “tg” stands for “transmission, global.”  IX.1.1 Local Lighting and Reﬂection Rays  We now give more details about the calculation of reﬂection rays and the associated lighting calculations. The basic setup is shown in Figure IX.5, where we are tracing the path of a ray whose direction is determined by the vector v. In keeping with our usual conventions that the vectors are pointing away from the point of intersection with the surface, the vector v is actually pointing in the opposite direction of the ray being traced.  The ﬁgure shows the traced ray as emanating from an eye position, but the ray could more generally emanate from another intersection point instead.  We assume v is a unit vector. Also, n is the unit vector normal to the surface at the point of intersection.  The direction of perfect reﬂection is shown as the vector rv. This is calculated according to  the formula  rv = 2 v · n n − v,  which is derived in the same way as the formula for the reﬂection vector in Section III.1.2.2  The basic ray tracing algorithms depend on the use of a particular local lighting model: this is commonly either the Phong lighting model or the Cook–Torrance lighting model; the discussion that follows will presume the use of the Phong lighting model  it is straightforward to substitute the Cook–Torrance model in its place . The illumination of the point on the surface as seen from the ray trace direction v is given by the formula  I = Ilocal + ρrg Ireﬂect.  The Ilocal term is the lighting due to direct illumination by the lights that are visible from the intersection point.  For a given light i, let  cid:7 i be the unit vector in the direction of the light. Then let δi equal 1 if the light is above the surface and is directly illuminating the point as determined by a shadow  IX.2  IX.3  2 The reﬂection vector is named rv instead of r to avoid confusion with the reﬂection of the light vector  cid:7   of Section III.1.2.   IX.1 Basic Ray Tracing  239  n  θv  v  vlat  tlat  t  θt  tperp  Figure IX.6. Computing the transmission ray direction t. The horizontal line represents the surface of a transmissive material; n is the unit vector normal to the surface. The vector v points in the direction opposite to the incoming ray. The direction of perfect transmission is shown by the vector t. The vectors vlat and tlat are the projections of these vectors onto the plane tangent to the surface, and, tperp is the projection of t onto the normal vector.  feeler; otherwise, let δi equal 0. The value of δi is computed by determining whether the light is above the surface by checking whether  cid:7 i · n > 0; if so, a shadow feeler is used to determine visibility of the light. The illumination due to the light i is deﬁned as  I i local  = ρa I in,i  a  + δi ·  ρd I in,i  d    cid:7 i · n  + ρs I in,i   rv ·  cid:7 i   f  s  .  IX.4  ’     You should compare this to Equation III.6 on page 74. We are here using the notations I in,i− for the light coming from the ith light. The term r · v has been replaced by rv ·  cid:7 i , which is clearly mathematically equivalent.  The net local lighting due to all the lights above the surface and incorporating all the  wavelengths is obtained by summing the illumination from all the lights:  Ilocal = ρa ∗ Iin  a  + ρd ∗ k cid:27   i=1    cid:7 i · n  + ρs ∗ k cid:27   i=1  δi Iin,i d   rv ·  cid:7 i   f + Ie,  δi Iin,i  s  which is similar to Equation III.9 on page 75. As before, the values ρa, ρd, ρs are tuples of coefﬁcients with one entry per color, and ∗ denotes a component-wise product. The value of Iin a is still given according to Formula III.10.  The second term in Equation IX.3 contains the new material property ρrg: this coefﬁcient is a scalar and can vary with wavelength  i.e., it is different for each color . The light intensity Ireﬂect is computed recursively by iterating the ray tracing algorithm.  IX.1.2 Transmission Rays  Now we turn to the details of how the ray tracing calculations work for transmission rays. First, we discuss how to compute the direction t of perfect transmission. The setup is shown in Figure IX.6.  The direction of the transmission vector t is found using the incoming direction v and the surface normal n with the aid of Snell’s law. Snell’s law relates the angle of incidence with the angle of refraction by the formula  = η.  sin θv sin θt   240  Ray Tracing  Here, θv, the angle of incidence, is the angle between v and the normal n; and θt , the angle of refraction, is the angle between the transmission direction t and the negated normal. The index of refraction, η, is the ratio of the speed of light in the medium above the surface  the side where v is  to the speed of light in the medium below the surface  the side where t is . Typical values for η are approximately equal to 1.3 for rays going from air to water, and approximately equal to 1.5 for rays going from air to glass. For the reverse direction you need the reciprocal, and so when traveling from water or glass to air the index of refraction would be approximately 1 1.3 or 1 1.5. Snell’s law can be derived from the wave model for light and can be found in many elementary physics books. Snell’s law can be rewritten as  sin θt = η−1 sin θv.  Now, if η < 1, it can happen that η−1 sin θv is greater than 1. Of course in this case there is no possible angle θt that satisﬁes Snell’s law. This corresponds to total internal reﬂection, where there is no transmission but only reﬂection. This happens only if η < 1, which is the case if light is traveling in a region of lower light speed  e.g., inside a medium such as glass or water  and is exiting to a medium, such as air, with a higher speed of light. In addition, this happens only when the angle of incidence is sufﬁciently large that the quantity η−1 sin θv is larger than 1.  We can derive a method of computing t from n and v as follows. Let vlat be the component  of v that is orthogonal to the normal vector, namely,  vlat = v −  v · n n.   The subscript “lat” stands for “lateral.”  Note that vlat = sin θv. Therefore, the component, tlat, of t orthogonal to n has magnitude equal to  tlat = sin θt = η−1 sin θv = η−1vlat.  If tlat ≥ 1, then total internal reﬂection occurs. Otherwise, if tlat < 1, we can continue the computation of the transmission direction. Since tlat points in the direction opposite to vlat, this means that  The component of t in the direction of the negation of the normal vector has magnitude equal to  tlat = − η−1vlat.  cos θt =  and therefore is equal to  tperp = − Finally, we have  t = tlat + tperp,   cid:20  1 − tlat2,   cid:19  1 − sin2 θt =  cid:20   1 − tlat2 · n.  which completes the calculation of the transmission direction.  Exercise IX.1 An alternative calculation of the transmission vector uses  tperp = −  1 − η−2 1 −  v · n 2  · n.  Prove that this formula is correct too.   cid:20    IX.1 Basic Ray Tracing  241  Light   a   Light   b   Figure IX.7.  a  Diffusely transmitted light.  b  Specularly transmitted light. The specularly transmitted light is centered around the transmission direction from Snell’s law.  The exercise lets us give a closed form expression for t:  t = η−1  v · n n − v  −  1 − η−2 1 −  v · n 2  · n   cid:20   IX.5  provided the formula in the square root is nonnegative. If the value in the square root is negative, then there is no transmission ray at all and we have total internal reﬂection.  To summarize, here is our preferred algorithm for computing the transmission ray:  CalcTransmissionDirection  v, n, η   {  Set tlat =   v · n n − v  η; Set sinSq = tlat2; If   sinSq>1   { } tlat − √ Set t Return t;  =  1 − sinSq · n;  }     sin2 θt    Return ``No transmission --- total internal reflection!'' ;  Next, we give details on how to extend the Phong lighting model to apply to transmission of light.  The Cook–Torrance or other local lighting models could be used instead, but we only discuss the Phong-style lighting model.  The new aspect of local lighting is that a transparent surface may now be illuminated by a light that lies on the far side of the surface. That is to say, the light may be on the opposite side of the surface from the viewer or incoming ray. As in the case of reﬂective illumination, transmitted illumination is modeled as having separate diffuse and specular components. These two kinds of illumination are shown in Figure IX.7; you should compare these with Figures III.2 and III.3 on page 69. The diffusely transmitted light is transmitted equally in all directions; the specularly transmitted light is transmitted primarily in the direction of perfect transmission.  The Ilocal term for the transmitted illumination from a light i that is on the opposite side of  + δ cid:3   ·  i  ρdt I in,i d    cid:7 i ·  −n   + ρst I in,i   t ·  cid:7 i   f  s  ,  IX.6  where ρdt and ρst are material properties for diffuse and specular transmitted light  these can reasonably be taken to just equal ρd and ρs in some cases . The value δ cid:3  i is equal to 1 if the light is below the surface and the surface point is visible from the light, as determined by a shadow feeler. Otherwise δ cid:3  i is equal to zero. Equation IX.6 needs to be used only when the = 1, and so  cid:7 i · n < 0; otherwise, Equation IX.4 would be light is behind the surface and δ cid:3  used instead. Figure IX.8 shows the vectors used in the application of Equation IX.6.  i  the surface is given by = ρa I in,i  I i local  a  ’      242  n  Ray Tracing  Ilocal  v  I in   cid:7   t  Figure IX.8. The vectors used in the computation of transmitted light are v,  cid:7 , t, and n. The vector v points in the direction opposite to the incoming ray. The direction of perfect transmission is shown by the vector t. The direction opposite to the incoming light is given by  cid:7 .  The full local lighting formula, incorporating both reﬂected and transmitted illumination  as well as all wavelengths, can be given as  Ilocal = ρa ∗ Iin  + ρd ∗ k cid:27   i=1  a  + ρdt ∗ k cid:27   i=1  δ cid:3  i Iin,i d    cid:7 i · n  + ρs ∗ k cid:27    cid:7 i ·  −n   + ρst ∗ k cid:27   δi Iin,i d  i=1  i=1  For each particular light i, at most one of δi and δ cid:3  be both above and below the surface.   rv ·  cid:7 i   f  δi Iin,i  s  δ cid:3  i Iin,i s   t ·  cid:7 i  f + Ie.  IX.7  i can be nonzero since the light source cannot  IX.1.3 Putting It All Together  We have ﬁnished the discussion of all the features of the basic form of recursive ray tracing. These are combined into a recursive routine for ray tracing. The main loop of the recursive routine loops over every pixel in the image and forms the ray from the eye through that pixel. With that ray, a routine RayTrace is called, which does the following:  1. Finds the ﬁrst place where the ray intersects the scene. If the ray does not hit any object in  the scene, then a default “background color” is used for the illumination level. 2. Calculates the illumination of that point according to the local lighting model. 3. Spawns a reﬂection ray and a transmission ray as appropriate. 4. Calls itself recursively with the reﬂection ray and with the transmission ray. 5. Combines the resulting illumination levels and returns.  In addition, a stopping criterion is needed to terminate the recursive calls to RayTrace: an easy, albeit rather arbitrary, stopping criterion is just to trace recursively to only a ﬁxed number of levels, or “bounces.” This is the approach we take in the pseudocode that follows.  Here is the main program for basic recursive ray tracing: RayTraceMain   {     Let x be the position of the viewer.    Let maxDepth be a positive integer. For each pixel p in the viewport, do {  Set u = unit vector in the direction from x to p.   IX.1 Basic Ray Tracing  243  Call RayTrace  x, u, maxDepth  ; Assign pixel p the color returned by RayTrace.  }  }  The recursive ray tracing routine is given next.  RayTrace  s, u, depth   {     s is the starting position of the ray.    u is unit vector in the direction of the ray.    depth is the trace depth.    Return value is a 3-tuple of color values  R,G,B .     Part I - Nonrecursive computations Check the ray with starting position s and direction u  against the surfaces of the objects in the scene. If it intersects any point, let z be the first intersection point and n be the surface normal at the intersection point.  If no point was intersected { Return the background color. } For each light {     Reached maximum trace depth.  Generate a shadow feeler from z to the light. Check if the shadow feeler intersects any object. Set δi and δ cid:3   i appropriately.     Use equation IX.7  } Set color = Ilocal;    Part II - Recursive computations If   depth==0   { }    Calculate reﬂection direction and add in reﬂection color If   ρrg  cid:16 = 0   {    if nonzero reﬂectivity  Return color;  Set r = u − 2 u · n n;    Eq. IX.2 with v = −u. Set color = color + ρrg∗RayTrace z, r, depth-1 ;  }    Calculate transmission direction  if any  and add in transmitted color If   ρtg  cid:16 = 0   {     if has transparency     Let η be the index of refraction. Set t = CalcTransmissionDirection −u, n, η ; If t is defined { }     if not total internal reﬂection Set color = color + ρtg∗RayTrace z, t, depth-1 ;  } Return color;  }  The basic recursive ray tracing algorithms have now been completely deﬁned with one notable exception; namely, we have not discussed how to ﬁnd intersections of a ray with objects in the virtual scene. The basic idea is to model each object in the scene as a geometric   244  Ray Tracing  object such as a sphere, cylinder, cone, or torus, or as a polygonal object with a surface comprising ﬂat polygonal faces, or as being bounded by more general surfaces such as B´ezier or B-spline patches. Then, we have to test the ray against each surface of each object for possible intersections. Further, it is important that the intersection testing algorithms be computationally efﬁcient because we have to perform the test for every ray and every shadow feeler. Indeed, it is typically the case that the computation time required for intersection testing is the major portion of the execution time in ray tracing.  The discussion of how to perform the intersection tests for rays against common surfaces  is left to Chapter X.  The basic ray tracing algorithm, with recursive calls and intersection testing, is much too slow for real-time rendering. Suppose, for instance, that the screen has about one million pixels and that each ray is traced to a depth of six bounces  i.e., starting with maxDepth set to 5 . In the worst case, each intersection will spawn both a reﬂection ray and a transmission ray and so for each pixel we trace a total of 1 + 2 + 4 + ··· + 25 = 63 rays. In the best case, there is no transmission; consequently, each pixel requires us to trace six rays. In addition, for each light and each intersection point, we must intersect a shadow feeler against the scene. Thus, all in all, we may need to handle tens of millions, or even hundreds of millions, of rays, each ray needing to be tested for intersections with objects in the scene. It is common for this process to take several minutes on a modern-day personal computer. Given the amount of work being performed, one feels lucky that it takes only this long!  IX.2 Advanced Ray Tracing Techniques  IX.2.1 Distributed Ray Tracing  Distributed ray tracing, ﬁrst introduced by  Cook, Porter, and Carpenter, 1984 , is a collection of techniques used to extend the functionality of ray tracing by increasing the number of rays that are traced. Generally speaking, distributed ray tracing is signiﬁcantly slower than basic recursive ray tracing; however, it can achieve a variety of additional effects. In this section, we describe some of the more common applications of distributed ray tracing.  Antialiasing with Multiple Eye-to-Pixel Rays In the basic ray tracing model, only one ray is sent from the eye position to each pixel. This means that only a single ray determines the color of a given pixel. However, in actuality, a pixel covers a square region of the image, and sometimes one would obtain better visual effects if the pixel were colored as an average color of the region subtended by the pixel. This average color can be approximated by supersampling the pixel, namely, by tracing multiple rays through the pixel with the rays spread more or less evenly across the pixel and then assigning the pixel the average of the colors from the multiple rays.  Two prominent applications in which forming an average pixel color can help with antialias- ing are  a  removing the “jaggies,” or pixel-sized bumps, from lines, edges, or other object boundaries; and  b  viewing texture maps. We have already discussed two ad hoc solutions to these problems:  a  lines can be smoothed through blending and transparency, and  b  texture map aliasing can be minimized by using mipmapping. Distributed ray tracing gives a more general solution to these and other related problems.  Supersampling and stochastic supersampling were discussed earlier in Section V.1.4 in the context of texture maps. Supersampling consists of selecting multiple subpixel locations.   IX.2 Advanced Ray Tracing Techniques  245   a  No supersampling.   b  Supersampling with jittered subpixel centers.  Figure IX.9. An example of antialiasing using jittered subpixel centers.  a  The scene rendered without supersampling; note the “jaggies” on the silhouettes of the balls, for instance.  b  The scene with pixels selectively supersampled up to a maximum of 40 times. See Color Plate 9.  Distributed ray tracing can trace separate rays from the eye to each subpixel location and then average the results. The strategies described in Section V.1.4 apply also to ray tracing; in particular, jittering is also a recommended method for selecting subpixel locations for distributed ray tracing  see Figure V.7 on page 134 .  Figures IX.9 and IX.10 show an example of antialiasing with jittered pixel supersampling.  Depth of Field with Jittered Eye Positions Depth of ﬁeld is caused by a lens’s focusing on objects at a given depth, thereby making objects that are either nearer or farther than the focus depth appear out of focus. This is particularly noticeable in movies when a camera switches from focusing up close to focusing far away or vice versa. Pinhole cameras and lenses with a very small aperture are not affected nearly so much by depth of ﬁeld. Depth of ﬁeld affects human eyes as well; however, your visual system compensates for this so that you do not notice it under normal circumstances. Computer graphics systems calculate images purely virtually and do not require physical focusing devices, and so of course they are not affected by depth-of-ﬁeld focusing problems. Nonetheless, it is sometimes desirable to simulate depth of ﬁeld in computer graphics.  Ray tracing allows depth-of-ﬁeld effects by jittering the eye position while keeping the focal plane ﬁxed. For this, you set up the virtual viewport in the plane of the image you wish to   246  Ray Tracing   a  No supersampling.   b  Supersampling with jittered subpixel centers.  Figure IX.10. Close-up views of the images in Figure IX.9. See Color Plate 10.  have in focus. Then, for each pixel, you trace multiple rays from jittered eye positions to the center of the pixel  the pixel’s center being kept ﬁxed in the focal plane . For instance, one possibility is to jitter the eye position to nine  or more  positions with the jittered positions obtained by moving the eye position up or down, and left or right. Then, from each jittered position, perform ray tracing as usual: the ﬁnal color of the pixel is the average of the results of the multiple ray traces.  The effect of jittering the eye position is that objects that lie in the focal plane  and are visible to the eye  are always hit exactly, and each of the multiple ray traces hits the same point and yields essentially the same results. On the other hand, objects that are either nearer or farther than the focal plane are hit differently from different jittered eye positions, and the averaging tends to blur them. Figure IX.11 shows how the rays converge and diverge to focus objects in the focal plane and blur objects at other depths. Figure IX.12 shows an example of depth of ﬁeld.  It is important that you choose the jittered positions for the eye separately for each pixel, that is, do not use the same jittered eye positions for all the pixels but instead use new jittered positions for each pixel. The problem with reusing the same jittered positions is that the result   IX.2 Advanced Ray Tracing Techniques  247  focal plane  Figure IX.11. The rays from the jittered viewpoints converge at the focal plane but not at the back plane.  would be a composite of multiple copies of the scene from slightly different viewpoints rather than an actual blurring of the scene.  Motion Blur Motion blur renders fast-moving objects as blurs or streaks to indicate their speed; an example is shown in Figure IX.13. Motion blur can be accomplished by jittering objects’ positions backwards in time. This can be done as follows: each time the high-level ray tracing routine begins tracing a ray from the eye position to a pixel, the moving object s  are moved back to their position at a small time, δt, in the past. The δt values should be chosen at random and independently. It probably would be best to adjust the probabilities so that small δt values are more likely than large ones. For instance, you could use the following algorithm to choose k jittered values for δt: First choose values ai randomly and independently from the intervals [ i k  k ], for 0 ≤ i < k. Then set bi by , i+1 bi = a2  .  i  Finally, set the ith jitter value δt equal to bi  cid:15 t, where  cid:15 t is the time period over which the motion blur should extend.  That is, large  cid:15 t values make the motion blur trail longer.  Calculating the δt values using the bi ’s instead of the ai ’s has the effect of compressing them to be closer to zero: the intended visual effect is that the motion blur trail fades out smoothly.  Soft Shadows with Extended Lights and Jittered Shadow Rays Up until now, we have discussed only point light sources. However, few light sources are modeled well by points. Most lights are either roundish or spherical  such as the sun or light  Figure IX.12. An example of depth of ﬁeld. The front of the eight ball is the focal plane. Note also the blurring of the checkerboard plane. In this image, each pixel is selectively supersampled up to 40 times. The eye positions and the subpixel positions were independently jittered as described on page 249. See Color Plate 11.   248  Ray Tracing  Figure IX.13. An example of motion blur. Pixels were selectively supersampled up to 40 times. Both motion supersampling and subpixel supersampling were used. See Color Plate 12.  bulbs  or are rectangularly shaped  such as ﬂuorescent lights in the ceiling behind a plastic cover . The term “extended light” refers to any nonpoint source.  Extended lights differ from point lights in several important ways. Mainly, an extended light source may be partially occluded. As a consequence, an extended light will not cast perfectly sharp shadows and generally gives a softer, smoother lighting effect. Figure IX.14 illustrates how soft shadows work. It shows a spherical light source shining on a wall with an obstruction shadowing part of the wall. Where the obstruction blocks the entire light, the wall is completely in shadow. But there is a region, called the penumbra, where the obstruction blocks only part of the spherical light. In the penumbra, the shadowing transitions smoothly from completely shadowed to completely illuminated.  Ray tracing can be used to simulate penumbra effects by casting multiple shadow feelers instead of a single shadow feeler. The shadow feelers should be more or less evenly distributed across the extent of the light as seen from the point being illuminated. The fraction of shadow feelers not ﬁnding an obstruction between the point of illumination and the light can be used as an estimate of the fraction by which the light is occluded. The lighting from the that light is then reduced correspondingly by the same fraction.  As usual, one gets better effects by randomly choosing positions on the light’s extent as seen by the point of illumination and then casting shadow feelers to those positions on the light. If you were to pick ﬁxed points on the light as the targets for shadow feelers, then the penumbra would show banding: there would be noticeable changes in the shading where each ﬁxed light point vanished from view. Jittering can be used to good effect to help distribute the shadow feeler targets evenly over the extent of the light.  Light  Full shadow  Full illumination  Penumbra  Penumbra  Full illumination  Figure IX.14. The penumbra is the area where the light is only partly blocked.   IX.2 Advanced Ray Tracing Techniques  249  Using Multiple Techniques at Once It is possible to combine multiple distributed ray tracing techniques to achieve more than one effect at once. For instance, you can render an image that has both antialiasing and depth of ﬁeld. To do this, you would jitter subpixel locations for antialiasing and jitter the eye position for depth of ﬁeld. At ﬁrst glance, this might seem to require tracing many more rays. That is, if each pixel has nine jittered subpixel locations and nine jittered eye positions, then one might try casting 92 = 81 rays from the eye to the pixel, one for each choice of eye position and pixel position. Fortunately, this large increase in the number of rays is not necessary. We can instead cast rays from each eye position and to each subpixel position but use only one ray for each eye position and choose one jittered subpixel position for each eye position. For best results, you need to make sure that the choices of jittered subpixel positions are independent of the jittered eye positions. In particular, suppose the jittered subpixel positions are chosen from square subpixels, as shown in Figure V.7 on page 134. Also suppose that the eye positions are chosen in a similar manner by jittering the centers of an array of squares around the central view position. Then you should choose a random assignment of subpixel positions to eye positions  i.e., a random one-to-one correspondence between subpixel positions and eye positions  and then recursively trace one ray from each eye position to its corresponding pixel position. The point of using the random assignment is to avoid having a correlation between the jittered eye positions and jittered pixel positions that could cause unwanted visual effects.  The high-level algorithm for this is as follows:  Variables:  Array p[N ]: An array for holding N subpixel positions. Array e[N ]: An array for holding N eye locations. Array π[N ]: An array that holds a permutation of [0, . . . , N − 1]  For each pixel: {  Fill p[] with N jittered subpixel locations. Fill e[] with N jittered eye positions. Choose π a random permutation of [0, . . . , N − 1]. For i = 0, . . . , N − 1 { }  Recursively ray trace with ray from e[i] to p[π[i]].  } To choose a random permutation of [0, . . . , N − 1], you can use the following code. We  use the function RandInt i  to compute a random integer in the range 0, . . . , i. RandomPermutation N   {  For i = 0, . . . , N − 1 { Set π[i] = i; } For i = N − 1, N − 2, . . . , 1 { Set j = RandInt i ; If j < i  Swap values of π[ j] and π[i];  }  }  Similar methods can be used to combine other distributed ray tracing methods.   250  Ray Tracing  Multiple Colors For greater realism, one can perform ray tracing for more colors than just the primary red, green, and blue colors. In addition, the speed of light in a medium typically depends on the wavelength of the light. For refraction, this means that the transmission direction varies with color: a good example of this is a prism splitting white light into a spectrum of wavelengths. In addition, in some local lighting models  such as Cook–Torrance, but not in the Phong model , the dominant reﬂection angle is also wavelength dependent. Thus, for more realistic results with multiple colors, one may wish to trace multiple reﬂection and transmission rays from a single ray–object intersection.  Path Tracing. Tracing Diffuse Reﬂection and Transmission The basic ray tracing methods described so far are a hybrid of  a  a local lighting model that includes ambient and diffuse lighting terms, and  b  ray tracing perfect reﬂection and perfect transmission directions. This hybrid is far from physically correct and contains several undesirable features. For example, the local lighting model has a term for ambient light, which is needed because of our inability to trace all rays of light completely. Similarly, the basic ray tracing model does not allow the illumination of a diffuse surface to illuminate other surfaces in the scene. For instance, in the real world, a diffusely lit red wall will itself illuminate nearby objects with reddish light; ray tracing, however, will not simulate this because it only follows reﬂections in the direction of perfect, specular reﬂection.  It would be more physically realistic if we could completely subsume the ambient and diffuse lighting from the local lighting model into the global methods of ray tracing. In essence, this would mean trying to trace all the photons in the entire scene to track the entire ﬂow of light throughout the scene. If this could be successfully done, then it would be possible to unify the local lighting models with the ray tracing model: for instance, one would use the same lighting models for both reﬂected and transmitted rays as for rays to light sources.  Several techniques are used to try to increase the realism of the ray tracing model by capturing more effects of diffuse and ambient reﬂection. The main idea behind these techniques is to try to follow reﬂection  and perhaps transmission  rays in all possible directions, not just in the direction of perfect reﬂection. Unfortunately, this requires spawning a huge number of reﬂection rays in hundreds, or thousands, of directions. This is often done via a technique called path tracing. In path tracing, one generates many rays starting at the eye position through a given pixel. At each intersection, the subsequent reﬂection direction is chosen by a random procedure. In this way, one attempts to sample a large number of representative paths by which light can reach the eye.  When tracing multiple reﬂection directions, one must also still trace shadow feelers to the lights and calculate direct illumination from the lights. Of course, this can be com- bined with extended lights and the use of multiple shadow feelers per light to create soft shadows.  The big drawback to tracing so many reﬂection directions is that it greatly increases the number of rays that must be traced by a factor of a thousandfold or more. These techniques are therefore very time consuming, and can require hours of computation time to trace a single image.  Path tracing can also be combined with so-called backwards ray tracing. Backwards ray tracing follows rays of light starting at the light source through one or more bounces and tracks the ﬂow of light from the light source towards the eye. Backwards ray tracing is discussed brieﬂy in the next section.   IX.2 Advanced Ray Tracing Techniques  251  Another global lighting method, called radiosity, can also be used to simulate the ﬂow of diffuse lighting through a scene. Radiosity is based on a method quite different from ray tracing and is covered in Chapter XI.  IX.2.2 Backwards Ray Tracing  Ray tracing as described so far has involved tracing paths of light starting at the eye position and ending at lights. It is also possible to trace light in the other direction by starting at light sources and tracing the paths taken by light from the light sources. This process is called backwards ray tracing. The name is somewhat misleading, since backwards ray tracing involves tracing the forward movement of light from the light source. The usual ray tracing, however, sometimes called forward ray tracing, traces backwards from the eye along the paths taken by light.  The difﬁculty with backwards ray tracing is that most of the light exiting light sources never reaches the eye position at all but instead either leaves the scene entirely or is attenuated by multiple bounces until it is insigniﬁcant. Thus, a pure backwards ray tracing algorithm would be much more computationally intensive than forward ray tracing. For this reason, backwards ray tracing is generally used in conjunction with forward ray tracing.  The most common methods use backwards ray tracing to track the overall distribution of light throughout the scene and then use forward ray tracing to view the lit scene.  Radiosity is another method with a similar idea.  The ﬁrst such method was the method of illumination maps introduced by  Arvo, 1986 . For illumination maps, all the surfaces of objects in the scene are parameterized and then gridded up into small patches. Then, numerous light rays are traced forward from the light sources through multiple bounces. Each time a light ray hits a surface, it is determined which surface patch is hit and the color and intensity of the illuminating light are applied to the patch. These color and intensity values are stored at the vertices of the patch, and the light color and intensity are distributed to each vertex roughly in proportion to the distance of the intersection point from the vertex  more precisely: by inverting linear or bilinear interpolation to get the weight coefﬁcients . The corners of the surface patches are used as accumulators, and, at the end of the backwards ray tracing phase, they hold the sum of all the weighted illumination from all the light rays that hit neighboring patches. These vertices and their stored illumination values are together called an illumination map. After the illumination map has been created, forward ray tracing can be used to view the scene. For the forward ray tracing, the diffuse component of the lighting model is omitted; instead, the illumination map values are used for the diffuse lighting. More precisely, when a ray hits a patch, the intersection point is expressed as a weighted average of the corners of the patch, and the illumination levels at these vertices are combined using the corner weights to calculate the diffuse illumination at the intersection point.  A common visual effect that can be simulated well with illumination maps is the focusing of light through transparent objects. For example, light shining on a glass ball can create bright patterns on a surface under the glass ball, where the curvature of the ball has acted to focus many rays of light into a small area. Another visual effect that can be handled in this way is caustics. An example of caustics is seen in a pool of clear water in which small ripples on the surface of the water will bend light, creating rippling patterns of light on the bottom of the pool. A more recent method of extending illumination maps is that of photon maps  Jensen, 2001; Jensen and Christensen, 1995 . Unlike illumination maps, which store aggregate illumination levels at vertices on a surface, a photon map stores information about each individual light ray  i.e., photon  that hits the surface along with its color and intensity and possibly its direction.   252  Ray Tracing  Photon maps were originally invented to avoid needing to parameterize surfaces, but when they include direction information they can also be used to model specular light. An example of how direction information can help is when light is reﬂected off a mirror and then strikes a surface at point x. Then, a viewer looking at point x slightly off the direction of perfect specular reﬂection will still be able to see the specular highlight, for it can be calculated from the photon map.  Using a photon map allows one to drop both the diffuse and specular terms from the local lighting model. In fact, if the backwards ray tracing is carried out sufﬁciently far, through enough bounces, then sometimes even the ambient light term can be omitted from the local lighting formula. Photon maps are also used for illumination of volumes, for light scattering, and for translucency, see  Jensen, 2001 .  Another form of backwards ray tracing is bidirectional path tracing  Lafortune and Willems, 1993; Veach and Guibas, 1994 . In bidirectional path tracing, paths are traced both from light sources and from the eye and then are joined together.  Further Reading Our treatment of the more advanced topics in ray tracing has been quite cursory. Some of the top- ics we have completely skipped are  a  Monte-Carlo methods for choosing ray trace directions, importance sampling, and more sophisticated probability distributions than jittered samples;  b  Russian roulette methods for deciding when to stop tracing rays  Arvo and Kirk, 1990 ; and  c  participating media, such as smoke, fog, or atmosphere, which scatter light.  There are several good sources for more information about these and other ray tracing top- ics. The book  Glassner, 1989  has a collection of introductory articles about the techniques of ray tracing as developed before 1990. The textbook  Watt and Watt, 1992  has several chapters devoted to advanced topics in ray tracing along with pointers to the literature.  Shirley, 2000  has a nice overview of ray tracing, including several advanced topics.  Glassner, 1995  covers many advanced topics relevant for ray tracing. The online newsletter Ray Tracing News, also maintained by Glassner, has a huge amount of material on developments in ray tracing. Fi- nally, many of the recent developments in ray tracing can be found in conference proceedings and journals; the annual proceedings of the ACM Siggraph conference and the Eurographics conferences are good places to search for this literature.  Ray tracing was ﬁrst developed by  Whitted, 1980 : this seminal paper is remarkably read-  able and still relevant.  IX.3 Special Effects without Ray Tracing  Ray tracing is too complicated and too experimental to be included in a standard graphics API such as OpenGL. Indeed, if you want to write a ray tracing application in OpenGL, you must completely rewrite all the lighting models yourself, including standard routines like the calculation of Phong lighting.  However, a ray tracing package is included with this book and described in Appendix B.  On the other hand, many visual effects similar to those that can be achieved with ray tracing can also be obtained with much simpler and faster methods. We will discuss some of the more common of such methods in this section. Most of these can be done efﬁciently in OpenGL; the rest can generally be done efﬁciently by modern graphics hardware. Low-cost graphics boards for PCs are nowadays very sophisticated, have memory for computing and storing multiple textures, and even let the programmer download simple programs for remote real-time execution in the graphics pipeline.  Future releases of OpenGL are planned to allow the user to access these capabilities of graphics boards from OpenGL programs.    IX.3 Special Effects without Ray Tracing  253  Antialiasing Lines with Blending OpenGL includes automatic use of blending to antialias lines, points, and polygons. These can be enabled by giving the commands   ;  GL_POINT_SMOOTH , GL_NICEST  ;  GL_POINT_SMOOTH_HINT  GL_LINE_SMOOTH_HINT  GL_POLYGON_SMOOTH  GL_LINE_SMOOTH  GL_POLYGON_SMOOTH_HINT  glEnable   glHint   glEnable GL_BLEND ; glBlendFunc GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA ;  These commands cause OpenGL to render pixels that lie at the border of, and are partially covered by, a point or edge as partly transparent. This is done by giving the partially covered pixels an alpha value between 0 and 1 equal to the fraction of the pixel that is covered. As these pixels are drawn, the blending operation averages the drawn color  the source color  with the color already stored for the pixel  the destination color .  Antialiasing in this way works reasonably well for line and points but does not work as well for ﬁlled polygons. You should see the OpenGL programming manual for a more sophis- ticated way to antialias polygon edges, but that method requires performing your own depth calculations instead of using the depth buffer for hidden surface removal.  Motion Blur and Depth of Field with the Accumulation Buffer The OpenGL accumulation buffer is a memory region in which you can temporarily store and combine images. It is possible to render a scene multiple times, combine the results into the accumulation buffer, and ﬁnally display the composite image. OpenGL allows you to scale the accumulation buffer contents, and the accumulation buffer can be loaded from, and saved to, the current frame buffer.  By taking multiple snapshots and averaging them together into the frame buffer, you can obtain motion blur and depth of ﬁeld similar to those that can be achieved with distributed ray tracing. For motion blur, you render the moving object several times at several intermediate positions in its motion. For depth of ﬁeld, you render the complete scene from several different viewpoints. To get results comparable to distributed ray tracing you may need to use a larger number of repeated images to avoid having the results look like several superimposed snapshots, but this approach is still substantially faster than ray tracing.  Finally, because a scene may have only a few fast moving objects, you can often render the more static background once and then repeatedly render the moving objects in front of the static background to thus avoid the expense of repeatedly rendering the entire scene.  The OpenGL commands for manipulating the accumulation buffer are  glutInitDisplayMode  GLUT_ACCUM  other-options  ;    GL_ACCUM GL_LOAD  GL_MULT GL_ADD  , float factor  ;  glAccum   GL_RETURN  glAccumClear  float red, float green, float blue, float alpha ; glClear GL_ACCUM_BUFFER_BIT ;   254  Ray Tracing  You must include the GLUT_ACCUM bit in the options to glutInitDisplayMode to request a rendering context with an accumulation buffer. The glAccumClear command sets the clear colors for the accumulator: the accumulator buffer is loaded with these values by the glClear command shown above. The call to glAccum with the GL_ACCUM operand adds into the accumulation buffer the contents of the current drawing buffer multiplied by the factor value. For superimposing multiple rendered images, you would use a loop of the following type:  glClear GL_ACCUM_BUFFER_BIT ; For i = 1,...,n {  glClear GL_COLOR_BUFFER_BIT  GL_DEPTH_BUFFER_BIT ; RenderScene  i  ; glAccum GL_ACCUM, 1.0 n ;     Render i-th version of scene  } glAccum GL_RETURN, 1.0 ;  The subroutine RenderScene   must render the changing scene as usual but should not swap buffers to display it. The last line uses the GL_RETURN option to glAccum to place the contents of the accumulation buffer back into the rendering buffer. The factor, which is equal to 1 here, speciﬁes another scaling value.  See the OpenGL programming manual for documentation on the rest of the operands to  glAccum.  Depth of Field with z-Buffer–Based Blurring The z-buffer contents contain the pseudo-distance from which one can determine the actual distance of the object from the eye. This distance information can be used to create depth of ﬁeld effects. To do this, any pixel whose depth does not approximately match the focal depth can be blurred by replacing it with a weighted average of the surrounding pixels. The radius of the area from which the surrounding pixels are taken should depend on the distance of the pixel from the focal plane.  Reﬂections with Environment Mapping Shiny, specular objects with reﬂections of the surrounding scene can be rendered using en- vironment maps. The environment map is created by rendering the scene from the viewpoint of the shiny object and then using this to create an environment map. Typically, this is done by rendering the scene from the viewpoint of the shiny object up to six times and storing the environment map in the box projection format. Once an environment map is created from every shiny object, the ﬁnal image can be rendered one further time from the eye position with the environment maps applied as textures to the objects. It is also possible to iterate this proce- dure to obtain multiple levels of reﬂection. Attenuated or blurry reﬂections can be handled by attenuating or blurring the environment map.  Environment maps were already discussed in more detail in Section V.3. Using environment maps in this way cannot fully simulate reﬂections. First there is some error in the calculation of reﬂection because the environment map is formed from the viewpoint of only a single position  usually the center point  of the object. Further, this approach does not handle self-reﬂections; for instance, a shiny teapot would not show the reﬂection of the spout on its body, or vice versa, unless you treat the spout and the body as separate objects and calculate separate environment maps for them.   IX.3 Special Effects without Ray Tracing  255  Mirror Reﬂections with Clones Reﬂections from ﬂat, mirrored surfaces can be created by rendering a mirror image of the world behind the mirror’s plane. This involves ﬁrst rendering the entire scene reﬂected across the plane of the mirror, then drawing the mirror as a transparent shape  using blending; see glBlend in the OpenGL programming manual , and then drawing the real scene. Attenuated reﬂections can be achieved by choosing blending value appropriately.  For small mirrors or for difﬁcult geometric arrangements, you may need to use the OpenGL stencil buffer to restrict the mirror image to be rendered only behind the mirror, for otherwise the mirror image of the world would be visible around the mirror too. For this, you set up the stencil buffer by drawing the mirror shape, then render the mirror image of the scene with the stencil buffer enabled, and then disable the stencil buffer and render the mirror and then the rest of the scene again. The stencil buffer acts as a mask to prevent rendering outside of a deﬁned area  for more details see the OpenGL programming manual .  Shadows As we discussed already in Section II.3.4, shadows can be projected on a ﬂat surface using projection transformations. For soft shadows, this process can be repeated with multiple light positions and blending.  Casting shadows on nonplanar surfaces is harder, but there are variety of methods that can render shadows in real time. Two of the most popular ways of rendering shadows in real time without ray tracing are the shadow volume method and the shadow map method. We give only brief descriptions of these methods, but you can consult the references mentioned below for more information.  The shadow volume method works by determining what regions in 3-space are in shadow. For each point light source  cid:11 i , and each polygonal object, we determine the solid region that lies in the shadow cast by that object from light  cid:11 i . This region is called a shadow volume. For positional lights, the shadow volume is a generalized truncated cone. For instance, if the object is a triangle, then its shadow volume is a three-sided, inﬁnitely tall pyramid that is capped  truncated  by the triangle. For general polygonal objects instead of triangles, it sufﬁces to ﬁnd the “silhouette edges” and then the shadow volume is the inﬁnite region bounded by the shadows cast by the silhouette edges and capped by the polygonal object. The side faces of the shadow volume are the boundaries of the shadow region as cast from the silhouette edges.  Standard implementations of shadow volumes proceed roughly as follows: First, the scene is rendered into the frame buffer as usual with all depth buffer information and either  a  with all lighting as usual, or  b  with ambient lighting only. Then, the shadow volumes’ side faces are rendered, but instead of drawing them into the frame buffer, the  pseudo- depths are compared with the depth buffer values in the frame buffer. By keeping track of the net number of front- and back-facing shadow volume faces that lie in front of a given pixel in the frame buffer, we can determine whether the pixel is in shadow.  The OpenGL stencil buffer can be used to keep track of the net number of front- and back-facing edges.  Third, once it is determined which pixels are in shadow, then either  a  all shadowed pixels are darkened to simulate shadows, or  b  Phong lighting is used to add diffuse and specular lighting to all nonshadowed pixels. These steps have to be repeated for each point light source.  The shadow volume method was ﬁrst described by  Crow, 1977 . It was generalized to more general shapes by  Bergeron, 1986  and adapted to handle soft shadows from extended lights by  Brotman and Badler, 1984 .  Heidmann, 1991  describes efﬁcient implementation of shadow volumes with the stencil buffer.  Everitt and Kilgard, 2002  also discuss implementations   256  Ray Tracing  on modern graphics hardware along with optimizations that avoid problems with clipping planes.  The second method is that of shadow maps. A shadow map consists of the view of the scene as rendered from the perspective of a point light source  instead of from the viewpoint of the viewer . For each point light source, a shadow map is created with a depth buffer and with hidden surfaces removed. The shadow map can be used to determine the distance from the light source to the ﬁrst object in the scene in any given direction  up the resolution of the shadow map . After the shadow maps are created, the scene is rendered as usual from the viewpoint of the viewer. Each pixel in the scene is rendered into screen space, with x- and y-coordinates and with a pseudodepth value z. These screen space coordinates can be inverted to obtain the position of the pixel’s contents in the scene in 3-space.3 Then the distance from the light in 3-space can be compared with the corresponding distance from the shadow map. If the object is farther away than the distance in the shadow map, it is shadowed; otherwise, it is not.  Usually, a bias value is added to the distance to avoid problems with self-shadowing caused by roundoff error.  Once it is known which pixels represent surfaces in shadow, then, as before, either shadowed pixels can be darkened or nonshadowed pixels can be illuminated with Phong lighting.  Shadow maps were introduced by  Williams, 1978 . They can suffer from problems with aliasing and roundoff error;  Reeves, Salesin, and Cook, 1987  use a method called “percentage closer ﬁltering” that can reduce aliasing and make softer shadows.  Agrawala et al., 2000  and  Chen and Williams, 1993  discuss ways to use shadow maps to render soft shadows with from jittered light sources.   McCool, 2000  describes a hybrid method that combines shadow volumes and shadow  maps by extracting shadow volume information from a shadow map.  Transparency, Blending, and Fog OpenGL includes several features that allow some aspects of transparency to be rendered easily. The OpenGL functions glBlendFunc and glFog control these features.  Blending allows transparent objects to modify the colors of objects behind them. The alpha component of colors is used to control blending. To obtain good results with blending, it is usually necessary to ﬁrst render all nontransparent objects and then render the transparent objects with the painter’s algorithm, namely, to render the transparent objects sorted so that more distant objects are rendered ﬁrst.  Fog allows more distant objects to “fade out,” as from fog or other atmospheric interference. Fog has the advantage of providing “depth cueing,” wherein the attenuation of images due to fog gives an indication of distance. In addition, fog can be used to obscure distant objects and thereby improve performance since obscured objects do not need to be rendered.  3 The OpenGL function gluUnProject can help with inverting the screen space coordinates.   Color Plate 1.  Figure I.1, page 2.  A pixel is formed from subregions or subpixels, each of which displays one of three colors.   a    b   Color Plate 2.  Figure VI.1, page 149.   a  The additive colors are red, green, and blue.  b  The subtractive colors are cyan, magenta, and yellow.  Green  Yellow  Cyan  Red  Blue  Magenta  Color Plate 3.  Figure VI.2, page 152.  Hue is measured in degrees representing an angle around the ◦ color wheel. Pure red has hue equal to 0 , and pure blue has hue equal to 240  ◦ , pure green has hue equal to 120  ◦  .    a    c    e    b    d    f    Color Plate 4.  Figure III.1, page 68.  Six teapots with various shading and lighting options.  a  Wireframe teapot.  b  Teapot drawn with solid color but no lighting or shading.  c  Teapot with ﬂat shading with only ambient and diffuse lighting.  d  Teapot drawn with Gouraud interpolation with only ambient and diffuse reﬂection.  e  Teapot drawn with ﬂat shading with ambient, diffuse, and specular lighting.  f  Teapot with Gouraud shading with ambient, diffuse, and specular lighting.    a    b   Color Plate 5.  Figure III.9, page 76.  Two cubes with  a  normals at vertices perpendicular to each face, and  b  normals outward from the center of the cube. Note that  a  is rendered with Gouraud shading, not ﬂat shading.  Color Plate 6.  Figure V.8, page 135.  A bump-mapped torus. Note the lack of bumps on the silhouette. Four white lights are shining on the scene plus a low level of ambient illumination. This picture was generated with the ray tracing software described in Appendix B.  Color Plate 7.  Figure V.10, page 138.  An environment map mapped into a sphere projection. This is the kind of environment map supported by OpenGL. The scene is the same as is shown in Figure V.11. Note that the front wall has the most ﬁdelity and the back wall the least. For this reason, spherical environment maps are best used when the view direction is close to the direction used to create the environment map.   Color Plate 8.  Figure V.11, page 138.  An environment map mapped into a box projection consists of the six views from a point mapped to the faces of a cube and then unfolded to make a ﬂat image. This scene shows the reﬂection map from the point at the center of a room. The room is solid blue except for yellow writing on the walls, ceiling, and ﬂoor. The rectangular white regions of the environment map are not used.   a  No supersampling.   b  Supersampling with jittered subpixel centers.  Color Plate 9.  Figure IX.9, page 245.  An example of antialiasing using jittered subpixel centers.  a  The scene rendered without supersampling; note the “jaggies” on the silhouettes of the balls, for instance.  b  The scene with pixels selectively supersampled up to a maximum of 40 times.    a  No supersampling.   b  Supersampling with jittered subpixel centers.  Color Plate 10.  Figure IX.10, page 246.  Closeup views of the images in ﬁgure IX.9.  Color Plate 11.  Figure IX.12, page 247.  An example of depth of ﬁeld. The front of the eight ball is the focal plane. Note also the blurring of the checkerboard plane. In this image, each pixel is selectively supersampled up to 40 times. The eye positions and the subpixel positions were independently jittered as described on page 249.   Color Plate 12.  Figure IX.13, page 248.  An example of motion blur. Pixels were selectively supersam- pled up to 40 times. Both motion supersampling and subpixel supersampling were used.  Color Plate 13.  Figure XI.1, page 273.  The patches used to render the radiosity scene of Figures XI.2 and XI.3.   Color Plate 14.  Figure XI.2, page 274.  A radiosity-rendered ﬁgure with ﬂat shading. It is evident that this image is based on the patches shown in Figure XI.1.  Color Plate 15.  Figure XI.3, page 274.  A radiosity-rendered ﬁgure with smooth shading of illumination. The red color of the box is reﬂected onto the nearby walls, giving them a slight reddish hue. This is based on the patches shown in Figure XI.1.   Color Plate 16.  Figure III.20, page 98.  Metallic tori with specular component computed using the Cook–Torrance model. The materials are, from top to bottom, gold, silver, and platinum. The roughness is m = 0.4 for all three materials. The tori are each illuminated by ﬁve positional white lights.   X  Intersection Testing  This chapter discusses issues in intersection testing and describes algorithms for intersecting rays with geometric objects. Intersection testing is one of the fundamental algorithms used in ray tracing, which usually requires intersecting a large number of rays against a large set of geometric objects. For this reason, it is often the case that the bulk of the computational time required for ray tracing is spent on intersection testing. Intersection testing has other applications besides ray tracing  for e.g., in motion planning and collision detection .  Intersection testing is a large and diverse ﬁeld. In this chapter, we discuss only some of the ﬁrst topics, namely, intersecting rays against simple geometric objects. We only brieﬂy discuss methods such as bounding boxes and bounding spheres and global pruning methods such as octtrees and binary space partitioning. More information on intersection testing can be found in the book  M¨oller and Haines, 1999 , which has two chapters devoted to this topic, including numerous references to the literature. The Graphics Gems volumes also contain many articles on intersection testing. For additional reading suggestions, see the end of this chapter.  Two important goals need be kept to in mind when designing software for intersection testing. The ﬁrst design goal concerns accuracy and robustness. Clearly, it is important that the algorithms be accurate; even more so, the algorithms need to be free from occasional errors that may make visible artifacts, such as holes, or cause an occasional inconsistency in intersection status. For example, in ray tracing applications, it ought to be impossible for a path to be confused about being inside or outside a closed object such as a sphere. Similarly, for objects made up of multiple parts, say a cube made from six square faces, or a surface whose “faces” are B´ezier patches, it should not be possible for roundoff error to allow a ray to pass through a “crack” between two faces without hitting the surface.  The second design goal for intersection testing is speed. It is often the case that intersection testing is the most computationally intensive part of a program. In particular, in ray tracing, most of the computation time is commonly spent on intersection testing. The reason for this is that there are typically numerous objects – hundreds, thousands, or perhaps many more – and one has to consider the possibility that each ray hits each object. Since the ray hits only one object, the time spent processing the actual hit is generally much less than the time spent determining which of the many objects is ﬁrst hit. A subordinate principle is that what is really important is that one be able to determine very quickly when an intersection has not occurred. That is, it is often far more important to decide quickly when a ray does not hit an object than it is to decide quickly that a ray does hit an object.  257   258  u  p  q1  a  a  q2  q  c  b  Intersection Testing  Figure X.1. The ray from p in direction u reaches its closest point to the center c of the sphere at q. The points q1 and q2 are the two places where the line intersects the sphere.  If a ray is being intersection tested against many objects, then it may be useful to preprocess the objects by arranging them hierarchically or by partitioning space with the use of octtrees or binary space partitioning trees. These techniques allow a quick rejection of many objects at once and thus intersection testing does not have to be performed against each individual object. We will discuss these techniques brieﬂy at the end of the chapter; however, our main emphasis is on algorithms for testing whether a ray intersects an individual object.  X.1 Fast Intersections with Rays  In this section, we discuss algorithms for intersecting rays with several common surfaces in R3. We do not try to be encyclopedic in our coverage of intersection testing with rays but instead strive to show the issues and algorithms that arise in many common cases. We consider intersections of rays against spheres, planes, triangles, convex polytopes, cylinders, quadrics, and B´ezier patches.  X.1.1 Ray versus Sphere Intersections  Assume that a ray and a sphere are ﬁxed. The ray is speciﬁed by its starting position p and a unit vector u in the direction of the ray. That is, the ray is the set of points  {p + αu : α ≥ 0}.  We will also talk about the line containing the ray, which we call the ray-line.  The sphere is speciﬁed by its center c and its radius r > 0 and is equal to the set of points  at distance r from the center. The ray–sphere intersection algorithm works by ﬁrst ﬁnding the point q on the ray-line closest to the center of the sphere.  Refer to Figure X.1.  The point q will be equal to p + αu, where α is a scalar measuring how far q is from p along the ray. A point q will be the closest point on the ray-line to the point c provided that the line from q to c is perpendicular to the ray; that is, the point q can be deﬁned by  0 =  q − c  · u =  p + αu − c  · u.  Solving for α, using the fact that u · u = 1, gives  α = − p − c  · u.  Therefore q = p −   p − c  · u u. Once we have found q, we can check whether it lies inside the sphere by checking whether q − c ≤ r. Finding the norm of a vector involves calculating a square root, and so it is actually more efﬁcient to check whether q − c2 ≤ r 2. The calculation of the square of the magnitude of a vector, say of w2, can be done with only three multiplications and two   X.1 Fast Intersections with Rays  259  When q does lie inside the sphere, let b = q − c and set a = √  additions, and this is signiﬁcantly more efﬁcient than also using a square root. If q does not lie inside the sphere, then obviously the ray does not intersect the sphere. r 2 − b2. Note that only the square of b is needed; however, a square root is needed to compute a. Then the ray-line intersects the sphere at the two points  q1 = p +  α − a u  and  q2 = p +  α + a u.   See Figure X.1.  Now, if α − a ≥ 0, then the ray does actually hit the sphere at q1, and this is its ﬁrst intersection with the sphere. However, if α < a, then the point q1 lies in the wrong direction along the ray-line, that is, behind p on the line. In this latter case, we then check whether α + a > 0; if so, then the point p lies inside the sphere and q2 is the point where the ray ﬁrst hits the sphere.  Putting this together gives the following algorithm for ray–sphere intersection testing.  Ray-Sphere Intersection: Input: p and u describe a ray. u a unit vector.  A sphere speciﬁed by center c and radius r.  Algorithm:  Return “No intersection”;  Set α = − p − c  · u; Set q = p + αu; Set bSq = q − c2; If   bSq > r 2   { } Set a = If   α ≥ a   {   cid:20  r 2 − bSq;  Set q1 = q − au; Return q1;  } If   α + a > 0   {  Set q2 = q + au; Return q2;  } Return “No intersection”;  As discussed in the introduction, the most important aspect of the computational speed of the algorithm is how fast it detects nonintersections. In the algorithm above, to get to the rejection test of b2 > r 2 on line 4, one performs 9 multiplications, 11 additions, and 1 comparison on the assumption that the radius squared, r 2, has been precomputed. If you know that the ray’s beginning point p is never inside the sphere, it could be worthwhile to add a check for whether α > 0 since α ≤ 0 means that the ray is not pointing towards the sphere at all. In ray tracing, this may be the case if the sphere is not transmissive. This extra test for nonintersection does not work so easily when it is possible for p to be inside the sphere. For that, you need to check both α > 0 and p − c2 > r 2, that is, check that p is outside the sphere and that the ray is pointing away from the sphere. This test then requires three extra multiplications, two extra additions, and two extra comparisons; thus, it is generally only marginally useful to perform this extra test.  Intersection tests for complicated geometric objects can be speeded up by giving the object a bounding sphere, which must completely enclose the object. To test whether a ray intersects   260  u  p  q  Intersection Testing  Figure X.2. The ray speciﬁed by its start position p and direction u intersects the plane at the point q.  the complicated object, you can ﬁrst test whether the ray intersects the bounding sphere. If not, then it also does not intersect the geometric object. However, if the ray does intersect the bounding sphere, you must further test for intersection with the geometric object. The advantage of the bounding sphere is that it allows you to detect many cases of nonintersection quickly.  Exercise X.1 Write an efﬁcient pseudocode algorithm for bounding sphere testing. [Hint: Use the ﬁrst part of the ray–sphere intersection algorithm, namely, the part through line 6 ending with the test for b2 > r 2. Finish up by testing the condition “α > 0 or α2 ≤ a2.”] Exercise X.2 An ellipsoid is speciﬁed by its center, three orthogonal axes, and three  cid:28  radii. The three orthognal axes and radii can be speciﬁed by three orthogonal vectors v1, v2, and v3, with each norm vi equal to the inverse of the radius in the direction of vi : i   x − c  · vi  2 = 1. Formulate an efﬁcient the ellipsoid is the set of points x such that ray versus ellipsoid intersection algorithm.   cid:1   X.1.2 Ray versus Plane Intersections  A plane is speciﬁed by a normal vector n perpendicular to the plane and a scalar d. The plane is the set of points x satisfying x · n = d.  If p and u specify a ray as usual, then, to intersect the ray with the plane, we ﬁrst calculate the point q  if it exists  that is the intersection of the ray-line with the plane. This q will equal p + αu for α a scalar. To lie in the plane, it must satisfy  d = q · n = p · n + αu · n.  Solving for α yields  α = d − p · n u · n  .  The quantities in this formula for α all have geometric meaning. If n is a unit vector, then the value d − p · n is the negative of the distance of p above the plane, where “above” means in the direction of n. For nonunit n,  d − p · n  n is the negative of the distance of p above the plane. In particular, p is above  respectively, below  the plane if and only if d − p · n is negative  respectively, positive . The dot product u · n is negative if the ray’s direction is downward relative to the plane  with n deﬁning the notions of “down” and “up” . If u · n = 0, then the ray is parallel to the plane, and the usual convention is that in this case the ray does not intersect the plane at all. Even if the ray lies in the plane, it is usually desirable for applications to treat this as not intersecting the plane. The value of α is the signed distance of q from p. If α < 0, then the ray does not intersect the plane.   X.1 Fast Intersections with Rays  261  These considerations give the following ray-versus-plane intersection algorithm:  Return “No intersection  parallel ”;  Ray-Plane Intersection: Input: p and unit vector u deﬁning a ray.  n and d deﬁning a plane.  Algorithm:  Set c = u · n; If   c == 0   { } Set α =  d − p · n  c; If   α < 0   { } Set q = p + αu; Return q;  Return “No intersection”;  Line-Plane Intersection: Input: p and unit vector u deﬁning a line.  n and d deﬁning a plane.  Return “No intersection  parallel ”;  Algorithm:  Set c = u · n; If   c == 0   { } Set α =  d − p · n  c; Set q = p + αu; Return q;  Sometimes we want to intersect the ray-line against the plane instead, such as in the ray versus convex polytope intersection algorithm in Section X.1.4. This is even simpler than the previous algorithm, for we just omit the test for α ≥ 0:  Exercise X.3 What would happen if we drop the requirement that the vector u be a unit vector? Show that the preceding algorithms would still compute the intersection point q correctly, but not the distance α.  X.1.3 Ray versus Triangle Intersections  We next take up the intersection of a ray with a triangle. In principle, this can be taken as the fundamental intersection operation, because all surfaces can be approximated by planar patches – indeed by triangles.  A ray is, as usual, speciﬁed by its starting position p and direction u, with u a unit vector. A triangle can be represented by its three vertices v0, v1, and v2, which are presumed to be noncollinear.  The ﬁrst step in intersecting a ray with the triangle is to intersect it with the plane containing the triangle. Let n be a vector normal to the plane, and let d be the scalar so that the plane consists of those points x such that n · x = d. By convention, the vector n is taken to be the “upward” direction, and we presume the triangle’s vertices are ordered in the counterclockwise   262  u  p  q  Intersection Testing  Figure X.3. Intersecting a ray with a triangle. The ﬁrst step is to ﬁnd the intersection q with the plane containing the triangle.  direction when the plane is viewed from above. Values for n and d can be computed by the following formulas:  n =  v1 − v0  ×  v2 − v0  d = n · v0.  The point q where the ray intersects the plane is found using the ray–plane intersection test of the previous section. This also gives the signed distance α from p to q; if this test ﬁnds that α < 0, then there is no intersection. By further examining the sign of either u · n or d − p · n, one can determine whether the point p lies above or below the surface.  Once the point q has been found, we still need to determine whether q is inside or outside the triangle. One way to do this is by computing the barycentric coordinates of q relative to the triangle. They can be found using Equations IV.15 and IV.16 on page 107. To translate these equations to our present setting, we let x = v0, y = v1, z = v2, and u = q. To ﬁnd the barycentric coordinates of q, we ﬁrst calculate  e1 = v1 − v0 e2 = v2 − v0 a = e2 b = e1 · e2 c = e2  1  .  2  D = ac − b2 A = a D B = b D C = c D.  β = uβ ·  q − v0  γ = uγ ·  q − v0  α = 1 − β − γ .  Here e1 and e2 are two of the edge vectors for the triangle. Then, calculate  Then let  uβ = Ce1 − Be2  and  uγ = Ae2 − Be1.  The barycentric coordinates α, β, γ , which represent q as q = αv0 + βv1 + γ v2 are found by  The point q lies in or on the triangle provided that α, β, and γ are all nonnegative.   X.1 Fast Intersections with Rays  263  Putting this together gives the following algorithm. The algorithm is split into two phases. The precomputation calculates values that depend on the triangle only, and these values can be computed once and saved.  Ray-Triangle Intersection Algorithm Input: p and unit vector u specifying a ray.  v0, v1, v2 specifying a triangle.  Precompute n, d, uβ, uγ :  Set e1 = v1 − v0; Set e2 = v2 − v0; Set n = e1 × e2; Set d = n · v0; Set a = e1 · e1; Set b = e1 · e2; Set c = e2 · e2; Set D = ac − b2; Set A = a D; Set B = b D; Set C = c D; Set uβ = Ce1 − Be2; Set uγ = Ae2 − Be1;  Main algorithm:  Return “No intersection”;  Return “No intersection”;  Invoke Ray-Plane intersection algorithm to calculate q. If   No ray-plane intersection exists   { } Set r = q − v0; Set β = uβ · r; If   β < 0   { } Set γ = uγ · r; If   γ < 0   { } Set α = 1 − β − γ ; If   α < 0   { } Return q;  Return “No intersection”;  Return “No intersection”;  The algorithm above has been optimized for speed, not memory usage. Examination of the main algorithm shows that for each triangle we need to have the values v0, n, d, uβ, and uγ ; this is four ﬂoating point numbers more than would be needed to store just the three vertices  but most applications would need to keep v1 and v2 too . There are several algorithms that use fewer precomputed numbers; see especially  M¨oller and Trumbore, 1997; M¨oller and Haines, 1999  for an algorithm that skips the stage of calculating q. Those algorithms have the advantage of needing less memory, which can be important if there are many triangles; however, without storing the plane normal and scalar values, it is not possible to have such a quick intersection rejection test.   264  Intersection Testing  X.1.4 Ray versus Convex Polytope Intersections  A convex polytope in R3 is a region bounded by a ﬁnite number of planes.1 In 3-space, convex polytopes are also called convex polyhedra, and examples include cubes, rectangular prisms  boxes , pyramids, and so on. In 2-space, the bounding planes are replaced by bounding lines, and so a convex polytope is the same as a convex polygon. The concept of polytope is easily extended to arbitrary dimension  in Rd, the bounding planes are replaced by  d − 1 - dimensional afﬁne subspaces , and the algorithms we develop in this section apply equally well to all dimensions. However, to avoid confusion, we will just discuss the case of polytopes in R3.  Because we never consider nonconvex polytopes, we simplify terminology by omitting the  adjective “convex” and using “polytope” to mean convex polytope.  After working out the rather complex algorithm for ray–triangle intersection in the previous section, one might fear that ray–polytope intersection algorithms would be even more com- plex. Surprisingly, and fortunately, this does not happen, and the algorithm for ray–polytope intersection is not particularly complicated. Consider a ﬁxed polytope. If there are k faces for the polytope, then the k planes bounding the polytope have normals ni and scalars di for 1 ≤ i ≤ k. By convention, the normals face outward from the polytope. Therefore, the polytope is the set of points x satisfying  x · ni ≤ di  for all i = 0, 1, 2, . . . , k.  That is to say, the polytope is the intersection of the k closed halfspaces bounded by the k planes.  To intersect a ray with a convex polytope, we ﬁrst intersect the ray with each of the k bounding planes. For each plane i, we compute the intersection qi of the ray-line with that plane along with the signed distance αi from the originating point p to qi . In addition, we compute whether the ray-line hits the bounding plane from above or from below. By “from above,” we mean that u · ni < 0 and that the ray direction vector u is pointing in the plane’s downward direction. By “from below,” we mean that u · ni > 0 and that the ray direction is pointing in the upward direction.  An intersection from above is also called a “front intersection,” meaning that the ray-line has hit the plane from its front face and is entering the halfspace bounded by the plane. An intersection from below is also called a “back intersection,” and the ray-line is hitting the back face and exiting the halfspace. The intersections are categorized as front or back intersections on the basis of the dot product u · ni according to the following table:  Meaning Front intersection: ray-line entering halfspace Back intersection: ray-line exiting halfspace Parallel ray below face: front intersection, αi = −∞. Parallel ray above face: back intersection, αi = −∞.  Test u · ni < 0 u · ni > 0 u · ni = 0 & p · ni ≤ di u · ni = 0 & p · ni > di The degenerate case of the ray’s being parallel to the plane is treated by the convention that it hits the plane at α = −∞. However, in this case, it still needs treated as a front or a back intersection. This is consistent with the treatment of other front and back intersections in that it makes the following property hold:  1 Generally, it is also required that the polytope be bounded, that is, not inﬁnite in size; however, the  algorithm we present does not require polytopes to be bounded.   X.1 Fast Intersections with Rays  265  f  fb  b  b  f  f  b  b  b  Figure X.4. The two rays are shown intersecting the bounding planes of the shaded polytope. Front intersections are labeled “f ” and back intersections are labeled “b”. The upper ray hits some back intersections before some front intersections and thus does not intersect the polytope. The lower ray hits all the front intersections before all the back intersections and thus does intersect the polytope.  Lemma X.1 Let qi and αi be set for the ith plane as above. Let p β  = p + βu. Then, a. If the intersection with the ith plane is a front intersection, then p β  is in the halfspace  bounded by the ith plane if and only if β ≥ αi . bounded by the ith plane if and only if β ≤ αi .  b. If the intersection with the ith plane is a back intersection, then p β  is in the halfspace  The proof of the lemma is immediate from the deﬁnitions.  The property of the lemma is the crucial idea behind the algorithm for intersecting a ray and a convex polytope. The algorithm calculates all the αi and qi values and categorizes them as either front or back intersections. It then lets  fMax = max{αi : the ith intersection is a front intersection} bMin = min{αi : the ith intersection is a back intersection}.  The ray-line then intersects the polytope if and only if fMax ≤ bMin. If fMax ≥ 0, then the ray intersects the polytope boundary ﬁrst at p fMax , and it is entering the polytope at this point. If fMax < 0 ≤ bMin, then p is inside the polytope, and the ray ﬁrst hits the polytope boundary at p bMin ; it is exiting the polytope at this point. If however, bMin < 0 or bMin < fMax, then the ray does not intersect the polytope. Figure X.4 illustrates the idea for this intersection testing algorithm.  To verify all the assertions of the last paragraph, you simply note that, in order to be in the polytope it is necessary and sufﬁcient to be inside all the half spaces simultaneously. The front intersections give the point where the line enters a half space, and the back intersections are where the line exits a half space. We can now give the intersection algorithm based on the preceding constructions. We use ±∞ only as a shorthand notation for very large  in absolute value  positive and negative numbers.  Input: A ray speciﬁed by p and a unit vector u  k planes speciﬁed by normals ni and scalars di .  Algorithm:  Set fMax = −∞; Set bMin = +∞;   266  Intersection Testing     If parallel to plane  Continue loop with next value of i;  For i = 1, 2, ..., k {    Ray to plane intersection Set s = u · ni ; If  s == 0  {  Return “No intersection”;  If   p · ni > di   { } Else { }  }    If not parallel to plane Set α =  di − p · ni   s; If   u · ni < 0   { If   α > fMax   {  } } Else {  If   α > bMin   { } Set fMax = α;  Return “No intersection”;  If   α < bMin   {  If   α < 0 or α < fMax   { Return “No intersection”; } Set bMin = α;  }  }  } If   fMax > 0   { Set α = fMax; } else { Set α = bMin; } Return q = p + αu;     If front intersection     Else, back intersection     End of for loop  There are some notable special cases for which the preceding algorithm can be sped up. In particular, many common shapes like cubes, rectangular prisms, parallelepipeds, and k-DOP’s  see Section X.2  have bounding planes that come in pairs with opposite faces parallel. For these, it is possible to speed up the algorithm by treating pairs of parallel faces simultaneously.  X.1.5 Ray versus Cylinder Intersections  The intersection of a ray with a cylinder can be done by combining the techniques for intersect- ing rays with spheres and polytopes. We consider only the case of right, circular, ﬁnite cylinders: such a cylinder is speciﬁed by a radius r, an axis v, a center point c, and a height h. It is con- venient to assume that v is a unit vector. The cylinder consists of the points that both lie within   X.1 Fast Intersections with Rays  267  f  f  b  b  Figure X.5. A cylinder is the intersection of an inﬁnite cylinder and the area between two parallel planes. The ray is shown hitting the top plane, then entering the  inﬁnite  cylinder, then exiting the cylinder, and ﬁnally hitting the bottom plane. All the front intersections come before all the back intersections, and thus the ray does intersect the cylinder.  distance r of the line through c in the direction v and are between the two planes perpendicular to v that are distance h 2 away from the center c. That is, the cylinder is the set of points  {x : x −   x − c  · v v − c2 ≤ r 2} ∩ {x :   x − c  · v 2 ≤  h 2 2}.  The cylinder is expressed as the intersection of two sets of points: the ﬁrst set is the inﬁnite height cylinder, and the second set is the region bounded between two parallel planes. Clearly, a cylinder is convex.  The algorithm to intersect a ray with this cylinder proceeds as follows. First, use essentially the method of Section X.1.1 to ﬁnd where the ray-line intersects the inﬁnite height cylinder: this gives zero, one, or two intersections.  Handle the case of the ray being parallel to the cylinder’s axis as a special case.  If there is only one intersection, it is a glancing intersection and should be treated as being either zero or two intersections. If there are two intersections, categorize them as being front and back intersections much like what was done in the algorithm for ray-polytope intersection; the front intersection will always precede the back intersection. Otherwise, if the ray does not intersect the inﬁnite cylinder, it also does not intersect the ﬁnite cylinder. Second, intersect the ray with the two parallel planes, getting its front and back intersections  the degenerate case of the ray parallel to the planes is best treated as a separate special case . Again, the front intersection will always precede the back intersection. Third, combine the  up to  four intersections in the same manner as was used for ray–polytope intersections. Figure X.5 illustrates the idea for this intersection testing algorithm.  Exercise X.4 Fill in the details of the paragraph above and write an algorithm for ray– cylinder intersections.  The RayTrace software package described in Appendix B includes more general cylin- ders, allowing them to have elliptical cross section and to have bounding planes that are not perpendicular to the central axis. We leave it to the reader as an exercise to work out efﬁcient intersection algorithms for these.  X.1.6 Ray versus Quadric Intersections  A quadric is a surface in 3-space that consists of the points satisfying a polynomial of degree 2. That is, a quadric is a surface consisting of all points  cid:5 x, y, z cid:6  satisfying an identity f = 0, where f is a function of the form  f   cid:5 x, y, z cid:6   = Ax 2 + By2 + Cz2 + Dx y + E xz + F yz + Gx + H y + J z + K .  Examples of quadrics include spheres, ellipsoids, cylinders, paraboloids, and hyperboloids.   268  Intersection Testing  To intersect a ray with a quadric, let p and u specify the starting point and the direction of the ray as usual. Let p α  equal p + αu. To ﬁnd the points p α  that lie on the quadric, we need to ﬁnd the values for α ≥ 0 such that f  p α   = 0. Since f is a polynomial of total degree two, the value of f  p α   is a polynomial of degree two,  f  p α   = aα2 + bα + c.  Solving for values of α such that f  p α   = 0 can easily be done with the quadratic formula and yields 0, 1, or 2 solutions. The least nonnegative solution, if any, gives the ﬁrst intersection of the ray with the quadric.  For ray tracing applications, you want to know not only the point of intersection but also the normal vector to the surface at that point. For a quadric, the normal vector can be found by using the method of Theorem III.2 on page 80 using the gradient of f . Except in degenerate cases, the gradient, ∇ f , will be nonzero.  X.1.7 Ray versus B´ezier Patch Intersections  Testing the intersection of a ray and B´ezier patch can be a daunting task. In fact, there is no way to give a closed-form solution to the problem, and one must instead use iterative methods to ﬁnd the intersection approximately.  There are several approaches to algorithms that perform ray-versus-B´ezier-patch intersec- tion testing. These basically fall into two categories:  a  Newton and quasi-Newton methods and  b  recursive subdivision methods.  Let a B´ezier patch be given by a function q u, v  that is, say, degree three in each of u and v, and let a ray be speciﬁed as usual by p and u. Finding an intersection is the same as ﬁnding values for u, v, and α so that q u, v  − p + αu = 0. Alternatively, one can deﬁne d q  to equal the distance from q to the ray-line. In this case, we are seeking values for u and v such that d q u, v   = 0. In both approaches, we are seeking the zeros of a function. Newton methods and quasi-Newton methods are methods that, at least in ideal situations, will iteratively compute points that converge rapidly to a solution. Papers that discuss  quasi- Newton methods include  Toth, 1985  and  Joy and Bhetanabhotla, 1986 .  Recursive subdivision algorithms are more straightforward but do not hold out the promise of fast quadratic convergence of the type that can be obtained from  quasi- Newton methods. For this, a surface patch is given a bounding volume such as a bounding sphere or a bounding box. The ray is checked for intersections against the bounding volume. If an intersection occurs, then the B´ezier patch is split into two subpatches using the de Casteljau subdivision algorithm, and the ray is recursively checked against both patches. The RayTrace software performs ray- versus-B´ezier-patch intersections in this way using a bounding parallelepiped. The bounding parallelepiped is chosen so as to enclose the control points of the patch. This is sufﬁcient, since the convex hull property guarantees that the entire B´ezier patch lies in the convex hull of its control points.  A recursive subdivision algorithm for ray versus bicubic surface patch intersection was used already in the original publication on ray tracing  Whitted, 1980 . A more sophisticated recursive subdivision algorithm is proposed by  Nishita, Sederberg, and Kakimoto, 1990 , who subdivide B´ezier patches into sizes smaller than half the size of the whole patch when this can be justiﬁed by convexity considerations. This allows for much faster convergence, particularly in cases in which the ray is hitting the patch at an angle signiﬁcantly away from parallel to the surface.   X.2 Pruning Intersection Tests  269   a    c    b    d   Figure X.6. Various kinds of two-dimensional bounding volumes enclosing a crescent shape.  a  A bounding sphere.  b  An axis-aligned bounded box  AABB .  c  An oriented bounding box  OBB .  d  A discrete oriented polygon  k-DOP  with k = 3.  X.2 Pruning Intersection Tests  We next discuss “pruning” methods that let us avoid having to perform so many intersection tests. For space reasons, we do not cover these in depth but instead give an overview of some of the more common techniques and provide some references at the end for further reading.  Several standard approaches are used to prune intersection tests. The ﬁrst is to use bounding volumes to enclose objects. The bounding volumes are picked to be much simpler than the enclosed object and must completely enclose the object. If there is no intersection with the bounding volume, then there is also no intersection with the enclosed object. Common bounding volumes include bounding spheres, bounding boxes called AABBs and OBBs, and k-DOPs. Figure X.6 shows examples of these different types of bounding volumes. A bounding sphere is a sphere that completely encloses an object. An AABB is an axis-aligned bounding box and is a box whose edges are parallel to the standard x, y, z-axes. An OBB is an oriented bounding box: this is a box placed at an arbitrary orientation. Computing intersections against OBBs is more complex than against AABBs, but OBBs can sometimes more closely enclose an object and moreover have the ﬂexibility to move with an object as it changes orientation. A k-DOP is a discrete oriented polygon: it is a convex polytope bounded by k planes, where the k-planes come in pairs so that opposite faces of the polytope are parallel  it is permitted for some planes to be extraneous and intersect the k-DOP in only a single point .  The second approach to pruning intersection tests involves partitioning space into regions. Each object lies in one or more regions. When a ray is tested for intersections with the set of all objects, the regions that the ray intersects are traversed one at a time: for each region that the ray enters, the ray intersection tests are performed for each object that intersects the region. There are a wide variety of ways to partition space. Representative methods include  a  room- or cell-based methods,  b  quadtrees or octtrees,  c  k-d trees, and  d  BSP trees.   270  Intersection Testing  Figure X.7. A quadtree.  Room- or cell-based partitions apply well to situations in which space is partitioned into rooms or regions: typical applications that could use room-based partitions are 3-D models of houses or buildings and computer games where the player traverses rooms or other discrete regions. In a room-based partition, the extents of the rooms would usually be explicitly set by the designer of the 3-D model.  Quadtrees are used to partition 2-space hierarchically into square regions, as shown in Figure X.7. The root of a quadtree is an axis-aligned square containing the entire region of interest. It is split into the four subsquares obtained by dividing it into half horizontally and vertically. Each of these subsquares may themselves be split into four subsquares, and so on, recursively. The decision of whether to split a square into four sub-subsquares depends usually on how many objects intersect the region. The entire quadtree is stored as a tree structure, including pointers to allow traversal of the quadtree. Octtrees are the generalization of quadtrees to three dimensions: each node of an octtree is a cube and can be split into eight subcubes.  The k-d trees are generalizations of quadtrees and partition space  of any dimension  by using axis-aligned planes, as shown in Figure X.8. The root of a k-d tree is a rectangular box containing the region of interest. Each nonleaf node N in a k-d tree has two children  i.e., is split into two subregions . The two subregions are deﬁned by choosing an axis and dividing the node N with a plane perpendicular to that axis. The most common way to choose the two subregions is by selecting a vertex v from an object in the region covered by N , choosing one axis, and splitting the region into two subregions based on v’s coordinate for that axis. In 2-space this means choosing a vertical or horizontal line through v; in 3-space this means splitting the region with an axis-aligned plane through v. The advantage of k-d trees over quadtrees is that one can intelligently pick the vertex v and axis direction so as to try to divide  Figure X.8. A k-d tree in two dimensions. A region in a k-d tree can be subdivided by either a vertical or a horizontal line.   X.2 Pruning Intersection Tests  271  Figure X.9. A BSP tree in two dimensions.  into subregions that partition the objects into sets of approximately equal size. The hope is that the tree will have lower depth and be faster to traverse.  Binary space partitioning trees, known as BSP trees, generalize k-d trees by allowing the regions to be partitioned by an arbitrary plane rather than only axis-aligned planes  see Figure X.9.  Typically, it contains one of the faces of one of the objects in the region. The BSP trees were ﬁrst introduced by  Fuchs, Abram, and Grant, 1983; Fuchs, Kedem, and Naylor, 1980 ,  see also the references in the Further Reading section below .  the plane that divides a region is chosen so that  The third approach to pruning intersection tests is the use of hierarchical bounding volumes. This is actually a hybrid of the ﬁrst two approaches. Typically, they work by ﬁrst enclosing each individual object with a bounding volume, then enclosing pairs or small clusters of bounding volumes by another bounding volume, and recursively iterating this procedure until the entire scene in enclosed in a bounding volume. Oriented bounding boxes are a popular choice for these bounding volumes  see  Gottschalk, Lin, and Manocha, 1996  , but other types of bounding volumes can be used as well.  Further Reading: Some good textbooks that cover octtrees, BSPs, and related spatial data structures are  Samet, 1990a; 1990b  and  de Berg et al., 2000 .  M¨oller and Haines, 1999  describe many algorithms for AABBs, OBBs, k-DOPs, and hierarchical methods.  This chapter has discussed only intersecting rays against three-dimensional objects. For many applications, one also wants to perform intersection tests on pairs of three-dimensional objects to determine if they have collided or interpenetrated: this is a much harder task in gen- eral. For an overview of intersecting three-dimensional objects, see  M¨oller and Haines, 1999 , who discuss algorithms for intersecting simple objects such as spheres, boxes, and k- DOPs. Exact algorithms for intersection testing between general convex objects have been given by  Lin, 1993; Lin and Canny, 1991  and  Gilbert, Johnson, and Keerthi, 1988 . As of this writing, at the University of North Carolina, the Geometry Group’s Web site, http:  www.cs.unc.edu ∼geom, has numerous related papers and resources, includ- ing extensive downloadable software.   XI  Radiosity  Radiosity is a global lighting method that tracks the spread of diffuse light around a scene. As a global lighting method, it attempts to simulate the effect of multiple light reﬂection. Unlike basic ray tracing, which tracks only the specular transport of light, radiosity tracks only the diffuse transport of light.  The goal of a radiosity algorithm is to calculate the illumination levels and brightness of every surface in a scene. As an example, consider a scene of a classroom with ﬂuorescent light ﬁxtures, painted walls, a nonshiny tile ﬂoor, and desks and other furniture. We assume that there are no shiny surfaces, and thus no signiﬁcant amount of specular light reﬂection. All the light in the room emanates originally from the ceiling lights; it then reﬂects diffusely from objects in the room, especially from the walls and ﬂoor, providing indirect illumination of the entire room. For instance, portions of the ﬂoor underneath the desk may have no direct illumination from any of the lights; however, these parts of the ﬂoor are only partly shadowed. Likewise, the ceiling of the room receives little direct illumination from the overhead lights but still is not dark. As a more extreme case, the bottom sides of the desk tops are partly shadowed but are certainly not completely dark: they are illuminated by light reﬂecting off the ﬂoor.  Another common example of a scene with diffuse lighting is a room lit by indirect light such as by a torch`ere. A torch`ere is a vertically standing, bright white light that shines up onto the ceiling of the room. The light reﬂects diffusely from the ceiling to illuminate the entire room even though essentially none of the room is directly visible to the light bulb. Radiosity can also model a room lit by indirect outdoor light.  Radiosity methods are, in many ways, complementary to ray tracing methods. Basic ray tracing tracks the global transport of specularly reﬂected light, whereas radiosity tracks the global transport of diffusely reﬂected light. Thus, radiosity is much better at softly lit scenes with subtle color shading, whereas ray tracing is better at rendering sharp shadows. Radiosity methods usually track the diffusely reﬂected light by starting at the light source and tracking the movement of illumination forward. Ray tracing generally starts at the view point position and tracks rays of light backwards  in the so-called forward ray tracing . For this reason, the results of ray tracing are view dependent, whereas the results of radiosity are view independent. Thus, radiosity can be used to preprocess a scene ahead of time, and once the radiosity algorithm is completed the scene can be traversed in real time without expensive computation. This means that radiosity is well suited to interactive walkthrough applications. By comparison, ray tracing cannot generally be viewed by a moving viewer in realtime, since the entire ray tracing procedure must be repeated for each change in the view position.  272   Radiosity  273  Figure XI.1. The patches used to render the radiosity scene of Figures XI.2 and XI.3. See Color Plate 13.  This chapter describes radiosity algorithms in some detail. However, before presenting the  detailed mathematical algorithms, we give a high-level overview of radiosity algorithms.  Radiosity algorithms typically begin by breaking the scene into a set of ﬂat polygons called “patches”  for an example, see Figure XI.1 . The main goal of the radiosity algorithm is to compute an illumination level, or brightness, of each patch. For this, the radiosity algorithm assumes that each patch is uniformly lit. In addition, it is assumed that all light is reﬂected only diffusely; that is, it is only the total illumination of a given patch that is important, and the direction of the incoming illumination can be ignored. Some of the patches are light sources: these are called emissive patches. For the other polygons, we wish to determine illumination levels. This will be done by tracing the ﬂow of all the light – from the light sources through multiple bounces – to determine the overall light levels for each patch.  After breaking the scene into patches, the radiosity algorithm computes “form factors.” The form factors will be used to describe how much light reﬂects diffusely from one patch to another. For each pair of patches, their form factor measures the fraction of the light leaving the ﬁrst patch that directly illuminates the second patch. For instance, if the ﬁrst patch lies on the wall of the classroom and the second patch corresponds to one tile on the ﬂoor, the form factor would be equal to the percentage of the light leaving the wall’s patch that goes directly to the tile.  Once the form factors have been determined, we set up equations that relate the patch illuminations and the form factors. These equations can be conveniently set up as a large system of linear equations. The remainder of the radiosity algorithm solves the system of equations to determine the level of illumination of each patch. Figure XI.2 shows an example of a scene with each patch illuminated according to the radiosity algorithm. In the ﬁgure, each patch is ﬂat shaded, and so the scene does not look realistic. But, as the ﬁnal step of the radiosity algorthm, an averaging procedure is applied to make each patch smoothly shaded. Figure XI.3 shows the result of smoothly shading the patches.  Although we will describe the radiosity algorithm as computing a single brightness value for each patch, in fact, we really mean for it to compute a different brightness level at each wavelength  typically, red, green, and blue . As a general rule, the same patches and the same form factors are used for all wavelengths.   274  Radiosity  Figure XI.2. A radiosity-rendered ﬁgure with ﬂat shading. It is evident that this image is based on the patches shown in Figure XI.1. See Color Plate 14.  XI.1 The Radiosity Equations  XI.1.1 Patches, Light Levels, and Form Factors  The ﬁrst step in rendering a scene in the radiosity algorithm is to break the surfaces in the scene into a set of small ﬂat patches. The main part of the radiosity algorithm will treat each patch as being uniformly illuminated, but in the end shading will be used to render the patches with smoothly varying illumination levels. It is important to choose patches sufﬁciently small that the assumption that each patch is uniformly illuminated will not cause too much error in the calculation. Thus, the illumination levels should not change very much between adjacent patches or within a single patch; otherwise, the radiosity algorithm may give poor results.  Figure XI.3. A radiosity-rendered ﬁgure with smooth shading of illumination. The red color of the box is reﬂected onto the nearby walls, giving them a slight reddish hue. This is based on the patches shown in Figure XI.1. See Color Plate 15.   XI.1 The Radiosity Equations  275  An example of a scene broken into patches is shown in Figure XI.1, which shows a table and a box sitting in a room with the whole scene drawn as wireframe quadrilaterals. This is a particularly simple example of a scene to break into patches, for all the surfaces are already rectangular. However, complications arise even here because the changes in illumination levels are more pronounced near corners; thus, it helps to use smaller patches near corners.  Several important issues are involved in making a good choice for the patches. The smaller the patches, the more likely it is that the radiosity algorithm will succeed in calculating lighting levels well. On the other hand, the radiosity algorithm takes time at least O n2 , where n is the number of patches, and so the running time increases quadratically with the number of patches. Even worse, the memory usage is also O n2 . Thus, it is common to use some kind of adaptive meshing in which some patches are large and some patches are small. In Figures XI.1–XI.3, we used smaller patches near the sides of the room, near the box, and under the table: the idea is that patches should be smaller where the illumination levels are changing more rapidly.  We will not further discuss issues in how to choose patches  see  Cohen and Wallace, 1993; Sillion and Puech, 1994  for a discussion of good tactics for choosing patches . Instead, we henceforth assume that patches have already been chosen. We label the patches P1, P2, . . . , Pn. We let Ai denote the area of patch Pi .  The central goal of the radiosity algorithm is to determine the average brightness of each patch Pi . For this, we deﬁne Bi to equal the light energy leaving patch Pi divided by the area of Pi . Thus, the brightness Bi measures the light energy per unit area averaged over patch Pi . Note that the Bi values are different from the intensity levels, denoted I , discussed in Chapter III. The intensities I were deﬁned as light ﬂux per unit area perpendicular to the direction of light propagation, whereas Bi equals light ﬂux per unit of surface area. The reason for using brightness values instead of intensity levels is that we now are interested in the illumination levels for each individual patch rather than  at least for the moment  in the illumination that reaches a viewer. However, the assumption that the surfaces are Lambertian means the perceived brightness of a patch is proportional to its Bi value and independent of the viewing angle.  Often, the term “radiosity” is used for the values Bi , but we will use the more intuitive term  to denote the brightness of the total light shining onto patch Pi . The equation  “brightness.”  We write Bin i  relating the incoming and outgoing brightnesses is  Bi = Ei + Ri · Bin  ,  i  XI.1  where Ei is the emissiveness of the patch and Ri is its reﬂectivity. Like the brightness values Bi and Bin i , the emissiveness Ei is measured in terms of light energy per unit area. The factor Ei represents the amount of light being generated by the surface  as compared with being reﬂected by the surface . Positive values of Ei are used for patches that are light sources. For ordinary surfaces other than lights, Ei should equal zero. The reﬂectivity value Ri speciﬁes the color of the patch. Since we are considering only a single wavelength, Ri is a scalar that equals the fraction of incoming light that is  diffusely  reﬂected by the patch. We require that 0 ≤ Ri < 1. If Ri = 0, the patch is not reﬂective at all, and values of Ri close to 1 mean that the patch is highly reﬂective. Values of Ri close to 0 are appropriate for black surfaces, and values near 1 are appropriate for white surfaces.  Equation XI.1 gives a formula for the light leaving a patch in terms of the light incident on the patch. We also want to express the light incident to a patch in terms of the outgoing brightnesses of the rest of the patches. The light incident on a patch Pi should be equal to the total light leaving the other patches that directly illuminates patch Pi . To express this mathematically, let Fi, j be the fraction of the light leaving patch Pi that shines directly onto   XI.2  XI.3  XI.4  XI.5  = n cid:27   j=1  Ai Bin i  Fj,i A j B j .  Ai Fi, j = A j Fj,i .  = n cid:27   j=1  Bin i  Fi, j B j .  Bi = Ei + Ri  Fi, j B j .  n cid:27   j=1    B1  ... Bn  B = E + MB.   I − M B = E.  276 Radiosity patch Pj without reﬂecting off any intermediate patches. To handle the case of i = j, we let Fi,i = 0. The values Fi, j are called form factors.  Since brightness is measured in terms of light energy per unit area, the total light leaving patch Pj is equal to A j B j . Likewise, the total light entering patch Pi is equal to Ai Bin i . Therefore, the deﬁnition of form factors gives us  We will see later that the form factors satisfy the following reciprocity equation:  With this, equation XI.2 may be rewritten as  Combining equations XI.1 and XI.3 gives the radiosity equation:  The radiosity equation can be rewritten in matrix form by letting  B =  and  E =    E1  ... En  and letting M be the n × n matrix, M =  Ri Fi, j  i, j . Then, the matrix form of the radiosity equation is  By letting I equal the n × n identity matrix, this can be rewritten as  The vector E of emissivities and the reﬂectivity values Ri are presumed to be known, and we will see how to compute the form factors Fi, j . It will then remain to compute the value of the brightness vector B. One way to do this would be to invert the matrix  I − M . However, matrix inversion is relatively time consuming and difﬁcult, and so we discuss alternate, iterative methods of computing B in Section XI.3.  XI.1.2 High-Level Description of the Radiosity Algorithm  We can now describe the major steps in the basic radiosity algorithm. These are illustrated in Figure XI.4. The ﬁrst step is to model the scene and break it into patches Pi . We presume that the emissivities Ei and the reﬂectivities Ri are given ahead of time.  The second step is to compute the form factors Fi, j . This typically is the computationally difﬁcult part of the radiosity algorithm and consumes most of the time needed for the radiosity computation. We discuss a couple methods for computing form factors in Section XI.2. Once the form factors are computed, it is easy to compute the entries in the matrix M and set up the radiosity equation XI.5.  The third step is to solve the radiosity equation for the brightness levels B. Several methods for solving this are presented in Section XI.3. These are iterative methods that mostly work   XI.2 Calculation of Form Factors  277  Mesh scene as patches  Compute  form factors  Solve  radiosity equations  for B  Render with  smooth shading  Figure XI.4. The four stages of the radiosity algorithm.  by chasing light around the scene from the light sources  i.e., patches with nonzero emis- sivity values  and calculating better and better estimates for the brightness levels of all the patches.  The fourth step is to render the scene. Each patch has been assigned a brightness  or color , but we do not merely want to render each patch as a ﬂat color; instead, we want to use interpolation to render the surfaces with smooth shading.  Figures XI.2 and XI.3 illustrate the difference between ﬂat and smooth shading.  To obtain smooth shading, we ﬁrst use the brightness levels for each patch to set the brightness levels for each patch vertex. For instance, each patch vertex can be assigned a brightness equal to a weighted average of the brightness levels of the adjacent patches. Once the brightness level is set for each vertex, then the patches can be rendered by standard means using Gouraud interpolation. The use of interpolation and shading helps to smooth out the lighting and hide the fact that we computed a uniform average brightness level for each patch.  Several complications arise in the fourth step. First, the lighting levels will generally be only continuous – but not C 1-continuous – across patch boundaries, which can sometimes cause visible edges due to “Mach banding.” The human eye is fairly sensitive to discontinuities in the ﬁrst-order derivative of lighting levels, and this tends to make boundaries between patches more visible than expected. Second, if the patches are not uniform in size, one must be careful with adjacent patches that share an edge. This was already discussed at the end of Chapter II as well as on page 177 with Figure VII.15. If a larger patch shares part of an edge with another smaller patch, then the common edge should be split for rendering the larger patch too.  The ﬁrst three stages of the radiosity algorithm in Figure XI.4 are view independent. The ﬁnal, fourth state is view dependent of course, but this stage is computationally easy and efﬁcient. For this reason, radiosity lends itself well to precomputation of lighting and allows interactive walkthroughs.  Figure XI.4 shows the most basic form of the radiosity algorithm. Frequently, one wishes to use adaptive methods to form patches: that is, on the basis of the quality of the solution obtained in the third stage, one may wish to reﬁne the patches in areas where light levels are changing rapidly or where the solution otherwise needs more accuracy. Thus, sophisticated algorithms may alternate between solving the radiosity equations, and adding more patches and computing new form factors.  XI.2 Calculation of Form Factors  Recall that Fi, j is equal to the fraction of the light leaving patch Pi that goes directly to patch Pj . Clearly, the values of Fi, j are always in the interval [0, 1]. We assume that we have an enclosed environment so that all light leaving a patch hits some other patch; in other words,  n cid:27   j=1  Fi, j = 1.  This holds without loss of generality, for, if necessary, we can add completely nonreﬂective black patches surrounding the environment.   278  Radiosity  Patch P1 , area A1 .  Patch P2 , area A2 .  Figure XI.5. A large patch and small patch.  To aid our intuition about the values of Fi, j , consider the situation shown in Figure XI.5. Here, a small patch P2 is facing upward, and centered above it is a large patch P1 facing downward. We expect the value of F1,2 to be small, since only a relatively small fraction of the light leaving the upper patch hits the small lower patch. Conversely, we expect the value of F2,1 to be large because the larger patch P1 ﬁlls much of the ﬁeld of view of the smaller patch.  Now consider two small patches Pi and Pj obliquely facing each other, as shown in Figure XI.6. The distance between the centers of the patches is equal to d, and the normal vectors to the two patches make angles ϕi and ϕ j with the line joining the centers of the two patches. Here we assume that ϕi and ϕ j are both less than 90 , for otherwise the two patches would not face each other and the form factors would be zero, Fi, j = 0 = Fj,i .  ◦  We make the further assumption that the patches are inﬁnitesimally small so as to simplify estimation of the form factors. The patches have areas Ai and A j . Consider the ﬁeld of view of patch Pi . The other patch Pj has area A j but is turned away at an angle of ϕ j and is a distance d away. Consider what happens when patch Pj is projected towards Pi onto the unit sphere centered around Pi . The area that the projection of patch Pj occupies on that unit sphere is equal to  cos ϕ j  A j  d2. The area of the upper half of the unit sphere is equal to 2π; hence, the fraction of Pi ’s ﬁeld of view that is occupied by patch Pj is  The surface of patch Pi is assumed to be Lambertian. A large Lambertian surface has the same apparent brightness from any viewing angle. But, as we remarked already on page 72, because of the foreshortening of areas when viewed obliquely the fraction of light that leaves the patch Pi in a direction at an angle ϕi from the normal is proportional to cos ϕi . Therefore, the fraction Fi, j of the light energy that leaves Pi in the direction of Pj is proportional to  The constant of proportionality is set from the condition that the total light leaving patch Pi should of course be fraction 1 of the light. For this, we let S2+ denote the upper half of the  XI.6   cos ϕ j  A j  .  2πd2  cos ϕi   cos ϕ j  A j  .  2πd2  Pj  nj  ϕj  Aj  d  ni  ϕi  Pi  Ai  Figure XI.6. Two inﬁnitesimally small patches Pi and Pj with areas Ai and A j . The normals to the patches are ni and n j .   XI.2 Calculation of Form Factors  unit sphere and, thinking of the patches A j constituting the unit sphere around Pi , evaluate the integral  ,  S2+  , π 2  ϕ=0  cos ϕ d A =   cos ϕ  2π sin ϕ  dϕ = π.  Therefore, we need to drop the factor of 2 from Equation XI.6, and the form factor Fi, j is equal to  279  XI.7  One convenient property of the form factors is the reciprocity property that  Fi, j =  cos ϕi   cos ϕ j  A j  .  πd2  Fi, j Ai = Fj,i A j .  The reciprocity property is an immediate consequence of Equation XI.7. In some cases, the reciprocity property can effectively cut the work of computing form factors in half. Usually, the areas are known; thus, once the form factors Fi, j with i < j have been computed, the rest can be computed by using Fj,i = Fi, j Ai  A j .  The preceding derivation of Formula XI.7 for the form factor is simple enough, but there are two potentially serious pitfalls. First, the formula was derived under the assumption that the two patches are inﬁnitesimal but are separated by a noninﬁnitesimal distance d. Often this assumption does not hold, and, in this case, the actual form factor may be quite different from the value given by Formula XI.7. As a general rule, if the sizes of the patches are small compared with the distance d, then Equation XI.7 will be close enough to the correct value for practical purposes. Deﬁne the diameter of a patch to be the diameter of the smallest circle that contains the patch. Then if the distance d between the patches is at least ﬁve times the diameters of the patches, then Equation XI.7 is likely to be sufﬁciently accurate.  One might wish to have a better formula for the form factors that could be applied to  say  arbitrary rectangles. Such formulas can be derived for important special cases, but even in simple cases, such as two patches that share a common edge and meet at right angles, the formulas are quite complicated. Thus, if you want more accurate calculation for form factors, you must perform a double integral over the surfaces of the two patches. In practice, this means that the two patches are divided into multiple, sufﬁciently small subpatches, and the form factors between each subpatch of Pi and subpatch of Pj are computed using XI.7. These form factors are then combined to obtain the overall form factor Fi, j for Pi and Pj .  The second pitfall in using Equation XI.7 concerns visibility. In other words, if there are other patches between Pi and Pj , then they can obstruct the light from Pi to Pj . Now, if the light from Pi to Pj is completely blocked, then Fi, j is just equal to 0. On the other hand, if the light is only partially blocked, the form factor needs to be reduced by multiplying by the fraction of light from Pi that can reach Pj .  XI.2.1 The Ray Tracing Method  One method for computing the visibility between patches is to use ray tracing. We sketch a simple, and fairly robust, way to compute form factors with the aid of ray tracing.  The computation of the form factors will be based on Equation XI.7 but with an additional visibility term Vi, j , which is an estimate for the fraction of patch Pi that is visible from patch Pj . Note that we will have Vi, j = V j,i . One way to compute Vi, j is to cast rays from k positions on patch Pi towards k positions on patch Pj . Ray tracing is then used to determine if these rays intersect any intermediate objects. We then set Vi, j equal to the fraction of rays that were not obstructed by intersections with intermediate objects.   280  Radiosity  Pj  Pi  Figure XI.7. Projection onto a hemicube.  A good way to choose the k rays is to use the method of jittering discussed in Chapters V and IX. You can choose k jittered subpixel positions on each of Pi and Pj , then choose a random one-to-one correspondence between jittered positions in Pi and jittered positions in Pj , and cast rays between the corresponding points.  The rest of the form factor calculation is unchanged. We let ci and c j be the centers of Pi and Pj , let d be the distance from ci to c j , and let ϕi and ϕ j be the angles that the patches’ normals make with the vector c j − ci . Then the form factor can be estimated by  Fi, j = Vi, j   cos ϕi   cos ϕ j  A j  .  πd2  XI.2.2 The Hemicube Method  The hemicube method, introduced by  Cohen and Greenberg, 1985 , is a method for computing form factors that takes advantage of hardware acceleration using the depth buffer algorithms present in most graphics chips. The hemicube algorithm computes the form factors for a particular patch Pi by rendering a view of the world from the viewpoint of patch Pi . For every other patch Pj , this rendered view can be used to determine what fraction of Pi ’s ﬁeld of view is occupied by patch Pj . After compensating for distance and for the cosine factors, we obtain the form factor Fi, j .  The basic idea of the hemicube algorithm is illustrated in Figure XI.7. Here a virtual hemicube is placed over the center of an inﬁnitesimal patch Pi . The hemicube is the top half of a cube with sides of length 2. The ﬁeld of view occupied by patch Pj is projected towards Pi onto the hemicube. Clearly, the form factor Fi, j is the same as the form factor from Pi to the projection of Pj .  This does not yet take visibility or occlusion into account. Now, for each of the ﬁve faces of the hemicube, the top and the four sides, we render a view of the scene from the center of Pi as seen through that face. This maps every other patch onto a  possibly empty  set of pixels of the viewscreen, and the depth buffer algorithm keeps track of which patches are visible in the direction of any given pixel. At the end of rendering the scene from the point of view of Pi , we do not display the rendered scene as usual but instead read the contents of the image buffer to determine which patch was visible at each pixel position.  We use a trick to determine which patch is visible in each pixel position. We do not render the patches in their correct color but instead assign to each patch Pj a distinct color C j . Then,   XI.2 Calculation of Form Factors  281  Pixels on top face: z = 1.  z  Shows Pj  ϕj   cid:2   d =  x2 + y2 + 1  ϕi  0  x, y  Figure XI.8. A row of pixels along the top of the hemicube. One pixel shows patch Pj . The origin is placed at the center of patch Pi . The top of the cube is the z = 1 plane.  Pj is visible at a given pixel position if and only if the pixel has been rendered with color C j . Since there are typically  256 3 many distinct colors, plenty of colors will be available to give each patch a distinct color.  The hemicube algorithm estimates the form factor Fi, j as the sum of the form factors from Pi  to the pixels showing Pj , namely, as   fraction of Pi ’s light that reaches pixel .  XI.8  Fi, j =   cid:27   Pixels  showing Pj  Figure XI.8 shows the situation for a pixel in the top surface of the hemicube. Here a pixel containing the color of Pj is at coordinates  cid:5 x, y, 1 cid:6  on the top surface of the hemicube, where the coordinates refer to the natural coordinatization of the hemicube relative to placing the origin at the center ci of patch Pi . The distance from ci to the pixel is d = x 2 + y2 + 1. The angles ϕi and ϕ j are equal, and the cosine of this angle is equal to 1 d. Thus, referring back of the hemicube is cid:27  to Equation XI.7, we ﬁnd that the contribution to the summation XI.8 from pixels on the top   cid:27    cid:20    1 d  1 d  Pi xel Area   =  πd2   Pi xel Area   ,  πd4  Pixels on top showing Pj  Pixels on top showing Pj  where d4 =  x 2 + y2 + 1 2. The “Pi xel Area” value is equal to the area occupied by a single pixel on the top of the cube. Since the top of the cube is a 2 × 2 square, the pixel area will be 4  w h , where h and w stand for “height” and “width,” respectively, and are the dimensions of the image buffer measured in pixels.  Pixels from the view through the side faces of the hemicube contribute similarly to the form factor Fi, j . For instance, pixels on any of the four side faces of the hemicube, as shown in Figure XI.9, contribute the following amount to Fi, j :   cid:27   Pixels on side showing Pj  z Pi xel Area   ,  πd4  where z is the z-component of the side face pixel.  There are some odd side effects that can arise when using the hemicube method. One phenomenon is that patches are treated asymmetrically when computing form factors. That is, when computing Fi, j for i ﬁxed and for all j’s, we are essentially treating patch Pi as a single point, whereas we are treating the other patches as extended areas. Therefore, the reciprocity j Fi, j = 1; this is condition may no longer hold. On the other hand, it is still guaranteed that   cid:28    282  Radiosity   cid:2   d =  1 + y2 + z2  ϕj  Shows Pj  cos ϕ i = z d j = 1 d cos ϕ  z  ϕi  0  Figure XI.9. A row of pixels along the x = 1 side of the hemicube.  x = 1  x, y  important because the convergence of the algorithms discussed in the next section for solving the radiosity equations depends on this fact. Finally, like any method based on discretization into pixels, the hemicube method is subject to errors involving aliasing.  XI.3 Solving the Radiosity Equations  We now assume that all patch geometry has been set and the form factors have all been computed; this means that the matrix M is completely known, and it remains to solve the radiosity equation XI.5 for the value of the brightness vector B. The ﬁrst section below will discuss theoretical issues, especially iterative methods that can obtain approximate values for B. The basic iterative method, called Jacobi iteration, works by solving a ﬁxed point equation by iterating a function. However, there are various ways to improve on this basic iteration. We give sketches of proofs that these various methods are guaranteed to converge. The remaining three sections describe the details of implementing successively better iterative methods for solving the radiosity equations.  Recall that the matrix form of the radiosity equations is  XI.3.1 Iterative Methods   I − M B = E.  The vectors B and E have n entries, M is an n × n matrix, I is the n × n identity matrix, and we assume that E and M are known. We wish to solve for the brightness vector B.  Of course, one way to solve for B would be to invert the matrix I − M and just set  B =  I − M   −1E.  The problem with this is that inverting a large matrix can be computationally expensive and difﬁcult to implement robustly. Because n is the number of patches in the scene, the matrix is indeed quite large, say on the order of n = 10, 000 for moderately complex scenes. It is not hard to verify that the straightforward algorithms for matrix inversion require running time of O n3 , and so it would be prohibitively difﬁcult to invert such a large matrix.  On the other hand, the matrix M enjoys several special properties, and there are iterative methods that can exploit these properties to get better and better approximations to the correct solution to the radiosity equation. These special properties of M are captured by the next lemma.  Deﬁnition The entry in the ith row and jth column of M is denoted mi, j . We denote this by M =  mi, j  i, j . Let max M  be the maximum entry of M. Let RowSumi  M  be the sum of the   283  XI.3 Solving the Radiosity Equations  entries in the ith row of M, that is,  RowSumi  M  = n cid:27   mi, j .  j=1  Finally, let MaxRowSum M  = max{ RowSumi  M  : i = 1, . . . , n}. Lemma XI.1 Let M =  mi, j  i, j be the matrix for the radiosity equation.  a  For all i, j, mi, j ≥ 0.  b  0 ≤ MaxRowSum M  < 1.  c  Let α = MaxRowSum M . For all k ≥ 0,  MaxRowSum  M k   ≤ αk . In particular, max M k  ≤ αk.  n cid:27   j=1  n cid:27   j=1  mi, j = Ri  Fi, j = Ri .  Proof That  a  and  b  hold follows immediately from the deﬁnition of M. Each diagonal entry of M is zero, and each off-diagonal entry is equal to mi, j = Ri Fi, j , which is certainly nonnegative. Thus,  a  holds. To prove  b , note that the sum of the entries in the ith row is equal to  As discussed in Section XI.1.1, the reﬂectances are strictly less than 1 for any realistic situation. Thus, each row sum is less than 1, and because there are ﬁnitely many rows the maximum row sum exists and is less than 1.  Now we prove  c . For k equal to 0 or 1,  c  is trivially true. The general case is proved by induction on k. First note that every entry in M k is nonnegative. To prove the induction step, we need the following fact: Claim If N =  ni, j  i, j and P =   pi, j  i, j are arbitrary matrices containing only nonnegative entries, and if ν = MaxRowSum N   and ρ = MaxRowSum P , then  To prove the claim, note that the entry in row i and column k of the product N P is equal to  MaxRowSum N P  ≤ νρ. n cid:27   ni, j p j,k .  j=1  Thus, RowSumi  N P  can be bounded by ni, j p j,k =  RowSumi  N P  =   cid:27    cid:27   ni, j  p j,k  j  k   cid:27   j   cid:27   cid:27   k  j  ≤  ni, j ρ ≤ νρ.  That proves the claim, and now part  c  follows easily by using induction on k.   cid:1  In particular, part  c  of the lemma implies that every entry in M k is ≤ αk. Thus, since α < 1, the matrices M k converge quickly to zero as k tends to inﬁnity. With part  c  of the lemma proved, we are now able to establish that the matrix I − M is invertible. One motivation   284 Radiosity for the next theorem comes from the Taylor series for the function f  x  = 1  1 − x . It is not hard to show, via the formula for Taylor series, that  1 1 − x  = 1 + x + x 2 + x 3 + x 4 + ··· ,  for all x such that x < 1. Thus, one might guess that a similar fact holds for the matrix I − M, namely,   I − M   −1 = I + M + M 2 + M 3 + M 4 + ··· ,  the condition that  x < 1 is now played by the property that where the role of MaxRowSum M  < 1. This formula for matrix inverse does indeed hold, as the next theorem states. Theorem XI.2 Let M satisfy the properties of parts  a  and  b  of Lemma XI.1. Then I − M is invertible, and its inverse is equal to the inﬁnite sum  I + M + M 2 + M 3 + M 4 + ··· .  XI.9  Proof We give a sketch of the proof. The ﬁrst observation is that the summation XI.9 converges to a matrix N , where the limit N is a matrix in which all entries are ﬁnite. This is because each entry in M k is in the range [0, αk] and the geometric series   cid:28  Let Nk be the matrix equal to the ﬁrst k + 1 terms in the series  αk has a ﬁnite limit.  k  Nk = I + M + M 2 + M 3 + ··· + M k .  As k → ∞, Nk → N , where N is the matrix given by XI.9. Now,   I − M Nk =  I − M  I + M + ··· + M k−1 + M k   =  I + M + ··· + M k−1 + M k  −  M + M 2 ··· + M k + M k+1  = I − M k+1.  Since M k+1 → 0, we have  I − M Nk → I as k → ∞. By the continuity of matrix product, this means that  I − M N = I . This proves the theorem.  cid:1   An important consequence of Theorem XI.2 is that there is a unique solution B to the radios- ity equation, namely, B =  I − M  −1E. The theorem also suggests one method for approxi- mating B: First, choose a value of k large enough so that M k is expected to be sufﬁciently close to zero. Then, compute Nk, the ﬁrst k + 1 terms of the power series. Then set B = N kE, so that  B =  I + M + M 2 + M 3 + ··· + M k E.  This would indeed work, but the runtime would still be much slower than we would like, for computing powers M i of M requires iterated matrix multiplication and the usual algorithms for matrix multiplication have a fairly poor cubic runtime of O n3  for n × n matrices. There are better algorithms for matrix multiplication, but even those are still not as good as we would like. To ﬁnd a faster algorithm, we cast the radiosity equation back into its original form B = E + MB. We think of this as a ﬁxed point problem by deﬁning an operator  cid:27  that acts on matrices by   cid:27  B  = E + MB.   cid:27  B  = B.  Then we are seeking a B  in fact, the unique B  such that   XI.3 Solving the Radiosity Equations  285  We call such a B a ﬁxed point of  cid:27 . A standard way to solve ﬁxed point problems is to choose an initial guess for the value of B and then repeatedly apply the operator  cid:27 . If we are lucky  and we will be lucky in the present situation , repeatedly applying  cid:27  yields a sequence of matrices that converge to a ﬁnite limit. In that case, the limit of the sequence will be a ﬁxed point of  cid:27 .  To make this more concrete, deﬁne a sequence of vectors B0, B1, B2, . . . by  B0 = 0 Bk+1 = E + MBk ,   the zero vector   for all k ≥ 0. Thus, B1 = E and B2 = E + ME =  I + M E and B3 = E + ME + M 2E =  I + M + M 2 E. For general k,  Bk+1 =  I + M + M 2 + ··· + M k E.  Therefore, by the earlier theorem and proofs, Bk converges to the solution of the radiosity equation as k increases.  The ﬁxed point algorithm for approximating the solution B of the radiosity equation is mathematically equivalent to the power series algorithm. However, in the ﬁxed point algorithm, each iteration uses only one matrix–vector product and one matrix addition. This takes time only O n2 + n  = O n2  and is considerably faster than the power series algorithm, which required matrix multiplications. There is a simple physical intuition for the meaning of the intermediate brightness vectors Bk obtained by the ﬁxed point iteration method. The ﬁrst nonzero one, B1 = E, is just the directly emitted light. The second one, B2 = E + ME, is equal to the emitted light plus the illumination from a single bounce of the emitted light. The kth one, Bk, is equal the lighting that results after k − 1 bounces of reﬂected light. A useful property of the Bi vectors is that they are increasing. Let the notation Bk,i represent the ith entry of Bk. Then the increasing property states that, for all i, k, we have Bk,i ≤ Bk+1,i . This is easy to prove by induction on k using the fact that every entry in the matrix M is nonnegative. Intuitively, this corresponds to the fact that the more reﬂection bounces that are taken into account, the brighter the scene gets.  i >k  The proofs of Theorem XI.2 and Lemma XI.1 give an estimate for the rate of convergence of the ﬁxed point iterative algorithm. Namely, the errors of the entries Nk are bounded by αi = αk+1  1 − α , where α is the maximum reﬂectivity of the patches. Actually, the error tends to zero more like βk, where β is the average of the reﬂectivities. Thus, not sur- prisingly, the lower the reﬂectivity values, the fewer the iterations that are needed to achieve a good accuracy. That is, the lower the reﬂectivities, the smaller the number of “bounces” that need to be followed.   cid:28   The iterative ﬁxed point method described above is the same as the Jacobi iteration given  in more detail in the next section.  XI.3.2 Jacobi Iteration  The Jacobi method for solving the radiosity equation is just the iterative method described in the previous section. This algorithm successively computes B1, B2, B3, . . . . Here is the algorithm expressed in terms of individual entries, rather than in terms of vectors.  JacobiIteration.     B[], E[] and Bnew[] are arrays. E[] is already set.    m[i,j] denotes mi, j .    Initialization: set B = E.   286  Radiosity  Set B[i] = E[i];  For i = 1 to n { }    Main loop.  cid:28  While  not converged enough  {  Set Bnew[i] = E[i] +  For i = 1 to n { } For i = 1 to n { }  Set B[i] = Bnew[i];  n j=1m[i,j]*B[j];  }  }  The algorithm uses the emissivity array E instead of the zero vector 0 for its initial brightness vector: this saves one iteration of the loop. The array Bnew[] is used to save a separate copy of B[] so that the previous values can be remembered long enough to compute the new values. Strictly speaking, there is no need to copy back the array values; instead, the two arrays could alternate roles on each iteration of the loop.  We have not shown any explicit test for whether the solution has converged sufﬁciently. Usually, this would just involve checking whether the change in value of B[i] is sufﬁciently small for all i. This can be tested by checking the values of Bnew[i]-B[i].  XI.3.3 Gauss–Seidel Iteration  The Gauss–Seidel method is an improvement of the Jacobi method that is easier to implement and converges to the solution faster. The new feature of the Gauss–Seidel method is that it does not save a copy of the old values of B[] but instead updates them immediately.  Gauss-Seidel Iteration.     B[] and E[] are arrays. E[] is already set.    m[i,j] denotes mi, j .    Initialization: set B = E. For i = 1 to n { }    Main loop. While  not converged enough  {  Set B[i] = E[i];  For i = 1 to n { }  Set B[i] = E[i] +   cid:28   n j=1m[i,j]*B[j];  The Gauss–Seidel method is sometimes called the gathering method. The reason for the name “gathering method” is that you can think of the computation’s updating the brightness Bi of patch Pi  that is, B[i]  by setting1   cid:27   j  Bi = Ei +  mi, j B j  as gathering together all the light from other patches to calculate the brightness of patch Pi . The difference with the Jacobi method is that we apply the update to Bi immediately instead  1 This Bi should not be confused with the vector Bi  note the difference in font .   XI.3 Solving the Radiosity Equations  287  of waiting until the next loop iteration for the new value to take effect. Thus, the new value of Bi affects the updated values of B j for j > i in the same loop iteration.  It is not hard to show that the Gauss–Seidel algorithm converges to the correct solution of the radiosity equation. In fact, it is easy to prove, by induction on the number of gathering calculations, that the brightness values in the array B[] computed by the Gauss–Seidel method are less than or equal to the correct brightness values. In addition, if Bk denotes the brightness vector obtained after k − 1 iterations of the Jacobi algorithm loop, and BG S the brightness vector obtained by k − 1 iterations of the Gauss–Seidel loop, then the entries in the vector BG S are greater than or equal to the corresponding entries in Bk. This fact is also easily proved by induction on k by again using the nonnegativity of the entries of M. Therefore, the Gauss–Seidel results are sandwiched between the results of the Jacobi iteration and the correct solution. Because the Jacobi algorithm converges to the correct solution, the Gauss–Seidel algorithm must also converge to the correct solution. In practice, the Gauss–Seidel method tends to converge noticeably faster than the Jacobi method.  k  k  XI.3.4 The Shooting Method  The shooting method, also known as the Southwell iteration method, is another iterative method for solving the radiosity equations. For both the Gauss–Seidel and Jacobi methods, a basic update step consists of choosing a single patch and updating its brightness level based on the brightnesses of all the other patches. The shooting method operates rather differently: the basic update step now chooses a single patch and sends  or “shoots”  its brightness out to all the other patches. That is, instead of concentrating on a single receiving patch at a time, the shooting method concentrates on a single transmitting patch. To make this work, the shooting method must track, for each patch Pj , how much of its brightness level has not yet been taken into account by the brightness levels of the other patches Pi .  The shooting algorithm maintains two brightness values for each patch, Bi and  cid:15 Bi . Both Bi and  cid:15 Bi will always be nonnegative, and the overall brightness of the patch is equal to the sum Bi +  cid:15 Bi . The value  cid:15 Bi represents the part of the brightness of patch Pi that has not yet been transmitted on to the other patches. The update loop consists of choosing a value for i and “shooting” the  cid:15 Bi value to all the other patches, thereby updating the values of all the other patches to take into account the brightness due to  cid:15 Bi .  The shooting algorithm is as follows.  Shooting_Method     B[] and  cid:15 B[] and E[] are arrays.    Initialization. For i = 1 to n { Set B[i] = 0; Set  cid:15 B[i] = E[i];  }    Main loop While  not converged enough  {  Choose j so that  cid:15 B[j]*A j is maximized; Set B[j] = B[j] +  cid:15 B[j]; For i = 1 to n { } Set  cid:15 B[j] = 0;  Set  cid:15 B[i] =  cid:15 B[i] + m[i,j]* cid:15 B[j];  }     A j = area of Pj   288  Radiosity     Finish up For i = 1 to n { }  Set B[i] = B[i]+ cid:15 B[i];  The choice of j was made so as to ﬁnd the patch having the largest amount of outgoing light energy that has not been accounted for. Since the brightness values B[] are measured in terms of light energy per unit surface area, we multiply the unshot brightness value  cid:15 B[i] times the patch area to measure the total outgoing light energy. Thus, this choice for j attempts to “shoot” the largest amount of light energy possible. Other choices for j could work well too, but it is important that every j value that still has unshot brightness get picked eventually.  The runtime of a single shooting operation is clearly just O n . For comparison, a single gather operation is also O n ; the advantage of the shooting algorithm lies in the possibility that fewer shooting operations may be needed because the shooting algorithm concentrates its efforts on the patches with the most “unshot” light.  The test in the while loop for sufﬁcient convergence would probably be based on a threshold value for the largest  cid:15 B[i]*Ai value. The code written above assumes that the diagonal entries m[j,j] in the matrix are equal to zero.  Exercise XI.1 Prove that, under the assumptions we have been making about the matrix M, the shooting method is guaranteed to converge to the correct answer. [Hint: Prove bounds on how fast the summation  i Ai  cid:15 Bi is decreasing. Use the reciprocity condition.]  Further Reading: This chapter has covered only the most basic aspects of radiosity. Good sources for information on more advanced topics in radiosity are the books  Cohen and Wallace, 1993  and  Sillion and Puech, 1994 . There is a hierarchical method of calculating form factors that can greatly reduce the computational work in very large scenes  Hanrahan, Salzman, and Aupperle, 1991  Advanced work in global lighting often combines techniques from radiosity and ray tracing.   Ashdown, 1994  gives a theoretical description and complete code for a radiosity renderer.   cid:28    XII  Animation and Kinematics  XII.1 Overview  The term animation refers to the process of specifying or controlling the movement of objects. Of particular concern to us in this chapter is the use of mathematical techniques to aid in the programming of animation.  Traditional animation techniques, used notably in movies, substantially predate comput- erized animation. Traditionally, animation requires drawing a series of pictures, each picture showing an instantaneous snapshot of objects in motion. These are then displayed in rapid succession, giving the visual effect of smooth motion. The same general idea applies to com- puter animation: a software program repeatedly renders a three-dimensional scene with each scene showing the objects at a particular point in time. These scenes are then displayed at a sufﬁciently fast frame rate to give the visual illusion of motion.  Nowadays, much of the work of animation is being taken over by computers. An artist will create objects, people, creatures, and so on as three-dimensional models in a CAD program. These models can include information about the formation and permissible motions of the objects. For instance, an object may have a skeleton of rigid links connected by joints, and the joints can be given characteristics that control their motion. The rest of the object can be controlled to move in synchronization with the skeleton. One such technique is called skinning and permits the “skin,” or surface, of a creature to move in conjunction with the movement of the skeleton. Once a model has been properly created and the appropriate software is written, the task of an animator is simpliﬁed greatly: he or she needs to control only the motion of the skeleton to control the motion of the entire model. Furthermore, techniques such as inverse kinematics  IK  allow an even simpler interface for the animator; inverse kinematics permits the animator to set the positions or orientations of only a few selected portions of the skeleton, and the software can automatically control the rest of the skeleton.  The outline of this chapter is as follows. First, there is some general introductory discussion about topics including keyframing, motion capture, and applications of animation and of forward and inverse kinematics. Next, we discuss some problems in animation of position, including “ease-in” algorithms. Animation of orientation is covered next, including yaw, pitch, and roll, as well as an in-depth treatment of quaternions. The chapter concludes with forward and inverse kinematics for articulated rigid bodies  multibodies .  289   290  Animation and Kinematics  XII.1.1 Techniques Evolved from Traditional Animation  Many techniques from traditional animation are useful for computer animation. Space  and lack of knowledge  prevents us from covering very much traditional animation, but you can ﬁnd extensive information on techniques traditionally used in animation in the books  Thomas and Johnston, 1981  and  White, 1986 .  The former book has a thorough discussion of animation at Disney.  Traditional animation is certainly more of an art than a science, and considerable experience and talent were needed to devise styles of animation that produce visually pleasing results. Of course, using computers for animation is no less of an art than traditional animation.  Several mathematical aspects of computer animation are direct extensions of techniques  used in traditional animation: two prominent examples are keyframing and motion capture.  Keyframing. Keyframing is the process of creating animated motion by specifying the positions of objects at keyframes and then ﬁlling in the motion in intermediate frames by interpolation. For traditional animation of movies, the keyframes, also called keys, are drawn by a senior animator. Other artists, inbetweeners and inkers, draw the intermediate frames and ﬂesh out the complete detailed drawings. The keyframes typically show the extreme poses, or most critical poses. Initially, the keyframes can be in only rough form without complete details. The job of the inbetweener would be to draw the intermediate poses, being sure to make the motion look ﬂuid and natural.  Keyframing is particularly important to the animation of full-length movies. A movie shows 24 frames per second, and thus there are too many frames for a single artist to draw all the frames in a movie. On the other hand, if multiple artists draw different parts of the movie, then consistency of style is lost. By employing a few senior animators to draw the keyframes and a larger number of inbetweeners and inkers, a movie can be drawn with a smaller number of senior animators. A single senior animator can handle the drawing of all keyframes for a particular character in the movie, providing more consistency of style.  The computerized analogue of keyframing and inbetweening is the use of splines for interpolating points. At keyframes, the positions, orientations, and shapes of objects in the scene are speciﬁed. Then, by using interpolating curves, one can obtain positions, orientations, and shapes of the objects as smooth functions of time. This often can be done fully automatically with Catmull–Rom or Overhauser splines, but manual editing can also be employed  e.g., using tension-continuity-bias splines .  Motion Capture. Motion capture is the measurement of the motion of  real-world  objects and the use of these measurements to guide animated motion. In early animated movies, motion capture consisted of ﬁlming live action. The ﬁlmed live action could be traced over to generate animated motion. For instance, to animate a ﬁght scene, one might ﬁrst ﬁlm a movie of a two actors mock ﬁghting. This could be translated into an animated ﬁght by using the motion and timing of the ﬁlmed ﬁght as the basis for the animated motion. Of course, the ﬁlmed motion capture does not need to be followed too slavishly. For instance, if one were animating a ﬁght involving Daffy Duck, then one certainly would not want the movements of Daffy Duck to follow the motion of the actor exactly. Rather, the motions would be modiﬁed to reﬂect Daffy’s physiology, and some aspects of the motion would be exaggerated for better artistic results. This kind of motion capture, when properly used, can greatly increase the ﬂuidity and naturalness of the animated motion.  Modern versions of motion capture involve attaching sensors to actors that allow measure- ment of their three-dimensional motion. There are various types of motion capture sensors. Some motion capture systems work by using small devices  called diodes  that sense motion   XII.1 Overview  291  through electrical or magnetic ﬁelds; these magnetic sensors can provide both position and orientation data in real time. Optical motion capture systems work by attaching bright reﬂective spheres to the actors and tracking the spheres with multiple cameras: the multiple camera views can be combined to give three-dimensional positional information. Other systems work by at- taching mechanical sensors to the actor’s body that directly measure joint angles or bending, and so on. A small-scale example of this is the data glove, which can capture precise ﬁnger movements.  All approaches provide for measurement of the position of each sensor as a function of time. The motion capture data usually needs  often signiﬁcant  processing to remove noise and distortion. After the motion capture data has been cleaned up, it can be translated into information about positions and joint angles. This detailed information about positions of parts of the bodies as a function of time can be used to control animated motion that is highly realistic. Typical applications include capturing the motion of actors performing movements such as walking, running, and ﬁghting or of acrobats or athletes performing movements. These animated movements can be approximated by spline curves and played back to reproduce the captured motion as an animation.  XII.1.2 Computerized Animation  The kinds of systems that can be animated with the aid of computers include the following:  Particle Systems. Particle systems are collections of particles moving as a group. These can be used to simulate a wide range of phenomena, including smoke, ﬂuids, and the ﬂocking behavior of large crowds or large groups of creatures.  Rigid Bodies. A rigid body does not change shape as it moves but does change position and orientation. It may be controlled directly in terms of its position and orientation or indirectly in terms of velocity and angular velocity.  Articulated Rigid Bodies. Articulated rigid bodies, also called multibodies, are hierarchi- cally connected assemblages of rigid bodies called links. The connections between the rigid bodies are generally joints. The joints may be rotational or translational; more com- plicated joints, such as screw joints, are also possible. Examples of objects that can be modeled as multibodies include skeletons of humans or other creatures; for this, the links are the bones of the skeletons. Other examples include robot arms and other mechanical linkages.  Flexible Objects. Flexible objects include cloth or rope as well as “squishy” or bendable  objects.  Camera Viewpoint. An important element in many computer games is the use of a camera that follows the player around as he or she navigates an environment. The camera needs to follow the viewpoint of the player without having excessive jerkiness, oscillation, or other jitter.  Other Specialized Phenomena. Other applications of animation are diverse, including  topics such as lightning, clouds, galaxy collisions, and many more.  The rest of the present chapter will be concerned with the animation of rigid bodies and of  articulated rigid bodies.  The motion of rigid bodies can be completely described in terms of position and orientation. The speciﬁcation of position is, at least from a mathematical viewpoint, quite straightforward. The position of an object is usually given by specifying the position of its center of mass, and the position consists of a single point in R3. Similarly, the velocity of an object  the velocity of the center of mass of the object, for instance  is just a single vector. Of course, both   292  Animation and Kinematics  position and velocity will generally be functions of time. Section XII.2 will cover some simple topics involved in controlling the position of objects.  Specifying and controlling the orientation of a rigid body are more problematic. There are several possible ways to represent orientation, including rotation matrices, yaw-pitch-roll angles, and quaternions. Section XII.3 discusses these ways of representing rotation with particular attention to the theory of quaternions. It also discusses spherical linear interpolation  slerping  for interpolation between two quaternion speciﬁcations of orientation.  Articulated rigid bodies are taken up in Section XII.4. Techniques for animating articulated bodies can be divided roughly into two categories. The ﬁrst category, kinematics, concerns the relationship between joint angles or, more generally, joint settings and the positions of the links. Typical concerns of kinematics include the relationships between, on the one hand, the joint angles and their rate of motion and, on the other hand, the positions and velocities of the links. The second category is dynamics and is concerned with physical properties such as forces, accelerations, energy, and so on. It is often convenient to subdivide techniques for animation of articulated objects further into four categories:  Forward Kinematics. The forward kinematics problem is as follows: Given settings for  all the joint angles, determine the positions of all the links in the articulated structure.  Inverse Kinematics. The inverse kinematics, or IK, problem is as follows: Given a desired position for one or more links of an articulated object, determine settings for the joint angles that will achieve the desired position. For example, we set the position of one or more of the hands or feet of an animated person and then solve the IK problem to determine good settings for all the joints in the body that give the hands or feet the desired positions. Inverse kinematics allows an animator to set only the position of a small number of links; for instance, to simulate a person reaching for an object, the animator could specify the trajectory of the hand as a function of time and let the IK algorithm automatically determine the position of the joints and thereby the position of the rest of the body. Not surprisingly, the inverse kinematics problem is much more difﬁcult than the forward kinematics problem.  Forward Dynamics. Forward dynamics is the same as physical simulation. If we are given the initial positions, orientations, velocities, and angular velocities  or essentially equiv- alently, if we are given the initial joint angles and rates of change of joint angles , and, if we are further given information about all external forces and torques, then we want to compute the movement of the articulated object as a function of time. This usually requires a physical simulation of the object’s motion.  Inverse Dynamics. The inverse dynamics problem is usually considerably simpler than forward dynamics. Here, we are given the motions of all the links  or, equivalently, the motions of all the joint angles . The problem is to determine what forces must be applied, ﬁrstly at the joints and secondly from external sources, to obtain this motion.  Section XII.4 will treat the mathematical theory of forward and inverse kinematics. We will  not discuss dynamics at all.  XII.2 Animation of Position  The position of an object at time u can be given by a single vector q u . We have several tools for describing curves q u , namely B´ezier curves and B-splines. To animate position using keyframing, one picks times u0, u1, . . . , un and corresponding values for q ui   for each i. Then, B´ezier or B-spline interpolation, as described in Sections VII.15 and VIII.13, can be used to describe the curve at arbitrary times u, for u0 ≤ u ≤ un.   XII.2 Animation of Position  293  Often, one wants to animate nonpreprogrammed motion. By “nonpreprogrammed” we mean that the motion is not following a path determined in advance but is instead following a path in response to changing circumstances. A notable example of this is in interactive applications such as computer games. However, nonpreprogrammed motion can also be useful in noninteractive situations. A prime example of nonpreprogrammed motion is the motion of the camera, or viewpoint, in a computer game that must follow the movement of a player around a virtual world. The player could be a character moving on foot or could be a vehicle in a driving game, and so on. The camera then needs to follow behind the character, keeping the character and the environs in view. In addition, the camera needs to move smoothly without jerkiness.  One way to control a camera position is with techniques known as “ease-in.” Ease-in refers to moving from a starting position to a desired position in a smooth, nonjerky fashion with no sudden changes in position or velocity and perhaps with an additional constraint of no sudden changes in acceleration. A real-world example of ease-in is the motion of a subway train or an airport tram as it stops at a station. The tram needs to stop smoothly with no sudden changes in acceleration that would jerk passengers, but it also needs to end up at a precise location so that the automatic doors line up correctly. The ease-in problem in computer graphics is much simpler to solve than the ease-in problem for trams because we do not have to deal with real-world considerations like brakes or with needing feedback to measure current velocity and position accurately.  XII.2.1 Ease In: Fixed Target  The ﬁxed-target ease-in problem is as follows. At some time u0, an object has position p0 and velocity v0. It is desired that at some future time u1 the object have position p1 and stay there with velocity 0. The airport tram mentioned above is an example of the ﬁxed-target ease-in problem. A simple solution to this ﬁxed-target ease-in problem can be given using degree three Hermite polynomials.  Hermite polynomials were deﬁned in Section VII.5.  First, if u0 = 0 and u1 = 1, then we can let  q u  = p0 H0 u  + v0 H1 u  + p1 H3 u   and let q u  specify the position at time u, 0 ≤ u ≤ 1. It is easy to verify that this meets all the requirements of the ease-in problem. In addition, the position curve q u  is a degree three polynomial and thus has a constant third derivative; consequently, the acceleration of the object is changing at a constant rate throughout the movement.1  For general u0 < u1, we need to make a change of variables by setting   cid:11    cid:12   .  u − u0 u1 − u0  Ji  u  = Hi  The functions Ji have properties similar to the Hermite functions but on the domain [u0, u1] instead of on [0, 1]. Note, however, that the change of variables affects the ﬁrst derivatives, and thus 1 u0  =  cid:3  J  1  .  u1 − u0  1 This solution would not be good enough for the above-mentioned tram example since the acceleration  does not go smoothly to zero at u = 1.   294 The curve q u  can then be deﬁned for u0 ≤ u ≤ u1 by q u  = p0 J0 u  +  u1 − u0 v0 J1 u  + p1 J3 u .  Animation and Kinematics  Exercise XII.1 The ﬁxed-target ease-out problem is similar to the ﬁxed-target ease-in problem but has initial position p0 and velocity 0 at time u0 and needs to reach a target position p1 and velocity v1 at time u1. Give a solution to the ﬁxed-target ease-out problem based on Hermite polynomials.  XII.2.2 Ease In: Moving Target  The moving target version of the ease-in problem is the problem of making an object both move smoothly and track a moving target. An example of this would be a camera position in a computer game; in a ﬁrst-person exploration game, or in a driving game, the camera position needs to follow behind the player position smoothly. In this case, it is desirable for the camera to stay at a more-or-less ﬁxed distance behind the player, but it is also important for the camera not to move too jerkily.  We will use the term “target position” to indicate the position we wish to track or approx- imate. The term “current position” means the current position of the object that is trying to track the target position. We assume that the animation is being updated in ﬁxed time steps, each time step being of duration  cid:15 t. Let ti denote the target position at time step i, that is, at time step i ·  cid:15 t. Let ci be the current position of the tracking object at time step i. In each time step, we are given the target positions up through ti+1 and wish to compute ci+1.  We will discuss two versions of the moving-target ease-in problem. In the ﬁrst case, suppose that neither the target nor the object has any inherent velocity. By “has inherent velocity,” we mean that the object has enough mass or inertia that velocity should not change abruptly. In the case where neither the target nor the tracking device has inherent velocity, a very simple update is to set  ci+1 =  1 − α ci + αti+1  for some ﬁxed scalar α between 0 and 1. This deﬁnes the next position ci+1 as a weighted average of the current position ci and the target position. The higher α is, the faster the object’s position responds to changes in the target position but the greater the possibility of jumpy or jerky movement. The best value for α would depend on the time step  cid:15 t and on the particular application.  For the second case, suppose the target does not have a velocity, but the tracking object  does. The current velocity of the tracking object can be approximated as  If the object were to keep moving at this velocity, then its next position would be  vi = ci − ci−1  .   cid:15 t  ci + ci − ci−1   cid:15 t   cid:15 t = 2ci − ci−1.  However, we want also to incorporate the new target position so we can set  ci+1 =  1 − α  ·  2ci − ci−1  + α · ti+1.  This sets ci+1 to be an average of the target position and the position the object would reach if there were no change in velocity.   XII.3 Representations of Orientations  295  In both cases, the closer the value of α is to 1, the more tightly the object tracks the target;  the closer α is to 0, the smoother, and less jerky, the motion of the object is.  XII.3 Representations of Orientations  We now turn to the problem of animating the orientation of objects. A rigid body’s position in space can be completely speciﬁed in terms of the position of its center  its center of mass, say  and its orientation. The position of the center of the rigid body is speciﬁed by a single vector q ∈ R3 and is readily amenable to keyframing and interpolation. Specifying the orientation of a rigid body is more problematic. There are several ways to represent orientations, and the best choice of representation depends on the application at hand.  Let us consider two examples of animation of orientation. As a ﬁrst example, consider the orientation of a camera or viewpoint. The camera is given a position as usual, and then its orientation can speciﬁed by a view direction and an “up” direction, as was used by the gluLookAt command. Cameras usually have a preferred up direction, namely, pointing up along the y-axis as much as possible. As a second example, consider the orientation of a spacecraft traveling in deep space away from any planets or suns. There is no preferred “up” direction in space, and so the orientation of the spacecraft is essentially arbitrary when it is not moving. If the spacecraft is accelerating, or has nonzero velocity relative to its surroundings, the spacecraft has a preferred forward orientation direction; but even in this case, it would generally not have a preferred axial rotation  or roll amount .  This lack of a preferred up direction for spacecraft is somewhat counterintuitive to us, for we are so used to living on the surface of a planet. Indeed, in popular shows such as Star Trek, spacecraft always have an up direction and, furthermore, whenever two spacecraft meet in an episode of Star Trek, they always miraculously share the same up direction. That is, they never meet turned axially or facing each other upside down, and so on. Of course, this common up direction is unrealistic because there is no reason that there should be a shared “up” direction out in deep space. On the other hand, for spacecraft near a planet, there is of course a preferred up direction, namely away from  or towards  the planet. For instance, the U.S. space shuttle frequently orients itself so that its top side is facing the Earth.  When animating orientation, the decision of how to represent orientations is crucial. For applications that have a preferred up direction  such as cameras , it is probably useful to use the yaw, pitch, and roll representation. For applications that do not have a preferred up direction, and where it is necessary to blend or interpolate orientations, quaternions provide a good represen- tation. We will discuss these representations, along with rotation matrices, in the next sections.  XII.3.1 Rotation Matrices  Specifying an orientation is essentially identical to specifying a rotation, namely, if we choose an initial orientation  cid:27 0, then any other orientation  cid:27  can be speciﬁed in terms of the rotation that takes the body from  cid:27 0 to  cid:27 . As was discussed in Chapter II, an orientation in 3-space can be described by an orthonormal 3 × 3 matrix that represents a rigid, orientation-preserving transformation.  A big drawback to using rotation matrices for animating orientation is that they cannot be interpolated or averaged in a straightforwardly. For instance, consider the following two rotation matrices:     0  0 1 1 0 0 −1 0 0  0 −1 0   .  1 0  0 0  0 1  and  XII.1   296  Animation and Kinematics ◦ ◦ The ﬁrst matrix represents a 90 rotation around the y-axis, and the second represents a 90 rotation around the z-axis. If you attempt to take the average of these two rotations by just adding the matrices and dividing by two, you obtain the matrix   0  1 2 −1 2   .  −1 2 1 2 1 2 0 1 2 0  The resulting matrix is not even orthonormal and certainly does not represent a rotation midway between the two initial rotations.  XII.3.2 Yaw, Pitch, and Roll  Yaw, pitch, and roll specify an orientation in terms of three successive rotations around the x-, y-, and z-axes. This is particularly useful for orientations in settings where there is a preferred up direction, such as for cameras or for airplane navigation.  Actually, yaw, pitch, and roll is only one example of a more general class of methods called Euler angles, which specify a rotation in terms of three rotations around three axes. There are many different forms of Euler angles depending  a  on the order in which the rotations are performed  i.e., on the order in which the axes x, y, and z are chosen for rotations , and  b  on whether the axes move with the object or remain ﬁxed in global coordinates. Yaw, pitch, and roll performs rotation ﬁrst around the y-axis  yaw , then around the x-axis  pitch , and ﬁnally around the z-axis  roll . The second and third rotations  pitch and roll  are around the local x- and z-axes that move with the object, not around the ﬁxed x-, z-axes in world coordinates.2 Figure XII.1 shows the effects of yaw, pitch, and roll on the orientation of an airplane.  So far, we have described the axes of rotations for yaw, pitch, and roll as being local axes that move with the object being rotated. An equivalent way to describe the rotations is as being made around the ﬁxed x-, y-, and z-axes. By “ﬁxed,” we mean that the axes do not move with the object. However, as discussed in Section II.1.7, if ﬁxed rotation axes are used, the rotations must be performed in the opposite order: ﬁrst roll around the z-axis, then pitch around the x-axis, and ﬁnally yaw around the y-axis. This representation of yaw, pitch, and roll around ﬁxed axes lets us give a formula for yaw, pitch, and roll. Let θy, θ p, and θr be the yaw, pitch, and roll angles with directions of rotation determined by the right-hand rule. Then the effect of the yaw, pitch, and roll is the transformation  Rθy ,j ◦ Rθ p ,i ◦ Rθr ,k.  XII.2  Exercise XII.2 The methods of Chapter II let you express the rotations Rθy ,j, Rθ p ,i, and Rθr ,k as 3 × 3 matrices. Use these to derive the formula for the rotation matrix of for- mula XII.2 in terms of the sines and cosines of the three angles. Your answer should have  the formsys psr + cycr  sys pcr − cysr c pcr cys pcr + sysr where cy = cos θy, sy = sin θy, etc.  cys psr − sycr  c psr   ,  syc p −s p cyc p  2 Our conventions for the names “yaw,” “pitch,” and “roll” and for the order in which the rotations occur are based on the assumption that the z-axis is the forward direction, the x-axis is the rightward direction, and the y-axis is the upward direction. The reader is warned that other conventions are often used.   XII.3 Representations of Orientations  297  Yaw y  x  Pitch  Roll  z  Figure XII.1. Yaw, pitch, and roll represent rotations around the y-axis, the x-axis, and the z-axis. If the axes move with the object, the rotations are performed in the order yaw, then pitch, and ﬁnally roll. If the axes are taken as ﬁxed, then the rotations are performed in the opposite order: roll, then pitch, then yaw. Rotation directions are determined by the right-hand rule. The reader is warned that the rotation directions for pitch and yaw shown in the ﬁgure are opposite to customary usage in aviation. For us, a positive pitch means the nose dips down, and a positive yaw steers to the left. However, aviation conventions are that a positive pitch means the nose moves up, and a positive yaw means turning to the right. It is customary for positive roll to mean that the right wing dips, which agrees with our convention. In aviation conventions, the directions of the x and y axes are reversed with the x-axis pointing rightward and the y-axis pointing downward.  As we discuss in the next paragraph, yaw, pitch, and roll can sometimes lead to bad behavior of interpolation. On the other hand, yaw, pitch, and roll have the advantage of being intuitive. For instance, yaw, pitch, and roll are commonly used for airplane navigation since they correspond well to the controls available to a pilot. Yaw, pitch, and roll also work well for a camera. Actually, cameras usually do not use roll but instead keep roll equal to zero. The orientation for a camera can be given in terms of just yaw and pitch, and interpolating yaw and pitch values usually works well for interpolating camera orientation.  ◦  There are three ways in which the use of yaw, pitch, and roll can cause problems with interpolation. The ﬁrst two are easy to circumvent, but the third one  gimbal lock  is more serious. First, when interpolating yaw, pitch, and roll, you need to keep in mind that if angles are changed by 360 the orientation is unchanged. For instance, when interpolating from a yaw ◦ angle of 170  with pitch and roll both held ﬁxed, say equal to zero , rather than rotating the other direction it is usually intended that the yaw vary by only 20 ◦ ◦ through 340 to the second angle and interpolating . This is easily handled by adding 360 ◦ the yaw from 170 to 190 can of course have ◦ 360  ◦ .  The interpolated yaw values greater than 180  , to a yaw angle of −170  subtracted back off if desired.   ◦  ◦  The second potential pitfall with interpolating yaw, pitch, and roll is that every orientation has two distinct representations. Namely, the orientation represented by the angles θy, θ p, and θr is identical to the orientation represented by the following yaw, pitch, and roll angles:  XII.3  y  θ cid:3  θ cid:3  θ cid:3   p  r  = θy ± 180 ◦ = −θ p ± 180 = θr ± 180 ◦,  ◦   298  Animation and Kinematics  where any combination of plus or minus signs may be used. Thus, care must be taken when interpolating yaw, pitch, and roll angles to decide properly whether to transform the angles according to Equations XII.3 before performing the interpolations.  , pitch equal to−90  The third, and most serious, problem with interpolation of yaw, pitch, and roll involves gimbal lock, which occurs when a degree of freedom is lost at particular angle settings  to be precise, at pitch equal to ±90 ◦  . As an example, consider interpolation between the following two orientations:  cid:27 1 is the “standard position” orientation given with yaw, pitch, and roll all ◦ equal to zero. Let  cid:27 2 be the orientation with yaw equal to 90 , and roll equal to −90 ◦ .  You should visualize this! The airplane of Figure XII.1 in orientation  cid:27 2 would have its nose pointing up the y-axis and its bottom facing the positive z-axis.  The orientation  cid:27 2 suffers from gimbal lock since a degree of freedom has been lost: in particular, the yaw and roll axes have become effectively identical, and so changing either yaw or roll would have the same effect on the orientation  cid:27 2. Now suppose we try to use averaging to obtain an orientation ◦ midway between  cid:27 1 and  cid:27 2; straightforward averaging will give yaw equal to 45 , pitch equal to −45 . This orientation is by no means intuitively midway between  cid:27 1 and  cid:27 2: indeed, the intuitive midway position would be obtained by rotating around the  global, ﬁxed  x-axis. One could complain that this example is unfair, for it involves a pitch of 90 , say ◦ a pitch of 89  and results in gimbal lock; however, one could use instead a pitch very close to 90  , and then there would still be the same kinds of problems with interpolation.  , and roll equal to −45 ◦  ◦  ◦  ◦  ◦  Exercise XII.3 Verify that yaw, pitch, and roll angles θ cid:3  represent the same orientation as θy, θ p, and θr .  y, θ cid:3   p and θ cid:3   r of Equations XII.3  XII.3.3 Quaternions  Quaternions provide a method of representing rotations by 4-tuples. Recall from Euler’s theo- rem in Section II.2.4 that an arbitrary, rigid, orientation-preserving linear transformation can be expressed as a rotation around some ﬁxed axis. Such a rotation is speciﬁed by a rotation angle θ and a rotation axis u, where u is a unit vector: recall that this rotation was denoted Rθ,u. To represent Rθ,u with a quaternion, let c = cos θ 2 , s = sin θ 2 , and u =  cid:5 u1, u2, u3 cid:6 . Then the 4-tuple q deﬁned by q =  cid:5 c, su1, su2, su3 cid:6   is called a quaternion and represents the rotation Rθ,u. We will see that quaternions provide a useful method of representing rotations in situations where there is no preferred up direction. Most of the discussion to follow will give a theoretical development of quaternions. But  before starting the theoretical treatment, we point out a few practical issues.  Note that the magnitude of the quaternion q as deﬁned above is equal to one  strictly speaking this is not necessary, and we can also deal with nonunit quaternions; however, in practice, it is common to use only magnitude 1 quaternions . Conversely, suppose we are given an arbitrary 4-tuple of magnitude 1, say  such that r 2 1  let v =  cid:5 r2, r3, r4 cid:6  so that v = √  = 1. Then, since −1 ≤ r1 ≤ 1, we can set ϕ = cos 2, the vector  2. Since sin ϕ = ±√  1 − r 1  1 − r 1  2  3  4  −1 r1 . Also,  r =  cid:5 r1, r2, r3, r4 cid:6 , + r 2  + r 2  + r 2  u = v sin ϕ  is a unit vector. Finally, let θ = 2ϕ. Then we have  r =  cid:5 cos θ 2 , sin θ 2 u1, sin θ 2 u2, sin θ 2 u3 cid:6 ,   XII.3 Representations of Orientations  299  and so r is a quaternion representing the rotation Rθ,u. By this method, any unit 4-tuple represents a rotation. Nonunit 4-tuples can be normalized and thus also represent rotations. Quaternions have the unexpected property that −q represents the same rotation as q. This ◦ is because adding 360 to a rotation angle does not change the ending orientation. That is, Rθ+360◦,u is the same transformation as Rθ,u. Letting c, s, and q be deﬁned from θ and u as above, we have −c = cos θ 2 + 180  . Thus, −q is the quaternion ◦ that corresponds to the transformation Rθ+360◦,u, and so −q represents the same rotation as q. We next take up the theoretical development of quaternions. The theoretical discussion culminates with practical considerations of how quaternions represent rotations and how to perform interpolation  slerping  with quaternions. For more discussion of how quaternions represent rotations, the reader can also consult  Hart, Francis, and Kauffman, 1994 .    and −s = sin θ 2 + 180 ◦  XII.3.4 Theoretical Development of Quaternions  Quaternions were developed by the mathematician W.R. Hamilton in 1843 to represent rotations in 3-space. The quaternions were invented  or discovered?  as a generalization of complex numbers. The complex numbers are of course obtained from the real numbers by including the number i, which is a square root of −1. Quaternions further extend the complex numbers by including a total of three square roots of −1, which are represented by i, j, and k. Thus, we have i 2 = j 2 = k2 = −1. We wish to be able to multiply quaternions, and for this we need to deﬁne how the three new symbols i, j, k multiply with each other, namely,  i 2 = −1 i j = k ji = −k  j 2 = −1 jk = i k j = −i  k2 = −1 ki = j ik = − j.  Note that this multiplication is not commutative; for example, i j  cid:16 = ji.  A quaternion q is deﬁned to equal an expression of the form  d + ai + bj + ck,  XII.4  where d, a, b, c are all scalars from R. We also represent this quaternion by the 4-tuple q =  cid:5 d, a, b, c cid:6 .3  Two quaternions are deﬁned to be equal if and only if they have exactly the same four components.  Two unequal quaternions may still represent the same rotation.  Addition of quaternions is deﬁned component-wise, namely j + c    +  a + a  i   j +  c + c  cid:3  The product of a scalar and quaternion is deﬁned also as expected, namely,  k  =  d + d  cid:3  +  b + b   d + ai + bj + ck  +  d  i + b   cid:3  + a   k.   cid:3    cid:3    cid:3    cid:3    cid:3   α d + ai + bj + ck  =  αd  +  αa i +  αb  j +  αc k,  where α ∈ R. The product of two quaternions q1 and q2 is denoted q1q2  we reserve the dot product notation q1 · q2 for the usual dot product . The deﬁnition of multiplication is more complicated than the deﬁnition of addition and is deﬁned from the identities XII.4 using the  3 There are various conventions on representing quaternions, and many authors put the scalar component last in the 4-tuple and might prefer the notation  cid:5 a, b, c, d cid:6  for d + ai + bj + ck. Similarly, we later introduce the notation  cid:5 d; u cid:6 , and these authors would typically prefer  cid:5 u, d cid:6  instead. We prefer to put the scalar component d ﬁrst since it corresponds better to the way one treats complex numbers.   300  Animation and Kinematics  XII.5  XII.6   cid:3    cid:3   associative and distributive laws. This gives j + c k  i 2 + ab i + aa  cid:3   cid:3  k + ca jk + cd  cid:3   cid:3   cid:3  + bc  cid:3  + ad   j +  dc  cid:3  + cd   cid:3  + a i + b  cid:3   cid:3  j + dc k + ad  cid:3  ji + bb j 2 + bc  cid:3   cid:3    +  da  cid:3  − cc  cid:3   cid:3  + ca  cid:3  − ac  cid:3    d + ai + bj + ck  d i + db = dd  cid:3  + bd =  dd   cid:3  + da j + ba  cid:3   cid:3  − aa +  db   cid:3  − bb  cid:3  + bd   cid:3    cid:3  − cb  cid:3   i  cid:3  + ab  i j + ac  cid:3  ki + cb  cid:3    cid:3  ik k j + cc   cid:3   k2   cid:3  − ba   cid:3    k.  This formula for multiplication is fairly messy but can be expressed more clearly with vector notation. Let u be the vector u =  cid:5 a, b, c cid:6 . Then the notation  cid:5 d; u cid:6  is used as a shorthand nota-  cid:3  cid:6 , we can rewrite equation XII.5 tion for the quaternion  cid:5 d, a, b, c cid:6 . Letting also u as   cid:3  =  cid:5 a   cid:3 , b   cid:3 , c    cid:5 d; u cid:6    cid:5 d   cid:3    cid:3  cid:6   =  cid:5 dd   cid:3  − u · u   cid:3   ; u   cid:3  + d   cid:3   u + u × u   cid:3  cid:6 .  ; du  Thus, for q =  cid:5 d; u cid:6  and q equal to dd   cid:3  − u · u   cid:3    cid:3  =  cid:5 d   cid:3    cid:3  cid:6 , the scalar component of the quaternion product qq   cid:3   ; u  is  , and the vector component is du   cid:3  + d   cid:3   u + u × u   cid:3   .  Theorem XII.1 Quaternion addition is commutative and associative. Quaternion multipli- cation is associative. The left and right distributive laws hold for quaternions, that is, for all quaternions q, r, s,  q r + s  = qr + qs  and   r + s q = rq + sq.  The theorem is proved by simple calculations, and we leave the proof to the reader. On the other hand, we already mentioned that quaternion multiplication is not commutative; in Equation XII.6 the noncommutativity arises from the fact that u × u is not generally equal to  cid:3  × u. The noncommutativity may seem strange at ﬁrst; however, you are already quite familiar u with some other noncommutative systems. First, matrices  2 × 2 matrices, for instance  have addition and multiplication operations that satisfy properties similar to quaternions, and matrix multiplication is not commutative. As a second example, consider vectors over R3 with the usual vector addition and with cross product as the multiplication operation. Vector addition is of course associative and commutative. Furthermore, cross products are distributive over vector addition. However, the vector cross product is neither commutative nor associative.  The norm, or magnitude, of a quaternion q =  cid:5 d, a, b, c cid:6  is deﬁned to equal   cid:3    cid:20  d2 + a2 + b2 + c2.  q =  √ We deﬁne the conjugate, q d2 + u2, where u2 = u · u. Also, q quaternion multiplication, that  ∗  ∗ = q  ∗  q =  cid:5 d2 + u2; 0 cid:6  = q2.  qq  , of q to equal q  ∗ =  cid:5 d,−a,−b,−c cid:6 . If q =  cid:5 d; u cid:6 , then q = ∗ =  cid:5 d;−u cid:6 . It is easily veriﬁed, from the deﬁnition of  A unit quaternion is a quaternion with norm equal to 1.  √  2 2  , 0,  , 0 cid:6 , q2 =  cid:5  √  Exercise XII.4 Let q1 =  cid:5  √ a. Calculate q1 + q2, q1 − q2, and q1 + q3. b. Calculate the products q1q2, q2q1, q1q3, q3q1, and q1 q2 + q3 . c. Calculate q d. Calculate q1, q2, q3, q1q2, and q1q3.  ∗ 2 , and q  ∗ 1 , q  , 0, 0,  ∗ 3 .  2 2  2 2  2 2  √  XII.7   cid:6 , and q3 =  cid:5 2, 0, 0, 0 cid:6 .   XII.3 Representations of Orientations  301  Exercise XII.5 Give examples showing that the vector cross product is not commutative and not associative.  A quaternion  cid:5 d; 0 cid:6  with zero vector component will be identiﬁed with the scalar d ∈ R. This is compatible with the earlier deﬁnitions since the product dq is the same whether d is interpreted as a quaternion or as a scalar. Similarly, a vector u ∈ R3 will be identiﬁed with the quaternion  cid:5 0; u cid:6  with zero scalar component. Care should be taken when vectors are interpreted as quaternions because a vector cross product is not the same as a quaternion product.  Indeed, they could not be the same, for quaternion products are associative whereas vector cross products are not.  As an example, we have   i + j  × j = k,  but,   i + j  j =   cid:5 0, 1, 1, 0 cid:6    cid:5 0, 0, 1, 0 cid:6   =  cid:5 −1, 0, 0, 1 cid:6   cid:16 =  cid:5 0, 0, 0, 1 cid:6  = k.  The next theorem discusses the scalar multiplication and multiplicative inverse properties for quaternions.  Theorem XII.2 a. The scalar 1 =  cid:5 1; 0 cid:6  is the multiplicative identity, that is, q = 1q = q1 for all quater- b. Let s =  cid:5 s; 0 cid:6  be a scalar. Then sq = qs for all quaternions q. c. Let q be a nonzero quaternion. Then  nions q.  q  −1 = 1q2 q  ∗  is the multiplicative inverse of q, that is, qq  −1 = q  −1q = 1.  The proof of the theorem is by straightforward calculation; use Equation XII.7 to help prove part c. Note that if q =  cid:5 d; u cid:6  is a unit quaternion, then q −1 is very simply computable as −1 =  cid:5 d;−u cid:6 . q  −1 4 .  −1 2 , q  −1 1 , q −1 = q  Exercise XII.6 Let q1, q2, and q3 be as in Exercise XII.4. Also, let q4 =  cid:5 1, 0, 1, 0 cid:6 . Calculate q  −1 3 , and q  −1 1 .  −1 2 q  ∗ Exercise XII.7 Let q1 and q2 be arbitrary quaternions. Prove that  q1q2  1 and that  q1q2  Exercise XII.8 Let q1 and q2 be arbitrary quaternions. Prove that q1q2 = q1 · q2. [Hint: This can be proved with straightforward but messy algebraic manipulation; alter- natively, a slick proof can be given using the previous exercise and Equation XII.7.]  ∗ 2 q  ∗ = q  XII.3.5 Representing Rotations with Quaternions  We are now ready to  re state the method by which quaternions represent rotations. Fix a unit vector u and a rotation angle θ. Recall that Rθ,u is the rotation around axis u through angle θ with the rotation direction given by the right-hand rule. Let c = cos θ 2  and s = sin θ 2 , and let q be the quaternion  q =  cid:5 c, su cid:6  =  cid:5 c, su1, su2, su3 cid:6 .  The next theorem explains the basic method by which quaternions represent rotations: to rotate a vector v you multiply on the left by q and on the right by q  −1.   302 Animation and Kinematics Theorem XII.3 Let u, θ, and q be as above. Let v be any vector in R3, and set w = Rθ,uv. Then,  −1 = w.  qvq  XII.8  Some comments are in order before we prove the theorem. First note that q, as deﬁned ∗ = w. above, is a unit quaternion, and so q Second, Equation XII.8 uses our convention on treating vectors as quaternions, and so another way of stating XII.8 is  . So for unit quaternions we have qvq  −1 = q  ∗  q cid:5 0; v cid:6 q  −1 =  cid:5 0; w cid:6 .  Third, Equation XII.8 can also be used for nonunit quaternions. To see this, let α be a nonzero scalar and let r = αq. Then r −1 =  αq v α−1q  −1 =  1 α q −1  = qvq  −1, and thus −1 = w.  rvr  In other words, multiplying a quaternion by a nonzero scalar does not change the value of −1. In this way, quaternions act very much like homogeneous coordinates since, if we are qvq −1, multiplication by nonzero interested only in what rotation is represented by the formula qvq scalars has no effect. In most applications it is best to work with unit quaternions, which can be viewed as 4-tuples that lie on the unit sphere S3 in R4. Conversely, each point on the unit sphere S3 can be viewed as a quaternion.4 Antipodal points on the sphere represent the same rotation, for q and −q differ by a nonzero scalar factor.  In abstract algebra, a mapping of the form  v  cid:13 → qvq  −1,  computed by multiplying on the left by a ﬁxed element and on the right by its inverse is called an inner automorphism.  We now prove Theorem XII.3.  Proof  Theorem XII.3.  Let u, θ, and q be as in the statement of the theorem: in particular, u is a unit vector and q is a unit quaternion. Referring back to Figure II.14 on page 37, we write the vector v as a sum of two vectors v = v1 + v2 such that v1 is parallel to u and v2 is perpendicular to u. By the distributive law, the map v  cid:13 → qvq −1  + qv2q  −1 is linear, that is, −1.  −1 = v1 quq  qvq  −1 = qv1q  −1 + qv2q Therefore, it will sufﬁce to prove  a. quq b. qv2q  −1 = u, and −1 = Rθ,uv2 for v2 perpendicular to u.  First we prove a. by direct calculation: −1  −1 = [  cid:5 c; su cid:6    cid:5 0; u cid:6  ]q  quq  =   cid:5 0 − su · u; cu + su × u cid:6  q =   cid:5 −s; cu cid:6  q =   cid:5 −s; cu cid:6    cid:5 c;−su cid:6    −1  −1  4 The unit sphere S3 is the set of points{ cid:5 x, y, z, w cid:6  : x 2 + y2 + z2 + w2 = 1}. The superscript 3 means  that the surface of the sphere is a three-dimensional manifold.   XII.3 Representations of Orientations  303  =  cid:5 −cs + csu · u; s2u + c2u − csu × u cid:6  =  cid:5 −cs + cs;  s2 + c2 u cid:6  =  cid:5 0; u cid:6  = u.  These calculations used the fact that u is a unit vector, and so u · u = 1. In addition, c2 + s2 = 1 because c = cos θ 2  and s = sin θ 2 . We now prove b. We have v3 = u × v2 and v3 × u = v2, where v3 is deﬁned as in Section  II.2.3  again, see Figure II.14 on page 37 . We will explicitly compute qv2q  −1. First,  qv2 =   cid:5 c; su cid:6    cid:5 0; v2 cid:6    =  cid:5 0 − su · v2; cv2 + su × v2 cid:6  =  cid:5 0; cv2 + sv3 cid:6 .  Then,  −1 =   cid:5 0; cv2 + sv3 cid:6    cid:5 c;−su cid:6    qv2q  =  cid:5 0 + scv2 · u + s2v3 · u; 0 + c2v2 + csv3 − csv2 × u − s2v3 × u cid:6  =  cid:5 0; c2v2 + csv3 + csv3 − s2v2 cid:6  =  cid:5 0;  c2 − s2 v2 +  2cs v3 cid:6 . =  cid:5 0;  cos θ v2 +  sin θ v3 cid:6  = Rθ,uv2.  The last equality follows from Equation II.8 on page 42. The next-to-last equality follows from the sine and cosine double angle formulas:  cos 2ϕ  = cos2 ϕ − sin2 ϕ  and  sin 2ϕ  = 2 cos ϕ sin ϕ,  with ϕ = θ 2. We have thus completed the proof of Theorem XII.3.   cid:1   Using quaternions to represent rotations makes it easy to calculate the composition of two rotations. Indeed, if the quaternion q1 represents the rotation Rθ1,u1 and if q2 represents Rθ2,u2, then the product q1q2 represents the composition Rθ1,u1 Rθ2,u2. To prove this, note that  Rθ1,u1 Rθ2,u2v = q1 q2vq  −1 2  q  −1 1  =  q1q2 v q  −1 2 q  1   =  q1q2 v q1q2  −1 −1  holds by associativity of multiplication and by Exercise XII.7.  Exercise XII.9 Let R1 and R2 be the two rotations with matrix representations given in the formulas XII.1 on page 295.  that represent R2?  a. What are the two unit quaternions that represent R1? What are the two unit quaternions b. Let v =  cid:5 1, 3, 2 cid:6 . Compute R1v and R2v using quaternion representations from part a. by the method of Theorem XII.3. Check your answers by multiplying by the matrices in XII.1.  XII.3.6 Quaternion and Rotation Matrix Conversions Because a quaternion represents a rotation, its action on R3 can be represented by a 3 × 3 matrix. We now show how to convert a quaternion q into a 3 × 3 matrix. Recall from the   304  Animation and Kinematics  discussion on page 35 that a transformation A v  is represented by the matrix  w1 w2 w3 , where the columns wi are equal to A i , A j , and A k . Thus, to represent a quaternion q by a matrix, we set w1 = qiq  and w3 = qkq  w2 = qjq  −1,  −1,  −1,  and then the matrix representation will be  w1 w2 w3 .  Let q =  cid:5 d, a, b, c cid:6  be a unit quaternion. To compute qiq    cid:5 d, a, b, c cid:6    cid:5 0, 1, 0, 0 cid:6   =  cid:5 −a, d, c,−b cid:6 . −1 =  cid:5 d,−a,−b,−c cid:6 , compute qiq  −1 by  Then, since q  −1, ﬁrst compute    cid:5 −a, d, c,−b cid:6    cid:5 d,−a,−b,−c cid:6   =  cid:5 0, d2 + a2 − b2 − c2, 2ab + 2cd, 2ac − 2bd cid:6 .   .  qkq  d2 + a2 − b2 − c2  2ab + 2cd 2ac − 2bd  Similar computations give  qjq  −1 =  cid:5 0, 2ab − 2cd, d2 − a2 + b2 − c2, 2bc + 2ad cid:6  −1 =  cid:5 0, 2ac + 2bd, 2bc − 2ad, d2 − a2 − b2 + c2 cid:6 .  Thus, the matrix representing the same rotation as the quaternion  cid:5 d, a, b, c cid:6  is  d2 − a2 + b2 − c2  2ab − 2cd 2bc + 2ad  2ac + 2bd 2bc − 2ad  d 2 − a2 − b2 + c2  XII.9  A 3 × 3 matrix that represents a rotation can also be transformed into a quaternion. For this, we are given a matrix M =  mi, j   and want to ﬁnd a quaternion q =  cid:5 d, a, b, c cid:6  such that M is equal to XII.9. Furthermore, the quaternion will be a unit quaternion with d2 + a2 + b2 + c2 = 1. Since q and −q represent the same rotation, there are two possible answers.  There are several methods for converting M into a quaternion  see  Klumpp, 1976; Spurrier, 1978; Shepperd, 1978  . We follow the algorithm of  Shepperd, 1978 . The algo- rithm is also similar to the one given in Section II.2.3 to convert a rotation matrix into a rotation axis and rotation angle.  The ﬁrst step in the derivation of a quaternion from a matrix is to note the following identities:  m2,1 + m1,2 = 4ab m2,1 − m1,2 = 4cd  m1,3 + m3,1 = 4ac m1,3 − m3,1 = 4bd  m3,2 + m2,3 = 4bc m3,2 − m2,3 = 4ad.  XII.10  If we know one of the values of d, a, b, c, and if this value is nonzero, then we can solve for the other three values by using the appropriate three of these six equations. For instance, if we have the value for d, then we can solve for a, b, c by using the bottom three equations; note that this requires dividing by d and thus works only if d is nonzero. T = m1,1 + m2,2 + m3,3 = 3d2 − a2 − b2 − c2 = 4d2 − 1,  The trace of M is equal to the sum of its diagonal elements:  where the last step used d2 + a2 + b2 + c2 = 1. It is convenient also to use the notation m0,0 for the trace, that is, set m0,0 = T . Then, we have  2m0,0 − T = T = 3d2 − a2 − b2 − c2 = 4d2 − 1 2m1,1 − T = −d2 + 3a2 − b2 − c2 = 4a2 − 1 2m2,2 − T = −d2 − a2 + 3b2 − c2 = 4b2 − 1 2m3,3 − T = −d2 − a2 − b2 + 3c2 = 4c2 − 1.   XII.3 Representations of Orientations  305  We can use any of these four equations to solve for values of any of a, b, c, d; for instance,   cid:20   a = ± 1 2  2m1,1 − T + 1.  However, there is the complication that we would not be able to determine the proper signs for a, b, c, and d in this way. In addition, this approach would require the computational expense of four square roots. Therefore, instead of using all four equations, we use just one of them to calculate one of a, b, c, or d : this value may arbitrarily be set to be either positive or negative since it will affect only the overall sign of the quaternion. Then we can use the appropriate equations from XII.10 to solve for the other three variables. To choose which of a, b, c, d to solve for ﬁrst, recall that we want to avoid division by zero. Further, to avoid division by a value near zero, we can choose to solve for the one of a, b, c, d having the largest absolute value. It is evident from the four equations that this is done by choosing the largest mi,i , for 0 ≤ i ≤ 3 and using the corresponding equation.  We can write out the complete algorithm as follows:  M has entries mi, j , for i = 1, 2, 3 and j = 1, 2, 3.  Input: A rotation matrix M. Output: A quaternion  cid:5 d, a, b, c cid:6  Algorithm: Set m0,0 = m1,1 + m2,2 + m3,3; Set i so that mi,i = max{m0,0, m1,1, m2,2, m3,3};  cid:20  Switch   i   { Case 0:     Trace     i == 0  Case 1:     i == 1   cid:20   m0,0 + 1;  Set d = 1 Set a =  m3,2 − m2,3   4d ; 2 Set b =  m1,3 − m3,1   4d ; Set c =  m2,1 − m1,2   4d ; Return;  2m1,1 − m0,0 + 1; Set a = 1 Set d =  m3,2 − m2,3   4a ; 2 Set b =  m2,1 + m1,2   4a ; Set c =  m1,3 + m3,1   4a ; Return;   cid:20  2m2,2 − m0,0 + 1; Set b = 1 Set d =  m1,3 − m3,1   4b ; 2 Set a =  m2,1 + m1,2   4b ; Set c =  m3,2 + m2,3   4b ; Return;   cid:20  2m3,3 − m0,0 + 1; Set c = 1 Set d =  m2,1 − m1,2   4c ; 2 Set a =  m1,3 + m3,1   4c ; Set b =  m3,2 + m2,3   4c ; Return;  }  Case 2:     i == 2  Case 3:     i == 3   306  i  Animation and Kinematics  1  Figure XII.2. Lerping moves from 1 to i at a constant rate along the secant line. Slerping moves from 1 to i at a constant rate along the great circle. The points drawn on the secant line and on the great circle are obtained by lerping and slerping with α = 1  3 . They do not correspond to the same rotation.  The algorithm returns a single quaternion q =  cid:5 d, a, b, c cid:6 ; however, recall that −q repre- sents the same rotation. Depending on how you use the quaternion, you may need to determine which of q or −q is more appropriate.  XII.3.7 Interpolation of Quaternions  Interpolation of quaternions is best done with the spherical linear interpolation introduced earlier in Section IV.6. Because every rotation is represented by a unit quaternion, we restrict our attention to unit quaternions. Recall that unit quaternions can be viewed as points on the unit sphere S3 in R4. The only catch is that antipodal points on the sphere represent the same rotation; thus, each rotation has two possible representations as a unit quaternion. It is often important in applications to choose the more appropriate of the two possible representions. Suppose we are given two unit quaternions q1 and q2 and a scalar α ∈ [0, 1], and wish to interpolate between q1 and q2. Because the quaternions lie on the unit sphere, it is better to use spherical linear interpolation instead of ordinary linear interpolation. Namely, one can interpolate with  q α  = slerp q1, q2, α .  The slerp function is computed by the method of Section IV.6.  What would go wrong if we used linear interpolation  lerping  instead of spherical linear interpolation  slerping ? First, of course, the results would not lie on the sphere and would need to be renormalized. Even more important, linear interpolation would not result in a constant rate of rotation. For example, in Figure XII.2, the two quaternions 1 =  cid:5 1, 0, 0, 0 cid:6  and i =  cid:5 0, 1, 0, 0 cid:6  are shown. The latter quaternion corresponds to a 180 ◦ rotation around the x-axis. Both slerping and lerping can be used to move smoothly from the quaternion 1 to the quaternion i. However, using linear interpolation and computing q α  = lerp 1, i  causes the quaternion q α  to move along the straight line segment from 1 to i at a constant rate. On the other hand, setting q α  = slerp 1, i, α  causes q α  to move along the great circle from 1 to i at a constant rate. So only slerping makes the orientation vary at a constant rate.  Recall from Equation IV.28 on pages 123–124 that the formula for spherical linear interpo-  lation is  slerp q1, q2, α  = sin  1 − α ϕ   sin ϕ  q1 + sin αϕ  sin ϕ  q2.  Here ϕ is the angle between q1 and q2. This angle can be computed by using the dot product q1 · q2, which is equal to cos ϕ.  You treat q1 and q2 as ordinary vectors in R4 to compute the   XII.4 Kinematics  307  dot product.  Alternately, you may also compute the sine of ϕ and then take the arctangent, as was done on page 124 in the second version of the Precompute_for_Slerp.  One typically is really interested in interpolating between rotations rather than between quaternions. That is say, one is typically given two orientations and is asked to interpolate between them. The orientations can be converted to quaternions by the method of the previous section, but then one has the choice of negating one of the quaternions to get a second quaternion representation of the same orientation. The question then is, Should one use  slerp q1, q2, α   or  slerp q1,−q2, α   for the interpolation?  Negating both quaternions just negates the results of the slerp function, and so these are really the only two choices.  The usual way to resolve this question is to consider the angle between q1 and q2. If this is less than or equal to 90 , then slerp between q1 , then slerp between q1 and −q2. Physically, this corresponds to ◦ and q2. If it is greater than 90 rotating in the shortest direction between the two orientations. To determine whether the angle , form the dot product q1 · q2; the dot product is negative if and only if the ◦ is greater than 90 ◦ angle is greater than 90  ◦  .  Interpolation between quaternions can be used to create splinelike curves that take on quaternion values. The importance of this is that it allows orientation to be smoothly animated by a spline function in terms of control points. The main remaining technical difﬁculty is that slerping only interpolates between two quaternions at a time, but the usual deﬁnitions of B´ezier and B-spline curves in terms of blending functions require taking a weighted average of multiple control points at a time. This problem can be circumvented by using de Casteljau and de Boor methods, which allow calculating the value of a B´ezier curve or B-spline curve by a series of interpolations of two control points at a time.  Shoemake, 1985; 1987  employs this as the basis for some methods of using Catmull–Rom style curves that interpolate given quaternions, and several other authors have made similar suggestions. We have also proposed a method of forming the weighted average of multiple quaternions at a time in  Buss and Fillmore, 2001 .  XII.4 Kinematics  The term “kinematics” refers to motion or movement without regard to physical properties such as mass or momentum. Instead, kinematics refers to the purely geometric properties of motion such as position, orientation, velocity, rotational velocity, and so forth.  We focus on the kinematics of hierarchies of simple, rigid, three-dimensional objects linked with perfect joints; such assemblages are also called articulated objects or multibodies. Ap- plications include the animation of humans and other creatures by controlling their skeletal movement. These techniques can also be used for simulating chains or ropes by approximating them as a series of short rigid segments. Much of the theory of kinematics was developed for the analysis and control of mechanical linkages as well as for motion planning and control of robots.  The outline of the rest of this chapter is as follows. We ﬁrst set up a framework for dis- cussing rigid, articulated objects. This involves creating a tree structure of links, with each link connected to its parent by a single degree of freedom  1–DOF  joint. Next we examine forward kinematics: this involves methods for calculating positions and orientations of the rigid objects as functions of the joint positions. The ﬁnal section will take up the harder topic of inverse kinematics, which provides methods to control the positions of the joints so as to achieve a desired motion.   308  Root  Animation and Kinematics  End effector f  a  b  c  d  e   a   A linear chain of links with 1-DOF rotational joints.  Root  a  b  g  h  e  f  i  j  c  d  k   b   A tree-like arrangement of links and 1-DOF joints. The points h- k are end effector points.  Figure XII.3. Two examples of tree-like arrangements of links. The black dots represent 1-DOF rotational joints. The small circles are end effector points.  XII.4.1 Rigid Links and Joints  We wish to model simple arrangements of rigid bodies, called links, connected by joints. We make several simplifying assumptions. The ﬁrst assumption is that the joints are purely rotational and have a single degree of freedom  that is, they are 1–DOF joints . This assumption is not so crucial in that it can be relaxed signiﬁcantly without seriously affecting the difﬁculty of either forward kinematics or inverse kinematics. The second assumption is that the links are hooked up in a treelike fashion  i.e., there is no loop or closed chain of links . This second assumption is crucial for our discussion of kinematics: Indeed any loop or closed chain would imply dependencies among joint positions, and we would have no meaningful way to deal with these dependencies kinematically  as compared with dealing with the dynamics or physics of the bodies .  We assume therefore that we have a set L of links  rigid objects  connected by rotational joints  see Figure XII.3 . The links are organized as a tree; the nodes of the tree are the set of links from L. One of the links is identiﬁed as the root link, and the leaves of the tree  i.e., links that do not have any children  are called end links. Each link is joined to its parent and its children in the tree by 1–DOF rotational joints. A joint is attached to ﬁxed positions on two links and has a single axis of rotation; this is similar in effect to a door hinge, for example. The axis of rotation of the 1–DOF joint is ﬁxed relative to the two links that it joins. End links are also called end effectors. For each end effector, we pick a ﬁxed point on the link called an end effector point. The end effector points are the points we are trying to control with inverse kinematics. For example, for a robot arm, the end effector point could be the position of the hand or other tool at the end of the robot arm, and we would like to control the position, orientation, or both of the end effector.  XII.4.2 Forward Kinematics  To describe the positions of links mathematically, we need to set up a scheme for naming joints and effectors their positions and orientations, and so on. Each link x ∈ L has an attachment point, which is the place where link x is attached to its parent. The root link also has an attachment point, called the base position, where it is attached to a ﬁxed point. We assume each attachment point consists of a 1–DOF joint. A 1–DOF joint rotates around a single axis. This   XII.4 Kinematics  rb  rc  rd  re  rf  rh  re  rf  rc  rd  rk  ri  rj  rb  rg  309  Figure XII.4. The relative position vectors rx measure the relative rest positions of the links; ra = 0 and the other relative position vectors are as shown.  axis is ﬁxed relative to the two adjacent links but of course may depend on other joint angles. We use the variable θx to denote the angle of the 1–DOF joint connecting link x to its parent. The relative positions of the links  other than the root link  will be speciﬁed with variables rx . The relative position vectors rx are ﬁxed and are not functions of the joint angles. The relative positions rx for a link x are deﬁned as follows: if y is the parent link of link x, and if all the joint angles are set equal to zero, then rx is equal the vector from the attachment point of y to the attachment point of x. This is illustrated in Figure XII.4. We also deﬁne rx when x is an end effector point instead of a link. In this case, if x lies on link y, then rx is deﬁned to be the vector from the attachment point of y to the end effector point x. Examples of this in Figure XII.4 are r f in the ﬁrst ﬁgure and rh through rk in the second ﬁgure.  As discussed earlier in this section, the angle θx is measured in terms of the relative orien- tation of joint x to its parent. This means that if the parent link is rotated and θx is held ﬁxed, then x moves and changes orientation with its parent  see Figure XII.5.  We will use vectors vx to denote the rotation axis for the 1–DOF joint attaching x to its parent link  or, if x is the root link, attaching x to the base position . The vector vx is equal to the unit vector along the axis of rotation of the joint when all the joint angles equal zero. Of course, as the joint angles θx vary, the joints’ actual axes of rotation can change  we will denote these changing axes by wx below in this section .  The vectors rx and vx give a description of the mechanical functionality of the links. These vectors are ﬁxed and do not vary with the joint angles θx ; in other words, they are static. We will shortly deﬁne values sx and wx that give the positions of the joints’ attachment points and the joints’ rotational axes as functions of the joint angles θx .  The basic problem of forward kinematics is to obtain a formula for end effector point positions as functions of the angles θx . We solve this problem by deﬁning vectors sx that equal  θe  θd  θc  θb  θa  Figure XII.5. The angles of joints are measured relative to the two links that are joined.   Animation and Kinematics  310  sd f  θe  θd  θe  sb f  θb  θc  θd  θc  θd  θe  sc f  θe  θa  θd  sa f  θc  θb  Figure XII.6. The deﬁnitions of sy shown in Figure XII.3.  f for the end effector f and the links y = a, b, c, d of the linear chain  x is a function of the angles θz such that z ∈ Ty. For a link x, sy  the position of the attachment point of a link x or the position of an end effector x, where sx is a function of the joint angles. A good way to deﬁne the vectors sx is to traverse the tree of links starting from the end effectors up to the root. We will give formulas for intermediate vectors sy x , where x is either a link or an end effector point and the link y is an ancestor of x in the tree. The meaning of sy x is as follows  also, refer to Figure XII.6 . Let Ty be the set containing the link y and all the links z that are descendants of y in the tree, that is, Ty is the subtree rooted at y. Then sy x is the vector from the attachment point of y to the attachment point of x if it is assumed that the joint positions are set according to the values of the angles θz and that θz cid:3  = 0 for all other links z  cid:3   ∈ Ty. For an end effector point x, sy x is the vector from the attachment point of y to the point x again on the assumption that the joint positions are set according to the values of the angles θz and that θz cid:3  = 0 for all z x that describes the rotation axis x will be a function of the angles θz such that z ∈ Ty. for the joint attaching x. The vector wy The value of wy x is deﬁned to be the unit vector along the axis of rotation for the 1–DOF joint connecting x to its parent  based on the angles θz, z ∈ Ty  under the same assumption that θz cid:3  = 0 for z = 0  For a link x in the subtree Ty, we also deﬁne a vector wy  It is fairly easy to give recursive formulas for sy  x . For y = x, we have   cid:3   ∈ Ty.   cid:3   ∈ Ty.  x and wy  = vx .  and  wx x  And, for an end effector position x on the link y,  Then, for y equal to the parent link of w and for x in Tw, we have  sx x  sy x  = rx .  = Rθy ,vy  rw + sw x  , = Rθy ,vy  ww x  .  sy x  wy x   XII.4 Kinematics  311  As you should recall from Section II.2.3, Rθ,u represents the linear transformation that performs a rotation of θ degrees around the axis u.  These formulas for sy  the position of end effector f is given as a function of the joint angles by sa root link.  x sufﬁce to solve the forward kinematics problem. For instance, f , where a is the  x and wy  To avoid excessive superscripts, we henceforth let sx and wx equal  sx = sa  x  and  wx = wa  x  ,  where a is the root link. Thus, sx gives the position of the link or end effector point x as a function of the joint angles. Likewise, wx gives the rotation axis for the joint at link x.  We now turn to the inverse kinematics problem, which is to ﬁnd joint angles that will produce  desired values for the end effector positions.  XII.4.3 Inverse Kinematics, Setting It Up  The inverse kinematics problem is the problem of, given desired positions for some of the links, ﬁnding appropriate joint angles that will place the links in these positions. Applications of inverse kinematics include motion planning in real-world applications, such as in robotics, and also include animation in graphical environments – especially of articulated ﬁgures such as humans or other creatures.  Our discussion of inverse kinematics is based loosely on  Girard and Maciejewski, 1985 , who used inverse kinematics to animate the walking motion of legged creatures. See also the later paper  Zhao and Badler, 1994  for more advanced methods of inverse kinematics, applications to human ﬁgures, and references to related work.  In computer graphics, a typical application of inverse kinematics is animation of a creature. An animator may, for example, specify the desired positions of the hand and feet of a person, and then the inverse kinematics problem will be solved to ﬁnd good positions for the joints of the entire body. If this works well, the job of the animator can be signiﬁcantly simpliﬁed because this approach can eliminate the work of manually setting all the joint angles in a skeleton. Other applications include motion planning – either for robotics or in a virtual reality application. For instance, if it is desired to make an arm and hand reach out to grasp an object, then inverse kinematics can be used to ﬁnd possible solutions for the movement. Of course, these possible solutions may need to take into account issues such as collision detection and avoidance, or joint forces and joint limits.  We discuss only the “pure” form of inverse kinematics: in particular, we do not consider issues like collision avoidance or limits on joint angles. Rather, we discuss solutions to the following problem: Given a set of joint angles, and thereby, from forward kinematics, given the positions and orientations of all the links, and given a set of desired new positions for some of the links, we want to ﬁnd a way to change the joint angles so as to move the links’ positions closer to the desired positions. This process can be iterated in such a way that each iteration moves the links’ positions closer to their target positions until eventually new joint positions are reached that place the links close enough to their desired positions. The reason for using an iterative procedure is that it is usually too complicated to actually solve for joint angles, θ, in terms of the desired link positions. The iterative procedure will be easier to implement and, if it converges sufﬁciently well, can provide values for the joint angles that put the links arbitrarily close to their desired positions.  For a single step of the iterative procedure, we consider the function telling us how links’ positions depend on joint angles  this function is obtainable from the forward kinematics of the last section . We then evaluate the partial derivatives of this function to ﬁnd a linear   Animation and Kinematics  312  sx  sx − sy  sy  θy  Figure XII.7. The rate of change of the position sx of point x with respect to the joint angle θy is calculated in terms of rotation around the axis wy of the joint y as wy ×  sx − sy . The axis wy is pointing out of the page, and so wy ×  sx − sy  has the right direction for the partial derivative. Since wy is a unit vector, wy ×  sx − sy  also has the right magnitude. This calculation works for any x and y, not for just end effectors and the root link.  approximation to the function. That is, we compute the rates of changes in links’ positions with respect to the rates of changes in joint angles. These give a Jacobian matrix of partial derivatives. With some assumptions about the nonsingularity of the Jacobian matrix, we can then ﬁnd a way to change the joints’ angles so as to move the links’ positions closer to the desired positions. Since the Jacobian gives only a linear approximation to the function, we have to iterate the process until it converges  we hope!  to a good solution.  Suppose that x is an end effector position or an attachment point of a link and that we  cid:3  are seeking to set the joint angles so as to set the position sx of x equal to a target value s x . More generally, we may have more than one x and be trying to make each x reach its target  cid:3  position s x . We assume the links are already placed in some initial conﬁguration with known joint angles θ, where θ represents the vector of all the joint angles. The discussion in the previous section on forward kinematics gives us a formula for sx in terms of the angles θ. The ﬁrst step in setting up the inverse kinematics problem is to deﬁne the Jacobian matrix, which will tell us how the position of x changes with respect to small changes in the angles θ; in other words, the matrix will contain the partial derivatives of sx with respect to the variables θ. To deﬁne the Jacobian matrix, we must deﬁne the partial derivatives of the functions sx giving the link positions. We have sx as a function of θ, that is, sx = sx  θ . For particular links x and y, we can deﬁne ∂sx  ∂θy as follows:   cid:1   =  ∂sx ∂θy  0 wy ×  sx − sy  otherwise  if y = x or x  ∈ Ty  To see that this correctly deﬁnes the partial derivative, note the following:  a  If x is not a proper descendant of y, then the rotation of y’s joint does not affect the position of x, and so ∂sx  ∂θy = 0.  b  Otherwise, the vector from point y to point x is equal to sx − sy, and the rotation axis for angle θy is the axis wy. An inﬁnitesimal rotation ϕ radians around the axis wy centered at sy will move the point x an inﬁnitesimal distance given by the vector ϕwy ×  sx − sy . From this observation, the second part of the deﬁnition of ∂sx  ∂θy is obtained immediately. Figure XII.7 shows how to visualize the derivation of the formula for the partial derivative.5  5 The formula for ∂sx  ∂θy is only correct if angles are measured in radians. If the angle θ is measured in units of α radians, then the equation for the partial derivative becomes αwy ×  sx − sy . For example, if angles are measured in degrees, then α = π 180.   XII.4 Kinematics   cid:11  The vector version of the Jacobian matrix is then deﬁned to equal the m × n matrix   cid:12   313  ∂sx ∂θy  ,  x,y  where the rows of the matrix are indexed by the m many links x whose position we are trying to set  often, x ranges over the set of end effectors, for instance  and the columns of the matrix are indexed by the set of all joints y.  The entries in the preceding matrix are 3-vectors; to convert the matrix into an ordinary matrix with real numbers as entries, we replace each vector-valued entry by its column form. This gives a matrix of dimension  3m  × n. We call this  3m  × n matrix the Jacobian matrix and denote it J . Each row in J has length n and consists of partial derivatives of one of the x-, y-, or z-coordinates of one of the sx values with respect to the n angles θy. for the angles θ. This gives values sx , and we denote the sequence of all these by s  so s is a  cid:3  sequence of m vectors and thus a sequence of 3m scalars . We also let s x be the desired values for these positions and let s cid:3  denote the sequence of all these. Finally, let  cid:15 s equal  To ﬁnish setting up the inverse kinematics problem, we assume we are given current values   cid:15 s = s cid:3  − s,   cid:15 s = J   cid:15 θ .  which equals the desired change in the links’ positions.  To solve the inverse kinematics problem, we want to solve the following equation for  cid:15 θ: XII.11 This will give  cid:15 θ as a ﬁrst-order approximation to the change in values of θ necessary to effect the desired change  cid:15 s in positions. The next section will describe an algorithm to ﬁnd a solution  cid:15 θ to Equation XII.11. Once we have this solution, we might be tempted to set θ equal to θ +  cid:15 θ. This, however, will not work so easily and is likely to lead to unstable performance. The Jacobian matrix gives only a ﬁrst-order approximation to the change in angles, and, unfortunately, the partial derivatives can change very rapidly with changes in the angles θ. A second problem is that when the links and joints are positioned badly, Equation XII.11 can be unstable; in particular, the matrix J may have rank less than n, or be close to having rank less than n, and this can cause instability and overshoot problems. To keep these problems under control, it is recommended that you choose a small positive scalar  cid:28  < 1 and update the joint angles θ by adding  cid:28  cid:15 θ. Then proceed iteratively by recom- puting the Jacobian based on the updated angles and positions, ﬁnding new values for  cid:15 θ and again updating with a small fraction  cid:28 . This is repeated until the links x are sufﬁciently close to the desired positions. The question of how small  cid:28  needs to be depends on the geometry of the links; it would be a good idea to keep  cid:28  small enough so that the angles are updated by at ◦ most 5 or 10  at a time.  XII.4.4 Inverse Kinematics, Finding a Local Solution The previous section reduced the inverse kinematics problem to the problem of solving Equa- tion XII.11 for  cid:15 θ in terms of  cid:15 s and J . Of course, if we are very lucky, then J is a square matrix and is invertible. In that case, we can solve for  cid:15 θ as   cid:15 θ = J  −1  cid:15 s .  However, we are not usually so lucky. First of all, J may well not be square. For example, if there is only one end effector, so m = 1, and there are n > 3 joints, then J is a 3 × n matrix   314 Animation and Kinematics with more columns than rows. In this case, the rank of J is ≤ 3, and thus the columns cannot be linearly independent. A second way that things can go wrong is when the rows of J are not linearly independent, that is, the rank of J is < 3m. A simple example of this is seen in Figure XII.3 a  on page 308. Suppose the joints are all straight, as shown in the ﬁgure, and that the end effector is at the point f at the right end of the rightmost link. Let fx measure the x-coordinate  horizontal position  of the end effector f . Then ∂ fx  ∂θ = 0 for all the joint angles θ: in other words, the corresponding row of J is zero. Physically, this means that no inﬁnitesimal change in joint angles can effect a change in the horizontal position of the end effector.  When J is not invertible, we will use the pseudo-inverse of J instead of the inverse of J . The pseudo-inverse is also sometimes called the Moore–Penrose inverse. Before deﬁning the pseudo-inverse of J , we need to develop some background from linear algebra.  See Appendix A.3.3 for related background material.  We deﬁne the kernel of J to be the set of vectors v ∈ Rn such that J v = 0. We deﬁne the rowspan of J to be the subspace of Rn spanned by the rows of J  i.e., the subspace of vectors that can be expressed as linear combinations of the rows of J  . Then Rn is the direct sum of kernel J   and rowspan J  ; that is, every vector v in Rn can be written uniquely in the form  v = k + r  with k ∈ kernel J   and r ∈ rowspan J  .  XII.12 Furthermore, the dot product k · r is equal to zero for all k ∈ kernel J   and r ∈ rowspan J  . Since these conditions hold, kernel J   and rowspan J   are called orthogonal complements. It is an elementary fact from linear algebra that any subspace of Rn has a unique orthogonal complement.  Similarly, we let colspan J   be the column span of J , and its orthogonal complement is kernel J T .6 It is easy to check that colspan J   is the same as the range of the linear map represented by J .  We henceforth let k = 3m be the number of rows of J .  Deﬁnition Let J be a k × n matrix. Then the pseudo-inverse of J , denoted J matrix such that  a  For every v ∈ kernel J T , J v = 0. † v ∈ rowspan J  .  b  For every v ∈ colspan J  , J †  c  For every v ∈ colspan J  , J J v = v. †  †  , is the n × k  †  A crucial property of the pseudo-inverse is that J  subspace rowspan J  ; namely, if Equation XII.12 holds, then J applying condition  b  with v replaced by J v, shows that J J J But also, J  J v = J v = J r. These two facts imply J  J J v − r ∈ rowspan J  , and thus J †  J v − r  = 0, and so J † J v − r = 0, that is, J †  †  †  †  † J v = r.  †  J is the projection mapping onto the J v = r. To prove this, note that J v is in rowspan J  . Further, by  c , J v − r ∈ kernel J  .  By similar reasoning, it can also be shown that J J  is the projection mapping onto † maps kernel J T , the orthogonal complement of colspan J  , to zero. colspan J  . By  a , J J For v ∈ colspan J  , J J v = v, by  c . Thus, J J † is the projection mapping onto colspan J  . , note that for all v ∈ colspan J  , there is a unique w ∈ rowspan J   such that J w = v. Thus,  a – c  uniquely determine J  v  for v in kernel J T  ∪ colspan J  . These are orthogonal complements, and so the linear map † J  To see that conditions  a – c  determine a unique matrix J  is thereby uniquely speciﬁed for all vectors v.  †  †  †  †  6  J T is the transpose of J .   XII.4 Kinematics  315  An alternative, and equivalent, deﬁnition of the pseudo-inverse of J is as follows: for any  †  v = w, where w ∈ Rn is the vector such that  vector v ∈ Rk, J  a  b   cid:3   cid:3     v − J w is minimized, and   w is the minimum among all w satisfying  a   cid:3    .   cid:3    cid:3   †    and  b  Conditions  a  is the projection mapping onto colspan J  , and thus condition  a  To see this equivalence, ﬁrst note that because the range of J is colspan J  , the quantity v − J w will be minimized if J w is the projection of v onto colspan J  . As just proved above,  cid:3      holds. Condition  b J J now follows from  b .   can be equivalently expressed in terms of minimizing the squares of the magnitudes, that is, minimizing v − J w2 and w2. The square magnitude of a vector  cid:3  is, of course, the sum of the squares of the components of the vector. Therefore,  a     and  b show that the pseudo-inverse J ﬁnds a solution that is as good as possible, where “good” is measured in terms of the sum of the squares. In other words, it solves the least-squares minimization problem.  cid:1   †  †   cid:3    cid:3    cid:3    cid:3   satisﬁes conditions  a    and  b   . Prove that it also  Exercise XII.10 Suppose that J satisﬁes conditions  a ,  b , and  c .  Now that we have deﬁned the pseudo-inverse, we can give a solution for Equation XII.11,  namely,   cid:15 θ = J  †    cid:15 s .  XII.13  †   cid:3    cid:3     and  b   , we see that this is  By the characterization of pseudo-inverses through conditions  a a reasonably good choice for  cid:15 θ.  †  It remains to explain how to compute J  . The next theorem gives a formula for ﬁnding J in the case where J has at least as many columns as rows and where the rows are linearly independent. Theorem XII.4 Suppose J is a k × n matrix and that J has rank k. Then J J T is nonsingular, and the pseudo-inverse J −1.  † = J T J J T   of J is  XII.14  J  †  Proof We start by just assuming that J J T is nonsingular, and thus  J J T  the matrix given by the right-hand side of equation XII.14. Since J has rank k, the rows of J are linearly independent. Also, colspan J   has dimension k. Thus, colspan J   is equal to all of Rk, and kernel J T  = {0}. Therefore, condition  a  of the deﬁnition of the pseudo-inverse automatically holds for J without even using Equation XII.14. −1 is In addition, the range of J T equals colspan J T , and therefore the range of J T J J T  certainly a subset of colspan J T . Since colspan J T  equals rowspan J  , condition  b  must hold for J  deﬁned by Equation XII.14. Finally, condition  c  holds since  be  †  −1 exists. Let J  †  † † = J  J T J J T  We have shown that if J  J J  −1  = J J T J J T  †  −1 = Identity.  is deﬁned by Equation XII.14, then conditions  a – c  hold, and so it remains only to prove the assumption that Z = J J T is invertible. Note that Z is a k × k matrix and that the entries of Z are equal to  zi, j = ri · r j ,  where ri is the ith row of J and “·” denotes a vector dot product. Suppose Z has rank < k and thus that there is a linear dependence among the rows of Z. This means there are scalars αi ,   Animation and Kinematics  αi ri · r j  for all j = 1, 2, . . . , k.  316   cid:27   i   cid:27   not all zero, such that  0 = ’ cid:27   i Then, for all j,  αi ri  i  αi zi, j =    · r j = 0.  The vector in the parentheses is in the span of the rows of J and also has a dot product equal to zero with each of the rows r j . Therefore, the quantity in parentheses must be zero. This,  cid:1  however, contradicts the hypothesis that the rows of J are linearly independent.  Very frequently, the Jacobian J does not have full row rank, that is, its rank is < k. In this case, Theorem XII.4 does not apply, and we must ﬁnd another way to compute the pseudo- inverse J  . Let  cid:11  equal the rank of J . We wish to express J in the form  †  J = J1 J2  XII.15 where J1 is a k ×  cid:11  matrix, J2 is an  cid:11  × n matrix, and both J1 and J2 have rank  cid:11 . When these conditions hold, the product J = J1 J2 is called the full rank factorization of J . To ﬁnd J1 and J2, ﬁrst ﬁnd  cid:11  rows of J that are linearly independent. Let rs1  , . . . , rs cid:11  be  these  cid:11  rows. Then, express all the rows of R as  ri =  cid:11  cid:27   j=1  αi, j rs j  .  The linearly independent rows rs j and the coefﬁcients αi, j can be found by a Gaussian elimina- tion type procedure. Care should be taken here to have good criteria for deciding when a given row is the span of another set of rows, since to deal with roundoff errors and with matrices that are near-singular, one has to allow a row nearly equal to a linear combination of other rows to be treated as being a linear combination.  Once the values αi, j have been found, let J1 be the matrix with entries αi, j , and let J2 be the matrix obtained from J by keeping the  cid:11  rows rs1 through rs cid:11  and discarding the rest of the rows. Then, by inspection, J = J1 J2. Theorem XII.5 Let J = J1 J2 be such that J1 is k ×  cid:11  and J2 is  cid:11  × n and suppose J  and thus J1 and J2  are rank  cid:11 . Then  † = J T  J  2  J2 J T 2    −1 J T  1 J1   −1 J T  1  .  XII.16  †  1 J1 is invertible. Let J  Proof We already proved that J2 J T 2 is invertible in the proof of Theorem XII.4. A similar argument shows that J T be the matrix deﬁned by Equation XII.16: we must show that conditions  a – c  hold. Since J T = J T 2   = {0}, we have kernel J T  = kernel J T 1  . Therefore, condition  a  certainly holds. Similarly, because kernel J1  = {0}, J and J2 have the same kernel, and so rowspan J2  = rowspan J  . Clearly, is a subset the range of J of rowspan J  , and so condition  b  holds. Finally, suppose v is in colspan J  , that is, v is in the range of J so that v = J  w  for some w. From this,  2   = rowspan J2 . Therefore, the range of J  is a subset of colspan J T  1 and kernel J T  2 J T  †  †  †  J J  v = J J † J w = J J T −1 J T 2  J2 J T 2   =  J1 J2 J T 2  J2 J T 2    1 J1  −1 J T  −1 J T 1 J1   1 J w −1 J T  1  J1 J2 w   2   J2 J T 2    −1 J T  1 J1   −1 J T  1 J1 J2w  XII.4 Kinematics  = J1 J2 J T = J1 J2w = J w = v,  and condition  c  is proved.  317   cid:1   Theorems XII.4 and XII.5 imply algorithms for ﬁnding the pseudo-inverse that are fairly efﬁcient as long as k is small; that is, as long as the total number of links we are trying to force to a speciﬁed position is small. There are other iterative methods that ﬁnd the pseudo-inverse by computing a singular value decomposition  c.f.,  Press et al., 1986  . Quasi-Newton methods have also been used to solve the inverse kinematics problem  c.f.,  Zhao and Badler, 1994  . We have glossed over many important issues that are important for writing a functioning inverse kinematics system based on pseudo-inverse calculations. Perhaps the most signiﬁcant of these issues are how to handle extra constraints such as joint limits and how to avoid unnecessarily reaching conﬁgurations of the links where the Jacobian has reduced row rank. One way to help avoid these problems was suggested by  Girard and Maciejewski, 1985 . For each joint angle, we choose a “rest position,” which is a desired value for the joint angle; preferably, this rest position would be in a partially ﬂexed position away from any joint limits and away from conﬁgurations that lead to reduced row rank in the Jacobian. In a given conﬁguration of the links, let  cid:15  H denote the change in the values of the joint angles θ that would sufﬁce to bring all the joints back to their rest positions. Then, after performing the pseudo-inverse calculation of  cid:15 θ, update the joint positions by   cid:28 [ cid:15 θ +  I − J  †  J    cid:15  H ].  †  J is the projection mapping onto the rowspan of J . Therefore,  I − J  †  J   is the  XII.17  Recall that J projection map onto the kernel of J , and we have  J   cid:15 θ +  I − J  †  J    cid:15  H   = J   cid:15 θ .  Updating the joint positions by XII.17 thus tends to move the joint angles back to their rest positions as well as can be done without worsening the progress made towards the target positions of the links.  Weighting Joint Angles. Often, it is useful to weight joint angle changes to allow some joints to rotate more readily than others. For example, in a robot arm, it can be much easier to rotate a joint angle near an end link than a joint angle near the root. Analogously, for a human arm, it is generally much easier to rotate a ﬁnger joint through an angle of ϕ than to move a shoulder joint through the same angle ϕ. Indeed, it is generally preferable to change a ﬁnger joint by a relatively large angle rather than a shoulder joint through a relatively small angle. The pseudo-inverse method described above does not incorporate any weighting of the costs of rotating different joints; however, it is fairly simple to modify it to do so. Let θ =  cid:5 θ1, . . . , θm cid:6 T be the joint angles  which are now indexed by integers instead of by links . We assign positive weights αi , for i = 1, . . . , m, to these joint angles, choosing the values αi to be proportional to the cost of changing the angle θi . That is to say, the cost of changing angle θi by a small angle ϕ is equal to αi  α j times the cost of changing angle θ j by the same amount ϕ. For instance, in the shoulder–ﬁnger example, the value of weight α would be much higher for   318  Animation and Kinematics  the shoulder joint than for the ﬁnger joint. Another way to state the property satisﬁed by the weights αi is that if αi  cid:15 θi = α j  cid:15 θ j , then the costs of the changes to the two angles θi and θ j θi = ψi  αi , and  cid:15 θi =   cid:15 ψi   αi , and so on. We now deﬁne a new Jacobian matrix*J using are equal. We introduce new variables ψi = αi θi , and let ψ be the vector of values ψi . Note that the variables ψ, namely,*J is the Jacobian matrix whose entries are equal to  ∂sx ∂ψi  .  Since  dθi  dψi   = 1 αi , we have  ∂sx ∂ψi  = 1 αi  ∂sx ∂θi  .  Therefore, the matrix*J can be obtained from the original Jacobian J by dividing the entries do this, form the pseudo-inverse*J in each column i by αi . Then we solve the least-squares problem but use the variables ψ. To  and set  †   cid:15 ψ = *J  †    cid:15 s .  Finish by letting  cid:15 θi =   cid:15 ψi   αi and then proceed as before, choosing a small  cid:28  and incre- mentally updating the joint angles.  We have just shown that weighting joint angle costs corresponds to a very simple change of variables. Now, one should wonder why it is appropriate to use the multipliers αi instead of some other value. This choice can be justiﬁed by the following simple example.  Suppose we want to solve  θ1 + θ2 = 1  subject to minimizing the quantity   α1θ1 2 +  α2θ2 2.  ψ1 α1  + ψ2 α2  + ψ 2  .  2  ψ 2 1  subject to minimizing the quantity  That is, we are trying to minimize the sum of the squares of the costs of the angles with α1 and α2 specifying the relative costs. When we change to the variables ψ1 and ψ2, this is the same as solving for = 1  In other words, the problem becomes an ordinary least-squares problem with all weights equal to 1. Thus, the transformation from the variables θi to the variables ψi converts the weighted least-squares minimization problem into an unweighted least-squares minimization problem.   APPENDIX A  Mathematics Background  This appendix quickly reviews many of the mathematical prerequisites for this book. This material is mostly from a ﬁrst-year calculus course with particular emphasis on vectors. The ﬁrst section covers some preliminaries. Section A.2 covers vectors in R2 and then in R3, including dot products and cross products. The next section introduces 3 × 3 matrices and their connections to vector dot products and cross products. Matrix determinants and inverses and adjoints are covered after that. Then, fundamental properties of linear spaces and dimension are reviewed. The concluding sections discuss some of the basic concepts from multivariable calculus, including partial derivatives, gradients, vector-valued functions, and Jacobians.  Other prerequisites, not covered in this appendix, include basic topics from discrete math, most notably proofs by induction and simple facts about trees. There a few places where we presume knowledge of big-O notation, of the choice function , and of geometric series. The reader is also expected to have prior knowledge of trigonometry and of the basics of single-variable calculus.  n k   cid:9    cid:10   A.1 Preliminaries The set R is the set of real numbers  also called scalars . For k ≥ 1 an integer, Rk is the set of k-tuples of real numbers; these k-tuples are also called k-vectors when we want to emphasize that Rk is a vector space  vector spaces are discussed more below . A k-tuple is a sequence of length k and is represented by the notation   cid:5 a1, a2, . . . , ak cid:6 , using angle brackets.  For a < b, the set [a, b] is the closed interval containing all points x such that a ≤ x ≤ b. The square brackets indicate the inclusion of the endpoints a and b. We use parentheses instead of square brackets when the endpoints are omitted; for example,  [a, b  = {x ∈ R : a ≤ x < b}  is a half-open interval. Exponent notation is used for tuples of elements from intervals too; for example,  [0, 1]2 = [0, 1] × [0, 1] = { cid:5 a, b cid:6  : a, b ∈ [0, 1]}  is the unit square containing pairs of reals from [0, 1].  319   Mathematics Background  320  y  q =  cid:1 q1, q2 cid:2   u =  cid:1 q1 − p1, q2 − p2 cid:2   p =  cid:1 p1, p2 cid:2   Figure A.1. Two points p and q and the vector u = q − p.  x  The notation f : A → B  indicates that f is a function with domain A and with range contained in B. A function is also called a mapping. The range of f is the set of values f  a  for a in the domain A; the set B is sometimes called the codomain of f . For example, the function g : R → R deﬁned by g x  = sin x  has domain R and range [−1, 1]. The function f : A → B is one-to-one provided that for each b ∈ B there is at most one a ∈ A such that f  a  = b. The function is onto provided that the range of f is equal to all of B.  When the codomain B is R, we deﬁne the support of f to be the set of elements a such that  f  a  is nonzero.  A.2 Vectors and Vector Products  A k-vector u is a sequence of k real numbers,  u =  cid:5 u1, u2, . . . , uk cid:6 .  Our conventions are to use boldface letters, like u to denote vectors and italic symbols, like u or ui , for scalar values. In computer graphics, we are mostly concerned with vectors with 2, 3, or 4 components. For k = 2, a 2-vector represents a point in R2, the real plane. Going up a dimension, a 3-vector represents a point in R3, that is, in three-dimensional space. We use 4-vectors mostly to represent points in homogeneous coordinates  see Chapter II for information on homogeneous coordinates .  The space of all k-vectors is the k-dimensional vector space, sometimes called Euclidean  space, and is denoted Rk.  A.2.1 Vectors in R2 A vector in R2 is a pair of real numbers and is written u =  cid:5 u1, u2 cid:6 . As an ordered pair, a vector can be viewed either as a point in the usual x y-plane or as a displacement between two points  see Figure A.1 . It is sometimes useful to make a distinction between points and vectors since they are often used in different ways. However, they are both represented by a pair of scalars, and their similarities greatly outweigh their differences. Thus, we ﬁnd it convenient to treat vectors and points as being the same kind of object, namely, as a pair of scalars.  The length of a vector, also called its magnitude or norm, can be deﬁned in terms of the   cid:19   Euclidean distance function  u =  + u2  2  .  u2 1  A unit vector is a vector with magnitude equal to 1.   A.2 Vectors and Vector Products  321  v  ϕ  u  Figure A.2. The angle between u and v equals ϕ and is used for computing the dot product. Since cos ϕ = cos −ϕ  = cos 360 ◦ − ϕ , it makes no difference which way the angle is measured for the purposes of computing the dot product.  The unit circle in R2, also called the 1-sphere, is the set of vectors with magnitude 1. Vector addition and vector subtraction are deﬁned to act component-wise:  u + v =  cid:5 u1, u2 cid:6  +  cid:5 v1, v2 cid:6  =  cid:5 u1 + v1, u2 + v2 cid:6 , u − v =  cid:5 u1, u2 cid:6  −  cid:5 v1, v2 cid:6  =  cid:5 u1 − v1, u2 − v2 cid:6 .  One could deﬁne a component-wise multiplication operation on vectors, but this turns out not to be a very useful operation. Instead, there are two much more useful ways to deﬁne multiplication on vectors, the dot product and the cross product:  u · v = u1v1 + u2v2 u × v = u1v2 − u2v1  Dot product  Cross product  Note that both the dot and cross products form the product of two vectors and produce a scalar as the result. If you have studied cross products before, you may remember their being deﬁned only for vectors in R3 and giving another vector as the result. It is useful, however, to deﬁne cross products also for vectors in R2. In R2, the cross product of two 2-vectors is a scalar.  The dot product is sometimes called the inner product.  Dot Products in R2 The dot product was deﬁned in  A.1  with the formula u1v1 + u2v2. An alternate deﬁnition can be given in terms of the magnitudes of u and v and the angle ϕ between the two vectors; that is, with reference to Figure A.2,  u · v = u · v cos ϕ.  exercise.   cid:1   It is ﬁne to take equation A.3 on faith, but if you wish to see a proof you may work the next  Exercise A.1 Prove the correctness of equation A.3. [Hint: Let u make angle ψ with the x-axis. Therefore, v makes angle ψ + ϕ with the x-axis. Express the vectors u and v component-wise with sines and cosines. Then compute the dot product according to the deﬁnition in equation A.1 and transform it using the sine or cosine angle sum formulas  or the angle difference formulas . Show that equation A.3 results.]  Suppose u and v are nonzero. Then equation A.3 shows that u · v is equal to zero if and only if cos θ equals zero. This happens if and only if the angle between u and v is a right angle. In this case, the two vectors are said to be perpendicular, or orthogonal. When u is a unit vector, the dot product formula reduces to just u · v = v cos ϕ. With reference to Figure A.3, this implies that, when u is a unit vector, u · v is the  signed  length  A.1  A.2  A.3   322  Mathematics Background  v  ϕ  u   u · v u =   cid:13 v cid:13  cos ϕ u  Figure A.3. The projection of v onto the line parallel to a unit vector u, where ϕ is the angle between u ◦ and v. How would the picture look if ϕ were between 90 and 180  ?  of the projection of v onto the line in the direction of u. The projection of v onto u is deﬁned to equal   u · v u,  which is the component of v parallel to the vector u.  This formula for projection is correct only if u is a unit vector.  Note that the projection is a vector parallel to u.  We can also ﬁnd a formula for the component of v perpendicular to u. Namely, if we subtract the projection, the remaining part is perpendicular to u. Thus, for a unit vector u, the component of v perpendicular to u is equal to  v −  u · v u.  It is easy to check that u · u = u2. Thus, the magnitude of u is  u · u. We use u2 as a  shorthand notation for u · u = u2.  √  Cross Products in R2 The cross product of vectors in R2 was deﬁned as u × v = u1v2 − u2v1. There are several alternate useful ways to think about cross products:   a  If you are more familiar with cross products in three dimensions, we can restate the two- dimensional cross product in terms of the three-dimensional cross product. For this, we pad u and v with a third entry equal to zero and take the cross product in three dimensions. This yields  cid:5 u1, u2, 0 cid:6  ×  cid:5 v1, v2, 0 cid:6  =  cid:5 0, 0, u1v2 − u2v1 cid:6 . Thus, the two-dimensional cross product is equal to the z-component of the cross product obtained by embedding u and v into three dimensions. The advantage of thinking about two-dimensional cross products in this way is that properties  c  and  d  below may already be quite familiar.  b  In the two-dimensional setting, the vector cross product can be expressed as a dot product with a rotated vector. To explain, let, as usual, u =  cid:5 u1, u2 cid:6 , and let urot be the vector u ◦ rotated counterclockwise 90 urot =  cid:5 −u2, u1 cid:6 . It is immediate from the deﬁnitions of cross and dot products that u × v = urot · v. That is, the cross product of u and v can be calculated by rotating u through a right angle and then forming the dot product with v.  . Referring to Figure A.4, we see that urot is equal to   A.2 Vectors and Vector Products  323  urot =  cid:1  u2, u 1 cid:2   y  u1  u2  u =  cid:1 u1 , u 2 cid:2   u2  x  u1  ◦  Figure A.4. The effect of rotating a vector 90  counterclockwise.  This tells us that u × v is equal to zero if and only if u and v are parallel  i.e., collinear . In other words, u × v = 0 if and only if u = αv  or v = αu  for some scalar α; or equivalently, ◦ if the angle between the vectors is equal to either 0 or 180  .   c  Let ϕ be the angle between u and v: the angle ϕ must be measured in the counterclockwise direction from u to v as shown in Figure A.5. Then the cross product of the 2-vectors is equal to u × v = u · v sin ϕ.  This can easily be proved from Equation A.3 and the fact that the cross product with u is equivalent to the dot product with urot.  Note that it is important that the angle ϕ be measured in the correct direction, for sin −ϕ  = − sin ϕ. Indeed, the cross product is antisymmetric: u × v = − v × u.   d  There is an elegant interpretation of cross product in terms of area. Consider the parallel- ogram with sides equal to the vectors u and v, as shown in Figure A.6. Then the  signed  area of the parallelogram is equal to Area = u × v. To prove this, use the formula  base  ·  height . If the base length is measured along u, it is just equal to u. Then, the height must be measured perpendicularly to u and is equal to v sin ϕ. , then the cross product u × v is negative. In this case, the parallelogram can be thought of as having “negative height” and hence negative area.  ◦ When the angle ϕ is greater than 180  v  ϕ  u  Figure A.5. The angle between u and v equals ϕ and is used for computing the cross product. The direction  sign  of the angle is important for the cross product.   Mathematics Background  324  u  v  ϕ  u  v  Figure A.6. In R2, the  signed  area of the parallelogram is equal to the cross product u × v. In R3, the area of the parallelogram is equal to the magnitude of u × v.  A.2.2 Vectors in R3 The three-dimensional Euclidean space is denoted by R3. A point or a vector u in R3 is speciﬁed by a triple of values, u =  cid:5 u1, u2, u3 cid:6 . In computer graphics, it is common to use x, y, z-axes that are oriented as shown in Figure I.4 on page 6: as shown there, the x-axis points rightward, the y-axis points upward, and the z-axis points toward the viewer. This is different from the usual conventions you probably learned in calculus class, but is still a right-handed coordinate system.  The main reason to work with a right-handed coordinate system rather than a left- handed coordinate system is that it makes the cross product obey the usual “right-hand rule.”  The length  usually called magnitude or norm  of a vector in R3 is given by the Euclidean  distance formula   cid:19   u =  + u2  2  + u2  3  .  u2 1  A vector u is a unit vector provided u = 1. The unit sphere in R2, also called the 2-sphere or S2, is the set of vectors with magnitude 1. A nonunit vector u is normalized by the process of replacing it with a unit vector pointing in the same direction. That is, u is normalized by calculating u u. The terminology is a little confusing because the term “normal vector” is used to mean a nonzero vector that is perpendicular  that is, normal  to a surface. By deﬁnition, normal vectors are not required to be unit vectors. In other words, normal vectors do not always need to be normalized. Nonetheless, it is frequently helpful to use unit normal vectors – particularly in Chapter III for lighting applications.  Addition and subtraction of vectors in R3 are deﬁned component-wise in much the same  way as their deﬁnition in R2. Dot product and cross product are discussed next.  Dot Products in R3 The dot product of two vectors in R3 is deﬁned by  u · v = u1v1 + u2v2 + u3v3.  This means that the dot product of two 3-vectors is a scalar.  If ϕ is the angle between the vectors u and v, then  u · v = u · v cos ϕ.  Suppose that u is a unit vector. Then the projection of the vector v onto the line containing the vector u has signed length equal to u · v.  This can be proved in the way used for R2 using the characterization of the dot product in terms of cos ϕ.  The projection of v onto the unit   A.3 Matrices  vector u is thus equal to the vector   u · v u.  This is the component of v in the direction of u.  The component of v perpendicular to u is equal to √  v −  u · v u.  The magnitude or norm of a vector u is equal to  u2 = √  u · u.  325  Cross Products in R3 The cross product of two vectors in R3 is the vector deﬁned by  u × v =  cid:5 u2v3 − u3v2, u3v1 − u1v3, u1v2 − u2v1 cid:6 .  To describe the deﬁnition of u × v in an alternate, geometric way, let ϕ be the angle from u  the direction to measure ϕ is unique for  to v measured in a direction such that 0 ≤ ϕ ≤ 180 ◦ noncollinear u and v . Then, u × v has magnitude  u · v sin ϕ,  and is perpendicular to both u and v with its direction given by the right-hand rule. The right- hand rule states that if you use the palm of your right hand to push u towards v with your thumb extended out at right angles, then your thumb will point in the direction of u × v.  An equivalent way to state the geometric deﬁnition of the cross product is as follows. Let u and v both lie in a plane P. The plane P divides R3 into two half-spaces. Arbitrarily choose one of these half-spaces as being “above” the plane. Viewing the two vectors from above, let ψ be the angle from u to v measured in the counterclockwise direction. Then u × v is the vector with signed magnitude equal to  u · v sin ψ,  A.4 and u × v is pointing up perpendicularly to P. We called the value A.4 the signed magnitude because, if this value is negative, the cross product is pointing downwards from P.  Evidently, for nonzero u and v, the cross product is equal to zero if and only if u and v are  collinear.  The parallelogram area property  d  of cross products in R2 still holds in R3. With reference to Figure A.6, the vectors u and v now lie in R3. The area of the parallelogram is equal to the length of u × v.  A.3 Matrices A matrix M =  mi, j  i, j is a rectangular array of scalars,   m1,1 ··· m1,s  ... ... mr,1 ··· mr,s  . . .   .  M =  Here M is r × s matrix, and mi, j is the entry in row i and column j.  If in addition N is an s × t matrix, then the matrix product of M times N is the r × t matrix P whose entries pi,k are obtained by taking the inner product of the ith row of M with the kth column of N , namely,  pi,k = s cid:27   j=1  mi, j n j,k .   326  Mathematics Background The r × r identity matrix is the matrix I that has diagonal entries equal to 1, and off- diagonal entries equal to 0. There is a different identity matrix for each r ≥ 1, but we use the same notation I for all of them because it should always be clear from the context what the dimension is.  The identity matrices have the property that  I M = M  and  M I = M.  −1 such that M M  −1 M = I . Only square matrices The inverse of M is the matrix M can have inverses, and not even all of them do. A matrix that is invertible is also said to be nonsingular. The transpose of M is the matrix M T obtained by swapping elements of M across the diagonal: for M =  mi, j  i, j , an r × s matrix, its transpose M T =  m j,i  i, j is an s × r matrix.  Note the subscripts in reverse order!   −1 = M  M T N T =  N M T  The following identities are easy to check: I T = I. −1 =  M  and  −1 T.  In addition, for invertible M,  M T  The matrices used in the early chapters of this book are primarily small  of dimensions 2 × 2 through 4 × 4 . Frequently, we are interested in how these matrices act on points or vectors. For this, points and vectors will be treated as being column vectors: namely, a 2-vector is a 2 × 1 matrix, and a 3-vector is a 3 × 1 matrix. For instance, our convention is that a 3-vector u =  cid:5 u1, u2, u3 cid:6  is the same as the column vector  u1   .  u2 u3  In this way, we can take the product of a matrix and a vector and get a vector as a result. You should refer to Chapter II for more information on matrices and vectors in R2 and R3. As discussed in Chapter II, matrices are used extensively in computer graphics to transform vectors by multiplication.  A.3.1 Matrices and Vector Products in R3  It is possible to reexpress dot and cross products in terms of matrix products. As we just said, a vector u =  cid:5 u1, u2, u3 cid:6  is, by convention, the same as a column vector  i.e., a 3 × 1 matrix . Therefore, the transpose of a vector is a 1 × 3 matrix or a row vector. That is,  It is easy to check that a dot product can be expressed as  uT =  u1 u2 u3  .  u · v = uTv.  Or, to write it out fully,   cid:5 u1, u2, u3 cid:6  ·  cid:5 v1, v2, v3 cid:6  =  u1 u2 u3   v1   .  v2 v3  To interpret this correctly, the left-hand side of each of the two equalities above is a dot product, and the right-hand side is a matrix product.  If one wanted to be overly precise, one could note   327 A.3 Matrices that the right-hand side really denotes a 1 × 1 matrix, not a scalar, but it does no harm to treat a 1 × 1 matrix as being the same as a scalar.  We just described how to reexpress a dot product as a matrix product using a 1 × 3 matrix. Similarly, a cross product operation can be expressed as a matrix product but now using a 3 × 3 matrix. Namely, let Mu× be the matrix   0 −u3 u2  0 −u1 0   .  Mu× =  u3 −u2 u1 Then it is easy to check that   Mu× v = u × v  by using the ﬁrst deﬁnition of cross product in R3. The matrix version of a dot product allows us to express the projection operator as a matrix. Let u be a unit vector, and recall that the projection of v onto u is equal to  u · v u. This can be rewritten as   u · v u = u u · v  = u uTv  =  uuT v.   The last equality uses the associativity of matrix multiplication.  Thus, letting Proju be the matrix    u1 u2 u3  =   u2  u1  u2 u3  u1u2 u1u3 1 u2 u1u2 u2u3 2 u2 u1u3 u2u3 3   ,  = uuT =  Proju  we have that  Proju v is equal to the projection of v onto u.  A.3.2 Determinants, Inverses, and Adjoints Let M be a square n × n matrix. For i, j ∈ {1, . . . , n}, the matrix Mi, j is deﬁned to be the  n − 1  ×  n − 1  matrix obtained by deleting the ith row and the jth column from M. We now deﬁne the determinant det M  of M. The deﬁnition of the determinant proceeds by induction on the dimension of M. When n = 1, M is just a 1 × 1 matrix, and det M  is equal to its sole entry m1,1. For n > 1, the determinant of M is equal to  det M  = m1,1det M1,1  − m1,2det M1,2  + m1,3det M1,3  −m1,4det M1,4  + ··· ± m1,ndet M1,n   −1 1+ j m1, j det M1, j  .  = n cid:27   A.5  The deﬁnition A.5 deﬁnes the determinant in terms of its expansion along the ﬁrst row of the matrix. More generally, the determinant can also be deﬁned with an expansion along any row i as  j=1  det M  = n cid:27  det M  = n cid:27   j=1  i=1   −1 i+ j mi, j det Mi, j  ,   −1 i+ j mi, j det Mi, j  .  as well as in terms of an expansion along any column j:   328 Mathematics Background The value  −1 i+ j det Mi, j   is called the cofactor of M at  i, j . Thus, the determinant is expressed in terms of an inner product of the entries in a given row  or column  of the matrix and its cofactors along the same row  or column .  The adjoint of M is the matrix N that is the transpose of the cofactors of M. Namely, N is  the matrix with entries  ni, j =  −1 i+ j det M j,i  .  It is always the case that  M N = N M = det M I,  −1 =  M  1  N .  det M   A.3.3 Linear Subspaces   cid:1   for N the adjoint of M. Therefore, if det M   cid:16 = 0, then M is invertible and  This gives a formula for inverting any invertible matrix, for a matrix M is invertible if and only if its determinant is nonzero.   Knowledge of linear subspaces is needed only for the discussion of inverse kinematics in Chapter XII and, to a lesser extent, for the material on projective geometry in Chapter II.  Let k ≥ 1 and consider Rk. A subset A ⊆ Rk is called a linear subspace provided that A is closed under addition and under scalar multiplication.1 That is, A is a linear subspace if and only if, for all x and y in A and for all scalars α, x + y and αx are also in A.  The vectors x1, x2, . . . , xn are said to be linearly independent provided there is no sequence  of scalars α1, . . . , αn, not all zero, such that  α1x1 + α2x2 + ··· + αnxn = 0.   Here, 0 is the zero vector.  The dimension of a linear subspace A is the largest value n for which A contains n linearly independent vectors. When A ⊆ Rk, the dimension of A can be at most k.  Let x1, . . . , xn be vectors in R. The span of these vectors is the linear subspace that contains all linear combinations of the vectors xi . In other words, the span of x1, . . . , xn is the following subspace:  span x  = {α1x1 + ··· + αnxn : α1, . . . , αn ∈ R}.  It is easy to check that this is closed under addition and scalar multiplication and thus is indeed a linear subspace. If x1, . . . , xn are linearly independent, then every vector in their span can be expressed as a linear combination of x1, . . . , xn in a unique way. Theorem A.1 Let A ⊆ Rk be a linear subspace of dimension n. Suppose x1, . . . , xn are in A and are linearly independent. Then span x  is equal to A.  Let A and B be linear subspaces of Rk. We say that A and B are orthogonal if and only if, for all x ∈ A and all y ∈ B, x · y = 0. We say that A and B are orthogonal complements if they are orthogonal and if for every u ∈ Rk there are x ∈ A and y ∈ B such that u = x + y. In this case, x and y are uniquely determined by u; in fact, x and y are the orthogonal projections of u onto the subspaces A and B.  1 Vector spaces are usually deﬁned very generally. However, we only use vector spaces that are subspaces of Rk for some k and therefore make the corresponding simpliﬁcations in the discussion of linear subspaces.   A.4 Multivariable Calculus  329  Theorem A.2 Let A be a linear subspace of Rk. Then there is a unique subspace B such that A and B are orthogonal complements. In fact,  B = {y : for all x ∈ A, x · y = 0}.  ⊥  We use A  to denote the orthogonal complement of A.  Now, we return to matrices. Let M be an r × s matrix. If x is an s-vector, then Mx is an  r-vector. Therefore, the mapping  f M : x  cid:13 → Mx  is a function with domain Rs and codomain Rr . We often conﬂate the matrix M with the mapping f M and use M to refer to both the matrix and the mapping. It is easily seen that the range of M is exactly equal to the span of the columns of M. That is, let M have as columns the r-vectors u1, . . . , us; then the range of M is equal to span u . The kernel of M  or of f M , to be more proper , is the set of vectors x ∈ Rs such that Mx = 0. Let the rows of M be the s-vectors v1, . . . , vr . Clearly, the kernel of M is the set of vectors x such that x · vi = 0 for all i = 1, . . . , r. From the previous theorem, it follows easily that the kernel of M is the linear subspace that is the orthogonal complement of the span of the rows of M; namely, the kernel of M is equal to  span v   ⊥ We call span u  the column span of M and span v  the row span of M. These are also  .  denoted colspan M  and rowspan M .  The rank of the matrix M is deﬁned to be the dimension of rowspan M  and of colspan M .  It is a theorem that these both have the same dimension.  The rank can also be deﬁned as being equal to the maximum number of linearly independent rows  or, columns  of M.  A.4 Multivariable Calculus  A.4.1 Multivariable Functions  A multivariable function is a function with multiple inputs. For now, we consider only real- valued multivariable functions, that is, functions with domain Rk and codomain R. Simple examples of such functions include  f  x, y  = x 2 + y2,  which can be visualized as a paraboloid surface, as well as functions of three variables such as f  x, y, z  = x 2 + y2 + z2. The latter function is hard to visualize because it would require four dimensions to graph it properly. In addition, functions that take vectors as inputs can be viewed as multivariable functions. For example, the vector magnitude function u  cid:13 → u can be viewed as a function of the three scalar values u1, u2, u3. Likewise, the distance function f  u, v  = u − v can be viewed as a function with domain R6, taking six scalar inputs. Fix some function f = f  x1, . . . , xk  with k inputs. We sometimes slightly abuse notation and also write f as f  x , where x =  cid:5 x1, . . . , xk cid:6 . The partial derivative of f with respect to xi is the multivariable function  ∂ f ∂xi   x1, . . . , xk   that equals the rate of change in values of f with respect to changes in the value of xi while keeping the rest of the input values ﬁxed. To express this formally with limits, the partial   330  Mathematics Background  derivative is the function satisfying  ∂ f ∂xi   x1, . . . , xk  = lim h→0  f  x1, . . . , xi−1, xi + h, xi+1, . . . xk  − f  x1, . . . , xi , . . . xk   .  h  The partial derivative is undeﬁned where this limit does not exist.  The total derivative of f is given by the expression  d f = ∂ f ∂x1  dx1 + ∂ f ∂x2  dx2 + ··· + ∂ f ∂xk  dxk .  A good way to visualize what the total derivative means is to think of it as providing a way to approximate f in the neighborhood of a point  cid:5 x1, . . . , xk cid:6 : f  x1 +  cid:15 x1, . . . , xk +  cid:15 xk  − f  x1, . . . , xk  ≈ ∂ f ∂x1   cid:15 x1 + ··· + ∂ f ∂xk   cid:15 xk .  A.6  We can write this more suggestively as   cid:15  f ≈ ∂ f ∂x1   cid:15 x1 + ··· + ∂ f ∂xk   cid:15 xk .  For well-behaved functions, this approximation is ﬁrst-order accurate, which is to say that the error in the approximation is only O  cid:15 x 2 k  . Therefore, the approximation is very 1 accurate for sufﬁciently small values of  cid:15 xi .  + ··· +  cid:15 x 2  The gradient of f  x1, . . . , xk  is the vector-valued function   cid:21    cid:22    ∇ f   x  =  ∂ f ∂x1  ∂ f ∂x2   x ,   x , . . . ,   x   .  ∂ f ∂xk  The gradient function has k scalar inputs, and its value is a k-vector.  The motivation for the deﬁnition of the gradient is that it plays the role of the ﬁrst derivative of f  x . Indeed, using the gradient function, we can rewrite the ﬁrst-order approximation of Equation A.6 in vector notation as  f  x +  cid:15 x  − f  x  ≈  ∇ f   ·   cid:15 x .  The right-hand side of this approximation is a vector dot product.  A level set of a function f is a set of the points  cid:5 x1, . . . xk cid:6  satisfying f  x1, . . . , xk  = c for some ﬁxed constant c. In this book, we only work with level sets of functions of three variables  i.e., k = 3 . Such sets are also called implicitly deﬁned surfaces. For example, the equation x 2 + y2 + z2 − 1 = 0 is an implicit deﬁnition of the unit sphere in R3.  In “nice” situations, an implicitly deﬁned surface is a two-dimensional surface lying in- side R3  think of the unit sphere, for instance . Of course, there are pathological cases of surfaces that have cusps, discontinuities, or self-intersections; however, in most cases that are of interest to us, an implicitly deﬁned surface is  at least locally  a smooth, well-behaved surface.  Let S be an implicitly deﬁned surface in R3 and x be a point on S. A vector n is said to be normal to the surface S at the point x provided that n is perpendicular to the surface at that point. If the gradient vector ∇ f  x  is nonzero, then it is normal to the surface at x. In this case,  n =  ∇ f   x   ∇ f   x   is a unit normal for the surface. It is harder to compute a normal vector when the gradient vector is zero; in fact, the surface may have a cusp or other strange behavior and may not have any normal vector at all.   A.4 Multivariable Calculus  331  As an example of computing n, consider the implicit deﬁnition of a ﬂattened ellipsoid by 4x 2 + y2 + 4z2 = 4. Here, ∇ f  x, y, z  =  cid:5 8x, 2y, 8z cid:6  is nonzero for any point  cid:5 x, y, z cid:6  on the ellipsoid and hence is normal to the ellipsoid at that point.  A.4.2 Vector-Valued Functions  A vector-valued function is a function whose values are vectors. We often use the convention of writing vector-valued functions in boldface – for instance f x , to distinguish them from scalar-valued functions.  Less commonly, we also use uppercase, such as P x , for the same purpose.  An example of a vector-valued function is a function p t  that gives the position of a point at time t. For a point moving in the x y-plane, p t  would be in R2; for a point moving in R3, p t  would be in R3.  The components of a vector-valued function f are scalar-valued functions, f1 x , . . . , fn x .  Thus,  f x  =  cid:5  f1 x , f2 x , . . . , fn x  cid:6 .   cid:3    x  =  cid:5  f  f   cid:3  1 x , f   cid:3  2 x , . . . , f  n x  cid:6 .  cid:3   The ﬁrst derivative of f is calculated component-wise. Namely, the ﬁrst derivative is equal to  For example, the derivative of a position function p t  is the velocity function v t  = p  cid:3  second derivative of p t  is the acceleration function. A parametric curve is deﬁned by a vector-valued function f x . The curve is the set of points {f x  : x ∈ R}. If the values of the function f are k-vectors, then the parametric curve lies in Rk. The ﬁrst derivative f  x  will be tangent to the curve at the point f x  provided it is nonzero.   t . The   cid:3   A.4.3 Multivariable Vector-Valued Functions  A vector-valued multivariable function is a function that has as input a sequence of reals and produces a vector as its value.  Let f : Rk → Rn. Then we can write f in terms of its n components as  f x  =  cid:5  f1 x , f2 x , . . . , fn x  cid:6 ,  where x =  cid:5 x1, . . . , xk cid:6 . Note that each fi is a scalar-valued, multivariable function.  The ﬁrst derivative of f is called the Jacobian of f. Intuitively, the ﬁrst derivative of f should be the vector of ﬁrst derivatives of its n components. However, from Section A.4.1, the ﬁrst derivative of a component fi is actually the gradient function ∇ fi , which is a k-vector valued function. Thus, the ﬁrst derivative of f x  becomes an n × k matrix called the Jacobian matrix. The Jacobian matrix is deﬁned to be the matrix whose ith row is equal to the gradient  of fi  x . This can be written explicitly as   cid:11    cid:12   J  x  =  =  ∂ fi ∂x j  i, j    ∂ f1 ∂x1 ... ∂ fn ∂x1  ··· ∂ f1 ∂xk ... . . . ··· ∂ fn ∂xk   .  The ﬁrst-order approximation formula for values of f in a neighborhood of x is then  f x +  cid:15 x  − f x  ≈ J  cid:15 x.   APPENDIX B  RayTrace Software Package  B.1 Introduction to the Ray Tracing Package  I have written a ray tracing package that implements basic recursive ray tracing. This software and its source code are freely available and can be downloaded from this book’s Web site.  The ray tracing software uses an object-oriented approach to rendering and ray tracing. The object-oriented design includes base classes for materials, for geometric shapes, for lights, and for textures. This provides considerable ﬂexibility in adding features since it allows the addition of new geometric shapes without affecting the functionality of older code; similarly, new kinds of lighting models, new kinds of textures, and so on, can be added without needing to change the structure of the software.  The material and lighting classes supported by the software include the usual material properties such as ambient, diffuse, and specular color and specular exponents. In addition, the material classes include reﬂection and transmission color coefﬁcients for use in recursive ray tracing. The complete Phong model for local lighting is supported, including all the OpenGL- type features such as spotlights and attenuation. A version of the Cook–Torrance model is also supported.  The ray tracing software supports a range of geometric shapes, including spheres, trian- gles, parallelograms, cones, cylinders, tori, ellipsoids, parallelepipeds, and B´ezier patches. Collectively, these geometric shapes are called viewable objects. The viewable object classes are responsible for detecting intersections of rays against a particular geometric shape. The viewable object classes also calculate normals and keep track of the material of an object. In addition, they calculate u and v coordinates for texture mapping purposes.  The texture mapping classes are in essence implemented as “callback” routines. This means that it is easy to add algorithmic texture maps in addition to the more traditional bitmap  table lookup  texture maps. Three kinds of texture maps are currently supported: texture maps formed from RGB images read from bitmap  .bmp  ﬁles, procedurally generated checkboard patterns, and bump maps.  To make the ray tracing software more modular, as well as easier to use, the software is split  into three levels  in separate C++ projects . These levels are as follows:  Top Level: Ray Tracing. The top level routines implement the recursive ray tracing algo- rithm and the high-level scene description. In the sample implementation, this is split into two parts. First, the program RayTraceData makes function calls to set up the lights and the geometric shapes and their materials and textures. Second, the program RayTrace implements the high-level recursive ray tracing algorithm. A similar set of  332   B.2 The High-Level Ray Tracing Routines  333  high-level routines, RayTrace2 and RayTraceData2, are also provided; these are similar but use a more complex scene with more kinds of geometric shapes.  These high-level routines are intended to be easy to modify without the programmer’s having to understand the internal structure of the intermediate and low levels. In fact, the high-level routines have been left in a fairly preliminary state: the software was developed for teaching purposes, and students are asked to improve on the high-level routines, for instance, by implementing distributed ray tracing. The intermediate- and low-level routines are more polished and are not really intended to be modiﬁed.  Intermediate Level: Geometry and Rendering. The intermediate level routines handle lights, geometric shapes, materials, and texture maps. In addition, they include code for local lighting calculation  Phong and Cook–Torrance lighting are both supported . The lights include all the usual OpenGL style features such as ambient, diffuse, and specular light components, attenuation, and spotlight effects. The materials encompass the usual OpenGL material properties, including ambient, diffuse, and specular colors and shininess, plus additional properties such as reﬂection and transmission coefﬁcients. The geometric shapes are implemented with a C++ base class called ViewableBase; derived classes include many shapes. These geometric classes incorporate efﬁcient routines for calculating intersections with rays. They also calculate normals and u, v coordinates for texture mapping. Texture maps are also C++ classes and are implemented somewhat like callback routines: a texture map is attached to a viewable object, and when an object is intersected by a ray the texture map routines are called. This provides a ﬂexible framework for texture mapping.  Low-Level Routines: Linear Algebra. These routines are in the project VrMath and in- clude linear algebra routines for 2-vectors, 3-vectors, and 4-vectors. The intermediate- and high-level routines have been written to isolate the low-level routines, allowing mod- iﬁcations to the high-level routines to require little knowledge of the low-level routines.  B.2 The High-Level Ray Tracing Routines  The high-level ray tracing routines are illustrated by the example code in RayTrace.cpp and RayTraceData.cpp, or in RayTrace2.cpp and RayTraceData2.cpp. We will ﬁrst discuss the RayTrace routines, which control the recursive ray tracing procedures.  RayTraceView: This is the highest level routine that initiates the ray tracing procedure. It functions in much the same way as the routine RayTraceMain on page 242. Ray- TraceView loops over all the pixels in the view window. For each pixel, it calculates the view ray from the view position towards the center of the pixel and then calls the recur- sive routine RayTrace to calculate the color value to render the pixel. The RayTrace routine returns the value curPixelColor, which is stored into the pixel array. After calculating all the pixel colors, the pixel array’s Draw routine is called to store the pixel colors into the rear OpenGL rendering buffer; then the buffers are swapped to show the ray traced scene.  RayTrace: This is the routine that recursively traces rays and combines color values. It is the heart of the recursive ray tracing algorithm. Its parameters consist of  a  a trace depth,  b  a starting position for the ray,  c  a unit vector giving the direction of the ray,  d  a 4-vector VectorR4 in which a color value is returned, and  e  an avoidance number that speciﬁes what object the ray originates from.  RayTrace begins by calling SeekIntersection, which calculates whether the ray intersects some viewable object. If not, then the ray is presumed to have passed   334  RayTrace Software Package  completely out of the scene and the default background color is returned. Otherwise, an intersection point is returned by SeekIntersection as an object of type Visible- Point. The VisiblePoint class includes information about the position, the nor- mal, and the material properties of the intersected point. RayTrace calls the routine CalcAllDirectIllum to calculate the illumination of the intersected point with the local lighting model, which incorporates the effect of global ambient lighting and of direct illumination from lights  the latter is usually computed according to the Phong lighting model . Then, if the trace depth has not been exhausted, RayTrace spawns reﬂection and transmission rays. Reﬂection rays have their direction computed by Equation IX.2 on page 238. RayTrace is called recursively with the reﬂection ray. Whatever color is returned is then ﬁltered by the reﬂective color  the ρrg values  of the material at the intersection point and added to the color as already calculated according to the direct illu- mination. Finally, a transmission ray may be spawned. The direction of the transmission ray is calculated by a routine CalcRefractDir that implements the algorithm given on page 241; transmission rays are otherwise handled in the same manner as reﬂection rays. When examining the routine RayTrace, you will note that it uses some C++ classes VectorR3 and VectorR4. These are vectors of real numbers, and their members are accessed via A.x, A.y, A.z, and A.w. The main reason for their use in the high-level ray trace routines is that positions and directions in 3-space are conveniently stored in a single VectorR3, which greatly simpliﬁes the interfaces for the ray trace routines. The alternative would be to pass arrays of ﬂoating point numbers, which would be somewhat less elegant and certainly more prone to errors owing to the lack of compile time type-checking. If you are modifying only the high-level ray tracing routines, you can probably avoid using much of the VectorR3 or VectorR4 classes.  SeekIntersection: This routine loops through the array of viewable objects, checking each one for an intersection with a ray. The ray is speciﬁed in terms of its starting position and a unit vector giving its direction. The ﬁrst thing done is to move the starting position a very small distance in the direction of the ray: this is to avoid having a repeated intersection with the same point owing to roundoff error.  This is not guaranteed to work always but has worked in all cases tried so far.  SeekIntersection checks every viewable object for intersections with the ray and returns the closest intersection found. CalcAllDirectIllum: This routine takes as input a view position and a visible point. It is presumed that the visible point is in fact visible from the view position.  The view position may be the position of the actual viewer or may be a position from whence a traced ray has been reﬂected or refracted.  The direct illumination of the point includes the following components: any emissive color of the visible point, color due to global ambient lights, and, for each light, the color due to direct illumination. Before any illumination from a light is calculated, a shadow feeler is traced from the visible point to the light position. If the shadow feeler is not intersected by any viewable object  as determined by the routine ShadowFeeler , the light is presumed to be shining on the visible point; otherwise, the light is deemed to have its direct light completely blocked. In either case, the value of percentLit is set, as appropriate, to either 0 or 1, indicating the fraction of the light illuminating the visible point. The illumination from each light is calculated with DirectIlluminateViewPos whether or not it is shadowed, since even shadowed lights contribute ambient lighting.  ShadowFeeler: This routine works in much the same way as SeekIntersection. However, it does not need to return a visible point. Since it returns only true or false depending on whether an intersection is found, this routine can stop as soon as any intersection is found without needing to continue searching for a closer intersection.   B.2 The High-Level Ray Tracing Routines  335  The program RayTraceData contains routines for describing the virtual scene to be ren- dered. First, there is the routine SetUpMainView, which describes information about the main view position  i.e., the position of the camera . This ﬁrst creates a new CameraView and sets its position and direction of view. The direction of view is speciﬁed by any nonzero vector  in this case as stored in an array of double’s . The camera view is conceptualized by envision- ing the camera as pointing at the center of a viewscreen of pixels. The viewscreen is thought of as being positioned in a rectangular array in 3-space. The distance to the viewscreen is set by a call to SetScreenDistance, and its width and height by a call to SetScreenDimen- sions. However, the routine ResizeWindow in RayTrace will resize the array of pixels as necessary to keep the entire viewscreen in view. If the aspect ratio of the OpenGL rendering window is different from the aspect ratio of the viewscreen, then the pixels are positioned so that the entire viewscreen area is rendered.  Neither a near-clipping plane or a far-clipping plane is used. However, the variable MAX_DIST should be set to be at least as large as the diameter of the scene because rays are traced only to that distance.  Second, there is a call to SetUpMaterials. This creates an array of pointers to materials. Each material is created with the C++ operator new and then has its material properties set. These material properties include ambient color, diffuse color, specular color, reﬂection color, and transmissive color, as well as shininess and index of refraction. If the reﬂection color is set to zero  but by default it is not zero , then the object does not generate reﬂection rays. If the transmission color is zero  and zero is its default value , then the object does not generate transmission rays. The index of refraction is used only for transmission rays, of course. Good values for the index of refraction would be numbers like 1.33, which is approximately the index of refraction of water, or 1.5, which is approximately the index of refraction for glass.  The color values for materials are speciﬁed by giving three or four ﬂoating point numbers for the red, green, blue, and possibly alpha values of the color.  The alpha values are just ignored for ray tracing purposes but were included in case future versions of the software want to exploit them.  The color values can be speciﬁed either by giving an array of ﬂoating point numbers, similar to the convention used by OpenGL, or, alternatively, by passing in a VectorR3 or VectorR4 object. This means that a wide variety of interfaces are supported to set color values, and you may use whatever one seems most convenient.  For example, here are the eight possible ways to set the ambient color of a material M  the  alpha value defaults to 1.0 :  M.SetColorAmbient 0.2,0.3,0.4 ;  M.SetColorAmbient 0.2,0.3,0.4,1.0 ; double c[3]={0.2,0.3,0.4}; M.SetColor3Ambient &c[0] ; double c[4]={0.2,0.3,0.4,1.0}; M.SetColor4Ambient &c[0] ; float c[3]={0.2,0.3,0.4}; M.SetColor3Ambient &c[0] ; float c[4]={0.2,0.3,0.4,1.0}; M.SetColor4Ambient &c[0] ;  M.SetColorAmbient  VectorR4 0.2,0.3,0.4,1.0   ;   336  RayTrace Software Package  The next routine that is called is SetUpLights. It deﬁnes one or more lights and sets their properties, which include the usual ones such as position and ambient, diffuse, and specular color. It is also possible to set attenuation constants and spotlight effects of exactly the same kind as are supported by OpenGL. In addition, the lights can be made directional instead of positional.  The next routine that is called is SetUpViewableObjects. The viewable objects are ge- ometric shapes deﬁned by ViewableBase objects. The SetUpViewableObjects routine deﬁnes the various objects and their positions and orientations; it also assigns material to the objects’ surfaces. See Section B.3.5 for information on how to set up viewable objects.  Every viewable object supports texture maps, which are applied by using objects of type TextureMap. You may have separate texture maps for the front and back surfaces of objects. Each type of object has its own system of assigning texture coordinates, and in a few cases, such as spheres and ellipses, there is more than one way for texture coordinates to be calculated.  B.3 The RayTrace API  B.3.1 Specifying Lights  The ray tracing package supports lights that are very similar to OpenGL’s lights. This includes the use of separate ambient, diffuse, and specular light as well as distance attenuation and spotlights.  Lights are C++ objects of type Light. A new light is allocated by declarations of one of  the following two forms:  Light* lightPtr = new Light  ;  Light myLight;  The ﬁrst form allocates a light in the C++ heap with lightPtr a pointer to the light; the second allocates a light on the stack.  By default, lights are positional and are placed at the origin; to place the light elsewhere,  you use one of the following routines:  SetPosition  double x, double y, double z  ; SetPosition  double *position  ; SetPosition  float *position  ; SetPosition  VectorR3& position  ;  These routines are all functionally equivalent: they make the light positional and place it at the location speciﬁed. In each case, three numeric values are given for x, y, z-components of the position. These numeric values are given explicitly in the ﬁrst form of SetPosition and are given by a pointer to a list of three double’s or float’s in the next two forms of SetPosition or by a single VectorR3 in the ﬁnal form of SetPosition. These different ways of setting values are provided in the ray tracing package since different ways of setting values may be more convenient in different settings.  To make a light directional, call one of the following routines to set a light to shine in a  particular direction:  SetDirectional  double x, double y, double z  ; SetDirectional  double *direction  ; SetDirectional  float *direction  ; SetDirectional  VectorR3& direction  ;   B.3 The RayTrace API  337  The next important property to set for a light is its color. Just as in the Phong lighting model used by OpenGL, each light has ambient, diffuse, and specular colors. To set the ambient color, use one of the following routines:  SetColorAmbient  double red, double green, double blue ; SetColor3Ambient  double *color  ; SetColor3Ambient  float *color  ; SetColor4Ambient  double *color  ; SetColor4Ambient  float *color  ; SetColor4Ambient  VectorR4& color  ;  The color contains red, green, and blue components as usual plus an optional α component. The α component is currently ignored by the ray tracing software and defaults to 1. The difference between the SetColor3* and SetColor4* routines is that the former expects an array of length three and the latter expects an array of length 4.  To set the diffuse and specular colors, use similar routines but with “Ambient” replaced by “Diffuse” and “Specular”. You can also use SetColorAmbientDiffuse to set the ambient and diffuse colors simultaneously or use “SetColor” to set all three colors at once. Lights support the same kind of distance attenuation as used in OpenGL. The attenuation  coefﬁcients are set by calling  SetAttenuate double aConst, double aLinear, double aQuadratic ;  Spotlights are also supported with exactly the same kinds of features as are supported by  OpenGL. The spotlight characteristics are set by the following routines:  SetSpotCutoff  double cutoffCosine  : SetSpotExponent  double spotExponent  ; SetSpotDirection  double x, double y, double z  ; SetSpotDirection  double* direction  ; SetSpotDirection  float* direction  ; SetSpotDirection  VectorR3& direction  ;  Calling any of these routines turns the light into a spotlight. To deactivate the spotlight effects, use ResetSpotlight  .  B.3.2 Deﬁning the Viewport and Camera Positions  We now describe how to set the camera position, the virtual viewport position, and the array of pixel positions. The ray trace software works only in global coordinates, and does not incorporate any use of model view or projection transformations. Thus, the software expects you to give camera position and direction, light positions and directions, and viewable object positions and orientations in global coordinates.  To set up a camera position and direction plus a screen position and size, use a sequence of  commands such as double Cpos[3] = {0.0,0.0,25.0};    Position of camera double Cdir[3] = {0.0,0.0,-1.0};    Direction of camera double Cdist = 25.0;    Distance to "screen" double width = 5.0, height=4.0;    Width and height of the screen int pixelWidth=640, pixelHeight=480;    Screen dimensions CameraView* cv = new CameraView  ; cv->SetPosition  Cpos  ;   338  RayTrace Software Package  cv->SetDirection  Cdir  ; cv->SetScreenDistance  Cdist  ; cv->SetScreenDimensions  width, height  ; cv->SetScreenPixelSize  pixelWidth, pixelHeight  ;  These calls specify the position of the camera, its view direction, and the distance from the camera to the virtual viewport. The “up” direction of the view is always as much “upward” along the y-axis as possible. This is the natural upward direction for a camera; if v is the view direction, then the up direction is given by the vector v ×  j × v .  For convenience, these commands have several different formats that give the same func-  tionality:  SetPosition  double x, double y, double z  ; SetPosition  double* pos  ; SetPosition  float* pos  ; SetPosition  VectorR3& pos  ;  SetDirection  double x, double y, double z  ; SetDirection  double* dir  ; SetDirection  float* dir  ; SetDirection  VectorR3& dir  ;  SetScreenPixelSize  int i, int j  ; SetScreenPixelSize  PixelArray& pixelarray  ;  You can also make the viewer either directional or positional using the commands  SetLocalViewer  ; SetNonLocalViewer  ;  The default is a local  i.e., positional  viewer. Nonlocal viewers are used for directional  or- thographic  camera views; nonlocal viewers must be given a ﬁnite position since the position helps determine the location of the viewport.  For ray tracing, it is convenient to know the position in space where a pixel position lies in order to be able to shoot a ray from the eye position through a pixel position. The CalcPixel Direction routine takes as input the coordinates of a pixel and returns the unit vector pointing in the direction from the eye to the given pixel. This command  a member function of CameraView  has the syntax:  CalcPixelDirection  double i, double j, double* dir ; CalcPixelDirection  double i, double j, float* dir ; CalcPixelDirection  double i, double j, VectorR3* dir  ;  The dir value is the returned unit vector. The pixel coordinates i and j are ﬂoating point numbers, which makes it easy to use subpixel locations for distributed ray tracing applications. For directional  or, orthographic  cameras, rays traced from the eye position have a ﬁxed direction but start at different locations. These are calculated for you by the CalcView Position routine, which has the calling syntax  CalcViewPosition  double i, double j, double* pos ; CalcViewPosition  double i, double j, float* pos ; CalcViewPosition  double i, double j, VectorR3* pos  ;  The pos value is the returned position.   B.3 The RayTrace API  339  The following routines can obtain the position of a pixel in the viewport:  CalcPixelPosition  double i, double j, double* pos ; CalcPixelPosition  double i, double j, float* pos ; CalcPixelPosition  double i, double j, VectorR3* pos  ;  If you modify the high-level routines to use distributed ray tracing with jittered eye positions, you should not move the position of the eye with SetPosition, for this would move the positions of the viewport pixels too. Instead, you should calculate the jittered eye position and then call CalcPixelPosition to get a pixel position. The ray direction can then be computed by taking the difference of these two positions and normalizing.  B.3.3 Working with the Pixel Array  A PixelArray object holds an array of pixel values. You can allocate a new pixel array of a given size by using the command  PixelArray px = new PixelArray  width, height ;  The size can be changed by the SetSize or ResetSize method. The former command explicitly sets the dimensions of the pixel array; the latter uses the size of the current GLUT rendering window to determine the size of the pixel array. The PixelArray class takes care of reallocating memory for the pixel array when the size of the array increases.  Each pixel in the pixel array holds red, green, and blue values as ﬂoating point numbers. These can be set by any of the following commands, which are member functions of Pixel Array:  SetPixel  int i, int j, float* color  ; SetPixel  int i, int j, double* color  ; SetPixel  int i, int j, VectorR4& color  ; SetPixel  int i, int j, VectorR3& color  ;  In each case, values for red, green, and blue are stored. There is no alpha value in the pixel array. A member function GetPixel will return the color values of a single pixel.  Finally, there is the important Draw   function, which copies the contents of the pixel array  into the current rendering window. This is invoked by  px->Draw  ;  B.3.4 Deﬁning Materials  A Material object encapsulates the reﬂective, transmissive, and emissive properties of a surface. A Material consists of the attributes listed below. Except for the last two, these values are set separately for red, green, and blue. The ﬁrst four coefﬁcients are used for the Phong lighting calculations and apply to both reﬂected and transmitted direct illumination.  ρa Ambient illumination coefﬁcients. ρd Diffuse illumination coefﬁcients. ρs Specular illumination coefﬁcients. ρe Emissive color. ρrg Global reﬂection coefﬁcients. ρtg Global transmission coefﬁcients.  η Index of refraction – same for all colors. f Specular shininess exponent.   340  RayTrace Software Package  For convenience, several different ways exist to set these values. For example, the ambient  illumination coefﬁcient may be set with any of the following member functions:  SetColorAmbient  double r, double g, double b  ; SetColorAmbient  double r, double g, double b, double alpha  ; SetColor3Ambient  double* color  ; SetColor4Ambient  double* color  ; SetColor3Ambient  float* color  ; SetColor4Ambient  float* color  ; SetColorAmbient  VectorR4& color  ;  The alpha component of color is ignored by the current software implementation but is reserved for future use. It defaults to the value 1. The same kinds of commands work for the other material coefﬁcients, and the function names are formed by replacing “Ambient” with “Diffuse,” “AmbientDiffuse,” “Specular,” “Emissive,” “Reflective,” or “Transmissive.” The only exception to this naming scheme is that the reﬂective and transmissive values do not have alpha components, and so the routines that set four components do not apply to them.  The index of refraction and the shininess exponent are set by the member functions  SetIndexOfRefraction  double eta  ; SetShininess  double exponent  ;  The default values for of all these are identical to the default OpenGL value. The default value for the global reﬂectivity coefﬁcients is 0.5, and for the global transmission coefﬁcients is 0. That is, by default surfaces are 50 percent reﬂective and are not transparent at all.  B.3.5 Deﬁning Viewable Objects  The “viewable objects” are the various geometric shapes that can be used in a scene. A viewable object generally contains the following information:  1. Geometric information, such as size, position, orientation, and shape. Each type of viewable object has its own unique speciﬁcations; for example, a sphere is speciﬁed by giving its center position and its radius, a triangle is speciﬁed by its three vertices, and so on.  2. Materials for the surfaces of the object. Most objects have two or more surfaces. Flat objects such as triangles and parallelograms have front and back surfaces. Solid objects such as spheres and tori have inner and outer surfaces. Each viewable object type allows a different material to be assigned to each surface, and thus each viewable object type has at least two materials that need to be speciﬁed. The most common way of specifying material is with member functions  SetMaterial  Material *material  ; SetMaterialOuter  Material *outermat  ; SetMaterialInner  Material *innermat  ;  For solid objects, including spheres, ellipses, tori, and parallelepipeds, these functions set the materials for the inner and outer surfaces. The ﬁrst function, SetMaterial, sets both the inner and outer materials.  Flat objects, such as triangles, parallelograms, and B´ezier patches, also have two materi- als, but they are called the “front” and “back” materials rather than the “outer” and “inner” materials.  The more complicated shapes, such as cones and cylinders, have the ability to specify  separate materials for the sides, bottom, and, in the case of a cylinder, the top.   B.3 The RayTrace API  341  3. Texture maps can be applied to all the surfaces of viewable objects. These are set with the  following member functions:  TextureMap  TextureMapBase* texture  ; TextureMapFront  TextureMapBase* texture  ; TextureMapBack  TextureMapBase* texture  ;  The ﬁrst command sets both the front and back texture maps. For objects with insides, such as spheres, “front” and “back” are synonyms for “outer” and “inner,” respectively.  When texture maps are assigned to a surface, texture coordinates are also needed. For- tunately, the ray tracing software will automatically calculate texture coordinates for all viewable objects. Each viewable object class provides customized methods for controlling how texture coordinates are assigned. Viewable objects always return texture map coordi- nates in the unit square [0, 1]2. Geometries with more than one face, such as parallelepipeds, cylinders, and so on, also return a face number.  B.3.6 Viewable Spheres  A sphere has type ViewableSphere; its geometry is set simply by giving its center and radius. These are set with the following member functions:  SetRadius  double radius  ;  SetCenter  double x, double y, double z  ; SetCenter  double *center  ; SetCenter  float *center  ; SetCenter  VectorR3& center  ;  The various forms of SetCenter all have the same functionality.  The geometry of the sphere becomes a little more complicated if texture coordinates need to be used. First, an orientation for the sphere needs to be deﬁned. The standard orientation for a sphere has the positive y-axis as the up direction and the positive z-axis as the forward direction. Then u and v coordinates are set so that v = 1 means the point at the top of the sphere  in the up direction, i.e., at the “North Pole”  and v = 0 means the point in the down direction, at the “South Pole.” The value u = 1 2 is used for direction of the positive z-axis. That is, a  cid:6  at the sphere centered at the origin in standard position has texture coordinates  cid:5 u, v cid:6  =  cid:5  1 point in the front of the sphere, namely, the point where the positive z-axis intersects the sphere. General orientations are speciﬁed by giving two axes. The ﬁrst axis, called AxisA speciﬁes the front direction, that is, the direction towards a viewer who is looking at the front of the sphere; its default value is k  the z-axis . The second axis, called AxisC is the up direction, and it defaults to j. These axes are set with any of the commands  , 1 2  2  SetuvAxes  double* axisA, double* axisC ; SetuvAxes  float* axisA, float* axisC ; SetuvAxes  VectorR3& axisA, VectorR3& axisC ;  In each case, the axis is speciﬁed by three ﬂoating point numbers; it is not necessary that the axis directions be unit vectors. They should be nonzero, however, or a divide-by-zero will occur. In addition, they should be orthogonal.  Recall from Section V.1.2 that there are two natural ways to calculate texture coordinates for spheres, as given by Equations V.2 and V.3 on page 131. Either of these methods can be used; they are enabled by the member functions  SetuvSpherical  ; SetuvCylindrical  ;  The default is the SetuvSpherical mode, as in Equation V.2.   342  RayTrace Software Package  B.3.7 Viewable Triangles and Parallelograms  Triangles and parallelograms are perfectly ﬂat with zero thickness. By default, they can be seen from both the front and the back. The classes for triangles and parallelograms are View- ableTriangle and ViewableParallelogram. Each is speciﬁed with three vertices; for the parallelogram, the fourth vertex is calculated from the other three. The member functions that can be used to set the three vertices are  Init  double* vertexpositions ; Init  float* vertexpositions ; Init  VectorR3& vA, VectorR3& vB, VectorR3& vC  ;  The ﬁrst two forms take an array of nine ﬂoating point numbers that specify the three vertices. The three vertices are given in counterclockwise order, as viewed from the front. For the parallelogram, the fourth vertex will be opposite the second speciﬁed vertex.  The materials for the front and back faces are set by the commands  SetMaterial  Material* material  ; SetMaterialFront  Material* frontmaterial  ; SetMaterialBack  Material* backmaterial  ;  The ﬁrst form of the command sets both materials. If the back material pointer is equal to 0, then the back face is invisible and is never intersected  i.e., is culled . The points on the triangle and parallelogram are assigned texture coordinates using linear interpolation. The three vertices A–C of the triangle are given texture coordinates  cid:5 0, 0 cid:6 ,  cid:5 1, 0 cid:6 , and  cid:5 0, 1 cid:6  in that order. The vertices A–D of the parallelogram are assigned texture coordinates  cid:5 0, 0 cid:6 ,  cid:5 1, 0 cid:6 ,  cid:5 1, 1 cid:6 , and  cid:5 0, 1 cid:6 . You cannot change the texture coordinates assigned to the vertices, but you can achieve the same effect by using TextureAffineXform and TextureBilinearXform objects, which allow texture coordinates to be modiﬁed by a linear or bilinear mapping.  An axis-aligned ellipsoid with center at the origin is speciﬁed by three radius values, α, β, γ and is the set of points  B.3.8 Viewable Ellipsoids  -  .   cid:5 x, y, z cid:6  :  x 2 α2  + y2 β2  + z2 γ 2  = 1  .  This ellipsoid is a sphere stretched to have dimensions α × β × γ . More generally, ellipsoids can be translated away from the origin and can be oriented so as to not be axis aligned.  An object of type ViewableEllipsoid is a general ellipsoid. Its center position is spec-  iﬁed by any of the member functions  SetCenter  double x, double y, double z  ; SetCenter  double *center  ; SetCenter  float *center  ; SetCenter  VectorR3& center  ;  A circular ellipsoid is one that has circular cross sections, that is, two of its three radii are  equal. A circular ellipsoid is set by using the functions  SetCentralAxis  VectorR3& axisC  ; SetRadii  double radiusC, double radiusAB  ;   B.3 The RayTrace API  343  The ﬁrst function sets the central axis  the default is the y-axis . The second command sets the height of the ellipsoid along its central axis and the radius of the central circular cross section. You may also specify noncircular ellipsoids. These have three axes with three separate radii.  The functions to set these values are  SetAxes  VectorR3& axisC, VectorR3& axisA  ; SetRadii  double radiusC, double radiusA, double radiusB  ;  The inner and outer materials for the ellipsoid are set in the usual way. Texture coordinates are calculated in much the same way as the texture coordinates on the sphere. In particular, the height along the center axis, AxisC, controls the v texture coordinate. The axis AxisA intersects the ellipsoid at the front, at the u = 1  2 position.  Just as for spheres, SetuvSpherical and SetuvCylindrical specify the method for  computing texture coordinates for ellipsoids.  B.3.9 Viewable Cylinders  The ViewableCylinder class supports a broad range of cylindrical shapes. The simplest cylinders are the circular right cylinders. “Circular” means that the cross sections parallel to the central axis are circular. A “right” cylinder is one in which the top and bottom faces are perpendicular to the central axis. The next simplest kind of cylinder is a noncircular, right cylinder. Finally, you may also deﬁne cylinders that are neither right nor circular. Noncircular cylinders have elliptical cross sections; nonright cylinders may have arbitrary planes bounding the top and bottom faces.  Every cylinder needs its center and its central axis speciﬁed: these are given with the  functions  SetCenterAxis  double x, double y, double z  ; SetCenterAxis  double* axisC  ; SetCenterAxis  float* axisC  ; SetCenterAxis  VectorR3& axisC  ;  SetCenter  double x, double y, double z  ; SetCenter  double* center  ; SetCenter  float* center  ; SetCenter  VectorR3& center  ;  A right cylinder is further speciﬁed by giving its height and radius with the member functions  SetHeight  double height  ; SetRadius  double radius  ;  A noncircular right cylinder has two radii, and you must specify another axis direction, AxisA. The third axis direction, AxisB, is computed for you as the cross product of the central axis and AxisA. To initialize a noncircular right cylinder, you ﬁrst call SetCenterAxis and SetCenter and then call the following three functions:  SetHeight  double height  ; SetRadialAxis  VectorR3& axisA  ; SetRadii double radiusA, double radiusB ;  For general nonright cylinders, you use the preceding commands to set the radius or the radial axes and their radii. But instead of using the SetHeight method, the following two   344  RayTrace Software Package  functions are called to deﬁne the plane equations for the top and bottom faces of the cylinder:  SetBottomFace  VectorR3& planenormal, double planecoef  ; SetTopFace  VectorR3& planenormal, double planeCoef  ;  The plane normals are vectors that are perpendicular to the plane containing the top or bottom face. If n is the normal for the top  respectively, the bottom  face, and if c is the center axis axisC, then it is required that n · c > 0  respectively, that n · c < 0 . The plane coefﬁcient is a scalar d. The plane is the set of points x satisfying x · n = d.  For a cylinder, you specify six materials: one for each of the inner and outer surfaces of the cylinder’s side, top face, and bottom face. These six materials can be set individually with the member functions  SetMaterialSideInner Material *material ; SetMaterialSideOuter Material *material ; SetMaterialTopInner Material *material ; SetMaterialTopOuter Material *material ; SetMaterialBottomInner Material *material ; SetMaterialBottomOuter Material *material ;  Several functions let you set multiple materials at once. These are:  SetMaterial Material *material ; SetMaterialInner Material *material ; SetMaterialOuter Material *material ;  SetMaterial sets all six materials at once, SetMaterialOuter sets all three outer mate- rials, and so forth. Texture coordinates are assigned separately for the side and for the top and bottom faces. For the side of the cylinder, the axis AxisA, points in the direction of the u = 1 2 line, and the v coordinate measures distance up and down the cylinder. Texture coordinates for the side are returned with u, v values in [0, 1]2. Texture coordinates for the top and bottom faces are returned with u, v values lying in the circle with radius 1 2 centered at  cid:5  1  cid:6 . For both the top and the bottom, the texture coordinates are from the viewpoint of a viewer outside the cylinder looking along the center axis with the u-axis pointing along the positive AxisB axis.  , 1 2  2  The top face, the bottom face, and the side of a cylinder are assigned different face numbers: the side is face number 0, the bottom is face 1, and the top is face 2. The face numbers can be used by texture maps to apply different textures to different faces  by using a TextureMultiFaces object .  B.3.10 Viewable Cones  Cones are objects of type ViewableCone. The interface for cones is mostly similar to the interface for cylinders. Cones can be right cones, with the bottom face perpendicular to the central axis, or can be nonright, with any plane for the bottom face.  Truncated cones are not supported, however.  Further, cones may have either circular or elliptical cross section.  Every cone has an apex position and a central axis. These are speciﬁed by the functions  SetCenterAxis  double x, double y, double z  ; SetCenterAxis  double* axisC  ; SetCenterAxis  float* axisC  ; SetCenterAxis  VectorR3& axisC  ;   B.3 The RayTrace API  345  SetApex  double x, double y, double z  ; SetApex  double* apexPos  ; SetApex  float* apexPos  ; SetApex  VectorR3& apexPos  ;  The apex is the position of the point at the top of the cone. The AxisC central axis points up out of the top of the apex. It does not need to be a normal vector and will be automatically normalized.  In addition, every cone has the steepness of its sides set in terms of their slope. For right  circular cones, you use the function  SetSlope  double slope  ;  The slope value is the slope of the sides measured by the change in distance from the center axis divided by the distance along the center axis from the apex. The slope should be positive. Noncircular cones have elliptical cross sections. For these, you specify a second, radial axis, called AxisA. The third axis, AxisB, is calculated as the cross product of the center axis and AxisA. The radial axis is set by the function  SetRadialAxis  VectorR3& axisA  ;  The central axis must be set before the radial axis. An elliptical cone has two slopes, one along AxisA and the other along AxisB. These are set with the functions  SetSlopes double slopeA, double slopeB ;  A right cone is one whose base is perpendicular to its central axis. The height of a right  cone is set by using the member function  SetHeight double height ;  For nonright cones, you may make any plane be the base by calling  SetBaseFace  VectorR3& planenormal, double planecoef  ;  The SetBaseFace function works in much the same way as the commands that specify the top and base face of a cylinder. The planenormal should be pointing out of the base  so its dot product with axisC should be negative , and the apex of the cone should therefore be below the plane.  A cone has four distinct materials; one for each of the inner and outer faces of the cone’s  side and base. These are set individually by the functions  SetMaterialSideInner Material *material ; SetMaterialSideOuter Material *material ; SetMaterialBaseInner Material *material ; SetMaterialBaseOuter Material *material ;  or, as with cylinders, multiple materials can be set at once with the functions  SetMaterial Material *material ; SetMaterialInner Material *material ; SetMaterialOuter Material *material ;  Texture coordinates for cones are similar to texture coordinates of cylinders. The side of the cone has texture coordinates in [0, 1]2. The base has texture coordinates that lie in the circle of radius 1 2 centered at  cid:5  1   cid:6 . The side is face number 0, and the base is face number 1.  , 1 2  2   346  RayTrace Software Package  B.3.11 Viewable Parallelepipeds  A parallelepiped is a solid object bounded by six planar faces with opposite faces parallel. This includes as special cases cubes and rectangular prisms  that is, boxes , but, more generally, any kind of linear transformation of a cube or rectangular prism is a parallelepiped.  The geometry for an object of type ViewableParallelepiped is speciﬁed by giving four of its vertices  corners . The ﬁrst corner VertexA is surrounded by the three vertices VertexB, VertexC, and VertexD. For help with visualizing the vertices’ positions, and for later assignment of face numbers, the following table lists, for each vertex, the identity of the corresponding corner of the parallelepiped:  Vertex VertexA VertexB VertexC VertexD  Position on Parallelepiped bottom left front vertex bottom right front vertex top left front vertex bottom left back vertex  The four vertices are speciﬁed with one of the functions  SetVertices  double *verts  ; SetVertices  float *verts  ; SetVertices  VectorR3& vertA, VectorR3& vertB, VectorR3& vertC,  VectorR3& vertD  ;  The argument to the ﬁrst two forms of the function is a pointer to an array of 12 ﬂoating point numbers.  Materials are set as usual with the SetMaterial, SetMaterialOuter, and SetMa- terialInner commands. There is currently no provision for giving separate materials to the six faces. Texture coordinates are set by mapping each face to the unit square [0, 1]. The face numbers for the six faces are given in the following table:  Face Front face Back face Top face Bottom face Right face Left face  Face Number 0 1 2 3 4 5  The top and bottom faces have texture coordinates set with the u-axis pointing “rightward,” and the four sides have texture coordinates set with the v-axis pointing “upward.”  B.3.12 Viewable Tori  The geometry of a torus, an object of type ViewableTorus, is given by specifying  a  the position of its center,  b  the axis of symmetry of the torus, and  c  the major and minor radius of the torus. The center can be set by any of the following member functions:  SetCenter  double x, double y, double z  ; SetCenter  double *centerpos  ; SetCenter  float *centerpos  ; SetCenter  VectorR3& centerpos  ;   B.3 The RayTrace API  347  The central axis direction, also known as AxisC, is set by one of the member functions  SetAxis  double* centralaxis  ; SetAxis  float* centralaxis  ; SetAxis  VectorR3& centralaxis  ;  It is not necessary that the central axis direction be a unit vector. To set the two radii, use the member function  SetRadii  double majorradius, double minorradius  ;  The major radius is the radius of the circle that forms the center of the torus’s tube. The minor radius is the radius of the tube.  The inner and outer materials are set in the usual fashion with SetMaterial, SetMa-  terialInner, and SetMaterialOuter.  To set texture coordinates, you also need to choose a radial axis: this is done by setting AxisA, which is the axis pointing out the front of the torus. This axis intersects the front of the torus where the texture coordinate u is equal to 1 2. This axis is set with the member function  SetRadialAxis  VectorR3& axisA  ;  The v-axis for texture coordinates runs vertically around the torus. The texture coordinates are calculated by the method asked for in Exercise V.2 on page 131.  B.3.13 Viewable B´ezier Patches  B´ezier patches are geometrically a good deal more complicated than the rest of the viewable objects. In fact, B´ezier patches are more general than the other geometric shapes, since spheres, cones, tori, and so on can all be realized as B´ezier patches. Corresponding to this fact, B´ezier patches are algorithmically much more difﬁcult to process, and computation speeds for B´ezier patches are worse than for simpler geometric objects by about an order of magnitude.  The ray tracing software supports both rational and nonrational B´ezier patches and patches of orders three and four. In addition, patches can have order three with respect to one variable and order four with respect to the other variable.  Objects of type ViewableBezierSet hold a set  i.e., a collection  of B´ezier patches. It is intended that a single ViewableBezierSet hold B´ezier patches that are clustered together: for example, a teapot composed of B´ezier patches would probably use a single ViewableBezierSet to holds its patches. If one were modeling multiple teapots, then each teapot would probably have its own ViewableBezierSet.  The only purpose of ViewableBezierSet is to hold a group of B´ezier patches and surround them with a single bounding sphere. The bounding sphere is used to prune intersection testing to speed up the processing of rays that do not come near the patches. Thus, the decision of what ViewableBezierSet’s to use and which patches to include in which set depends mostly on the question of which patches could proﬁtably be surrounded by a single bounding sphere. A secondary consideration is that every patch in a ViewableBezierSet is given the same texture map object  however, the different patches are assigned different face numbers and so can be distinguished by a texture map .  To create a new ViewableBezierSet, you use a constructor of one of the forms  ViewableBezierSet myBezierSet;  ViewableBezierSet* myBezierSetPtr = new ViewableBezierSet  ;   348  RayTrace Software Package  The set is created without any patches. You must add patches one at a time to the set using the commands AddPatch, AddRationalPatch, or both. These commands have the following forms:  AddPatch  int uOrder, int vOrder, float* controlPts  ; AddRationalPatch  int uOrder, int vOrder, float* controlPts  ; AddPatch  int uOrder, int vOrder, double* controlPts  ; AddRationalPatch  int uOrder, int vOrder, double* controlPts  ;  The parameters uOrder and vOrder must equal either 3 or 4  it is permitted for them to be different , and they give the orders of the cross-sectional slices of the B´ezier patch in the u and v directions. Recall that the order of a B´ezier curve is one greater than the degree of the curve. The pointer controlPts points to an array of ﬂoating point numbers. For Rational patches, the ﬂoating point numbers come in groups of four values, giving the x, y, z, w-components of the control points in homogeneous representation. For nonrational patches, the ﬂoating point numbers come in groups of three, specifying x, y, z-coordinates of the control points. The control points are denoted pi, j , where 0 ≤ i < uOrder and 0 ≤ j < vOrder. The default assumption is that the control points come in the order p0,0, p1,0, p2,0, . . . with the i subscript changing faster than the j subscript  see below for how to change this order .  It is also possible to use VectorR3 and VectorR4 formats for control points. The relevant  forms of the AddPatch commands are  AddPatch  int uOrder, int vOrder, VectorR3* controlPts  ; AddPatch  int uOrder, int vOrder, VectorR4* controlPts  ;  The ﬁrst of these uses nonrational control points, and the second uses rational control points. You may also specify the order of the control points by giving different forms of the  AddPatch commands:  AddPatch  int uOrder, int vOrder, float* controlPts, int uStride, int vStride  ;  AddRationalPatch  int uOrder, int vOrder, float* controlPts,  int uStride, int vStride  ; AddPatch  int uOrder, int vOrder, double* controlPts, int uStride, int vStride  ;  AddRationalPatch  int uOrder, int vOrder, double* controlPts,  int uStride, int vStride  ;  AddPatch  int uOrder, int vOrder, VectorR3* controlPts,  int uStride, int vStride  ;  AddPatch  int uOrder, int vOrder, VectorR4* controlPts,  int uStride, int vStride  ;  The uStride and vStride parameters give the number of steps  the stride  between suc- cessive control points in the u and v directions. In other words, if controlPts+m points to the beginning of the control point pi, j , where m is an integer, then controlPts+m+uStride and controlPts+m+vStride point to the control points pi+1, j and pi, j+1, respectively. For example, the default values of uStride and vStride for the ﬁrst of the six AddPatch com- mands are uStride=3 and vStride=3*uOrder. The factor 3 signiﬁes that each nonrational point uses three ﬂoating point numbers: it would be replaced by 4 for rational control points.   B.3 The RayTrace API  349  For the ﬁnal two forms of the AddPatch commands, the default values are uStride=1 and vStride = uOrder.  Face numbers are assigned to patches in numerical order; in addition, the AddPatch func-  You can set the material of B´ezier patches by using the commands  member functions of  tions return face numbers.  ViewableBezierSet ,  SetMaterial  Material *material  ; SetMaterialFront  Material *frontMaterial  ; SetMaterialBack  Material *backMmaterial  ;  As usual, the ﬁrst command sets both the front and back materials. The material speciﬁcations will affect all subsequent patches added to the set and remain in effect until the next material speciﬁcation. Thus, different patches in the same ViewableBezierSet may have different materials.  Texture coordinates can be set by the command  SetUvRange  double uMin, double vMin, double uMax, double vMax ;  For the purpose of reporting texture coordinates, this command makes u vary from uMin to uMax, and v vary from vMin to vMax. The default values for the minimum and maximum values are 0 and 1. Like the SetMaterial commands, SetUvRange affects subsequent patches added to the ViewableBezierSet. When using textures, you would usually need to call SetUvRange for each patch.  The texture map itself is speciﬁed as usual with the TextureMap, TextureMapFront, and TextureMapBack commands. Every patch in the ViewableBezierSet shares the same texture map.  In some circumstances, you may wish to use SetBoundingSphereCenter command to explicitly specify the center position for the bounding sphere used to hold the set of B´ezier patches. If this command is not given, then the bounding sphere center and radius are auto- matically calculated the ﬁrst time an attempt is made to trace a ray and intersect it with the set of patches.  B.3.14 Texture Maps  The ray tracing software supports several basic texture mapping features. At present, it sup- ports a checkerboard pattern, texture maps that apply bitmap images, and bump mapping. It also incorporates several methods for transforming texture map coordinates, for sequentially applying multiple texture maps to a surface, and for applying different texture maps based on face numbers.  The checkerboard pattern consists of inﬁnitely repeating rectangles of two different mate- rials. A checkered texture map is an object of type TextureCheckered and is speciﬁed by giving two materials and the width and height of the rectangles in the check pattern. The two materials are speciﬁed by the following member functions of TextureCheckered:  SetMaterials  Material* mat1, Material* mat2  ; SetMaterial1  Material* mat1  ; SetMaterial2  Material* mat2  ;  The ﬁrst function subsumes the other two calls. The width and height of the rectangles are set by the member function  SetWidths double uwidth, double vwidth ;   350  RayTrace Software Package  Here uwidth and vwidth mean the width and height, which are measured in the direction of the u and v coordinates, respectively.  A TextureRgbImage texture map contains a texture map loaded from a bitmap. You can  create a new TextureRgbImage by the command  TextureRgbImage* tRgb = new TextureRgbImage  "filename.bmp"  ;  where filename.bmp is the name of the bitmap format ﬁle containing the texture map image. Many common drawing programs support the bitmap ﬁle format, and thus this ﬁle format is relatively easy to create. When the texture map tRgb is applied to a surface, it overwrites the ambient and diffuse reﬂectivity coefﬁcients with the color from the texture map. The specular reﬂectivity coefﬁcient of the surface is left unchanged. The texture map is applied before the lighting calculation; consequently, the effect of the texture map is to make the ambient and diffuse colors of the surface equal the values from the texture map. The colors of specular highlights are unchanged by the texture map, however.  You may specify whether the texture map is repeating by the commands   cid:2    cid:1   SetWrapMode   TextureRgbImage::WrapUV TextureRgbImage::ClampUV   ;  These allow you set whether the texture map repeats or whether it clamps to the color of the border. In addition to these two wrap modes, you can also set a background color to be used instead of the border colors when not wrapping. This background color is set by  SetWrapMode  VectorR3& color  ;  A BumpMapFunction texture map can be used to create a bump map. This allows you to specify a function that computes the bump map height function d, as discussed in Section V.2. The most common way to create a BumpMapFunction is to invoke it with the constructor  BumpMapFunction  f  ;  where f is a function of type double f double u, double v . The function f will be called as needed by the bump map, and it must compute the height function d. Op- tionally, you may call the member function SetBorderType   to set the way the height function wraps around at the borders of the unit square [0, 1]. The default setting is that the height function f  u, v  is deﬁned for all values of u and v. In the current implementation, a BumpMapFunction will not work correctly if it is applied subsequently to a texture map that transforms texture coordinates, such as the TextureAffineXform and TextureBilin- earXform functions described below, because the calculation of the partial derivatives for bump mapping does not  at present  take into account the effects of these transformations.  A TextureSequence combines several texture maps into a single texture map that applies  the constituent texture maps sequentially. It can be created by one of the constructors  TextureSequence  int numMaps, TextureMapBase* texMaps[]  ;  TextureSequence  TextureMapBase* texMap1, ...,  TextureMapBase* texMapn  ;  Here texMaps should be an array of pointers to texture maps, and the texMapi’s should be pointers to texture maps  n can be 2, 3, or 4 . The speciﬁed texture maps will be applied sequentially by the TextureSequence object. The component texture maps can be changed by using the SetTexture member function. The total number of texture maps cannot be changed, but null pointers can be used for disabling texture maps.   B.3 The RayTrace API  351  A TextureMultiFaces texture map allows you to apply different texture maps to differ- ent faces; for example, different faces of a cylinder can receive different textures. The texture map can be created with one of the constructors:  TextureMultiFaces  int numMaps, TextureMapBase* texMaps[]  ;  TextureMultiFaces  TextureMapBase* texMap1, ...,  TextureMapBase* texMapn  ;  Here, n may be 2, 3, 4, or 6. The ith texture map is applied to face number i. For face  numbers greater than or equal to numMaps, the last texture map is applied.  Note that TextureSequence and TextureMultiFaces are themselves texture map  objects  i.e., are subclasses of the TextureMapBase class .  Several of the viewable objects in the previous section have special methods for specifying axes that determine the way texture coordinates are assigned. The sphere, for instance, has methods for setting two “u–v”-axes, whereas the cylinder, cone, and torus use a “center axis” and an “AxisA” and “AxisB.” Finally, the ellipsoid uses axes A, B, and C. To keep in mind how these work, think of the default as being that axis A is the z-axis, axis B is the x-axis, and axis C is the y-axis. Axis C is often the axis of symmetry and in this case is called the center axis. The texture coordinates are set so that if the axes have their default values, and if the viewer is looking straight down the z-axis towards the center of the object, then he or she will see the v-component of the texture coordinates varying from bottom to top on the surface in front and the u-coordinates varying from left to right with u = 1 2 in the center of the view. Sometimes the default assignments of texture coordinates are not what you want, and one may then use several special texture maps that let you remap texture coordinates by linear or bilinear transformations. These texture maps do not actually apply any texture but instead can be combined with other texture maps using a TextureSequence object.  A TextureAffineXform allows you to apply an arbitrary afﬁne transformation to texture  coordinates. There are four options for deﬁning a TextureAffineXform:  SetScaling  uFactor, vFactor  ;  SetLinearMatrix  a11, a21, a12, a22  ;  SetAffineMatrix  a11, a21, a12, a22, a13, a23  ;  SetTriangleCoords  Ax, Ay, Bx, By, Cx, Cy ;  The SetScaling function makes the afﬁne map a simple scaling linear transformation that applies different scaling values to u and v coordinates. The SetLinearMatrix function allows you to set an arbitrary linear map by setting the four entries of a 2 × 2 matrix – the operands are given in column order. The SetAffineMatrix function allows you to set an arbitrary afﬁne map by giving the six entries of a 2 × 3 matrix  in column order  that deﬁne an afﬁne map: these six entries are the top two rows of a 3 × 3 matrix that has bottom row  0 0 1  as is usual for matrices acting on homogeneous coordinates.  The function SetTriangleCoords is a convenience function that deﬁnes the afﬁne map that maps the canonical texture coordinates for the vertices of a triangle  namely the points  cid:5 0, 0 cid:6 ,  cid:5 1, 0 cid:6 , and  cid:5 0, 1 cid:6   to the texture coordinates  cid:5 Ax, Ay cid:6 ,  cid:5 Bx, By cid:6 , and  cid:5 Cx, Cy cid:6 . This is convenient for deﬁning a texture map on a triangle or parallelogram by linear interpolation  and linear extrapolation .  A TextureBilinearXform object lets you deﬁne texture coordinates by bilinear in- terpolation from four vertices of a rectangle. A bilinear transformation is deﬁned by setting four texture coordinate values  cid:5 ui , vi cid:6 , with i = 0, 1, 2, 3. The transformation maps the four   352 RayTrace Software Package corners of the unit square,  cid:5 0, 0 cid:6 ,  cid:5 1, 0 cid:6 ,  cid:5 1, 1 cid:6 , and  cid:5 0, 1 cid:6  to the four speciﬁed values  in that order  and computes texture coordinates at other points by bilinear interpolation. To set the four texture coordinate values you may use one of the functions  SetTextureCoordinates  double &txcoords[0]  ;  SetTextureCoordinates  float &txcoords[0]  ;  where txcoords[] is an array of eight ﬂoating point values. Alternatively, you may give the following four commands:  SetTextureCoordA  double u0, double v0  ; SetTextureCoordB  double u1, double v1  ; SetTextureCoordC  double u2, double v2  ; SetTextureCoordD  double u3, double v3  ;   Bibliography  M. A, R. R, A. H,  L. M, Efﬁcient image-based methods for rendering  soft shadows, in Computer Graphics Proceedings, ACM, 2000, pp. 375–384. SIGGRAPH’2000.  E. A, OpenGL: A Primer, Addison–Wesley, Boston, 2002. J. A, Backwards ray tracing, in Developments in Ray Tracing, 1986. SIGGRAPH’86 Course Notes,  J. A  D. K, Particle transport and image synthesis, Computer Graphics, 24  1990 . SIG-  Volume 12.  GRAPH’90.  I. A, Radiosity: A Programmer’s Perspective, John Wiley, New York, 1994. R. H. B, J. C. B,  B. A. B, An Introduction to Splines for Use in Computer Graphics and Geometric Modeling, Morgan Kaufmann, Los Altos, CA, 1987. Forewords by P. B´ezier and A.R. Forrest.  P. B  A. S, The Scattering of Electromagnetic Waves from Rough Surfaces, Mac-  millan, New York and Pergamon Press, Oxford, UK, 1963.  P. B, A general version of Crow’s shadow volumes, IEEE Computer Graphics and Applications,  R. S. B, F. W. B, M. S, Billmeyer and Saltzman’s Principles of Color Technology,  6  1986 , pp. 17–28.  John Wiley, New York, 3rd ed., 2000.  P. E. B´, Mathematical and practical possibilities of UNISURF, in Computer Aided Geometric Design, Proceedings of Conference held at the University of Utah, Salt Lake City, March 1974, R. E. Barnhill and R. F. Riesenfeld, eds., Academic Press, New York, 1974, pp. 127–152. , How Renault uses numerical control for car body design and tooling, in Society of Automotive Engineers’ Congress, 1968. SAE paper 680010.  E. A. B  K. R. S J., Two-part texture mappings, IEEE Computer Graphics and Applications,  6  1986 , pp. 40–53.  J. B, Models of light reﬂection for computer synthesized pictures, Computer Graphics, 11  1973 ,  pp. 192–193. SIGGRAPH’77. , Simulation of wrinkled surfaces, Computer Graphics, 12  1978 . SIGGRAPH’78. Reprinted in  Wolfe, 1998 . , What, teapots again?, IEEE Computer Graphics and Applications, 7  1987 , pp. 61–63. Reprinted in  Blinn, 1998 , pp. 17–20. , Hyperbolic interpolation, IEEE Computer Graphics and Applications, 12  1992 , pp. 89–94. Reprinted in  Blinn, 1996 . , Jim Blinn’s Corner: A Trip Down the Graphics Pipeline, Morgan Kaufmann, San Francisco, 1996. , Jim Blinn’s Corner: Dirty Pixels, Morgan Kaufmann, San Francisco, 1998.  W. B¨, Inserting new knots into B-spline curves, Computer-Aided Design, 12  1980 , pp. 199–  201.  W. B¨  H. P, The insertion algorithm, Computer-Aided Design, 17  1985 , pp. 58–59.  353   354  Bibliography  P. J. B, Physical Aspects of Colour: An Introduction to the Scientiﬁc Study of Colour Stimuli and Colour Sensations, Philips Technical Library, Macmillan, London, 2nd ed., 1971. Edited by W. de Groot, A.A. Kruithof, and J.L. Guweltjes.  L. S. B  N. I. B, Generating soft shadows with a depth buffer algorithm, IEEE Computer  Graphics and Applications, 4  1984 , pp. 5–12.  S. R. B  J. F, Spherical averages and applications to spherical splines and interpolation,  ACM Transactions on Graphics, 20  2001 , pp. 95–126.  S. E. C  L. W, View interpolation for image synthesis, Computer Graphics, 27  1993 ,  pp. 279–288. SIGGRAPH’92.  E. C, T. L,  R. F. R, Discrete B-splines and subdivision techniques in computer- aided geometric design and computer graphics, Computer Graphics and Image Processing, 14  1980 , pp. 87–111.  M. F. C  D. P. G, The hemi-cube: A radiosity solution for complex environments,  Computer Graphics, 19  1985 , pp. 31–40.  M. F. C  J. R. W, Radiosity and Realistic Image Synthesis, Academic Press, Boston, 1993.  R. L. C, T. P,  L. C, Distributed ray tracing, Computer Graphics, 18  1984 ,  R. L. C  K. E. T, A reﬂectance model for computer graphics, ACM Transactions on  M. G. C, The numerical evaluation of B-splines, Journal of the Institute of Mathematics and Its  Includes a chapter by P. Hanrahan.  pp. 137–145. SIGGRAPH’84.  Graphics, 1  1982 , pp. 7–24.  Applications,  1972 , pp. 134–149.  H. S. M. C, Projective Geometry, Springer-Verlag, New York, second ed., 1974. F. C. C, Shadow algorithms for computer graphics, Computer Graphics, 11  1977 , pp. 242–248.  SIGGRAPH’77.  H. B. C  I. J. S, On spline distributions and their limits: The P´olya distribution function,  Abstract 308t, Bulletin of the American Mathematical Society, 53  1947 , p. 1114.  M. D  J. C. D, The numerical problem of using B´ezier curves and surfaces in the power  basis, Computer Aided Geometric Design, 6  1989 , pp. 121–128.  M.  B, M. H. O, M. V. K,  O. S, Computational Geometry: Algo-  rithms and Applications, Springer-Verlag, Berlin, 2nd ed., 2000.  C.  B, On calculating with B-splines, Journal of Approximation Theory, 6  1972 , pp. 50–62. P.  C, Outillages m´ethodes calcul. Technical report, 1959.  , Courbes et surfaces `a poles. Technical report, 1963.  C. E  M. J. K, Practical and robust stenciled shadow volumes for hardware-accelerated  rendering. Manuscript at http:  developer.nvidia.com, 2002.  M. D. F, Color Appearence Models, Addison–Wesley, Reading, MA, 1998. H. S. F, M. H. B,  H. H, How the CIE 1931 color-matching functions were  derived from Wright–Guild data, Color Research and Application, 22  1997 , pp. 11–23.  G. F, Curves and Surfaces for Computer Aided-Geometric Design: A Practical Guide, Academic  Press, San Diego, 4th ed., 1997. Contains chapters by P. B´ezier and W. B¨ohm.  R. T. F, On the stability of transformations between power and Bernstein polynomial forms, Com-  puter Aided Geometric Design, 8  1991 , pp. 29–36.  R. T. F  V. T. R, On the numerical condition of polynomials in Bernstein form, Computer  Aided Geometric Design, 4  1987 , pp. 191–216. , Algorithms for polynomials in Bernstein form, Computer Aided Geometric Design, 5  1988 , pp. 1–26.  R. T. F  T. S, Real rational curves are not “unit speed,” Computer Aided Geometric  J. F, Multivariable curve interpolation, Journal of the Association for Computing Machinery, 11  R. P. F, Lectures on Physics, Volume I, Addison–Wesley, Redwood City, CA, 1989. Chapters 35  Design, 8  1991 , pp. 151–157.   1964 , pp. 221–228.  and 36.   Bibliography  355  J. F, A.  D, S. K. F,  J. F. H, Computer Graphics: Principles and Practice,  Addison–Wesley, Reading, MA., 2nd ed., 1990.  H. F, G. D. A,  E. D. G, Near real-time shaded display of rigid objects, Computer  Graphics, 17  1983 . SIGGRAPH’83.  H. F, Z. K, B. F. N, On visible surface generation by a priori tree structures, Computer  Graphics, 14  1980 , pp. 124–133. SIGGRAPH’80.  E. G. G, D. W. J,  S. S. K, A fast procedure for computing the distance between objects in three-dimensional space, IEEE J. Robotics and Automation, RA-4  1988 , pp. 193– 203.  M. G A. A. M, Computational modelingfor the computer animation of legged ﬁgures,  Computer Graphics, 19  1985 , pp. 263–270. SIGGRAPH’85.  A. G, ed., An Introduction to Ray Tracing, Academic Press, London, 1989.  , Andrew Glassner’s Notebook : Recreational Computer Graphics, Morgan Kaufmann, San Francisco, 1999. , Principles of Digital Image Synthesis, Morgan Kaufmann, San Francisco, 1995. Two volumes.  S. G, M. C. L,  D. M, OBBTree: A hierarchical structure for rapid interference  detection, Computer Graphics, 30  1996 , pp. 171–180. SIGGRAPH ’96.  H. G, Continuous shading of curved surfaces, IEEE Transactions on Computers, 20  1971 ,  pp. 623–629.  B. G¨, Convex Polytopes, Interscience, London, 1967. R. H, Illumination and Color in Computer Generated Imagery, Springer-Verlag, New York, 1989. P. H, D. S,  L. A, A rapid hierachical radiosity algorithm, Computer Graphics,  J. C. H, G. K. F,  L. H. K, Visualizing quaternion rotation, ACM Transactions on  25  1991 , pp. 197–206. SIGGRAPH’91.  Graphics, 13  1994 , pp. 256–276.  X. D. H, K. E. T, F. X. S,  D. P. G, A comprehensive physical model for light  reﬂection, Computer Graphics, 25  1991 , pp. 175–186. SIGGRAPH’91.  P. S. H  H. P. M, Interpolation for polygon texture mapping and shading, in State of the Art in Computer Graphics: Visualization and Modeling, D. F. Rogers and R. A. Earnshaw, eds., Springer-Verlag, New York, 1991, pp. 101–111.  T. H, Real shadows real time, Iris Universe, 18  1991 , pp. 28–31. Silicon Graphics, Inc. N. J. H, Accuracy and Stability of Numerical Algorithms, Society for Industrial and Applied Math-  ematics, Philadelphia, 1996.  F. S. H, Computer Graphics Using OpenGL, Prentice–Hall, Upper Saddle River, NJ, 2001. J. H  D. L, Fundamentals of Computer Aided Geometric Design, AK Peters, Wellesley,  MA., 1993. Translated from German by L. Schumaker.  R. J, L. MD,  K. F, Computer Generated Colour: A Practical Guide to Pre-  sentation and Display, John Wiley, Chichester, UK, 1994.  H. W. J, Realistic Image Synthesis Using Photon Mapping, A.K. Peters, Natick, MA, 2001. H. W. J  N. J. C, Photon maps in bidirectional Monte Carlo ray tracing of complex  objects, Computers and Graphics, 19  1995 , pp. 215–224.  K. I. J  M. N. B, Ray tracing parametric surface patches utilizing numerical tech-  niques and ray coherence, Computer Graphics, 20  1986 , pp. 279–285. SIGGRAPH’86.  J. T. K, Anisotropic reﬂection models, Computer Graphics, 19  1985 , pp. 15–21. SIGGRAPH’85. A. R. K, Singularity-free extraction of a quaternion from a direction-cosine matrix, Journal of  Spacecraft and Rockets, 13  1976 , pp. 754–755.  D. H. U. K  R. H. B, Interpolating splines with local tension, continuity and bias  control, Computer Graphics, 18  1984 , pp. 33–41. SIGGRAPH’84.  E. P. L Y. D. W, Bi-directional path tracing, in Proc. 3rd International Confernence on Computational Graphics and Visualization Techniques  Compugraphics ’93 , ACM, 1993, pp. 145– 153.  E. L, Rational B´ezier representation for conics, in Geometric Modeling: Algorithms and New Trends,  G. E. Farin, ed., Philadelphia, 1987, SIAM, pp. 3–19.   356  Bibliography  M. L, Collision Detection for Animation and Robotics, Ph.D. thesis, U.C. Berkeley, 1993. M. C. L J. F. C, Efﬁcient algorithms for incremental distance computation, in IEEE Conference  on Robotics and Automation, 1991, pp. 1008–1014.  M. D. MC, Shadow volume reconstruction from depth maps, ACM Transactions on Graphics, 19  T. M¨  E. H, Real-Time Rendering, AK Peters, Natick, MA, 1999. T. M¨  B. T, Fast, minimum storage ray–triangle intersection, Journal of Graphics Tools,  W. M. N  R. F. S, Principles of Interactive Computer Graphics, McGraw–Hill, New   2000 , pp. 1–26.  2  1997 , pp. 21–28.  York, second ed., 1979.  T. N, T. W. S,  M. K, Ray tracing trimmed rational surface patches, Computer  Graphics, 24  1990 , pp. 337–345. SIGGRAPH’90.  M. O S. K. N, Generalization of Lambert’s reﬂectance model, Computer Graphics, 28  1994 ,  pp. 239–246. SIGGRAPH’94. , Generalization of the Lambertian model and implications for machine vision, International Journal of Computer Vision, 14  1995 , pp. 227–251.  A. O, Analytic deﬁnition of curves and surfaces by parabolic blending, tech. rep., Ford Motor  B. T. P, Illumination for computer generated pictures, Communications of the ACM, 18  1975 ,  L. P  W. T, A menagerie of rational B-spline circles, IEEE Computer Graphics and Appli-  Company, 1968.  pp. 311–317.  cations, 9  1989 , pp. 48–56.  L. P  W. T, The NURBS Book, Springer-Verlag, Berlin, 2nd ed., 1997. H. P, A short proof of the Oslo algorithm, Computer Aided Geometric Design, 1  1984 , pp. 95–  96.  2001.  W. H. P, B. P. F, S. A. T,  W. T. V, Numerical Recipes: The Art of  Scientiﬁc Computing, Cambridge University Press, Cambridge, 1986.  W. T. R, D. H. S,  R. L. C, Rendering antialiased shadows with depth maps, Computer  Graphics, 21  1987 , pp. 283–291. SIGGRAPH’87.  D. F. R, An Introduction to NURBS: With Historical Perspective, Morgan Kaufmann, San Francisco,  H. S, Applications of Spatial Data Structures: Computer Graphics, Image Processing and GIS,  Addison–Wesley, Reading, MA, 1990. , The Design and Analysis of Spatial Data Structures, Addison–Wesley, Reading, MA, 1990.  C. S, An inexpensive BRDF model for physically-based rendering, Computer Graphics Forum, 13   1994 , pp. 233–246. Proceedings, Eurographics’94.  D. S, ed., OpenGL Reference Manual: The Ofﬁcial Reference Document to OpenGL, Version 1.2, OpenGL Architecture Review Board, Addison–Wesley Developers Press, Reading, MA, third ed., 1999.  P. S¨,  D. Z,  ., Subdivision for Modeling and Animation, SIGGRAPH’98 Course  Notes 36, ACM, 1998.  L. L. S, Spline Functions: Basic Theory, Wiley, New York, 1981. H.-P. S, Knot insertion from a blossoming point of view, Computer Aided Geometric Design, 5   1988 , pp. 81–86. , A new multiafﬁne approach to B-splines, Computer Aided Geometric Design, 6  1989 , pp. 23– 32.  S. W. S, Quaternion from rotation matrix, Journal of Guidance and Control, 1  1978 , pp. 223–  224.  P. S, Realistic Ray Tracing, AK Peters, Natick, MA, 2000. K. S, Animating rotation with quaternion curves, Computer Graphics, 19  1985 , pp. 245–254.  SIGGRAPH’85. , Quaternion calculus and fast animation, in SIGGRAPH’87 Course Notes on State of the Art Image Synthesis, ACM, 1987, pp. 101–121.   Bibliography  357  I. J. S, Contributions to the problem of approximation of equidistant data by analytic functions, Part A – On the problem of smoothing or gradation, a ﬁrst class of analytic approximation formulae, Quarterly of Applied Mathematics, 4  1946 , pp. 45–99. , On spline functions, in Inequalities, Proceedings of a Symposium held at Wright–Paterson Air Force Base, August 19–27, 1965, O. Shisha, ed., New York, 1967, Academic Press.  F. X. S  C. P, Radiosity and Global Illumination, Morgan Kaufmann, San Francisco, 1994. R. A. S, Comment on “Singularity-free extraction of a quaternion from a direction-cosine matrix,”  Journal of Spacecraft and Rockets, 15  1978 , pp. 255–256.  F. T  O. J, Disney Animation: The Illusion of Life, Abbeville Press, New York, 1981. D. L. T, On ray tracing parametric surfaces, Computer Graphics, 19  1985 , pp. 171–179. SIG-  GRAPH’85.  Y. S. T  D. P. W, Thermal Radiative Properties: Metallic Elements and Alloys, Thermo-  physical Properties of Matter, Vol. 7, IFI Plenum, New York, 1970. , Thermal Radiative Properties: Nonmetallic Solids, Thermophysical Properties of Matter, Vol. 8, IFI Plenum, New York, 1972.  Y. S. T, D. P. W, R. S. H, Thermal Radiative Properties: Coatings, Thermophysical  Properties of Matter, Vol. 9, IFI Plenum, New York, 1972.  T. S. T K. P. R, Average irregularity representation of a rough surface for ray reﬂection,  Journal of the Optical Society of America, 65  1975 , pp. 531–536.  E. V  L. G, Bidirectional estimators for light transport, in Proceedings, Fifth Eurographics  Workshop on Rendering, New York, 1994, Springer-Verlag, pp. 147–162.  J. W H. W, Subdivision Methods for Geometric Design: A Constructive Approach, Morgan  Kaufmann, San Francisco, 2002.  A. W, 3D Computer Graphics, Addison–Wesley, Reading, MA, 2nd ed., 1993. A. W  M. W, Advanced Animation and Rendering Techniques: Theory and Practice, Addison–  Wesley, Reading, MA, 1992.  T. W, The Animator’s Workbook, Phaidon Press, Oxford, UK, 1986. T. W, An improved illumination model for shaded display, Communications of the ACM, 23  1980 . L. W, Casting curved shadows on curved surfaces, Computer Graphics, 12  1978 , pp. 270–274.  SIGGRAPH’78. , Pyramidal parametrics, Computer Graphics, 17  1983 , pp. 1–11. SIGGRAPH’83.  R. W, ed., signiﬁcant Seminal Papers of Computer Graphics: Pioneering Efforts that Shaped the  Field, Association for Computing Machinery, New York, 1998.  L. B. W  D. J. K, Ray tracing with polarization parameters, IEEE Computer Graphics  and Applications, 10  1990 , pp. 44–55.  M. W, J. N, T. D,  D. S, OpenGL Programming Guide: The Ofﬁcial Guide to Learning OpenGL, Version 1.2, OpenGL Architecture Review Board, Addison–Wesley Developers Press, Reading, MA, third ed., 1999.  R. S. W J., OpenGL SuperBible, Waite Group, Indianapolis, 2nd ed., 1999. G. W  W. S. S, Color Science: Concepts and Methods, Quantitative Data and Formulae,  John Wiley & Sons, New York, 2nd ed., 1982.  J. Z  N. I. B, Inverse kinematics positioning using nonlinear programming for highly artic-  ulated ﬁgures, ACM Transactions on Graphics, 13  1994 , pp. 313–336.  G. M. Z, Lectures on Polytopes, Springer-Verlag, New York, 1995.    Index  AABB, see bounding box, axis-aligned Abram, G., 271 abutting polygons, 64 accumulation buffer, 253 additive colors, 149 AddPatch, 348, 349 AddRationalPatch, 348 adjoint, 82, 328 afﬁne, 218 afﬁne combination, 101, 103  preserved under, 102  afﬁne transformation, 17, 20, 35, 36, 46, 81  matrix, 27, 35, 36 orientation-preserving, 23, 35 preserved under, 101, 168  Agrawala, M., 256 aliasing, 2, 64, 127, 132 alpha channel, 84, 253, 256 ambient light, 69, 74, 75, 84, 85, 337 ambient reﬂection, 74 ambient reﬂectivity coefﬁcient, 70, 74, 85,  339, 350 Angel, E., xii angle brackets, 21 angle of incidence, 69, 71, 72, 239 angle of reﬂection, 69, 72 angle of refraction, 239 animation, 15, 17, 23, 64, 77, 99, 289 anisotropic surface, 88 anti-aliasing, 8, 132–135, 234, 244, 253 antipodal, 33, 44, 122 apex, 345 arclength, 186, 190 arctangent, 24 articulated object, 291, 307 Arvo, D., 251 Arvo, J., 252  Ashdown, I., 288 aspect ratio, 57 associative law, 300 atan2, 24 attachment point, 308 attenuation, see distance attenuation Aupperle, L., 288 automorphism, inner, 302 averaging, see interpolation axis-aligned bounding box, see bounding box,  axis-aligned  axis conventions, 4 azimuth, 131, see also yaw, pitch and roll  back buffer, 15 back face, 13, 83 back intersection, 264 background color, 242 backwards ray tracing, 234, 250–252 Badler, N., 255, 311, 317 ball, 117 Barsky, B., 155 Bartels, R., 155, 193 barycentric coordinates, 102–107, 262  calculating, 105 base position, 308 basic ray tracing, see recursive ray tracing basis function, 200, see blending function basis spline, 200, see also B-spline curve Beatty, J., 155 Beckmann distribution, 91 Beckmann, P., 91 Bergeron, P., 255 Berns, R., 146, 154 Bernstein polynomial, 157, 166, 209, 226 Bessel spline, see Overhauser spline Bessel tangent, 192  359   360  Index  Bessel twist method, 197 B´ezier curve, 101, 155–199, 307  as B-spline, 208, 228 degree three, 156, 157 derivative, 158, 166 general degree, 165–172 in OpenGL, 178–179 piecewise, 163–164, 168 quadratic, 182–187 rational, 26, 46, 102, 121, 178, 180–187, 228 subdivision, see recursive subdivision  B´ezier patch, 173–177, 257, 268  in OpenGL, 179–180 rational, 187–188, 348 viewable, 347  B´ezier, P., 155 Bhetanabhotla, M., 268 bias, 194 bicubic patch, 197 bidirectional path tracing, 252 bidirectional reﬂectivity, 87–89 Bier, E., 128 bilinear interpolation, 107–116, 127, 133, 137,  342, 351  inverting, 113–116  BilinearInvert, 115, 116 Billmeyer, F., 146, 154 binary space partitioning  BSP  tree, 258, 271 binomial theorem, 157, 166, 170 bitmap ﬁle, 350 black, 10, 149 blending, 65, 84, 150, 253, 256 blending function, 157, 201–203, 307 Blinn, J., xv, xvi, 87, 90, 93, 121, 135, 180 blossom, 217–221 B¨ohm method, 223–225 B¨ohm, W., 223 Bouma, P., 154 bounding box, 268, 269  axis-aligned  AABB , 269 discrete oriented polygon  k-DOP ,  269, 270  oriented  OBB , 269, 271  bounding sphere, 259, 268, 269 bounding volume, 268, 269, 271 box, 264 BRDF, 88 Bresenham algorithm, 61–64, 122 BRIDF, see bidirectional reﬂectivity brightness, 151, 275 Brill, M., 154 Brotman, L., 255 browser-safe colors, 151  browsers, 151 Brunelleschi, F., 34 BSP tree, see binary space partitioning tree B-spline curve, 101, 187, 200–232, 307  as B´ezier curve, 226–227 derivative, 221 in OpenGL, 229 interpolating, 229–232 knot insertion, 218, 223 nonuniform knots, 204–214 rational, 26, 46, 102, 121, 228–229 repeated knots, 213 smoothness, 212, 213, 221–223 uniform knots, 201–204, 206  buffer, 15 bump mapping, 135–137 BumpMapFunction, 350 Buss, S., 307  ∞  -continuous, 164  C C 1-continuity, 164, 168, 174, 175, 190, 194, 210 C 2-continuity, 203, 210 CalcAllDirectIllum, 334 CalcPixelDirection, 338 CalcPixelPosition, 339 CalcRefractDir, 334 CalcTransmissionDirection, 241 calculus, 329 CalcViewPosition, 338 camera, 245, 291, 295 camera position, see viewpoint CameraView, 335, 337 Canny, J., 271 Carpenter, L., 244 Casteljau method, 159–160, 168–169, 175, 214,  227, 268, 307  Casteljau, P. de, 155, 168, 221 Catmull–Rom spline, 189–190, 193, 195, 232,  290  caustics, 251 cell, 270 centripetal parameterization, 191 Chen, S.E., 256 choice function, 157 chord-length parameterization, 189–192, 232 Christiansen, N., 251 chroma, 151 chromaticity, 151 CIE, 154 CIELAB, 154 CIELUV, 154 circle, 121, 182–185, 187–188, 229 C k-continuity, 164   Index  CLAMP_TO_EDGE, 140 ClampUV, 350 clipping plane, 48 clockwise, 13 clone, 255 CLUT, see color lookup table CMY, 150  to from RGB, 150  CMYK, 150 codomain, 320 cofactor, 82, 328 Cohen, E., 223 Cohen, M., 275, 280, 288 collinear, 323 color, 1, 2, 10, 58–60, 63, 146–154, 250  additive and subtractive, 149  color lookup table, 151 color perception, 146–148 colorfulness, 151 column span  colspan , 314, 329 column vector, 21, 23, 34, 326 commutative law, 300 complex numbers, 299 composition, 20, 303 ComputeG, 95 computer-aided design, 155 cone, 344  general, 255  conic section, 102, 121, 181–188, 226, 228–229 conjugate, 300 ConnectDots, 16, 193 constant attenuation factor, 86 continuity, see C 1-, C 2-, and C k-continuity continuity  TCB , 194 control point, 101, 156, 180, 201, 204, 228, 230 control polygon, 167, 168, 171, 223 convex, 264 convex hull, 117, 162 convex hull property, 162, 166, 168, 185,  223, 268  convex polytope, see polytope convex quadrilateral, 109, 110 convex set, 9, 10, 117–119 Cook, R., 87, 90, 93, 97, 244, 256 Cook–Torrance lighting, 67, 87–98, 233, 235, 332 coordinate system, 4 counterclockwise, 13 Cox–de Boor formula, 200, 206–209, 214 Coxeter, H., 34 cracking, 66, 176, 177 cross product, 5, 42, 300, 321, 322, 325 Crow, F., 255 cube, 128, 264  361  cubic curve, 168 culling back faces, 13, 83, 342 Curry, H., 200 cutoff angle, 86 cyan, 10, 149, 150 cylinder, 129, 266, 343  Daniel, M., 159 data glove, 291 data types, 6 Daubisse, J., 159 de Berg, M., 271 de Boor algorithm, 214–217, 219, 227, 307 de Boor, C., 200 de Casteljau, see Casteljau degree elevation, 171–172, 184, 227 degree of freedom, 308 denominator equals zero, 206 depth, 12, 49, 52, 58 depth buffer, 12, 50, 52, 54, 60, 62, 63, 233, 254,  see also pseudo-distance  depth cueing, 256 depth of ﬁeld, 5, 234, 245, 247, 253, 254 derivative, 331 determinant, 22, 35, 327 diagonal property, 218 diameter, 279 different curves, 168 diffuse light, 69, 71, 85 diffuse reﬂection, 69, 71–72 diffuse reﬂectivity coefﬁcient, 71, 85, 242, 339,  350  diffuse transmission, 241 diffuse transmission coefﬁcient, 242 diode, 290 DirectIlluminateViewPos, 334 directional light, 74, 83, 84, 336 discrete oriented polygon, see bounding box display list, 3 distance, see depth and pseudo-distance distance attenuation, 75, 82, 85–87, 337 distributed ray tracing, 234, 244–251 distributive law, 300 dot product, 81, 307, 321, 324  preserved, 24, 35  double buffering, 15–16 Draw, 339 drawThreePoints, 28–31 dynamics, 292  ease in, 293  ﬁxed target, 293–294 moving target, 294–295   362  ease out, ﬁxed target, 294 ellipse, 121 ellipsoid, 342 emissive intensity, 74, 85, 339 emissiveness, 275 emissivity, 70, 74 empty set, 218 end effector, 308 end effector point, 308 end link, 308 environment map, 137–139, 254  in OpenGL, 143–145  equivalent, 147 Euclidean space, 320 Euler angles, 296 Euler’s theorem, 36, 44–45, 298 Everitt, C., 256 extended light, 248 extinction coefﬁcient, 97 extrapolation, 100, 101 eye, 146 eye position, see viewpoint  face culling, 13 Fairchild, M., 154 Fairman, H., 154 fake distance, see pseudo-distance far clipping plane, 48, 51, 52, 55, 56 Farin, G., 155, 168, 199, 220, 224, 227 Farouki, R., 159, 186, 187 Ferguson patches, 197 Ferguson, J., 197 Ferris wheel, 17 Feuerbach, K., 34 Feynman, R., 146 ﬁeld of view, see viewport Fillmore, J., 307 FindIntersection, 333 ﬁxed point, 25, 285 ﬁxed-point problem, 284 ﬁxed target, see ease in, ﬁxed target ﬂat shading, 2, 12, 68 ﬂats, 197 ﬂexible objects, 291 ﬂocking, 291 focal plane, 246 focusing, 251 fog, 252, 256 Foley, J., xv, 146, 151 form factor, 273, 276–282 forward dynamics, 292 forward kinematics, 292 forward ray tracing, 251  Index  FourTextures, 139, 143 frame, 15 frame rate, 15 Francis, G., 299 Freeman, K., 146, 154 Fresnel equation, 87, 90, 96–98 front buffer, 15 front face, 9, 13, 83 front intersection, 264 frustum, 55, 56 Fuchs, H., 271 full-rank factorization, 316 function, 320  G1-continuity, 164, 168, 174, 175 gathering method, 286 Gauss-Seidel, 286 Gauss–Seidel iteration, 286–287 Gaussian elimination, 316 generalized rotation, 23, 25, 44 geodesic, 122 geometric continuity, see G1-continuity geometric occlusion, 91–96 GetPixel, 339 Geuzaine, C., xvi GIF, 151 Gilbert, E., 271 gimbal lock, 298 Girard, M., 311, 317 GL_ACCUM, 253, 254 GL_ACCUM_BUFFER_BIT, 253, 254 GL_ADD, 253 GL_AMBIENT, 85 GL_AMBIENT_AND_DIFFUSE, 85 GL_AUTO_NORMAL, 180 GL_BACK, 13, 14, 85 GL_BLEND, 6, 8, 253 GL_CCW, 13 GL_CLAMP, 140 GL_CLAMP_TO_EDGE, 140 GL_COLOR_BUFFER_BIT, 12, 13, 254 GL_COLOR_MATERIAL, 85 GL_CONSTANT_ATTENUATION, 86 GL_CULL_FACE, 13 GL_CW, 13 GL_DECAL, 142 GL_DEPTH_BUFFER_BIT, 13, 254 GL_DEPTH_TEST, 12 GL_DIFFUSE, 85 GL_EMISSION, 85 GL_FILL, 14, 180 GL_FLAT, 11, 83 GL_FRONT, 13, 14, 85   Index  363  GL_FRONT_AND_BACK, 13, 14, 85 GL_LIGHTi, 83–86 GL_LIGHT_MODEL_AMBIENT, 84 GL_LIGHT_MODEL_COLOR_CONTROL, 142 GL_LIGHT_MODEL_LOCAL_VIEWER, 83 GL_LIGHT_MODEL_TWO_SIDE, 83 GL_LIGHTING, 83, 142 GL_LINE, 14, 179, 180 GL_LINE_LOOP, 7 GL_LINE_SMOOTH, 8, 253 GL_LINE_SMOOTH_HINT, 8, 253 GL_LINE_STRIP, 7, 179 GL_LINEAR, 141 GL_LINEAR_ATTENUATION, 86 GL_LINEAR_MIPMAP_LINEAR, 141 GL_LINEAR_MIPMAP_NEAREST, 141 GL_LINES, 7 GL_LOAD, 253 GL_MAP1_COLOR_4, 178 GL_MAP1_VERTEX_3, 178 GL_MAP1_VERTEX_4, 178 GL_MAP2_COLOR_4, 180 GL_MAP2_TEXTURE_COORD_2, 180 GL_MAP2_VERTEX_3, 179 GL_MAP2_VERTEX_4, 180 GL_MODELVIEW, 29, 30, 37, 39 GL_MODULATE, 142 GL_MULT, 253 GL_NEAREST, 141 GL_NEAREST_MIPMAP_LINEAR, 141 GL_NEAREST_MIPMAP_NEAREST, 141 GL_NICEST, 6, 8, 127, 253 GL_NORMALIZE, 87, 180 GL_ONE_MINUS_SRC_ALPHA, 6, 8, 253 GL_PERSPECTIVE_CORRECTION_HINT, 127 GL_POINT, 14, 179, 180 GL_POINT_SMOOTH, 6, 253 GL_POINT_SMOOTH_HINT, 6, 253 GL_POINTS, 6, 28, 179 GL_POLYGON, 10 GL_POLYGON_OFFSET_FILL, 54 GL_POLYGON_OFFSET_LINE, 54 GL_POLYGON_OFFSET_POINT, 54 GL_POLYGON_SMOOTH, 253 GL_POLYGON_SMOOTH_HINT, 253 GL_POSITION, 84 GL_PROJECTION, 57 GL_PROXY_TEXTURE_2D, 140 GL_QUAD_STRIP, 9, 10 GL_QUADRATIC_ATTENUATION, 86 GL_QUADS, 9, 10 GL_REPEAT, 140 GL_REPLACE, 142  GL_RESCALE_NORMAL, 87 GL_RETURN, 253, 254 GL_RGB, 139, 140 GL_RGBA, 139, 140 GL_S, 144 GL_SEPARATE_SPECULAR_COLOR, 142 GL_SHININESS, 85 GL_SINGLE_COLOR, 142 GL_SMOOTH, 11, 83 GL_SPECULAR, 85 GL_SPHERE_MAP, 144 GL_SPOT_CUTOFF, 86 GL_SPOT_DIRECTION, 86 GL_SPOT_EXPONENT, 86 GL_SRC_ALPHA, 6, 8, 253 GL_T, 144 GL_TEXTURE, 145 GL_TEXTURE_1D, 143 GL_TEXTURE_2D, 139–141, 143 GL_TEXTURE_3D, 143 GL_TEXTURE_ENV, 142 GL_TEXTURE_ENV_MODE, 142 GL_TEXTURE_GEN_MODE, 144 GL_TEXTURE_GEN_S, 144 GL_TEXTURE_GEN_T, 144 GL_TEXTURE_MAG_FILTER, 141 GL_TEXTURE_MIN_FILTER, 141 GL_TEXTURE_WRAP_S, 140 GL_TEXTURE_WRAP_T, 140 GL_TRIANGLE_FAN, 9 GL_TRIANGLE_STRIP, 9 GL_TRIANGLES, 8 GL_UNPACK_ALIGNMENT, 139 glAccum, 253, 254 glAccumClear, 253, 254 Glassner, A., xv, 146, 154, 252 glBegin, 6–11, 28, 83, 179 glBindTexture, 143 glBlend, 255 glBlendFunc, 6, 8, 253, 256 glClear, 12, 13, 253, 254 glClearColor, 12 glColor*, 10, 11, 40, 82, 85, 86 glColor3f, 10, 39 glColorMaterial, 86 glCullFace, 13, 83 glDeleteTextures, 143 glDisable, see the GL options that can be  disabled GLdouble, 6 glEnable, see the GL options that can be  enabled  glEnd, 6–9, 11, 28, 83, 179   364  Index  glEvalCoord1f, 178, 179 glEvalCoord2f, 180 glEvalMesh1, 179 glEvalMesh2, 180 glEvalPoint1, 179 glEvalPoint2, 180 GLfloat, 6 glFlush, 15 glFog, 256 glFrontFace, 13 glFrustum, 55–57, 83 glGenTextures, 143 glHint, 6, 8, 127 glide rotation, 44 GLint, 6 glLightf, 86 glLightfv, 84–86 glLightModelfv, 84 glLightModeli, 83, 142 glLineWidth, 8 glLoadIdentity, 29, 30, 37, 39 glLoadMatrix, 23, 38 glMap1f, 178, 179 glMap2f, 179, 180 glMapGrid1f, 179 glMapGrid2f, 180 glMaterial*, 84, 85 glMaterialf, 85 glMaterialfv, 85 glMatrixMode, 29, 30, 37, 39, 145 glMultMatrix, 23 glMultMatrixf, 38 glNormal*, 179 glNormal3f, 84, 87, 141 global lighting, 68 global reﬂectivity coefﬁcient, 237, 334, 339 glOrtho, 55, 83 glPixelStorei, 139, 140 glPointSize, 6 glPolygonMode, 14 glPolygonOffset, 54 glPopMatrix, 30, 39 glPushMatrix, 30, 39 glRotatef, 29–31, 37, 39, 40 glScalef, 38 glShadeModel, 11, 83 GLshort, 6 glTexCoord*, 143, 179 glTexCoord2f, 141 glTexEnvi, 142 glTexGeni, 144 glTexImage*, 143 glTexImage2D, 139, 140  glTexParameter*, 143 glTexParameteri, 140,141 glTranslatef, 29–31, 37, 39, 40 glu OpenGL utility routines, 229 gluBeginSurface, 229 gluBuild2DMipmaps, 140, 143 gluDeleteNurbsRenderer, 229 gluEndSurface, 229 GLuint, 143 gluLookAt, 54, 58, 83, 295 gluNewNurbsRenderer, 229 gluNurbsProperty, 229 gluNurbsSurface, 229 gluOrtho2D, 55 gluPerspective, 55–57, 83 GLUT_ACCUM, 253, 254 GLUT_DEPTH, 12, 15 GLUT_DOUBLE, 15 GLUT_RGB, 12, 15 glutDisplayFunc, 15 glutIdleFunc, 15 glutInitDisplayMode, 12, 15, 253,  254  glutPostRedisplay, 15 glutReshapeFunc, 57 glutSwapBuffers, 15 glutWireSphere, 39, 40 gluUnProject, 256 glVertex*, 5, 8, 36, 84, 86, 141, 179 glVertex2f, 6, 7, 28, 36 glVertex2fv, 6 glVertex3f, 5–9, 46 glVertex3fv, 5 glVertex4f, 46 glViewport, 57 goniometer, 88 Gottschalk, S., 271 Gouraud shading, 2, 60, 62, 67, 68, 74, 77, 82, 83,  104, 153, 277 Gouraud, H., 60, 67 gradient, 80, 268, 330 Grant, E., 271 great circle, 33, 122 Greenberg, D., 87, 280 Guibas, L., 252 Gr¨unbaum, B., 118  Haines, E., xv, 257, 263, 271 half-space, 118 halfway vector, 73, 74, 83, 91 Hall, R., 146, 149, 154 Hamilton, W.R., 299 Hanrahan, P., 288   Index  365  Hart, J., 299 He, X., 87 heading, 131, see also yaw,pitch and roll Heckbert, P., 121, 122 Heidmann, T., 255 Heirich, A., 256 helix, 186 Helmholtz, H., 146 hemicube, 280 hemicube method, 280–282 Hemmendinger, H., 154 Hering, E., 147 Hermite polynomial, 164–165, 293, 294 Hernicz, R., 97 hidden surface, 12–14, 18, 47, 50, 52, 233, 234 high color, 150 Higman, N., 114 Hill, F., xvi homogeneous coordinates, 26, 35, 180, 181, 228  afﬁne combinations, 102, 119–121  homogeneous matrix, 27, 36, 82 Horner’s method, 159 Hoschek, J., 199 HSL, 151–153  from RGB, 152  hue, 151 hyperbola, 121 hyperbolic interpolation, 77, 121–122, 127,  128  identity matrix, 37, 326 identity transformation, 20 IK, see inverse kinematics illumination maps, 251 implicitly deﬁned surface, 80, 330 importance sampling, 252 inbetweener, 290 index of refraction, 96, 237, 240, 340 indexed color, see color lookup table inherent velocity, 294 Init, 342 inker, 290 inner automorphism, 302 inner product, see dot product intensity, 151 interpolating points, 100, 157, 189–199, 229–232,  290, 292, see also Catmull–Rom spline, Bessel twist method, Ferguson patches, Overhauser spline, and tension-continuity-bias spline  with surface, 195, 199  interpolation  averaging , 75, 99–125, 290, see  also bilinear interpolation, Gouraud shading,  hyperbolic interpolation, linear interpolation, Phong shading, quaternion, scan line interpolation, and spherical linear interpolation  intersection testing, 162, 243, 257–271  line-plane, 261 ray-B´ezier curve, 162 ray-B´ezier patch, 268 ray-cylinder, 266–267 ray-ellipsoid, 260 ray-plane, 260–261 ray-polytope, 261, 264–266 ray-quadric, 267–268 ray-sphere, 258–260 ray-triangle, 261–263  intrinsically curved, 130, 131 inverse, 20, see also matrix inverse inverse dynamics, 292 inverse kinematics, 289, 292, 311–318  Jackson, R., 146, 154 Jacobi iteration, 282, 285–286 Jacobian, 312, 313, 331 JacobiIteration., 285 jaggies, 2, 4, 64, 244, 245, 253 Jensen, H., 251, 252 jittering, 134, 135, 248, 280, 339 jittering eye position, see viewpoint jittering Johnson, D., 271 Johnston, O., 290 joint, 308 Joy, K., 268  Kakimoto, M., 268 k-DOP, see bounding box Kauffman, L., 299 Kedem, Z., 271 Keerthi, S., 271 kernel, 314, 329 keyframe, 290 keyframing, 290, 292 Kilgard, M., 256 kinematics, 292, 307–318 Kirk, D., 252 Klein, F., 34 Klumpp, A., 304 knot, 155, 204 knot elimination, 228 knot insertion, 227 knot multiplicity, 213 knot reﬁnement, 223, 227 knot vector, 204, 224 standard, 210, 214   366  Kochanek, D., 193 Krevald, M., 271 Kurlander, D., 89  Lafortune, E., 252 Lambertian surface, 71, 72 Lasser, D., 199 least-squares minimization, 315, 318 Lee, E., 183 Lempel, A., 151 lerp, see linear interpolation lerp, 101 level of detail, 133 level set, 80, 330 level surface, see implicitly deﬁned surface Light, 336 Lin, M., 271 line, 7 line at inﬁnity, 32, 33, 35, 46 line loop, 7 line strip, 7 line–plane intersection, 261 linear attenuation factor, 86 linear combination, 101 linear interpolation, 59, 60, 62, 127, 159, 306  inversion, 100 three points, 102–107 two points, 99–101  linear subspace, 45, 328–329 linear transformation, 17, 19, 24, 35  matrix, 21, 35  linearly independent, 328 link, 291, 308 local control, 202, 203, 212, 232 local lighting, 67, 68, 87, 238 local viewer, 74, 83, 144, 338 LOD, see level of detail luminance, 151 LUT, see color lookup table Lyche, T., 223 LZW compression, 151  MacDonald, L., 146, 154 Mach banding, 277 Maciejewski, A., 311, 317 magenta, 10, 149, 150 magnitude, 300, 320, 324, 325 major radius, 80, 131, 347 Manﬁeld, L., 200 Manocha, D., 271 mapping, 320 masking, 92 Material, 339, 340  Index  material properties, 70, 75  in OpenGL, 82–87 in RayTrace, 335  matrix, 325 matrix inverse, 22, 282, 326, 327 matrix, orthonormal, 24 matrix product, 325 matrix representation  cross product, 42 orthographic projection, 48 quaternion, 303–306 reﬂection, 44 rotation, 24, 37, 41 scaling, 38 shadow projection, 53 translation, 37  matrix representation of a transformation, 21, 23,  27, 35, 36  matrix transpose, 21, 23, 326 McCool, D., 256 Mercator map, 130 metal, 87 metamerism, 147, 148 Meyer, G., 149 microfacet, 87, 89–91 millions of colors, 59, 150 minor radius, 80, 131, 347 mipmapping, 127, 132–134, 244 mirror, 72, 137, 233, 255 mirror image, 38 M¨obius, A., 34 model view matrix, 18, 28, 36, 58 Moll, L., 256 M¨oller, T., xv, 257, 263, 271 Monte-Carlo, 252 moon, 40, 72 Moore–Penrose inverse, see pseudo-inverse Moreton, H., 121, 122 mosaic, 1 motion blur, 6, 234, 247, 248, 253 motion capture, 290 move-to, 3 movie, 233 moving target, see ease-in, moving target multiafﬁne, 218 multibody, see articulated object multiplication, quaternion, 300 multiplicative identity, 301 multiplicative inverse, 301 multiplicity, 213 multitexturing, 145 multivariable, 329 multum in parvo, 133   Index  367  Nayar, S., 95 Naylor, B., 271 near clipping plane, 48, 51, 52, 55, 56 Newman, W., 34 Newton’s method, 117, 268 Nishita, T., 268 noise, 135 nonlocal viewer, 74, 144 nonuniform B-spline, see B-spline norm, 300, 320, 324, 325 normal vector, 78, 81–83, 87, 112, 268, 324, 330  interpolation, 78, see also Phong shading  normalization, 87, 324 NURBS, see B´ezier curve, rational and B-spline  curve, rational in OpenGL, 229  OBB, see bounding box, oriented octtree, 258, 270 one-to-one, 320 onto, 320 opponent color theory, 146, 147 order, 180, 205, 211, 348 Oren, M., 95 orientation, 295–307 orientation-preserving, 23, 35, 36, 44, 295, 298 oriented bounding box, see bounding box,  oriented origin, 19, 34 orthogonal, 321, 328 orthogonal complement, 314, 328, 329 orthographic projection, 47–48, 54, 338 orthonormal, 24 oscilloscope, 3 Oslo method, 223 Overhauser, A., 191 Overhauser spline, 189–193, 195, 232, 290,  see also Bessel twist method  Overmars, M., 271 oversampling, see jittering and supersampling overshoot, 193, 194  painter’s algorithm, 12, 256 Palmer, G., 146 palmtop, 2 parabola, 121 parallel, 323 parallelepiped, 268, 346 parallelogram, 342 parametric curve, 156, 157, 186, 331 parametric surface, 78, 129, 131, 135, 173 partial derivative, 329 participating media, 252  particle systems, 291 partition of unity, 203 patch, 273 path tracing, 250 pen down, 3 pen plotter, 3 pen up, 3 penumbra, 248 percentage closer ﬁltering, 256 permutation, 249 perpendicular, 321 perspective division, 18, 47, 122 perspective transformation, 17, 46, 47, 49–58, 74  preserved under, 121, 181  pglRotatef, 29–31 pglTranslatef, 29–31 Phong interpolation, see Phong shading Phong lighting, 67–75, 89, 126, 135, 137, 141,  144, 148, 233, 235, 238, 241, 332, 334  in OpenGL, 82–87  Phong shading, 67, 77, 137 Phong, B., 67 photon maps, 251 piecewise B´ezier curve, see B´ezier curve Piegl, L., 182, 224, 227 pinhole camera, 245 pitch, 131, see also yaw, pitch and roll pixel, 1, 2, 132 pixel shader, 137 PixelArray, 339 plane, 4, 43, 44, 260 plane at inﬁnity, 35, 46 point, 19, 21, 34 point at inﬁnity, 26, 32, 33, 35, 45, 46, 84, 181,  182  pointillism, 1 points, 23 polar form, see blossom polygon offset, 54 polygonal modeling, 3 polyhedron, see polytope polynomial curve, 168 polytope, 264 Porter, T., 244 positional light, 74, 83, 84, 336 postscript, 3, 171 Prautsch, H., 223 Precompute_for_Slerp, 124, 307 Press, W., 317 primary color, 2, 10, 146–150 prism, 264 projected convexity condition, 109, 110, 116 projection, 322, 324   368  projection matrix, 18, 37, 55, 56, 58, 84 projective geometry, 32–34, 45–46, 53 projective line, 33, 34, 46 projective plane, 32, 46 projective point, 33, 34, 45, 46 projective space, 46 pseudo-distance, 18, 50, 52, 58 pseudo-inverse, 314–317 Puech, C., 275, 288 pyramid, 264  quadratic attenuation factor, 86 quadratic curve, 168, 182–187 quadratic formula, 113, 115 quadric, 267 quadrilateral, 9 quadrilateral strip, 10 quadtree, 270 quasi-Newton method, 268, 317 quaternion, 43, 122, 292, 295, 298–307  conjugate, 300 equality, 299 from matrix, 304–306 interpolation, 306–307 matrix form, 303–304 multiplication, 300 norm, 300 unit, 300  radiosity, 66, 272–288 radiosity  brightness , 275 radiosity equation, 276, 282–288 Rajan, V., 159 Ramamoorthi, R., 256 Ramshaw, L., 221 RandInt i , 249 RandomPermutation, 249 range, 320, 329 rank, 329 rational curve, 180, 228, see also B´ezier curve  and B-spline curve  rational linear interpolation, see hyperbolic  interpolation  ray, 258 ray trace software, 332–352 ray tracing, 2, 90, 135, 137, 233–256, 279–280 Ray Tracing News, 252 ray–B´ezier patch intersection, 268 ray–cylinder intersection, 266–267 ray–ellipsoid intersection, 260 ray–line, 258 ray–plane intersection, 260–261 ray–polytope intersection, 261, 264–266  Index  ray–quadric intersection, 267–268 ray–sphere intersection, 258–260 ray–triangle intersection, 261–263 RayTrace, 242, 243, 332, 334, 335 RayTrace2, 333 RayTraceData, 332 RayTraceData2, 333 RayTraceMain, 242 reciprocity, 276, 279, 281 recursive ray tracing, 234–238 recursive subdivision, 159–162, 169–171, 175,  176, 223, 268  Reeves, W., 256 reﬂection, 38, 43, 44, 233, 254 reﬂection direction, 72, see also view reﬂection reﬂection map, see environment map reﬂection ray, 235–238, 334 reﬂectivity, 275 reﬂectivity coefﬁcient, see ambient, diffuse,  global, and specular  refraction, 233 Reitz, K., 88 rendering pipeline, 17, 18, 46, 47, 50, 52, 58, 122,  137, 141  repeated knots, 213 ResetSize, 339 ResetSpotlight, 337 resize window, 57 ResizeWindow, 57, 335 rest position, 317 retina, 146 RGB, 150–151 to HSL, 152 to from CMY, 150  Riesenfeld, R., 223 right cylinder, 343 right-hand rule, 5, 35–37, 83, 296, 325 right-handed coordinate system, 5, 34, 324 rigid body, 291 rigid transformation, 23, 24, 35, 36, 44, 295, 298 Robin, N., xiv Rogers, D., 155 roll, see yaw, pitch and roll room, 270 root link, 308 rotation, 22–26, 36, 37, 44, 295–307, see also  generalized rotation  rotation interpolation, see quaternions rotation matrix, 24, 37, 41–43, 292, 295–296, 304 rotational joint, see joint roundoff error, 43, 54, 62, 64, 65, 114, 130, 257,  316, 334  row vector, 21, 23, 326   Index  rowspan, 314, 329 Russian roulette, 252  Sakkalis, T., 186, 187 Salesin, D., 256 Saltzman, M., 146, 154 Salzman, D., 288 Samet, H., 271 saturation, 151 scalar, 19 scalar quaternion, 301 scaling transformation, 38 scan line interpolation, 61, 62, 77, 104 Schlick, C., 87 Schreiner, D., 82 Schr¨oder, P, 199 Schumaker, L., 155 Schwartzkopf, O., 271 Sederberg, T., 268 SeekIntersection, 334 Seidel, H.-P., 221 self reﬂection, 254 SetAffineMatrix, 351 SetApex, 345 SetAxes, 343 SetAxis, 347 SetBaseFace, 345 SetBorderType  , 350 SetBottomFace, 344 SetBoundingSphereCenter, 349 SetCenter, 341–343, 346 SetCenterAxis, 343, 344 SetCentralAxis, 342 SetColor, 337 SetColorAmbient, 335, 337, 340 SetColorAmbientDiffuse, 337, 340 SetColorDiffuse, 337, 340 SetColorEmissive, 340 SetColorReflective, 340 SetColorSpecular, 337, 340 SetColorTransmissive, 340 SetDirection, 338 SetDirectional, 336 SetHeight, 343, 345 SetIndexOfRefraction, 340 SetLinearMatrix, 351 SetLocalViewer, 338 SetMaterial, 340, 342, 344–347, 349 SetMaterial1, 349 SetMaterial2, 349 SetMaterialBack, 342, 349 SetMaterialBaseInner, 345 SetMaterialBaseOuter, 345  369  SetMaterialBottomInner, 344 SetMaterialBottomOuter, 344 SetMaterialFront, 342, 349 SetMaterialInner, 340, 344–347 SetMaterialOuter, 340, 344–347 SetMaterials, 349 SetMaterialSideInner, 344, 345 SetMaterialSideOuter, 344, 345 SetMaterialTopInner, 344 SetMaterialTopOuter, 344 SetNonLocalViewer, 338 SetPixel, 339 SetPosition, 336–339 SetRadialAxis, 343, 345, 347 SetRadii, 342, 343, 347 SetRadius, 341, 343 SetScaling, 351 SetScreenDimensions, 335, 338 SetScreenDistance, 335, 338 SetScreenPixelSize, 338 SetShininess, 340 SetSize, 339 SetSlope, 345 SetSlopes, 345 SetSpotCutoff, 337 SetSpotDirection, 337 SetSpotExponent, 337 SetTexture, 350 SetTopFace, 344 SetTriangleCoords, 351 SetUpLights, 336 SetUpMainView, 335 SetUpMaterials, 335 SetUpViewableObjects, 336 SetuvAxes, 341 SetuvCylindrical, 341, 343 SetUvRange, 349 SetuvSpherical, 341, 343 SetVertices, 346 SetWidths, 349 SetWrapMode, 350 shading, 4, 11, 67, 75, see also ﬂat shading shadow map, 255, 256 shadow volume, 65, 255 shadow feeler, 235–236, 241, 248, 334 ShadowFeeler, 334 shadowing, 92 shadows, 53–54, 233, 247, 255 shearing, 38, 87 Shepperd, S., 304 shininess, see specular exponent Shirley, P., 252 Shoemake, K., 122, 307   370  Shoenberg, I., 200 shooting method, 287–288 Shooting_Method, 287 silhouette edges, 255 Sillion, F., 87, 275, 288 simple polygon, 10 SimpleAnim, 15 SimpleDraw, 6–8, 13 SimpleNurbs, 179, 180, 188 singular value decomposition, 317 skeleton, 289 skinning, 289 slerp, see spherical linear interpolation slerp, 123 Slerp, 124 Sloan, K., 128 smoke, 252, 291 Snell’s law, 96, 239, 241 soft shadows, 247, 255 solar program, 38–40, 57, 58 Southwell iteration, 287 spacecraft, 295 span, 314, 328 spectral sampling, 148, 149 specular exponent, 70, 73, 75, 85, 339,  340  Index  superposition principle, 69, 74 supersampling, 134–135, 244 support, 320 surface normal, see normal vector surface of revolution, 180, 187–188 symmetric function, 218  TCB spline, see tension–continuity–bias spline teapot, 2, 68, 180 television, 2, 147 tension, 193 tension–continuity–bias spline, 189, 193–195,  290  terrain, 116 texture coordinates, 59, 127, 128  texture map, 4, 58, 108, 126–145, 332, 341, 349,  cylinder, 129–130, 344 sphere, 130–131, 341 torus, 131–132, 347  see also mipmapping decal replace, 126, 142 in OpenGL, 139–145 modulate, 142 repeating, 130, 140, 350 resident, 143 specular highlight, 142  specular highlight, 2, 67–69, 73, 77, 142 specular light, 69, 72, 73, 85, 337 specular reﬂection, 69, 72–74 specular reﬂectivity coefﬁcient, 70, 73, 85, 242,  339, 350  specular transmission, 241 specular transmission coefﬁcient, 242 sphere, 39, 130, 257, 258, 341 spherical linear interpolation, 122–125, 306 Spizzichino, A., 91 spline, 155, see also B´ezier curve and B-spline  curve  spotlight, 75, 77, 82, 85–87, 337 spotlight direction, 86 spotlight exponent, 86 Sproull, R., 34 Spurrier, R., 304 standard knot vector, 210, 214 Star Trek, 295 stencil buffer, 255, 256 Stiles, W., 154 stochastic supersampling, 134–135, 244, see also  jittering  stratiﬁed stochastic supersampling, see jittering stride, 348 subdivision surface, 199 subtractive colors, 149  texture matrix, 145 texture object, 139, 143 TextureAffineXform, 342, 351 TextureBilinearXform, 342, 351 TextureBMP, 139 TextureCheckered, 349 TextureMap, 336, 341, 349 TextureMapBack, 341, 349 TextureMapBase, 341 TextureMapFront, 341, 349 TextureMultiFaces, 344, 351 TextureRgbImage, 350 TextureSequence, 350, 351 TextureTorus, 139 Thomas, F., 290 thousands of colors, 59, 150 Tiller, W., 182, 224, 227 tilt, planetary, 40 torch`ere, 272 Torrance, K., 87, 90, 93, 97 torus, 10, 80, 131, 346 total derivative, 330 total internal reﬂection, 96, 240, 241, 243 Toth, D., 268 Touloukian, Y., 97 trace, 42, 304 traditional animation, 290   Index  transformation, 19, 35, see also afﬁne  transformation, linear transformation, and rigid transformation  translation, 20, 23, 35, 37 transmission  diffuse light, 241 specular light, 241  transmission coefﬁcient, 238, 339 transmission ray, 237–238, 334  direction, 239–241, 334  transparency, 84, 150, 233, 241 transpose, see matrix transpose triangle, 3, 8, 102, 261, 342 triangle fan, 9, 10, 12 triangle strip, 8 triangulation, 9 trichromatic theory, 146 tridiagonal matrix, 231 trilinear interpolation, 117  inversion, 117  tristimulus method, 147 Trowbridge, T., 88 true color, 150 Trumbore, B., 263 tuple, 319 turtle geometry, 3 twist vector, 175, 196–198  undershoot, 193, 194 uniform speed, 187 unit circle, 321 unit quaternion, 300, 301 unit sphere, 33, 122, 302, 324 unit vector, 320, 324 up direction, 58, 338 updateScene, 15, 16  value, 151 vanishing point, 34, 49 variation diminishing, 168, 171, 225 Veach, E., 252 vector, 19, 21, 23, 34, 301, 319, 320 vector graphics, 2 vector, as quaternion, 301 vector-valued function, 79, 331 VectorR3, 334 VectorR4, 334 view orientation, 58, 338 view reﬂection, 138, 144 viewable object, 332, 340–349 ViewableBase, 333, 336 ViewableBezierSet, 347, 349 ViewableCone, 344 ViewableCylinder, 343  371  ViewableEllipsoid, 342 ViewableParallelepiped, 346 ViewableParallelogram, 342 ViewableSphere, 341 ViewableTorus, 346 ViewableTriangle, 342 viewing transformation, 46, 54 viewpoint, 337 viewpoint animation, 291, 295 viewpoint at origin, 83, 84 viewpoint jittering, 245, 339 viewport, 17, 57, 58, 234, 245 viewport position, 337 VisiblePoint, 334  Wallace, J., 275, 288 Warren, J., 199 Watt, A., xvi, 128, 252 Watt, M., xvi, 128, 252 Web-safe colors, 151 weighted average, 101, 102, 117, 118, 157, 162,  166, 168, 203, 212  homogeneous coordinates, 102, 119–121  Welch, T., 151 white, 10, 149 White, T., 290 Whitted, T., 252, 268 wide-angle lens, 58 Wiemar, H., 199 Williams, L., 133, 256 Willems, Y., 252 winding number, 130 wireframe, 14 Witt, D., 97 Wolff, L., 89 Woo, M., xii, 5, 54, 82, 142, 143 WrapTorus, 11, 15 WrapUV, 350 Wright Jr., R., xii writePixel, 62 Wyszecki, G., 154  yaw, pitch and roll, 292, 295–298 yellow, 10, 149, 153 Young, T., 146  z buffer, see depth buffer Zandt, T. van, xvi z ﬁghting, 54 zero vector, 19, 34 Zhao, J., 311, 317 Ziegler, G., 118 Ziv, J., 151 Zorin, D., 199
